{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _defineProperty = require('babel-runtime/core-js/reflect/define-property');\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _weakMap = require('babel-runtime/core-js/weak-map');\n\nvar _weakMap2 = _interopRequireDefault(_weakMap);\n\nvar _isObject2 = require('lodash/isObject');\n\nvar _isObject3 = _interopRequireDefault(_isObject2);\n\nvar _has2 = require('lodash/has');\n\nvar _has3 = _interopRequireDefault(_has2);\n\nvar _defaults2 = require('lodash/defaults');\n\nvar _defaults3 = _interopRequireDefault(_defaults2);\n\nvar _events = require('events');\n\nvar _common = require('@webex/common');\n\nvar _commonTimers = require('@webex/common-timers');\n\nvar _uuid = require('uuid');\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nvar _errors = require('../errors');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar sockets = new _weakMap2.default();\n/**\n * Generalized socket abstraction\n */\n\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nvar Socket = function (_EventEmitter) {\n  (0, _inherits3.default)(Socket, _EventEmitter);\n  /**\n   * constructor\n   * @returns {Socket}\n   */\n\n  function Socket() {\n    (0, _classCallCheck3.default)(this, Socket);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Socket.__proto__ || (0, _getPrototypeOf2.default)(Socket)).call(this));\n\n    _this.onmessage = _this.onmessage.bind(_this);\n    _this.onclose = _this.onclose.bind(_this);\n    return _this;\n  }\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @returns {string}\n   */\n\n\n  (0, _createClass3.default)(Socket, [{\n    key: 'close',\n\n    /**\n     * Closes the socket\n     * @param {Object} options\n     * @param {string} options.reason\n     * @param {number} options.code\n     * @returns {Promise}\n     */\n    value: function close(options) {\n      var _this2 = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        var socket = sockets.get(_this2);\n\n        if (!socket) {\n          // Open has not been called yet so there is no socket to close\n          resolve();\n          return;\n        } // logger is defined once open is called\n\n\n        _this2.logger.info('socket: closing');\n\n        if (socket.readyState === 2 || socket.readyState === 3) {\n          _this2.logger.info('socket: already closed');\n\n          resolve();\n          return;\n        }\n\n        options = options || {};\n\n        if (options.code && options.code !== 1000 && (options.code < 3000 || options.code > 4999)) {\n          reject(new Error('`options.code` must be 1000 or between 3000 and 4999 (inclusive)'));\n          return;\n        }\n\n        options = (0, _defaults3.default)(options, {\n          code: 1000,\n          reason: 'Done'\n        });\n        var closeTimer = (0, _commonTimers.safeSetTimeout)(function () {\n          try {\n            _this2.logger.info('socket: no close event received, forcing closure');\n\n            resolve(_this2.onclose({\n              code: 1000,\n              reason: 'Done (forced)'\n            }));\n          } catch (error) {\n            _this2.logger.warn('socket: force-close failed', error);\n          }\n        }, _this2.forceCloseDelay);\n\n        socket.onclose = function (event) {\n          _this2.logger.info('socket: close event fired', event.code, event.reason);\n\n          clearTimeout(closeTimer);\n\n          _this2.onclose(event);\n\n          resolve(event);\n        };\n\n        socket.close(options.code, options.reason);\n      });\n    }\n    /**\n     * Opens a WebSocket\n     * @param {string} url\n     * @param {options} options\n     * @param {number} options.forceCloseDelay (required)\n     * @param {number} options.pingInterval (required)\n     * @param {number} options.pongTimeout (required)\n     * @param {string} options.token (required)\n     * @param {string} options.trackingId (required)\n     * @param {Logger} options.logger (required)\n     * @param {string} options.logLevelToken\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'open',\n    value: function open(url, options) {\n      var _this3 = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        /* eslint complexity: [0] */\n        if (!url) {\n          reject(new Error('`url` is required'));\n          return;\n        }\n\n        if (sockets.get(_this3)) {\n          reject(new Error('Socket#open() can only be called once per instance'));\n          return;\n        }\n\n        options = options || {};\n        (0, _common.checkRequired)(['forceCloseDelay', 'pingInterval', 'pongTimeout', 'token', 'trackingId', 'logger'], options);\n        (0, _keys2.default)(options).forEach(function (key) {\n          (0, _defineProperty2.default)(_this3, key, {\n            enumerable: false,\n            value: options[key]\n          });\n        });\n        var WebSocket = Socket.getWebSocketConstructor();\n\n        _this3.logger.info('socket: creating WebSocket');\n\n        var socket = new WebSocket(url, [], options);\n        socket.binaryType = 'arraybuffer';\n        socket.onmessage = _this3.onmessage;\n\n        socket.onclose = function (event) {\n          event = _this3._fixCloseCode(event);\n\n          _this3.logger.info('socket: closed before open', event.code, event.reason);\n\n          switch (event.code) {\n            case 1005:\n              // IE 11 doesn't seem to allow 4XXX codes, so if we get a 1005, assume\n              // it's a bad websocket url. That'll trigger a device refresh; if it\n              // turns out we had a bad token, the device refresh should 401 and\n              // trigger a token refresh.\n              return reject(new _errors.UnknownResponse(event));\n\n            case 4400:\n              return reject(new _errors.BadRequest(event));\n\n            case 4401:\n              return reject(new _errors.NotAuthorized(event));\n\n            case 4403:\n              return reject(new _errors.Forbidden(event));\n            // case 4404:\n            //   return reject(new NotFound(event));\n\n            default:\n              return reject(new _errors.ConnectionError(event));\n          }\n        };\n\n        socket.onopen = function () {\n          _this3.logger.info('socket: connected');\n\n          _this3._authorize().then(function () {\n            _this3.logger.info('socket: authorized');\n\n            socket.onclose = _this3.onclose;\n            resolve();\n          }).catch(reject);\n        };\n\n        socket.onerror = function (event) {\n          _this3.logger.warn('socket: error event fired', event);\n        };\n\n        sockets.set(_this3, socket);\n\n        _this3.logger.info('socket: waiting for server');\n      });\n    }\n    /**\n     * Handles incoming CloseEvents\n     * @param {CloseEvent} event\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'onclose',\n    value: function onclose(event) {\n      this.logger.info('socket: closed', event.code, event.reason);\n      clearTimeout(this.pongTimer);\n      clearTimeout(this.pingTimer);\n      event = this._fixCloseCode(event);\n      this.emit('close', event); // Remove all listeners to (a) avoid reacting to late pongs and (b) ensure\n      // we don't have a retain cycle.\n\n      this.removeAllListeners();\n    }\n    /**\n     * Handles incoming message events\n     * @param {MessageEvent} event\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'onmessage',\n    value: function onmessage(event) {\n      try {\n        var data = JSON.parse(event.data);\n        var sequenceNumber = parseInt(data.sequenceNumber, 10);\n        this.logger.debug('socket: sequence number: ', sequenceNumber);\n\n        if (this.expectedSequenceNumber && sequenceNumber !== this.expectedSequenceNumber) {\n          this.logger.debug('socket: sequence number mismatch indicates lost mercury message. expected: ' + this.expectedSequenceNumber + ', actual: ' + sequenceNumber);\n          this.emit('sequence-mismatch', sequenceNumber, this.expectedSequenceNumber);\n        }\n\n        this.expectedSequenceNumber = sequenceNumber + 1; // Yes, it's a little weird looking; we want to emit message events that\n        // look like normal socket message events, but event.data cannot be\n        // modified and we don't actually care about anything but the data property\n\n        var processedEvent = {\n          data: data\n        };\n\n        this._acknowledge(processedEvent);\n\n        if (data.type === 'pong') {\n          this.emit('pong', processedEvent);\n        } else {\n          this.emit('message', processedEvent);\n        }\n      } catch (error) {\n        // The above code should only be able to throw if we receive an unparsable\n        // message from Mercury. At this time, the only action we have is to\n        // ignore it and move on.\n\n        /* istanbul ignore next */\n        this.logger.warn('socket: error while receiving WebSocket message', error);\n      }\n    }\n    /**\n     * Sends a message up the socket\n     * @param {mixed} data\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'send',\n    value: function send(data) {\n      var _this4 = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        if (_this4.readyState !== 1) {\n          return reject(new Error('INVALID_STATE_ERROR'));\n        }\n\n        if ((0, _isObject3.default)(data)) {\n          data = (0, _stringify2.default)(data);\n        }\n\n        var socket = sockets.get(_this4);\n        socket.send(data);\n        return resolve();\n      });\n    }\n    /**\n     * Sends an acknowledgment for a specific event\n     * @param {MessageEvent} event\n     * @returns {Promise}\n     */\n\n  }, {\n    key: '_acknowledge',\n    value: function _acknowledge(event) {\n      if (!event) {\n        return _promise2.default.reject(new Error('`event` is required'));\n      }\n\n      if (!(0, _has3.default)(event, 'data.id')) {\n        return _promise2.default.reject(new Error('`event.data.id` is required'));\n      }\n\n      return this.send({\n        messageId: event.data.id,\n        type: 'ack'\n      });\n    }\n    /**\n     * Sends an auth message up the socket\n     * @private\n     * @returns {Promise}\n     */\n\n  }, {\n    key: '_authorize',\n    value: function _authorize() {\n      var _this5 = this;\n\n      return new _promise2.default(function (resolve) {\n        _this5.logger.info('socket: authorizing');\n\n        _this5.send({\n          id: _uuid2.default.v4(),\n          type: 'authorization',\n          data: {\n            token: _this5.token\n          },\n          trackingId: _this5.trackingId,\n          logLevelToken: _this5.logLevelToken\n        });\n\n        var waitForBufferState = function waitForBufferState(event) {\n          if (!event.data.type && (event.data.data.eventType === 'mercury.buffer_state' || event.data.data.eventType === 'mercury.registration_status')) {\n            _this5.removeListener('message', waitForBufferState);\n\n            _this5._ping();\n\n            resolve();\n          }\n        };\n\n        _this5.once('message', waitForBufferState);\n      });\n    }\n    /**\n     * Deals with the fact that some browsers drop some close codes (but not\n     * close reasons).\n     * @param {CloseEvent} event\n     * @private\n     * @returns {CloseEvent}\n     */\n\n  }, {\n    key: '_fixCloseCode',\n    value: function _fixCloseCode(event) {\n      if (event.code === 1005 && event.reason) {\n        switch (event.reason.toLowerCase()) {\n          case 'replaced':\n            this.logger.info('socket: fixing CloseEvent code for reason: ', event.reason);\n            event.code = 4000;\n            break;\n\n          case 'authentication failed':\n          case 'authentication did not happen within the timeout window of 30000 seconds.':\n            this.logger.info('socket: fixing CloseEvent code for reason: ', event.reason);\n            event.code = 1008;\n            break;\n\n          default: // do nothing\n\n        }\n      }\n\n      return event;\n    }\n    /**\n     * Sends a ping up the socket and confirms we get it back\n     * @param {[type]} id\n     * @private\n     * @returns {[type]}\n     */\n\n  }, {\n    key: '_ping',\n    value: function _ping(id) {\n      var _this6 = this;\n\n      var confirmPongId = function confirmPongId(event) {\n        try {\n          _this6.logger.debug('socket: pong', event.data.id);\n\n          if (event.data && event.data.id !== id) {\n            _this6.logger.info('socket: received pong for wrong ping id, closing socket');\n\n            _this6.logger.debug('socket: expected', id, 'received', event.data.id);\n\n            _this6.close({\n              code: 1000,\n              reason: 'Pong mismatch'\n            });\n          }\n        } catch (error) {\n          // This try/catch block was added as a debugging step; to the best of my\n          // knowledge, the above can never throw.\n\n          /* istanbul ignore next */\n          _this6.logger.error('socket: error occurred in confirmPongId', error);\n        }\n      };\n\n      var onPongNotReceived = function onPongNotReceived() {\n        try {\n          _this6.logger.info('socket: pong not receive in expected period, closing socket');\n\n          _this6.close({\n            code: 1000,\n            reason: 'Pong not received'\n          }).catch(function (reason) {\n            _this6.logger.warn('socket: failed to close socket after missed pong', reason);\n          });\n        } catch (error) {\n          // This try/catch block was added as a debugging step; to the best of my\n          // knowledge, the above can never throw.\n\n          /* istanbul ignore next */\n          _this6.logger.error('socket: error occurred in onPongNotReceived', error);\n        }\n      };\n\n      var scheduleNextPingAndCancelPongTimer = function scheduleNextPingAndCancelPongTimer() {\n        try {\n          clearTimeout(_this6.pongTimer);\n          _this6.pingTimer = (0, _commonTimers.safeSetTimeout)(function () {\n            return _this6._ping();\n          }, _this6.pingInterval);\n        } catch (error) {\n          // This try/catch block was added as a debugging step; to the best of my\n          // knowledge, the above can never throw.\n\n          /* istanbul ignore next */\n          _this6.logger.error('socket: error occurred in scheduleNextPingAndCancelPongTimer', error);\n        }\n      };\n\n      id = id || _uuid2.default.v4();\n      this.pongTimer = (0, _commonTimers.safeSetTimeout)(onPongNotReceived, this.pongTimeout);\n      this.once('pong', scheduleNextPingAndCancelPongTimer);\n      this.once('pong', confirmPongId);\n      this.logger.debug('socket: ping ' + id);\n      return this.send({\n        id: id,\n        type: 'ping'\n      });\n    }\n  }, {\n    key: 'binaryType',\n    get: function get() {\n      return sockets.get(this).binaryType;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n     * @returns {number}\n     */\n\n  }, {\n    key: 'bufferedAmount',\n    get: function get() {\n      return sockets.get(this).bufferedAmount;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n     * @returns {string}\n     */\n\n  }, {\n    key: 'extensions',\n    get: function get() {\n      return sockets.get(this).extensions;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n     * @returns {string}\n     */\n\n  }, {\n    key: 'protocol',\n    get: function get() {\n      return sockets.get(this).protocol;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n     * @returns {number}\n     */\n\n  }, {\n    key: 'readyState',\n    get: function get() {\n      return sockets.get(this).readyState;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n     * @returns {string}\n     */\n\n  }, {\n    key: 'url',\n    get: function get() {\n      return sockets.get(this).url;\n    }\n    /**\n     * Provides the environmentally appropriate constructor (ws in NodeJS,\n     * WebSocket in browsers)\n     * @returns {WebSocket}\n     */\n\n  }], [{\n    key: 'getWebSocketConstructor',\n    value: function getWebSocketConstructor() {\n      throw new Error('Socket.getWebSocketConstructor() must be implemented in an environmentally appropriate way');\n    }\n  }]);\n  return Socket;\n}(_events.EventEmitter);\n\nexports.default = Socket;","map":{"version":3,"sources":["socket-base.js"],"names":["sockets","Socket","EventEmitter","options","socket","resolve","reject","code","reason","closeTimer","event","clearTimeout","url","enumerable","value","WebSocket","UnknownResponse","BadRequest","NotAuthorized","Forbidden","ConnectionError","data","JSON","sequenceNumber","parseInt","processedEvent","messageId","type","id","uuid","token","trackingId","logLevelToken","waitForBufferState","confirmPongId","onPongNotReceived","scheduleNextPingAndCancelPongTimer"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {EventEmitter} from 'events';\n\nimport {checkRequired} from '@webex/common';\nimport {safeSetTimeout} from '@webex/common-timers';\nimport {defaults, has, isObject} from 'lodash';\nimport uuid from 'uuid';\n\nimport {\n  BadRequest,\n  ConnectionError,\n  Forbidden,\n  NotAuthorized,\n  UnknownResponse\n  // NotFound\n} from '../errors';\n\nconst sockets = new WeakMap();\n\n/**\n * Generalized socket abstraction\n */\nexport default class Socket extends EventEmitter {\n  /**\n   * constructor\n   * @returns {Socket}\n   */\n  constructor() {\n    super();\n    this.onmessage = this.onmessage.bind(this);\n    this.onclose = this.onclose.bind(this);\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @returns {string}\n   */\n  get binaryType() {\n    return sockets.get(this).binaryType;\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @returns {number}\n   */\n  get bufferedAmount() {\n    return sockets.get(this).bufferedAmount;\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @returns {string}\n   */\n  get extensions() {\n    return sockets.get(this).extensions;\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @returns {string}\n   */\n  get protocol() {\n    return sockets.get(this).protocol;\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @returns {number}\n   */\n  get readyState() {\n    return sockets.get(this).readyState;\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @returns {string}\n   */\n  get url() {\n    return sockets.get(this).url;\n  }\n\n  /**\n   * Provides the environmentally appropriate constructor (ws in NodeJS,\n   * WebSocket in browsers)\n   * @returns {WebSocket}\n   */\n  static getWebSocketConstructor() {\n    throw new Error('Socket.getWebSocketConstructor() must be implemented in an environmentally appropriate way');\n  }\n\n  /**\n   * Closes the socket\n   * @param {Object} options\n   * @param {string} options.reason\n   * @param {number} options.code\n   * @returns {Promise}\n   */\n  close(options) {\n    return new Promise((resolve, reject) => {\n      const socket = sockets.get(this);\n\n      if (!socket) {\n        // Open has not been called yet so there is no socket to close\n        resolve();\n\n        return;\n      }\n      // logger is defined once open is called\n      this.logger.info('socket: closing');\n\n      if (socket.readyState === 2 || socket.readyState === 3) {\n        this.logger.info('socket: already closed');\n        resolve();\n\n        return;\n      }\n\n      options = options || {};\n      if (options.code && options.code !== 1000 && (options.code < 3000 || options.code > 4999)) {\n        reject(new Error('`options.code` must be 1000 or between 3000 and 4999 (inclusive)'));\n\n        return;\n      }\n\n      options = defaults(options, {\n        code: 1000,\n        reason: 'Done'\n      });\n\n      const closeTimer = safeSetTimeout(() => {\n        try {\n          this.logger.info('socket: no close event received, forcing closure');\n          resolve(this.onclose({\n            code: 1000,\n            reason: 'Done (forced)'\n          }));\n        }\n        catch (error) {\n          this.logger.warn('socket: force-close failed', error);\n        }\n      }, this.forceCloseDelay);\n\n      socket.onclose = (event) => {\n        this.logger.info('socket: close event fired', event.code, event.reason);\n        clearTimeout(closeTimer);\n        this.onclose(event);\n        resolve(event);\n      };\n\n      socket.close(options.code, options.reason);\n    });\n  }\n\n  /**\n   * Opens a WebSocket\n   * @param {string} url\n   * @param {options} options\n   * @param {number} options.forceCloseDelay (required)\n   * @param {number} options.pingInterval (required)\n   * @param {number} options.pongTimeout (required)\n   * @param {string} options.token (required)\n   * @param {string} options.trackingId (required)\n   * @param {Logger} options.logger (required)\n   * @param {string} options.logLevelToken\n   * @returns {Promise}\n   */\n  open(url, options) {\n    return new Promise((resolve, reject) => {\n      /* eslint complexity: [0] */\n      if (!url) {\n        reject(new Error('`url` is required'));\n\n        return;\n      }\n\n      if (sockets.get(this)) {\n        reject(new Error('Socket#open() can only be called once per instance'));\n\n        return;\n      }\n\n      options = options || {};\n\n      checkRequired([\n        'forceCloseDelay',\n        'pingInterval',\n        'pongTimeout',\n        'token',\n        'trackingId',\n        'logger'\n      ], options);\n\n      Object.keys(options).forEach((key) => {\n        Reflect.defineProperty(this, key, {\n          enumerable: false,\n          value: options[key]\n        });\n      });\n\n      const WebSocket = Socket.getWebSocketConstructor();\n\n      this.logger.info('socket: creating WebSocket');\n      const socket = new WebSocket(url, [], options);\n\n      socket.binaryType = 'arraybuffer';\n      socket.onmessage = this.onmessage;\n\n      socket.onclose = (event) => {\n        event = this._fixCloseCode(event);\n        this.logger.info('socket: closed before open', event.code, event.reason);\n        switch (event.code) {\n          case 1005:\n          // IE 11 doesn't seem to allow 4XXX codes, so if we get a 1005, assume\n          // it's a bad websocket url. That'll trigger a device refresh; if it\n          // turns out we had a bad token, the device refresh should 401 and\n          // trigger a token refresh.\n            return reject(new UnknownResponse(event));\n          case 4400:\n            return reject(new BadRequest(event));\n          case 4401:\n            return reject(new NotAuthorized(event));\n          case 4403:\n            return reject(new Forbidden(event));\n            // case 4404:\n            //   return reject(new NotFound(event));\n          default:\n            return reject(new ConnectionError(event));\n        }\n      };\n\n      socket.onopen = () => {\n        this.logger.info('socket: connected');\n        this._authorize()\n          .then(() => {\n            this.logger.info('socket: authorized');\n            socket.onclose = this.onclose;\n            resolve();\n          })\n          .catch(reject);\n      };\n\n      socket.onerror = (event) => {\n        this.logger.warn('socket: error event fired', event);\n      };\n\n      sockets.set(this, socket);\n      this.logger.info('socket: waiting for server');\n    });\n  }\n\n  /**\n   * Handles incoming CloseEvents\n   * @param {CloseEvent} event\n   * @returns {undefined}\n   */\n  onclose(event) {\n    this.logger.info('socket: closed', event.code, event.reason);\n    clearTimeout(this.pongTimer);\n    clearTimeout(this.pingTimer);\n\n    event = this._fixCloseCode(event);\n    this.emit('close', event);\n\n    // Remove all listeners to (a) avoid reacting to late pongs and (b) ensure\n    // we don't have a retain cycle.\n    this.removeAllListeners();\n  }\n\n  /**\n   * Handles incoming message events\n   * @param {MessageEvent} event\n   * @returns {undefined}\n   */\n  onmessage(event) {\n    try {\n      const data = JSON.parse(event.data);\n      const sequenceNumber = parseInt(data.sequenceNumber, 10);\n\n      this.logger.debug('socket: sequence number: ', sequenceNumber);\n      if (this.expectedSequenceNumber && sequenceNumber !== this.expectedSequenceNumber) {\n        this.logger.debug(`socket: sequence number mismatch indicates lost mercury message. expected: ${this.expectedSequenceNumber}, actual: ${sequenceNumber}`);\n        this.emit('sequence-mismatch', sequenceNumber, this.expectedSequenceNumber);\n      }\n      this.expectedSequenceNumber = sequenceNumber + 1;\n\n      // Yes, it's a little weird looking; we want to emit message events that\n      // look like normal socket message events, but event.data cannot be\n      // modified and we don't actually care about anything but the data property\n      const processedEvent = {data};\n\n      this._acknowledge(processedEvent);\n      if (data.type === 'pong') {\n        this.emit('pong', processedEvent);\n      }\n      else {\n        this.emit('message', processedEvent);\n      }\n    }\n    catch (error) {\n      // The above code should only be able to throw if we receive an unparsable\n      // message from Mercury. At this time, the only action we have is to\n      // ignore it and move on.\n      /* istanbul ignore next */\n      this.logger.warn('socket: error while receiving WebSocket message', error);\n    }\n  }\n\n  /**\n   * Sends a message up the socket\n   * @param {mixed} data\n   * @returns {Promise}\n   */\n  send(data) {\n    return new Promise((resolve, reject) => {\n      if (this.readyState !== 1) {\n        return reject(new Error('INVALID_STATE_ERROR'));\n      }\n\n      if (isObject(data)) {\n        data = JSON.stringify(data);\n      }\n\n      const socket = sockets.get(this);\n\n      socket.send(data);\n\n      return resolve();\n    });\n  }\n\n  /**\n   * Sends an acknowledgment for a specific event\n   * @param {MessageEvent} event\n   * @returns {Promise}\n   */\n  _acknowledge(event) {\n    if (!event) {\n      return Promise.reject(new Error('`event` is required'));\n    }\n\n    if (!has(event, 'data.id')) {\n      return Promise.reject(new Error('`event.data.id` is required'));\n    }\n\n    return this.send({\n      messageId: event.data.id,\n      type: 'ack'\n    });\n  }\n\n  /**\n   * Sends an auth message up the socket\n   * @private\n   * @returns {Promise}\n   */\n  _authorize() {\n    return new Promise((resolve) => {\n      this.logger.info('socket: authorizing');\n      this.send({\n        id: uuid.v4(),\n        type: 'authorization',\n        data: {\n          token: this.token\n        },\n        trackingId: this.trackingId,\n        logLevelToken: this.logLevelToken\n      });\n\n      const waitForBufferState = (event) => {\n        if (!event.data.type && (event.data.data.eventType === 'mercury.buffer_state' || event.data.data.eventType === 'mercury.registration_status')) {\n          this.removeListener('message', waitForBufferState);\n          this._ping();\n          resolve();\n        }\n      };\n\n      this.once('message', waitForBufferState);\n    });\n  }\n\n  /**\n   * Deals with the fact that some browsers drop some close codes (but not\n   * close reasons).\n   * @param {CloseEvent} event\n   * @private\n   * @returns {CloseEvent}\n   */\n  _fixCloseCode(event) {\n    if (event.code === 1005 && event.reason) {\n      switch (event.reason.toLowerCase()) {\n        case 'replaced':\n          this.logger.info('socket: fixing CloseEvent code for reason: ', event.reason);\n          event.code = 4000;\n          break;\n        case 'authentication failed':\n        case 'authentication did not happen within the timeout window of 30000 seconds.':\n          this.logger.info('socket: fixing CloseEvent code for reason: ', event.reason);\n          event.code = 1008;\n          break;\n        default:\n        // do nothing\n      }\n    }\n\n    return event;\n  }\n\n  /**\n   * Sends a ping up the socket and confirms we get it back\n   * @param {[type]} id\n   * @private\n   * @returns {[type]}\n   */\n  _ping(id) {\n    const confirmPongId = (event) => {\n      try {\n        this.logger.debug('socket: pong', event.data.id);\n        if (event.data && event.data.id !== id) {\n          this.logger.info('socket: received pong for wrong ping id, closing socket');\n          this.logger.debug('socket: expected', id, 'received', event.data.id);\n          this.close({\n            code: 1000,\n            reason: 'Pong mismatch'\n          });\n        }\n      }\n      catch (error) {\n        // This try/catch block was added as a debugging step; to the best of my\n        // knowledge, the above can never throw.\n        /* istanbul ignore next */\n        this.logger.error('socket: error occurred in confirmPongId', error);\n      }\n    };\n\n    const onPongNotReceived = () => {\n      try {\n        this.logger.info('socket: pong not receive in expected period, closing socket');\n        this.close({\n          code: 1000,\n          reason: 'Pong not received'\n        })\n          .catch((reason) => {\n            this.logger.warn('socket: failed to close socket after missed pong', reason);\n          });\n      }\n      catch (error) {\n        // This try/catch block was added as a debugging step; to the best of my\n        // knowledge, the above can never throw.\n        /* istanbul ignore next */\n        this.logger.error('socket: error occurred in onPongNotReceived', error);\n      }\n    };\n\n    const scheduleNextPingAndCancelPongTimer = () => {\n      try {\n        clearTimeout(this.pongTimer);\n        this.pingTimer = safeSetTimeout(() => this._ping(), this.pingInterval);\n      }\n      catch (error) {\n        // This try/catch block was added as a debugging step; to the best of my\n        // knowledge, the above can never throw.\n        /* istanbul ignore next */\n        this.logger.error('socket: error occurred in scheduleNextPingAndCancelPongTimer', error);\n      }\n    };\n\n    id = id || uuid.v4();\n    this.pongTimer = safeSetTimeout(onPongNotReceived, this.pongTimeout);\n    this.once('pong', scheduleNextPingAndCancelPongTimer);\n    this.once('pong', confirmPongId);\n\n    this.logger.debug(`socket: ping ${id}`);\n\n    return this.send({\n      id,\n      type: 'ping'\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}