{"ast":null,"code":"/*!\n * jwe/encrypt.js - Encrypt to a JWE\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar assign = require(\"lodash.assign\"),\n    clone = require(\"lodash.clone\"),\n    util = require(\"../util\"),\n    generateCEK = require(\"./helpers\").generateCEK,\n    JWK = require(\"../jwk\"),\n    slice = require(\"./helpers\").slice,\n    zlib = require(\"zlib\"),\n    CONSTANTS = require(\"../algorithms/constants\");\n\nvar DEFAULTS = require(\"./defaults\");\n/**\n * @class JWE.Encrypter\n * @classdesc\n * Generator of encrypted data.\n *\n * @description\n * **NOTE:** This class cannot be instantiated directly. Instead call {@link\n * JWE.createEncrypt}.\n */\n\n\nfunction JWEEncrypter(cfg, fields, recipients) {\n  var finalized = false,\n      format = cfg.format || \"general\",\n      protectAll = !!cfg.protectAll,\n      content = new Buffer(0);\n  /**\n   * @member {String} JWE.Encrypter#zip\n   * @readonly\n   * @description\n   * Indicates the compression algorithm applied to the plaintext\n   * before it is encrypted.  The possible values are:\n   *\n   * + **`\"DEF\"`**: Compress the plaintext using the DEFLATE algorithm.\n   * + **`\"\"`**: Do not compress the plaintext.\n   */\n\n  Object.defineProperty(this, \"zip\", {\n    get: function () {\n      return fields.zip || \"\";\n    },\n    enumerable: true\n  });\n  /**\n   * @member {Boolean} JWE.Encrypter#compact\n   * @readonly\n   * @description\n   * Indicates whether the output of this encryption generator is\n   * using the Compact serialization (`true`) or the JSON\n   * serialization (`false`).\n   */\n\n  Object.defineProperty(this, \"compact\", {\n    get: function () {\n      return \"compact\" === format;\n    },\n    enumerable: true\n  });\n  /**\n   * @member {String} JWE.Encrypter#format\n   * @readonly\n   * @description\n   * Indicates the format the output of this encryption generator takes.\n   */\n\n  Object.defineProperty(this, \"format\", {\n    get: function () {\n      return format;\n    },\n    enumerable: true\n  });\n  /**\n   * @member {String[]} JWE.Encrypter#protected\n   * @readonly\n   * @description\n   * The header parameter names that are protected. Protected header fields\n   * are first serialized to UTF-8 then encoded as util.base64url, then used as\n   * the additional authenticated data in the encryption operation.\n   */\n\n  Object.defineProperty(this, \"protected\", {\n    get: function () {\n      return clone(cfg.protect);\n    },\n    enumerable: true\n  });\n  /**\n   * @member {Object} JWE.Encrypter#header\n   * @readonly\n   * @description\n   * The global header parameters, both protected and unprotected. Call\n   * {@link JWE.Encrypter#protected} to determine which parameters will\n   * be protected.\n   */\n\n  Object.defineProperty(this, \"header\", {\n    get: function () {\n      return clone(fields);\n    },\n    enumerable: true\n  });\n  /**\n   * @method JWE.Encrypter#update\n   * @description\n   * Updates the plaintext data for the encryption generator. The plaintext\n   * is appended to the end of any other plaintext already applied.\n   *\n   * If {data} is a Buffer, {encoding} is ignored. Otherwise, {data} is\n   * converted to a Buffer internally to {encoding}.\n   *\n   * @param {Buffer|String} [data] The plaintext to apply.\n   * @param {String} [encoding] The encoding of the plaintext.\n   * @returns {JWE.Encrypter} This encryption generator.\n   * @throws {Error} If ciphertext has already been generated.\n   */\n\n  Object.defineProperty(this, \"update\", {\n    value: function (data, encoding) {\n      if (finalized) {\n        throw new Error(\"already final\");\n      }\n\n      if (data != null) {\n        data = util.asBuffer(data, encoding);\n\n        if (content.length) {\n          content = Buffer.concat([content, data], content.length + data.length);\n        } else {\n          content = data;\n        }\n      }\n\n      return this;\n    }\n  });\n  /**\n   * @method JWE.Encrypter#final\n   * @description\n   * Finishes the encryption operation.\n   *\n   * The returned Promise, when fulfilled, is the JSON Web Encryption (JWE)\n   * object, either in the Compact (if {@link JWE.Encrypter#compact} is\n   * `true`) or the JSON serialization.\n   *\n   * @param {Buffer|String} [data] The final plaintext data to apply.\n   * @param {String} [encoding] The encoding of the final plaintext data\n   *        (if any).\n   * @returns {Promise} A promise for the encryption operation.\n   * @throws {Error} If ciphertext has already been generated.\n   */\n\n  Object.defineProperty(this, \"final\", {\n    value: function (data, encoding) {\n      if (finalized) {\n        return Promise.reject(new Error(\"already final\"));\n      } // last-minute data\n\n\n      this.update(data, encoding); // mark as done...ish\n\n      finalized = true;\n      var promise = Promise.resolve({}); // determine CEK and IV\n\n      var encAlg = fields.enc;\n      var encKey;\n      promise = promise.then(function (jwe) {\n        if (cfg.cek) {\n          encKey = JWK.asKey(cfg.cek);\n        }\n\n        return jwe;\n      }); // process recipients\n\n      promise = promise.then(function (jwe) {\n        var procR = function (r, one) {\n          var props = {};\n          props = assign(props, fields);\n          props = assign(props, r.header);\n          var algKey = r.key,\n              algAlg = props.alg; // generate Ephemeral EC Key\n\n          var tks, rpromise;\n\n          if (props.alg.indexOf(\"ECDH-ES\") === 0) {\n            tks = algKey.keystore.temp();\n\n            if (r.epk) {\n              rpromise = Promise.resolve(r.epk).then(function (epk) {\n                r.header.epk = epk.toJSON(false, [\"kid\"]);\n                props.epk = epk.toObject(true, [\"kid\"]);\n              });\n            } else {\n              rpromise = tks.generate(\"EC\", algKey.get(\"crv\")).then(function (epk) {\n                r.header.epk = epk.toJSON(false, [\"kid\"]);\n                props.epk = epk.toObject(true, [\"kid\"]);\n              });\n            }\n          } else {\n            rpromise = Promise.resolve();\n          } // encrypt the CEK\n\n\n          rpromise = rpromise.then(function () {\n            var cek, p; // special case 'alg=dir'\n\n            if (\"dir\" === algAlg && one) {\n              encKey = Promise.resolve(algKey);\n              p = encKey.then(function (jwk) {\n                // fixup encAlg\n                if (!encAlg) {\n                  props.enc = fields.enc = encAlg = jwk.algorithms(JWK.MODE_ENCRYPT)[0];\n                }\n\n                return {\n                  once: true,\n                  direct: true\n                };\n              });\n            } else {\n              if (!encKey) {\n                if (!encAlg) {\n                  props.enc = fields.enc = encAlg = cfg.contentAlg;\n                }\n\n                encKey = generateCEK(encAlg);\n              }\n\n              p = encKey.then(function (jwk) {\n                cek = jwk.get(\"k\", true); // algKey may or may not be a promise\n\n                return algKey;\n              });\n              p = p.then(function (algKey) {\n                return algKey.wrap(algAlg, cek, props);\n              });\n            }\n\n            return p;\n          });\n          rpromise = rpromise.then(function (wrapped) {\n            if (wrapped.once && !one) {\n              return Promise.reject(new Error(\"cannot use 'alg':'\" + algAlg + \"' with multiple recipients\"));\n            }\n\n            var rjwe = {},\n                cek;\n\n            if (wrapped.data) {\n              cek = wrapped.data;\n              cek = util.base64url.encode(cek);\n            }\n\n            if (wrapped.direct && cek) {\n              // replace content key\n              encKey = JWK.asKey({\n                kty: \"oct\",\n                k: cek\n              });\n            } else if (cek) {\n              /* eslint camelcase: [0] */\n              rjwe.encrypted_key = cek;\n            }\n\n            if (r.header && Object.keys(r.header).length) {\n              rjwe.header = clone(r.header || {});\n            }\n\n            if (wrapped.header) {\n              rjwe.header = assign(rjwe.header || {}, wrapped.header);\n            }\n\n            return rjwe;\n          });\n          return rpromise;\n        };\n\n        var p = Promise.all(recipients);\n        p = p.then(function (rcpts) {\n          var single = 1 === rcpts.length;\n          rcpts = rcpts.map(function (r) {\n            return procR(r, single);\n          });\n          return Promise.all(rcpts);\n        });\n        p = p.then(function (rcpts) {\n          jwe.recipients = rcpts.filter(function (r) {\n            return !!r;\n          });\n          return jwe;\n        });\n        return p;\n      }); // normalize headers\n\n      var props = {};\n      promise = promise.then(function (jwe) {\n        var protect, lenProtect, unprotect, lenUnprotect;\n        unprotect = clone(fields);\n\n        if (protectAll && jwe.recipients.length === 1 || \"compact\" === format) {\n          // merge single recipient into fields\n          protect = assign(jwe.recipients[0].header || {}, unprotect);\n          lenProtect = Object.keys(protect).length;\n          unprotect = undefined;\n          lenUnprotect = 0;\n          delete jwe.recipients[0].header;\n\n          if (Object.keys(jwe.recipients[0]).length === 0) {\n            jwe.recipients.splice(0, 1);\n          }\n        } else {\n          protect = {};\n          lenProtect = 0;\n          lenUnprotect = Object.keys(unprotect).length;\n          cfg.protect.forEach(function (f) {\n            if (!(f in unprotect)) {\n              return;\n            }\n\n            protect[f] = unprotect[f];\n            lenProtect++;\n            delete unprotect[f];\n            lenUnprotect--;\n          });\n        }\n\n        if (!jwe.recipients || jwe.recipients.length === 0) {\n          delete jwe.recipients;\n        } // \"serialize\" (and setup merged props)\n\n\n        if (unprotect && lenUnprotect > 0) {\n          props = assign(props, unprotect);\n          jwe.unprotected = unprotect;\n        }\n\n        if (protect && lenProtect > 0) {\n          props = assign(props, protect);\n          protect = JSON.stringify(protect);\n          jwe.protected = util.base64url.encode(protect, \"utf8\");\n        }\n\n        return jwe;\n      }); // (OPTIONAL) compress plaintext\n\n      promise = promise.then(function (jwe) {\n        var pdata = content;\n\n        if (!props.zip) {\n          jwe.plaintext = pdata;\n          return jwe;\n        } else if (props.zip === \"DEF\") {\n          return new Promise(function (resolve, reject) {\n            zlib.deflateRaw(new Buffer(pdata, \"binary\"), function (err, data) {\n              if (err) {\n                reject(err);\n              } else {\n                jwe.plaintext = data;\n                resolve(jwe);\n              }\n            });\n          });\n        }\n\n        return Promise.reject(new Error(\"unsupported 'zip' mode\"));\n      }); // encrypt plaintext\n\n      promise = promise.then(function (jwe) {\n        props.adata = jwe.protected;\n\n        if (\"aad\" in cfg && cfg.aad != null) {\n          props.adata += \".\" + cfg.aad;\n          props.adata = new Buffer(props.adata, \"utf8\");\n        } // calculate IV\n\n\n        var iv = cfg.iv || util.randomBytes(CONSTANTS.NONCELENGTH[encAlg] / 8);\n\n        if (\"string\" === typeof iv) {\n          iv = util.base64url.decode(iv);\n        }\n\n        props.iv = iv;\n\n        if (\"recipients\" in jwe && jwe.recipients.length === 1) {\n          props.kdata = jwe.recipients[0].encrypted_key;\n        }\n\n        if (\"epu\" in cfg && cfg.epu != null) {\n          props.epu = cfg.epu;\n        }\n\n        if (\"epv\" in cfg && cfg.epv != null) {\n          props.epv = cfg.epv;\n        }\n\n        var pdata = jwe.plaintext;\n        delete jwe.plaintext;\n        return encKey.then(function (encKey) {\n          var p = encKey.encrypt(encAlg, pdata, props);\n          p = p.then(function (result) {\n            jwe.iv = util.base64url.encode(iv, \"binary\");\n\n            if (\"aad\" in cfg && cfg.aad != null) {\n              jwe.aad = cfg.aad;\n            }\n\n            jwe.ciphertext = util.base64url.encode(result.data, \"binary\");\n            jwe.tag = util.base64url.encode(result.tag, \"binary\");\n            return jwe;\n          });\n          return p;\n        });\n      }); // (OPTIONAL) compact/flattened results\n\n      switch (format) {\n        case \"compact\":\n          promise = promise.then(function (jwe) {\n            var compact = new Array(5);\n            compact[0] = jwe.protected;\n\n            if (jwe.recipients && jwe.recipients[0]) {\n              compact[1] = jwe.recipients[0].encrypted_key;\n            }\n\n            compact[2] = jwe.iv;\n            compact[3] = jwe.ciphertext;\n            compact[4] = jwe.tag;\n            compact = compact.join(\".\");\n            return compact;\n          });\n          break;\n\n        case \"flattened\":\n          promise = promise.then(function (jwe) {\n            var flattened = {},\n                rcpt = jwe.recipients && jwe.recipients[0];\n\n            if (jwe.protected) {\n              flattened.protected = jwe.protected;\n            }\n\n            if (jwe.unprotected) {\n              flattened.unprotected = jwe.unprotected;\n            }\n\n            [\"header\", \"encrypted_key\"].forEach(function (f) {\n              if (!rcpt) {\n                return;\n              }\n\n              if (!(f in rcpt)) {\n                return;\n              }\n\n              flattened[f] = rcpt[f];\n            });\n\n            if (jwe.aad) {\n              flattened.aad = jwe.aad;\n            }\n\n            flattened.iv = jwe.iv;\n            flattened.ciphertext = jwe.ciphertext;\n            flattened.tag = jwe.tag;\n            return flattened;\n          });\n          break;\n      }\n\n      return promise;\n    }\n  });\n}\n\nfunction createEncrypt(opts, rcpts) {\n  // fixup recipients\n  var options = opts,\n      rcptStart = 1,\n      rcptList = rcpts;\n\n  if (arguments.length === 0) {\n    throw new Error(\"at least one recipient must be provided\");\n  }\n\n  if (arguments.length === 1) {\n    // assume opts is the recipient list\n    rcptList = opts;\n    rcptStart = 0;\n    options = {};\n  } else if (JWK.isKey(opts) || opts && \"kty\" in opts || opts && \"key\" in opts && (JWK.isKey(opts.key) || \"kty\" in opts.key)) {\n    rcptList = opts;\n    rcptStart = 0;\n    options = {};\n  } else {\n    options = clone(opts);\n  }\n\n  if (!Array.isArray(rcptList)) {\n    rcptList = slice(arguments, rcptStart);\n  } // fixup options\n\n\n  options = assign(clone(DEFAULTS), options); // setup header fields\n\n  var fields = clone(options.fields || {});\n\n  if (options.zip) {\n    fields.zip = typeof options.zip === \"boolean\" ? options.zip ? \"DEF\" : false : options.zip;\n  }\n\n  options.format = (options.compact ? \"compact\" : options.format) || \"general\";\n\n  switch (options.format) {\n    case \"compact\":\n      if (\"aad\" in opts) {\n        throw new Error(\"additional authenticated data cannot be used for compact serialization\");\n      }\n\n    /* eslint no-fallthrough: [0] */\n\n    case \"flattened\":\n      if (rcptList.length > 1) {\n        throw new Error(\"too many recipients for compact serialization\");\n      }\n\n      break;\n  } // note protected fields (globally)\n  // protected fields are global only\n\n\n  var protectAll = false;\n\n  if (\"compact\" === options.format || \"*\" === options.protect) {\n    protectAll = true;\n    options.protect = Object.keys(fields).concat(\"enc\");\n  } else if (typeof options.protect === \"string\") {\n    options.protect = [options.protect];\n  } else if (Array.isArray(options.protect)) {\n    options.protect = options.protect.concat();\n  } else if (!options.protect) {\n    options.protect = [];\n  } else {\n    throw new Error(\"protect must be a list of fields\");\n  }\n\n  if (protectAll && 1 < rcptList.length) {\n    throw new Error(\"too many recipients to protect all header parameters\");\n  }\n\n  rcptList = rcptList.map(function (r, idx) {\n    var p; // resolve a key\n\n    if (r && \"kty\" in r) {\n      p = JWK.asKey(r);\n      p = p.then(function (k) {\n        return {\n          key: k\n        };\n      });\n    } else if (r) {\n      p = JWK.asKey(r.key);\n      p = p.then(function (k) {\n        return {\n          header: r.header,\n          reference: r.reference,\n          key: k\n        };\n      });\n    } else {\n      p = Promise.reject(new Error(\"missing key for recipient \" + idx));\n    } // convert ephemeral key (if present)\n\n\n    if (r.epk) {\n      p = p.then(function (recipient) {\n        return JWK.asKey(r.epk).then(function (epk) {\n          recipient.epk = epk;\n          return recipient;\n        });\n      });\n    } // resolve the complete recipient\n\n\n    p = p.then(function (recipient) {\n      var key = recipient.key; // prepare the recipient header\n\n      var header = recipient.header || {};\n      recipient.header = header;\n      var props = {};\n      props = assign(props, fields);\n      props = assign(props, recipient.header); // ensure key protection algorithm is set\n\n      if (!props.alg) {\n        props.alg = key.algorithms(JWK.MODE_WRAP)[0];\n      }\n\n      header.alg = props.alg; // determine the key reference\n\n      var ref = recipient.reference;\n      delete recipient.reference;\n\n      if (undefined === ref) {\n        // header already contains the key reference\n        ref = [\"kid\", \"jku\", \"x5c\", \"x5t\", \"x5u\"].some(function (k) {\n          return k in header;\n        });\n        ref = !ref ? \"kid\" : null;\n      } else if (\"boolean\" === typeof ref) {\n        // explicit (positive | negative) request for key reference\n        ref = ref ? \"kid\" : null;\n      }\n\n      var jwk;\n\n      if (ref) {\n        jwk = key.toJSON();\n\n        if (\"jwk\" === ref) {\n          if (\"oct\" === key.kty) {\n            return Promise.reject(new Error(\"cannot embed key\"));\n          }\n\n          header.jwk = jwk;\n        } else if (ref in jwk) {\n          header[ref] = jwk[ref];\n        }\n      } // freeze recipient\n\n\n      recipient = Object.freeze(recipient);\n      return recipient;\n    });\n    return p;\n  }); // create and configure encryption\n\n  var cfg = {\n    aad: \"aad\" in options ? util.base64url.encode(options.aad || \"\") : null,\n    contentAlg: options.contentAlg,\n    format: options.format,\n    protect: options.protect,\n    cek: options.cek,\n    iv: options.iv,\n    protectAll: protectAll\n  };\n  var enc = new JWEEncrypter(cfg, fields, rcptList);\n  return enc;\n}\n\nmodule.exports = {\n  encrypter: JWEEncrypter,\n  createEncrypt: createEncrypt\n};","map":{"version":3,"sources":["/Users/pratison/Work/Cisco/Education/React/education-webex/node_modules/node-jose/lib/jwe/encrypt.js"],"names":["assign","require","clone","util","generateCEK","JWK","slice","zlib","CONSTANTS","DEFAULTS","JWEEncrypter","cfg","fields","recipients","finalized","format","protectAll","content","Buffer","Object","defineProperty","get","zip","enumerable","protect","value","data","encoding","Error","asBuffer","length","concat","Promise","reject","update","promise","resolve","encAlg","enc","encKey","then","jwe","cek","asKey","procR","r","one","props","header","algKey","key","algAlg","alg","tks","rpromise","indexOf","keystore","temp","epk","toJSON","toObject","generate","p","jwk","algorithms","MODE_ENCRYPT","once","direct","contentAlg","wrap","wrapped","rjwe","base64url","encode","kty","k","encrypted_key","keys","all","rcpts","single","map","filter","lenProtect","unprotect","lenUnprotect","undefined","splice","forEach","f","unprotected","JSON","stringify","protected","pdata","plaintext","deflateRaw","err","adata","aad","iv","randomBytes","NONCELENGTH","decode","kdata","epu","epv","encrypt","result","ciphertext","tag","compact","Array","join","flattened","rcpt","createEncrypt","opts","options","rcptStart","rcptList","arguments","isKey","isArray","idx","reference","recipient","MODE_WRAP","ref","some","freeze","module","exports","encrypter"],"mappings":"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","sourcesContent":["/*!\n * jwe/encrypt.js - Encrypt to a JWE\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar assign = require(\"lodash.assign\"),\n    clone = require(\"lodash.clone\"),\n    util = require(\"../util\"),\n    generateCEK = require(\"./helpers\").generateCEK,\n    JWK = require(\"../jwk\"),\n    slice = require(\"./helpers\").slice,\n    zlib = require(\"zlib\"),\n    CONSTANTS = require(\"../algorithms/constants\");\n\nvar DEFAULTS = require(\"./defaults\");\n\n/**\n * @class JWE.Encrypter\n * @classdesc\n * Generator of encrypted data.\n *\n * @description\n * **NOTE:** This class cannot be instantiated directly. Instead call {@link\n * JWE.createEncrypt}.\n */\nfunction JWEEncrypter(cfg, fields, recipients) {\n  var finalized = false,\n    format = cfg.format || \"general\",\n    protectAll = !!cfg.protectAll,\n    content = new Buffer(0);\n\n  /**\n   * @member {String} JWE.Encrypter#zip\n   * @readonly\n   * @description\n   * Indicates the compression algorithm applied to the plaintext\n   * before it is encrypted.  The possible values are:\n   *\n   * + **`\"DEF\"`**: Compress the plaintext using the DEFLATE algorithm.\n   * + **`\"\"`**: Do not compress the plaintext.\n   */\n  Object.defineProperty(this, \"zip\", {\n    get: function() {\n      return fields.zip || \"\";\n    },\n    enumerable: true\n  });\n  /**\n   * @member {Boolean} JWE.Encrypter#compact\n   * @readonly\n   * @description\n   * Indicates whether the output of this encryption generator is\n   * using the Compact serialization (`true`) or the JSON\n   * serialization (`false`).\n   */\n  Object.defineProperty(this, \"compact\", {\n    get: function() { return \"compact\" === format; },\n    enumerable: true\n  });\n  /**\n   * @member {String} JWE.Encrypter#format\n   * @readonly\n   * @description\n   * Indicates the format the output of this encryption generator takes.\n   */\n  Object.defineProperty(this, \"format\", {\n    get: function() { return format; },\n    enumerable: true\n  });\n  /**\n   * @member {String[]} JWE.Encrypter#protected\n   * @readonly\n   * @description\n   * The header parameter names that are protected. Protected header fields\n   * are first serialized to UTF-8 then encoded as util.base64url, then used as\n   * the additional authenticated data in the encryption operation.\n   */\n  Object.defineProperty(this, \"protected\", {\n    get: function() {\n      return clone(cfg.protect);\n    },\n    enumerable: true\n  });\n  /**\n   * @member {Object} JWE.Encrypter#header\n   * @readonly\n   * @description\n   * The global header parameters, both protected and unprotected. Call\n   * {@link JWE.Encrypter#protected} to determine which parameters will\n   * be protected.\n   */\n  Object.defineProperty(this, \"header\", {\n    get: function() {\n      return clone(fields);\n    },\n    enumerable: true\n  });\n\n  /**\n   * @method JWE.Encrypter#update\n   * @description\n   * Updates the plaintext data for the encryption generator. The plaintext\n   * is appended to the end of any other plaintext already applied.\n   *\n   * If {data} is a Buffer, {encoding} is ignored. Otherwise, {data} is\n   * converted to a Buffer internally to {encoding}.\n   *\n   * @param {Buffer|String} [data] The plaintext to apply.\n   * @param {String} [encoding] The encoding of the plaintext.\n   * @returns {JWE.Encrypter} This encryption generator.\n   * @throws {Error} If ciphertext has already been generated.\n   */\n  Object.defineProperty(this, \"update\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        throw new Error(\"already final\");\n      }\n      if (data != null) {\n        data = util.asBuffer(data, encoding);\n        if (content.length) {\n          content = Buffer.concat([content, data],\n                      content.length + data.length);\n        } else {\n          content = data;\n        }\n      }\n\n      return this;\n    }\n  });\n  /**\n   * @method JWE.Encrypter#final\n   * @description\n   * Finishes the encryption operation.\n   *\n   * The returned Promise, when fulfilled, is the JSON Web Encryption (JWE)\n   * object, either in the Compact (if {@link JWE.Encrypter#compact} is\n   * `true`) or the JSON serialization.\n   *\n   * @param {Buffer|String} [data] The final plaintext data to apply.\n   * @param {String} [encoding] The encoding of the final plaintext data\n   *        (if any).\n   * @returns {Promise} A promise for the encryption operation.\n   * @throws {Error} If ciphertext has already been generated.\n   */\n  Object.defineProperty(this, \"final\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        return Promise.reject(new Error(\"already final\"));\n      }\n\n      // last-minute data\n      this.update(data, encoding);\n\n      // mark as done...ish\n      finalized = true;\n      var promise = Promise.resolve({});\n\n      // determine CEK and IV\n      var encAlg = fields.enc;\n      var encKey;\n      promise = promise.then(function(jwe) {\n        if (cfg.cek) {\n          encKey = JWK.asKey(cfg.cek);\n        }\n        return jwe;\n      });\n\n      // process recipients\n      promise = promise.then(function(jwe) {\n        var procR = function(r, one) {\n          var props = {};\n          props = assign(props, fields);\n          props = assign(props, r.header);\n\n          var algKey = r.key,\n              algAlg = props.alg;\n\n          // generate Ephemeral EC Key\n          var tks,\n              rpromise;\n          if (props.alg.indexOf(\"ECDH-ES\") === 0) {\n            tks = algKey.keystore.temp();\n            if (r.epk) {\n              rpromise = Promise.resolve(r.epk).\n                then(function(epk) {\n                  r.header.epk = epk.toJSON(false, [\"kid\"]);\n                  props.epk = epk.toObject(true, [\"kid\"]);\n                });\n            } else {\n              rpromise = tks.generate(\"EC\", algKey.get(\"crv\")).\n                then(function(epk) {\n                  r.header.epk = epk.toJSON(false, [\"kid\"]);\n                  props.epk = epk.toObject(true, [\"kid\"]);\n                });\n            }\n          } else {\n            rpromise = Promise.resolve();\n          }\n\n          // encrypt the CEK\n          rpromise = rpromise.then(function() {\n            var cek,\n                p;\n            // special case 'alg=dir'\n            if (\"dir\" === algAlg && one) {\n              encKey = Promise.resolve(algKey);\n              p = encKey.then(function(jwk) {\n                // fixup encAlg\n                if (!encAlg) {\n                  props.enc = fields.enc = encAlg = jwk.algorithms(JWK.MODE_ENCRYPT)[0];\n                }\n                return {\n                  once: true,\n                  direct: true\n                };\n              });\n            } else {\n              if (!encKey) {\n                if (!encAlg) {\n                  props.enc = fields.enc = encAlg = cfg.contentAlg;\n                }\n                encKey = generateCEK(encAlg);\n              }\n              p = encKey.then(function(jwk) {\n                cek = jwk.get(\"k\", true);\n                // algKey may or may not be a promise\n                return algKey;\n              });\n              p = p.then(function(algKey) {\n                return algKey.wrap(algAlg, cek, props);\n              });\n            }\n            return p;\n          });\n          rpromise = rpromise.then(function(wrapped) {\n            if (wrapped.once && !one) {\n              return Promise.reject(new Error(\"cannot use 'alg':'\" + algAlg + \"' with multiple recipients\"));\n            }\n\n            var rjwe = {},\n                cek;\n            if (wrapped.data) {\n              cek = wrapped.data;\n              cek = util.base64url.encode(cek);\n            }\n\n            if (wrapped.direct && cek) {\n              // replace content key\n              encKey = JWK.asKey({\n                kty: \"oct\",\n                k: cek\n              });\n            } else if (cek) {\n              /* eslint camelcase: [0] */\n              rjwe.encrypted_key = cek;\n            }\n\n            if (r.header && Object.keys(r.header).length) {\n              rjwe.header = clone(r.header || {});\n            }\n            if (wrapped.header) {\n              rjwe.header = assign(rjwe.header || {},\n                                     wrapped.header);\n            }\n\n            return rjwe;\n           });\n           return rpromise;\n        };\n\n        var p = Promise.all(recipients);\n        p = p.then(function(rcpts) {\n          var single = (1 === rcpts.length);\n          rcpts = rcpts.map(function(r) {\n            return procR(r, single);\n          });\n          return Promise.all(rcpts);\n        });\n        p = p.then(function(rcpts) {\n          jwe.recipients = rcpts.filter(function(r) { return !!r; });\n          return jwe;\n        });\n        return p;\n      });\n\n      // normalize headers\n      var props = {};\n      promise = promise.then(function(jwe) {\n        var protect,\n          lenProtect,\n          unprotect,\n          lenUnprotect;\n\n        unprotect = clone(fields);\n        if ((protectAll && jwe.recipients.length === 1) || \"compact\" === format) {\n          // merge single recipient into fields\n          protect = assign(jwe.recipients[0].header || {},\n                     unprotect);\n          lenProtect = Object.keys(protect).length;\n\n          unprotect = undefined;\n          lenUnprotect = 0;\n\n          delete jwe.recipients[0].header;\n          if (Object.keys(jwe.recipients[0]).length === 0) {\n            jwe.recipients.splice(0, 1);\n          }\n        } else {\n          protect = {};\n          lenProtect = 0;\n          lenUnprotect = Object.keys(unprotect).length;\n          cfg.protect.forEach(function(f) {\n            if (!(f in unprotect)) {\n              return;\n            }\n            protect[f] = unprotect[f];\n            lenProtect++;\n\n            delete unprotect[f];\n            lenUnprotect--;\n          });\n        }\n\n        if (!jwe.recipients || jwe.recipients.length === 0) {\n          delete jwe.recipients;\n        }\n\n        // \"serialize\" (and setup merged props)\n        if (unprotect && lenUnprotect > 0) {\n          props = assign(props, unprotect);\n          jwe.unprotected = unprotect;\n        }\n        if (protect && lenProtect > 0) {\n          props = assign(props, protect);\n          protect = JSON.stringify(protect);\n          jwe.protected = util.base64url.encode(protect, \"utf8\");\n        }\n\n        return jwe;\n      });\n\n      // (OPTIONAL) compress plaintext\n      promise = promise.then(function(jwe) {\n        var pdata = content;\n        if (!props.zip) {\n          jwe.plaintext = pdata;\n          return jwe;\n        } else if (props.zip === \"DEF\") {\n          return new Promise(function(resolve, reject) {\n            zlib.deflateRaw(new Buffer(pdata, \"binary\"), function(err, data) {\n              if (err) {\n                reject(err);\n              }\n              else {\n                jwe.plaintext = data;\n                resolve(jwe);\n              }\n            });\n          });\n        }\n        return Promise.reject(new Error(\"unsupported 'zip' mode\"));\n      });\n\n      // encrypt plaintext\n      promise = promise.then(function(jwe) {\n        props.adata = jwe.protected;\n        if (\"aad\" in cfg && cfg.aad != null) {\n          props.adata += \".\" + cfg.aad;\n          props.adata = new Buffer(props.adata, \"utf8\");\n        }\n        // calculate IV\n        var iv = cfg.iv ||\n                 util.randomBytes(CONSTANTS.NONCELENGTH[encAlg] / 8);\n        if (\"string\" === typeof iv) {\n          iv = util.base64url.decode(iv);\n        }\n        props.iv = iv;\n\n        if (\"recipients\" in jwe && jwe.recipients.length === 1) {\n          props.kdata = jwe.recipients[0].encrypted_key;\n        }\n\n        if (\"epu\" in cfg && cfg.epu != null) {\n          props.epu = cfg.epu;\n        }\n\n        if (\"epv\" in cfg && cfg.epv != null) {\n          props.epv = cfg.epv;\n        }\n\n        var pdata = jwe.plaintext;\n        delete jwe.plaintext;\n        return encKey.then(function(encKey) {\n          var p = encKey.encrypt(encAlg, pdata, props);\n          p = p.then(function(result) {\n            jwe.iv = util.base64url.encode(iv, \"binary\");\n            if (\"aad\" in cfg && cfg.aad != null) {\n             jwe.aad = cfg.aad;\n            }\n            jwe.ciphertext = util.base64url.encode(result.data, \"binary\");\n            jwe.tag = util.base64url.encode(result.tag, \"binary\");\n            return jwe;\n          });\n          return p;\n        });\n      });\n\n      // (OPTIONAL) compact/flattened results\n      switch (format) {\n        case \"compact\":\n          promise = promise.then(function(jwe) {\n            var compact = new Array(5);\n\n            compact[0] = jwe.protected;\n            if (jwe.recipients && jwe.recipients[0]) {\n              compact[1] = jwe.recipients[0].encrypted_key;\n            }\n\n            compact[2] = jwe.iv;\n            compact[3] = jwe.ciphertext;\n            compact[4] = jwe.tag;\n            compact = compact.join(\".\");\n\n            return compact;\n          });\n          break;\n        case \"flattened\":\n          promise = promise.then(function(jwe) {\n            var flattened = {},\n                rcpt = jwe.recipients && jwe.recipients[0];\n\n            if (jwe.protected) {\n              flattened.protected = jwe.protected;\n            }\n            if (jwe.unprotected) {\n              flattened.unprotected = jwe.unprotected;\n            }\n            [\"header\", \"encrypted_key\"].forEach(function(f) {\n              if (!rcpt) { return; }\n              if (!(f in rcpt)) { return; }\n              flattened[f] = rcpt[f];\n            });\n            if (jwe.aad) {\n              flattened.aad = jwe.aad;\n            }\n            flattened.iv = jwe.iv;\n            flattened.ciphertext = jwe.ciphertext;\n            flattened.tag = jwe.tag;\n\n            return flattened;\n          });\n          break;\n      }\n\n      return promise;\n    }\n  });\n}\n\nfunction createEncrypt(opts, rcpts) {\n  // fixup recipients\n  var options = opts,\n    rcptStart = 1,\n    rcptList = rcpts;\n\n  if (arguments.length === 0) {\n    throw new Error(\"at least one recipient must be provided\");\n  }\n  if (arguments.length === 1) {\n    // assume opts is the recipient list\n    rcptList = opts;\n    rcptStart = 0;\n    options = {};\n  } else if (JWK.isKey(opts) ||\n        (opts && \"kty\" in opts) ||\n        (opts && \"key\" in opts &&\n        (JWK.isKey(opts.key) || \"kty\" in opts.key))) {\n    rcptList = opts;\n    rcptStart = 0;\n    options = {};\n  } else {\n    options = clone(opts);\n  }\n  if (!Array.isArray(rcptList)) {\n    rcptList = slice(arguments, rcptStart);\n  }\n\n  // fixup options\n  options = assign(clone(DEFAULTS), options);\n\n  // setup header fields\n  var fields = clone(options.fields || {});\n  if (options.zip) {\n    fields.zip = (typeof options.zip === \"boolean\") ?\n           (options.zip ? \"DEF\" : false) :\n           options.zip;\n  }\n  options.format = (options.compact ? \"compact\" : options.format) || \"general\";\n  switch (options.format) {\n    case \"compact\":\n      if (\"aad\" in opts) {\n        throw new Error(\"additional authenticated data cannot be used for compact serialization\");\n      }\n      /* eslint no-fallthrough: [0] */\n    case \"flattened\":\n      if (rcptList.length > 1) {\n        throw new Error(\"too many recipients for compact serialization\");\n      }\n      break;\n  }\n\n  // note protected fields (globally)\n  // protected fields are global only\n  var protectAll = false;\n  if (\"compact\" === options.format || \"*\" === options.protect) {\n    protectAll = true;\n    options.protect = Object.keys(fields).concat(\"enc\");\n  } else if (typeof options.protect === \"string\") {\n    options.protect = [options.protect];\n  } else if (Array.isArray(options.protect)) {\n    options.protect = options.protect.concat();\n  } else if (!options.protect) {\n    options.protect = [];\n  } else {\n    throw new Error(\"protect must be a list of fields\");\n  }\n\n  if (protectAll && 1 < rcptList.length) {\n    throw new Error(\"too many recipients to protect all header parameters\");\n  }\n\n  rcptList = rcptList.map(function(r, idx) {\n    var p;\n\n    // resolve a key\n    if (r && \"kty\" in r) {\n      p = JWK.asKey(r);\n      p = p.then(function(k) {\n        return {\n          key: k\n        };\n      });\n    } else if (r) {\n      p = JWK.asKey(r.key);\n      p = p.then(function(k) {\n        return {\n          header: r.header,\n          reference: r.reference,\n          key: k\n        };\n      });\n    } else {\n      p = Promise.reject(new Error(\"missing key for recipient \" + idx));\n    }\n\n    // convert ephemeral key (if present)\n    if (r.epk) {\n      p = p.then(function(recipient) {\n        return JWK.asKey(r.epk).\n          then(function(epk) {\n            recipient.epk = epk;\n            return recipient;\n          });\n      });\n    }\n\n    // resolve the complete recipient\n    p = p.then(function(recipient) {\n      var key = recipient.key;\n\n      // prepare the recipient header\n      var header = recipient.header || {};\n      recipient.header = header;\n      var props = {};\n      props = assign(props, fields);\n      props = assign(props, recipient.header);\n\n      // ensure key protection algorithm is set\n      if (!props.alg) {\n        props.alg = key.algorithms(JWK.MODE_WRAP)[0];\n      }\n      header.alg = props.alg;\n\n      // determine the key reference\n      var ref = recipient.reference;\n      delete recipient.reference;\n      if (undefined === ref) {\n        // header already contains the key reference\n        ref = [\"kid\", \"jku\", \"x5c\", \"x5t\", \"x5u\"].some(function(k) {\n          return (k in header);\n        });\n        ref = !ref ? \"kid\" : null;\n      } else if (\"boolean\" === typeof ref) {\n        // explicit (positive | negative) request for key reference\n        ref = ref ? \"kid\" : null;\n      }\n      var jwk;\n      if (ref) {\n        jwk = key.toJSON();\n        if (\"jwk\" === ref) {\n          if (\"oct\" === key.kty) {\n            return Promise.reject(new Error(\"cannot embed key\"));\n          }\n          header.jwk = jwk;\n        } else if (ref in jwk) {\n          header[ref] = jwk[ref];\n        }\n      }\n\n      // freeze recipient\n      recipient = Object.freeze(recipient);\n      return recipient;\n    });\n\n    return p;\n  });\n\n  // create and configure encryption\n  var cfg = {\n    aad: (\"aad\" in options) ? util.base64url.encode(options.aad || \"\") : null,\n    contentAlg: options.contentAlg,\n    format: options.format,\n    protect: options.protect,\n    cek: options.cek,\n    iv: options.iv,\n    protectAll: protectAll\n  };\n  var enc = new JWEEncrypter(cfg, fields, rcptList);\n\n  return enc;\n}\n\nmodule.exports = {\n  encrypter: JWEEncrypter,\n  createEncrypt: createEncrypt\n};\n"]},"metadata":{},"sourceType":"script"}