{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _constants = require('./constants');\n\nvar _serviceHost = require('./service-host');\n\nvar _serviceHost2 = _interopRequireDefault(_serviceHost);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * The parameter transfer object for {@link ServiceRegistry#mapRemoteCatalog}.\n * This object is shaped to match the object returned from the **U2C** service.\n *\n * @typedef {Record<string, string>} RSL\n * @typedef {Record<string, Array<Record<string, number | string>>>} RHC\n *\n * @typedef {Object} MapRemoteCatalogPTO\n * @property {string} MapRemoteCatalogPTO.catalog - Service catalog name.\n * @property {RSL} MapRemoteCatalogPTO.serviceLinks - Service links.\n * @property {RHC} MapRemoteCatalogPTO.hostCatalog - Service host catalog.\n */\n\n/**\n * Service manipulation filter object for retrieving services within the\n * {@link ServiceRegistry} class.\n *\n * @typedef {Object} HostFilter\n * @property {boolean} [HostFilter.active] - Active state to filter.\n * @property {Array<string> | string} [HostFilter.catalog] - Catalogs to filter.\n * @property {Array<string> | string} [HostFilter.cluster] - Clusters to filter.\n * @property {boolean} [HostFilter.local] - Filter to the user's home cluster.\n * @property {boolean} [HostFilter.priority] - Filter for the highest priority.\n * @property {Array<string> | string} [HostFilter.service] - Services to filter.\n * @property {Array<string> | string} [HostFilter.url] - URL to filter.\n */\n\n/**\n * @class\n * @classdesc - Manages a collection of {@link ServiceHost} class objects.\n */\n\n\nvar ServiceRegistry = function () {\n  /**\n   * Generate a new {@link ServiceHost}.\n   *\n   * @public\n   * @constructor\n   * @memberof ServiceHost\n   */\n  function ServiceRegistry() {\n    (0, _classCallCheck3.default)(this, ServiceRegistry);\n    /**\n     * The collection of managed {@link ServiceHost}s.\n     *\n     * @instance\n     * @type {Array<ServiceHost>}\n     * @private\n     * @memberof ServiceRegistry\n     */\n\n    this.hosts = [];\n  }\n  /**\n   * An active, local, and priority mapped record of the current\n   * {@link ServiceCatalog#hosts}.\n   *\n   * @public\n   * @memberof ServiceCatalog\n   * @type {Record<string, string>}\n   */\n\n\n  (0, _createClass3.default)(ServiceRegistry, [{\n    key: 'clear',\n\n    /**\n     * Removes a collection of {@link ServiceHost} class objects from the\n     * {@link ServiceRegistry#hosts} array based on the provided\n     * {@link HostFilter}.\n     *\n     * @public\n     * @memberof ServiceRegistry\n     * @param {HostFilter} filter - The inclusive filter for hosts to remove.\n     * @returns {Array<ServiceHost>} - The removed {@link ServiceHost}s.\n     */\n    value: function clear(filter) {\n      // Collect a list of hosts to remove based on the provided filter.\n      var removing = this.find(filter); // Remove the hosts from the array.\n\n      this.hosts = this.hosts.filter(function (host) {\n        return !removing.includes(host);\n      }); // Return the removed hosts.\n\n      return removing;\n    }\n    /**\n     * Mark a collection of {@link ServiceHost} class objects from the\n     * {@link ServiceRegistry#hosts} array as failed based on the provided\n     * {@link HostFilter}.\n     *\n     * @public\n     * @memberof ServiceRegistry\n     * @param {HostFilter} filter - The inclusive filter for hosts to mark failed.\n     * @returns {Array<ServiceHost>} - The {@link ServiceHost}s marked failed.\n     */\n\n  }, {\n    key: 'failed',\n    value: function failed(filter) {\n      // Collect a list of hosts to mark as failed based on the provided filter.\n      var failing = this.find(filter); // Mark the hosts from the array as failed.\n\n      failing.forEach(function (host) {\n        host.setStatus({\n          failed: true\n        });\n      }); // Return the marked hosts.\n\n      return failing;\n    }\n    /**\n     * Filter the {@link ServiceRegistry#hosts} array against their active states.\n     *\n     * @private\n     * @memberof ServiceRegistry\n     * @param {boolean} [active] - Filter for the host state.\n     * @returns {Array<ServiceHost>} - The filtered host array.\n     */\n\n  }, {\n    key: 'filterActive',\n    value: function filterActive(active) {\n      // Filter the host array if the active requirement is true.\n      return typeof active === 'boolean' ? this.hosts.filter(function (host) {\n        return host.active === active;\n      }) : [].concat((0, _toConsumableArray3.default)(this.hosts));\n    }\n    /**\n     * Filter the {@link ServiceRegistry#hosts} array against their assigned\n     * catalog values.\n     *\n     * @private\n     * @memberof ServiceRegistry\n     * @param {Array<string> | string} [catalog] - Catalogs to filter.\n     * @returns {Array<ServiceHost>} - The filtered host array.\n     */\n\n  }, {\n    key: 'filterCatalog',\n    value: function filterCatalog() {\n      var catalog = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; // Generate a catalog names array based on the provided catalog param.\n\n      var catalogs = (Array.isArray(catalog) ? catalog : [catalog]).map(function (catalogId) {\n        return ServiceRegistry.mapCatalogName({\n          id: catalogId,\n          type: _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING\n        }) || catalogId;\n      }); // Filter the host array against the catalog names array.\n\n      return catalogs.length > 0 ? this.hosts.filter(function (host) {\n        return catalogs.includes(host.catalog);\n      }) : [].concat((0, _toConsumableArray3.default)(this.hosts));\n    }\n    /**\n     * Filter the {@link ServiceRegistry#hosts} array against their assigned\n     * cluster values.\n     *\n     * @private\n     * @memberof ServiceRegistry\n     * @param {Array<string> | string} [cluster] - Clusters to filter for.\n     * @returns {Array<ServiceHost>} - The filtered host array.\n     */\n\n  }, {\n    key: 'filterCluster',\n    value: function filterCluster() {\n      var cluster = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; // Generate an array of clusters regardless of parameter type.\n\n      var clusters = Array.isArray(cluster) ? cluster : [cluster]; // Filter the host array against the provided clusters.\n\n      return clusters.length > 0 ? this.hosts.filter(function (host) {\n        return clusters.includes(host.id);\n      }) : [].concat((0, _toConsumableArray3.default)(this.hosts));\n    }\n    /**\n     * Filter the {@link ServiceRegistry#hosts} array against their location in\n     * reference to the authenticated user.\n     *\n     * @private\n     * @memberof ServiceRegistry\n     * @param {boolean} [local] - Filter for the host location.\n     * @returns {Array<ServiceHost>} - The filtered host array.\n     */\n\n  }, {\n    key: 'filterLocal',\n    value: function filterLocal(local) {\n      return typeof local === 'boolean' ? this.hosts.filter(function (host) {\n        return host.local === local;\n      }) : [].concat((0, _toConsumableArray3.default)(this.hosts));\n    }\n    /**\n     * Filter the {@link ServiceRegistry#hosts} array for the highest priority\n     * hosts for each specific service.\n     *\n     * @private\n     * @memberof ServiceRegistry\n     * @param {boolean} [priority] - Filter for the highest priority\n     * @returns {Array<ServiceHost>} - The filtered host array.\n     */\n\n  }, {\n    key: 'filterPriority',\n    value: function filterPriority(priority) {\n      return priority ? this.hosts.reduce(function (filteredHosts, currentHost) {\n        // Validate that the current host is not active.\n        if (!currentHost.active) {\n          return filteredHosts;\n        } // Determine if the filtered hosts array contains a host from the same\n        // host group.\n\n\n        var foundHost = filteredHosts.find(function (host) {\n          return host.hostGroup === currentHost.hostGroup;\n        }); // Validate if a host was found.\n\n        if (!foundHost) {\n          filteredHosts.push(currentHost);\n          return filteredHosts;\n        } // Map the found host's catalog to its priority value.\n\n\n        var foundHostCatalogPriority = ServiceRegistry.mapCatalogName({\n          id: foundHost.catalog,\n          type: _constants.SERVICE_CATALOGS_ENUM_TYPES.NUMBER\n        }); // Map the current host's catalog to its priority value.\n\n        var currentHostCatalogPriority = ServiceRegistry.mapCatalogName({\n          id: currentHost.catalog,\n          type: _constants.SERVICE_CATALOGS_ENUM_TYPES.NUMBER\n        }); // Validate if the found host has a lower priority than the current\n        // host.\n\n        if (foundHostCatalogPriority < currentHostCatalogPriority || foundHost.priority < currentHost.priority) {\n          filteredHosts.splice(filteredHosts.indexOf(foundHost, 1));\n          filteredHosts.push(currentHost);\n        }\n\n        return filteredHosts;\n      }, []) : [].concat((0, _toConsumableArray3.default)(this.hosts));\n    }\n    /**\n     * Filter the {@link ServiceRegistry#hosts} array for hosts with a specified\n     * set of service names.\n     *\n     * @private\n     * @memberof ServiceRegistry\n     * @param {Array<string> | string} [service] - Services to filter.\n     * @returns {Array<ServiceHost>} - The filtered host array.\n     */\n\n  }, {\n    key: 'filterService',\n    value: function filterService() {\n      var service = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; // Generate an array of services regardless of parameter type.\n\n      var services = Array.isArray(service) ? service : [service]; // Filter the host array against the provided services.\n\n      return services.length > 0 ? this.hosts.filter(function (host) {\n        return services.includes(host.service);\n      }) : [].concat((0, _toConsumableArray3.default)(this.hosts));\n    }\n    /**\n     * Filter the {@link ServiceRegistry#hosts} array for hosts with a specified\n     * set of URLs.\n     *\n     * @private\n     * @memberof ServiceRegistry\n     * @param {Array<string> | string} [url] - URL to filter.\n     * @returns {Array<ServiceHost>} - The filter host array.\n     */\n\n  }, {\n    key: 'filterUrl',\n    value: function filterUrl() {\n      var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; // Generate an array of URLs regardless of the parameter type.\n\n      var urls = Array.isArray(url) ? url : [url]; // Filter the host array against the provided URLs.\n\n      return urls.length > 0 ? this.hosts.filter(function (host) {\n        return urls.includes(host.url);\n      }) : [].concat((0, _toConsumableArray3.default)(this.hosts));\n    }\n    /**\n     * Get an array of {@link ServiceHost}s based on a provided\n     * {@link HostFilter} from the {@link ServiceRegistry#hosts} array.\n     *\n     * @public\n     * @memberof ServiceRegistry\n     * @param {HostFilter} [filter] - The inclusive filter for hosts to find.\n     * @returns {Array<ServiceHost>} - The filtered hosts.\n     */\n\n  }, {\n    key: 'find',\n    value: function find() {\n      var _this = this;\n\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          active = _ref.active,\n          catalog = _ref.catalog,\n          cluster = _ref.cluster,\n          local = _ref.local,\n          priority = _ref.priority,\n          service = _ref.service,\n          url = _ref.url;\n\n      return this.hosts.filter(function (host) {\n        return _this.filterActive(active).includes(host) && _this.filterCatalog(catalog).includes(host) && _this.filterCluster(cluster).includes(host) && _this.filterLocal(local).includes(host) && _this.filterPriority(priority).includes(host) && _this.filterService(service).includes(host) && _this.filterUrl(url).includes(host);\n      });\n    }\n    /**\n     * Load a formatted array of {@link ServiceHost} constructor parameter\n     * transfer objects as instances of {@link ServiceHost} class objects to the\n     * {@link ServiceRegistry#hosts} array.\n     *\n     * @public\n     * @memberof ServiceRegistry\n     * @param {Array<ServiceHost.ConstructorPTO>} hosts\n     * @returns {this}\n     */\n\n  }, {\n    key: 'load',\n    value: function load() {\n      var _hosts;\n\n      var hosts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; // Validate that the provided hosts are eligible to be loaded.\n\n      var validHosts = hosts.filter(function (host) {\n        return !!ServiceRegistry.mapCatalogName({\n          id: host.catalog,\n          type: _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING\n        });\n      }); // Load the eligible hosts.\n\n      (_hosts = this.hosts).push.apply(_hosts, (0, _toConsumableArray3.default)(validHosts.map(function (loadableHost) {\n        return new _serviceHost2.default(loadableHost);\n      })));\n\n      return this;\n    }\n    /**\n     * Mark a collection of {@link ServiceHost} class objects from the\n     * {@link ServiceRegistry#hosts} array as replaced based on the provided\n     * {@link HostFilter}.\n     *\n     * @public\n     * @memberof ServiceRegistry\n     * @param {HostFilter} filter - The inclusive filter to mark replaced.\n     * @returns {Array<ServiceHost>} - The {@link ServiceHost}s marked replaced.\n     */\n\n  }, {\n    key: 'replaced',\n    value: function replaced(filter) {\n      // Collect a list of hosts to mark as replaced based on the provided filter.\n      var replacing = this.find(filter); // Mark the hosts from the array as replaced.\n\n      replacing.forEach(function (host) {\n        host.setStatus({\n          replaced: true\n        });\n      }); // Return the marked hosts.\n\n      return replacing;\n    }\n    /**\n     * Reset the failed status of a collection of {@link ServiceHost} class\n     * objects from the {@link ServiceRegistry#hosts} array based on the provided\n     * {@link HostFilter}.\n     *\n     * @public\n     * @memberof ServiceRegistry\n     * @param {HostFilter} filter - The inclusive filter of hosts to reset.\n     * @returns {Array<ServiceHost>} - The {@link ServiceHost}s that reset.\n     */\n\n  }, {\n    key: 'reset',\n    value: function reset(filter) {\n      // Collect a list of hosts to mark as replaced based on the provided filter.\n      var resetting = this.find(filter); // Mark the hosts from the array as replaced.\n\n      resetting.forEach(function (host) {\n        host.setStatus({\n          failed: false\n        });\n      }); // Return the marked hosts.\n\n      return resetting;\n    }\n    /**\n     * Convert a {@link SERVICE_CATALOGS} identifier or value to its associated\n     * idenfier or value.\n     *\n     * @public\n     * @static\n     * @memberof ServiceRegistry\n     * @param {Object} pto - The parameter transfer object.\n     * @property {string | number} pto.id - The identifier to convert in the enum.\n     * @property {SERVICE_CATALOGS_ENUM_TYPES} pto.type - The desired output.\n     * @returns {string|number} - The matching enum value or index.\n     */\n\n  }, {\n    key: 'map',\n    get: function get() {\n      // Get a list of active, local, and priority-mapped hosts.\n      return this.find({\n        active: true,\n        local: true,\n        priority: true\n      }).reduce(function (map, host) {\n        // Generate a new object to assign the existing map.\n        var hostReference = {}; // Assign the key:value pair for the service and url.\n\n        hostReference[host.service] = host.url; // Assign the reference to the map and return.\n\n        return (0, _extends3.default)({}, map, hostReference);\n      }, {});\n    }\n  }], [{\n    key: 'mapCatalogName',\n    value: function mapCatalogName(_ref2) {\n      var id = _ref2.id,\n          type = _ref2.type; // Validate that the id is a number.\n\n      if (typeof id === 'number') {\n        // Validate that the desired type is a number.\n        if (type === _constants.SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {\n          return _constants.SERVICE_CATALOGS[id] !== undefined ? id : undefined;\n        } // Validate that the desired type is a string.\n\n\n        if (type === _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING) {\n          return _constants.SERVICE_CATALOGS[id];\n        }\n      } // Validate that the id is a string.\n\n\n      if (typeof id === 'string') {\n        // Validate that the desired type is a string.\n        if (type === _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING) {\n          return _constants.SERVICE_CATALOGS.includes(id) ? id : undefined;\n        } // Validate that the desired type is a number.\n\n\n        if (type === _constants.SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {\n          return _constants.SERVICE_CATALOGS.includes(id) ? _constants.SERVICE_CATALOGS.indexOf(id) : undefined;\n        }\n      }\n\n      return undefined;\n    }\n    /**\n     * Generate a formatted array based on the object received from the **U2C**\n     * service for usage in the {@link ServiceRegistry#load} method.\n     *\n     * @public\n     * @static\n     * @memberof ServiceRegistry\n     * @param {MapRemoteCatalogPTO} pto - The parameter transfer object.\n     * @throws - If the target catalog does not exist.\n     * @returns {Array<ServiceHost#ServiceHostConstructorPTO>}\n     */\n\n  }, {\n    key: 'mapRemoteCatalog',\n    value: function mapRemoteCatalog(_ref3) {\n      var catalog = _ref3.catalog,\n          hostCatalog = _ref3.hostCatalog,\n          serviceLinks = _ref3.serviceLinks; // Collect the service catalog name if needed.\n\n      var catalogIndex = ServiceRegistry.mapCatalogName({\n        id: catalog,\n        type: _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING\n      }); // Validate that the target catalog exists.\n\n      if (!_constants.SERVICE_CATALOGS.includes(catalogIndex)) {\n        throw new Error('service-catalogs: \\'' + catalog + '\\' is not a valid catalog');\n      } // Map the remote catalog to a mountable host array.\n\n\n      return (0, _keys2.default)(hostCatalog).reduce(function (output, key) {\n        output.push.apply(output, (0, _toConsumableArray3.default)(hostCatalog[key].map(function (host) {\n          return {\n            catalog: catalogIndex,\n            defaultUri: serviceLinks[host.id.split(':')[3]],\n            hostGroup: key,\n            id: host.id,\n            priority: host.priority,\n            uri: host.host\n          };\n        })));\n        return output;\n      }, []);\n    }\n  }]);\n  return ServiceRegistry;\n}();\n\nexports.default = ServiceRegistry;","map":{"version":3,"sources":["service-registry.js"],"names":["ServiceRegistry","active","local","priority","hostReference","host","filter","removing","failing","failed","catalog","catalogs","Array","id","type","SERVICE_CATALOGS_ENUM_TYPES","STRING","cluster","clusters","currentHost","foundHost","filteredHosts","foundHostCatalogPriority","NUMBER","currentHostCatalogPriority","service","services","url","urls","hosts","validHosts","ServiceHost","replacing","replaced","resetting","SERVICE_CATALOGS","hostCatalog","serviceLinks","catalogIndex","output","defaultUri","hostGroup","uri"],"mappings":"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","sourcesContent":["import {\n  SERVICE_CATALOGS,\n  SERVICE_CATALOGS_ENUM_TYPES\n} from './constants';\nimport ServiceHost from './service-host';\n\n/**\n * The parameter transfer object for {@link ServiceRegistry#mapRemoteCatalog}.\n * This object is shaped to match the object returned from the **U2C** service.\n *\n * @typedef {Record<string, string>} RSL\n * @typedef {Record<string, Array<Record<string, number | string>>>} RHC\n *\n * @typedef {Object} MapRemoteCatalogPTO\n * @property {string} MapRemoteCatalogPTO.catalog - Service catalog name.\n * @property {RSL} MapRemoteCatalogPTO.serviceLinks - Service links.\n * @property {RHC} MapRemoteCatalogPTO.hostCatalog - Service host catalog.\n */\n\n/**\n * Service manipulation filter object for retrieving services within the\n * {@link ServiceRegistry} class.\n *\n * @typedef {Object} HostFilter\n * @property {boolean} [HostFilter.active] - Active state to filter.\n * @property {Array<string> | string} [HostFilter.catalog] - Catalogs to filter.\n * @property {Array<string> | string} [HostFilter.cluster] - Clusters to filter.\n * @property {boolean} [HostFilter.local] - Filter to the user's home cluster.\n * @property {boolean} [HostFilter.priority] - Filter for the highest priority.\n * @property {Array<string> | string} [HostFilter.service] - Services to filter.\n * @property {Array<string> | string} [HostFilter.url] - URL to filter.\n */\n\n/**\n * @class\n * @classdesc - Manages a collection of {@link ServiceHost} class objects.\n */\nexport default class ServiceRegistry {\n  /**\n   * Generate a new {@link ServiceHost}.\n   *\n   * @public\n   * @constructor\n   * @memberof ServiceHost\n   */\n  constructor() {\n    /**\n     * The collection of managed {@link ServiceHost}s.\n     *\n     * @instance\n     * @type {Array<ServiceHost>}\n     * @private\n     * @memberof ServiceRegistry\n     */\n    this.hosts = [];\n  }\n\n  /**\n   * An active, local, and priority mapped record of the current\n   * {@link ServiceCatalog#hosts}.\n   *\n   * @public\n   * @memberof ServiceCatalog\n   * @type {Record<string, string>}\n   */\n  get map() {\n    // Get a list of active, local, and priority-mapped hosts.\n    return this.find({\n      active: true,\n      local: true,\n      priority: true\n    }).reduce(\n      (map, host) => {\n        // Generate a new object to assign the existing map.\n        const hostReference = {};\n\n        // Assign the key:value pair for the service and url.\n        hostReference[host.service] = host.url;\n\n        // Assign the reference to the map and return.\n        return {...map, ...hostReference};\n      }, {}\n    );\n  }\n\n  /**\n   * Removes a collection of {@link ServiceHost} class objects from the\n   * {@link ServiceRegistry#hosts} array based on the provided\n   * {@link HostFilter}.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {HostFilter} filter - The inclusive filter for hosts to remove.\n   * @returns {Array<ServiceHost>} - The removed {@link ServiceHost}s.\n   */\n  clear(filter) {\n    // Collect a list of hosts to remove based on the provided filter.\n    const removing = this.find(filter);\n\n    // Remove the hosts from the array.\n    this.hosts = this.hosts.filter(\n      (host) => !removing.includes(host)\n    );\n\n    // Return the removed hosts.\n    return removing;\n  }\n\n  /**\n   * Mark a collection of {@link ServiceHost} class objects from the\n   * {@link ServiceRegistry#hosts} array as failed based on the provided\n   * {@link HostFilter}.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {HostFilter} filter - The inclusive filter for hosts to mark failed.\n   * @returns {Array<ServiceHost>} - The {@link ServiceHost}s marked failed.\n   */\n  failed(filter) {\n    // Collect a list of hosts to mark as failed based on the provided filter.\n    const failing = this.find(filter);\n\n    // Mark the hosts from the array as failed.\n    failing.forEach(\n      (host) => {\n        host.setStatus({failed: true});\n      }\n    );\n\n    // Return the marked hosts.\n    return failing;\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array against their active states.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {boolean} [active] - Filter for the host state.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterActive(active) {\n    // Filter the host array if the active requirement is true.\n    return (typeof active === 'boolean') ?\n      this.hosts.filter((host) => host.active === active) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array against their assigned\n   * catalog values.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {Array<string> | string} [catalog] - Catalogs to filter.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterCatalog(catalog = []) {\n    // Generate a catalog names array based on the provided catalog param.\n    const catalogs = (Array.isArray(catalog) ? catalog : [catalog])\n      .map((catalogId) => ServiceRegistry.mapCatalogName({\n        id: catalogId,\n        type: SERVICE_CATALOGS_ENUM_TYPES.STRING\n      }) || catalogId);\n\n    // Filter the host array against the catalog names array.\n    return (catalogs.length > 0) ?\n      this.hosts.filter((host) => catalogs.includes(host.catalog)) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array against their assigned\n   * cluster values.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {Array<string> | string} [cluster] - Clusters to filter for.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterCluster(cluster = []) {\n    // Generate an array of clusters regardless of parameter type.\n    const clusters = (Array.isArray(cluster) ? cluster : [cluster]);\n\n    // Filter the host array against the provided clusters.\n    return (clusters.length > 0) ?\n      this.hosts.filter((host) => clusters.includes(host.id)) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array against their location in\n   * reference to the authenticated user.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {boolean} [local] - Filter for the host location.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterLocal(local) {\n    return (typeof local === 'boolean') ?\n      this.hosts.filter((host) => host.local === local) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array for the highest priority\n   * hosts for each specific service.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {boolean} [priority] - Filter for the highest priority\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterPriority(priority) {\n    return (priority) ?\n      this.hosts.reduce(\n        (filteredHosts, currentHost) => {\n          // Validate that the current host is not active.\n          if (!currentHost.active) {\n            return filteredHosts;\n          }\n\n          // Determine if the filtered hosts array contains a host from the same\n          // host group.\n          const foundHost = filteredHosts.find(\n            (host) => host.hostGroup === currentHost.hostGroup\n          );\n\n          // Validate if a host was found.\n          if (!foundHost) {\n            filteredHosts.push(currentHost);\n\n            return filteredHosts;\n          }\n\n          // Map the found host's catalog to its priority value.\n          const foundHostCatalogPriority = ServiceRegistry.mapCatalogName({\n            id: foundHost.catalog,\n            type: SERVICE_CATALOGS_ENUM_TYPES.NUMBER\n          });\n\n          // Map the current host's catalog to its priority value.\n          const currentHostCatalogPriority = ServiceRegistry.mapCatalogName({\n            id: currentHost.catalog,\n            type: SERVICE_CATALOGS_ENUM_TYPES.NUMBER\n          });\n\n          // Validate if the found host has a lower priority than the current\n          // host.\n          if (\n            foundHostCatalogPriority < currentHostCatalogPriority ||\n            foundHost.priority < currentHost.priority\n          ) {\n            filteredHosts.splice(filteredHosts.indexOf(foundHost, 1));\n            filteredHosts.push(currentHost);\n          }\n\n          return filteredHosts;\n        }, []\n      ) : [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array for hosts with a specified\n   * set of service names.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {Array<string> | string} [service] - Services to filter.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterService(service = []) {\n    // Generate an array of services regardless of parameter type.\n    const services = (Array.isArray(service) ? service : [service]);\n\n    // Filter the host array against the provided services.\n    return (services.length > 0) ?\n      this.hosts.filter((host) => services.includes(host.service)) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array for hosts with a specified\n   * set of URLs.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {Array<string> | string} [url] - URL to filter.\n   * @returns {Array<ServiceHost>} - The filter host array.\n   */\n  filterUrl(url = []) {\n    // Generate an array of URLs regardless of the parameter type.\n    const urls = (Array.isArray(url) ? url : [url]);\n\n    // Filter the host array against the provided URLs.\n    return (urls.length > 0) ?\n      this.hosts.filter((host) => urls.includes(host.url)) :\n      [...this.hosts];\n  }\n\n  /**\n   * Get an array of {@link ServiceHost}s based on a provided\n   * {@link HostFilter} from the {@link ServiceRegistry#hosts} array.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {HostFilter} [filter] - The inclusive filter for hosts to find.\n   * @returns {Array<ServiceHost>} - The filtered hosts.\n   */\n  find({\n    active,\n    catalog,\n    cluster,\n    local,\n    priority,\n    service,\n    url\n  } = {}) {\n    return this.hosts.filter(\n      (host) => (\n        this.filterActive(active).includes(host) &&\n        this.filterCatalog(catalog).includes(host) &&\n        this.filterCluster(cluster).includes(host) &&\n        this.filterLocal(local).includes(host) &&\n        this.filterPriority(priority).includes(host) &&\n        this.filterService(service).includes(host) &&\n        this.filterUrl(url).includes(host)\n      )\n    );\n  }\n\n  /**\n   * Load a formatted array of {@link ServiceHost} constructor parameter\n   * transfer objects as instances of {@link ServiceHost} class objects to the\n   * {@link ServiceRegistry#hosts} array.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {Array<ServiceHost.ConstructorPTO>} hosts\n   * @returns {this}\n   */\n  load(hosts = []) {\n    // Validate that the provided hosts are eligible to be loaded.\n    const validHosts = hosts.filter((host) => !!(\n      ServiceRegistry.mapCatalogName({\n        id: host.catalog,\n        type: SERVICE_CATALOGS_ENUM_TYPES.STRING\n      })));\n\n    // Load the eligible hosts.\n    this.hosts.push(\n      ...validHosts.map((loadableHost) => new ServiceHost(loadableHost))\n    );\n\n    return this;\n  }\n\n  /**\n   * Mark a collection of {@link ServiceHost} class objects from the\n   * {@link ServiceRegistry#hosts} array as replaced based on the provided\n   * {@link HostFilter}.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {HostFilter} filter - The inclusive filter to mark replaced.\n   * @returns {Array<ServiceHost>} - The {@link ServiceHost}s marked replaced.\n   */\n  replaced(filter) {\n    // Collect a list of hosts to mark as replaced based on the provided filter.\n    const replacing = this.find(filter);\n\n    // Mark the hosts from the array as replaced.\n    replacing.forEach(\n      (host) => {\n        host.setStatus({replaced: true});\n      }\n    );\n\n    // Return the marked hosts.\n    return replacing;\n  }\n\n  /**\n   * Reset the failed status of a collection of {@link ServiceHost} class\n   * objects from the {@link ServiceRegistry#hosts} array based on the provided\n   * {@link HostFilter}.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {HostFilter} filter - The inclusive filter of hosts to reset.\n   * @returns {Array<ServiceHost>} - The {@link ServiceHost}s that reset.\n   */\n  reset(filter) {\n    // Collect a list of hosts to mark as replaced based on the provided filter.\n    const resetting = this.find(filter);\n\n    // Mark the hosts from the array as replaced.\n    resetting.forEach(\n      (host) => {\n        host.setStatus({failed: false});\n      }\n    );\n\n    // Return the marked hosts.\n    return resetting;\n  }\n\n  /**\n   * Convert a {@link SERVICE_CATALOGS} identifier or value to its associated\n   * idenfier or value.\n   *\n   * @public\n   * @static\n   * @memberof ServiceRegistry\n   * @param {Object} pto - The parameter transfer object.\n   * @property {string | number} pto.id - The identifier to convert in the enum.\n   * @property {SERVICE_CATALOGS_ENUM_TYPES} pto.type - The desired output.\n   * @returns {string|number} - The matching enum value or index.\n   */\n  static mapCatalogName({id, type}) {\n    // Validate that the id is a number.\n    if (typeof id === 'number') {\n      // Validate that the desired type is a number.\n      if (type === SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {\n        return (SERVICE_CATALOGS[id] !== undefined) ? id : undefined;\n      }\n\n      // Validate that the desired type is a string.\n      if (type === SERVICE_CATALOGS_ENUM_TYPES.STRING) {\n        return SERVICE_CATALOGS[id];\n      }\n    }\n\n    // Validate that the id is a string.\n    if (typeof id === 'string') {\n      // Validate that the desired type is a string.\n      if (type === SERVICE_CATALOGS_ENUM_TYPES.STRING) {\n        return SERVICE_CATALOGS.includes(id) ? id : undefined;\n      }\n\n      // Validate that the desired type is a number.\n      if (type === SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {\n        return (SERVICE_CATALOGS.includes(id)) ?\n          SERVICE_CATALOGS.indexOf(id) :\n          undefined;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Generate a formatted array based on the object received from the **U2C**\n   * service for usage in the {@link ServiceRegistry#load} method.\n   *\n   * @public\n   * @static\n   * @memberof ServiceRegistry\n   * @param {MapRemoteCatalogPTO} pto - The parameter transfer object.\n   * @throws - If the target catalog does not exist.\n   * @returns {Array<ServiceHost#ServiceHostConstructorPTO>}\n   */\n  static mapRemoteCatalog({catalog, hostCatalog, serviceLinks}) {\n    // Collect the service catalog name if needed.\n    const catalogIndex = ServiceRegistry.mapCatalogName({\n      id: catalog,\n      type: SERVICE_CATALOGS_ENUM_TYPES.STRING\n    });\n\n    // Validate that the target catalog exists.\n    if (!SERVICE_CATALOGS.includes(catalogIndex)) {\n      throw new Error(`service-catalogs: '${catalog}' is not a valid catalog`);\n    }\n\n    // Map the remote catalog to a mountable host array.\n    return Object.keys(hostCatalog).reduce((output, key) => {\n      output.push(\n        ...hostCatalog[key].map((host) => ({\n          catalog: catalogIndex,\n          defaultUri: serviceLinks[host.id.split(':')[3]],\n          hostGroup: key,\n          id: host.id,\n          priority: host.priority,\n          uri: host.host\n        }))\n      );\n\n      return output;\n    }, []);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}