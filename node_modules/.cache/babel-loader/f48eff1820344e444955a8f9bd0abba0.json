{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _isArray2 = require('lodash/isArray');\n\nvar _isArray3 = _interopRequireDefault(_isArray2);\n\nexports.proxyEvents = proxyEvents;\nexports.transferEvents = transferEvents;\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Proxies the event binding methods of emitter onto proxy\n * @param {EventEmitter|EventEmitterProxy} emitter\n * @param {mixed} proxy (probably a promise)\n * @returns {EventEmitter} Returns the source emitter to ease use in promise chains\n */\n\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nfunction proxyEvents(emitter, proxy) {\n  ['on', 'once'].forEach(function (key) {\n    proxy[key] = function () {\n      emitter[key].apply(emitter, arguments);\n      return proxy;\n    };\n  });\n  return emitter;\n}\n/**\n * Given a list of events, fires them on drain when they're emitted from source\n * @param {Array|string} events\n * @param {EventEmitter} source\n * @param {EventEmitter} drain\n * @returns {undefined}\n */\n\n\nfunction transferEvents(events, source, drain) {\n  events = (0, _isArray3.default)(events) ? events : [events];\n  events.forEach(function (event) {\n    if (source.on) {\n      source.on(event, function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return emit.apply(undefined, [drain, event].concat(args));\n      });\n    }\n  });\n}\n/**\n * Emits an event\n * @param {EventEmitter} target The EventEmitter from which to emit an event\n * @returns {mixed}\n */\n\n\nfunction emit(target) {\n  var method = target.trigger || target.emit;\n  /* istanbul ignore if */\n\n  if (!method) {\n    throw new Error('count not determine emit method');\n  }\n\n  for (var _len2 = arguments.length, rest = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    rest[_key2 - 1] = arguments[_key2];\n  }\n\n  return (0, _apply2.default)(method, target, rest);\n}","map":{"version":3,"sources":["events.js"],"names":["proxyEvents","proxy","emitter","transferEvents","events","source","args","emit","rest","method","target"],"mappings":";;;;;;;;;;;;;;QAYgBA,W,GAAAA,W;QAsBAG,c,GAAAA,c;;;;;;;AA5BhB;;;;;;;AANA;;;;;AAYO,SAAA,WAAA,CAAA,OAAA,EAAA,KAAA,EAAqC;AAC1C,GAAA,IAAA,EAAA,MAAA,EAAA,OAAA,CAGU,UAAA,GAAA,EAAS;AACjBF,IAAAA,KAAAA,CAAAA,GAAAA,CAAAA,GAAa,YAAa;AACxBC,MAAAA,OAAAA,CAAAA,GAAAA,CAAAA,CAAAA,KAAAA,CAAAA,OAAAA,EAAAA,SAAAA;AAEA,aAAA,KAAA;AAHFD,KAAAA;AAJF,GAAA;AAWA,SAAA,OAAA;AACD;AAED;;;;;;;;;AAOO,SAAA,cAAA,CAAA,MAAA,EAAA,MAAA,EAAA,KAAA,EAA+C;AACpDG,EAAAA,MAAAA,GAAS,CAAA,GAAA,SAAA,CAAA,OAAA,EAAA,MAAA,IAAA,MAAA,GAA2B,CAApCA,MAAoC,CAApCA;AACAA,EAAAA,MAAAA,CAAAA,OAAAA,CAAe,UAAA,KAAA,EAAW;AACxB,QAAIC,MAAAA,CAAJ,EAAA,EAAe;AACbA,MAAAA,MAAAA,CAAAA,EAAAA,CAAAA,KAAAA,EAAiB,YAAA;AAAA,aAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAAIC,IAAJ,GAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AAAIA,UAAAA,IAAJ,CAAA,IAAA,CAAIA,GAAJ,SAAA,CAAA,IAAA,CAAIA;AAAJ;;AAAA,eAAaC,IAAAA,CAAAA,KAAAA,CAAAA,SAAAA,EAAAA,CAAAA,KAAAA,EAAAA,KAAAA,EAAAA,MAAAA,CAAb,IAAaA,CAAAA,CAAb;AAAjBF,OAAAA;AACD;AAHHD,GAAAA;AAKD;AAED;;;;;;;AAKA,SAAA,IAAA,CAAA,MAAA,EAA+B;AAC7B,MAAMK,MAAAA,GAASC,MAAAA,CAAAA,OAAAA,IAAkBA,MAAAA,CAAjC,IAAA;AAEA;;AACA,MAAI,CAAJ,MAAA,EAAa;AACX,UAAM,IAAA,KAAA,CAAN,iCAAM,CAAN;AACD;;AAN4B,OAAA,IAAA,KAAA,GAAA,SAAA,CAAA,MAAA,EAANF,IAAM,GAAA,KAAA,CAAA,KAAA,GAAA,CAAA,GAAA,KAAA,GAAA,CAAA,GAAA,CAAA,CAAA,EAAA,KAAA,GAAA,CAAA,EAAA,KAAA,GAAA,KAAA,EAAA,KAAA,EAAA,EAAA;AAANA,IAAAA,IAAM,CAAA,KAAA,GAAA,CAAA,CAANA,GAAM,SAAA,CAAA,KAAA,CAANA;AAAM;;AAQ7B,SAAO,CAAA,GAAA,OAAA,CAAA,OAAA,EAAA,MAAA,EAAA,MAAA,EAAP,IAAO,CAAP;AACD","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {isArray} from 'lodash';\n\n/**\n * Proxies the event binding methods of emitter onto proxy\n * @param {EventEmitter|EventEmitterProxy} emitter\n * @param {mixed} proxy (probably a promise)\n * @returns {EventEmitter} Returns the source emitter to ease use in promise chains\n */\nexport function proxyEvents(emitter, proxy) {\n  [\n    'on',\n    'once'\n  ].forEach((key) => {\n    proxy[key] = (...args) => {\n      emitter[key](...args);\n\n      return proxy;\n    };\n  });\n\n  return emitter;\n}\n\n/**\n * Given a list of events, fires them on drain when they're emitted from source\n * @param {Array|string} events\n * @param {EventEmitter} source\n * @param {EventEmitter} drain\n * @returns {undefined}\n */\nexport function transferEvents(events, source, drain) {\n  events = isArray(events) ? events : [events];\n  events.forEach((event) => {\n    if (source.on) {\n      source.on(event, (...args) => emit(drain, event, ...args));\n    }\n  });\n}\n\n/**\n * Emits an event\n * @param {EventEmitter} target The EventEmitter from which to emit an event\n * @returns {mixed}\n */\nfunction emit(target, ...rest) {\n  const method = target.trigger || target.emit;\n\n  /* istanbul ignore if */\n  if (!method) {\n    throw new Error('count not determine emit method');\n  }\n\n  return Reflect.apply(method, target, rest);\n}\n"]},"metadata":{},"sourceType":"script"}