{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');\n\nvar _deleteProperty2 = _interopRequireDefault(_deleteProperty);\n\nvar _isEmpty2 = require('lodash/isEmpty');\n\nvar _isEmpty3 = _interopRequireDefault(_isEmpty2);\n\nvar _isObject2 = require('lodash/isObject');\n\nvar _isObject3 = _interopRequireDefault(_isObject2);\n\nvar _cloneDeep2 = require('lodash/cloneDeep');\n\nvar _cloneDeep3 = _interopRequireDefault(_cloneDeep2);\n\nvar _clone2 = require('lodash/clone');\n\nvar _clone3 = _interopRequireDefault(_clone2);\n\nvar _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _desc, _value, _obj;\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar _querystring = require('querystring');\n\nvar _querystring2 = _interopRequireDefault(_querystring);\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _jsonwebtoken = require('jsonwebtoken');\n\nvar _jsonwebtoken2 = _interopRequireDefault(_jsonwebtoken);\n\nvar _common = require('@webex/common');\n\nvar _commonTimers = require('@webex/common-timers');\n\nvar _webexPlugin = require('../webex-plugin');\n\nvar _webexPlugin2 = _interopRequireDefault(_webexPlugin);\n\nvar _decorators = require('../storage/decorators');\n\nvar _grantErrors = require('./grant-errors');\n\nvar _grantErrors2 = _interopRequireDefault(_grantErrors);\n\nvar _scope = require('./scope');\n\nvar _token = require('./token');\n\nvar _token2 = _interopRequireDefault(_token);\n\nvar _tokenCollection = require('./token-collection');\n\nvar _tokenCollection2 = _interopRequireDefault(_tokenCollection);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n/**\n * @class\n */\n\n\nvar Credentials = _webexPlugin2.default.extend((_dec = (0, _common.oneFlight)({\n  keyFactory: function keyFactory(scope) {\n    return scope;\n  }\n}), _dec2 = (0, _decorators.waitForValue)('@'), _dec3 = (0, _decorators.persist)('@'), _dec4 = (0, _decorators.waitForValue)('@'), _dec5 = (0, _common.whileInFlight)('isRefreshing'), _dec6 = (0, _decorators.waitForValue)('@'), (_obj = {\n  collections: {\n    userTokens: _tokenCollection2.default\n  },\n  dataTypes: {\n    token: (0, _common.makeStateDataType)(_token2.default, 'token').dataType\n  },\n  derived: {\n    canAuthorize: {\n      deps: ['supertoken', 'supertoken.canAuthorize', 'canRefresh'],\n      fn: function fn() {\n        return Boolean(this.supertoken && this.supertoken.canAuthorize || this.canRefresh);\n      }\n    },\n    canRefresh: {\n      deps: ['supertoken', 'supertoken.canRefresh'],\n      fn: function fn() {\n        // If we're operating in JWT mode, we have to delegate to the consumer\n        if (this.config.jwtRefreshCallback) {\n          return true;\n        }\n\n        return Boolean(this.supertoken && this.supertoken.canRefresh);\n      }\n    }\n  },\n  props: {\n    supertoken: (0, _common.makeStateDataType)(_token2.default, 'token').prop\n  },\n  namespace: 'Credentials',\n  session: {\n    isRefreshing: {\n      default: false,\n      type: 'boolean'\n    },\n\n    /**\n     * Becomes `true` once the {@link loaded} event fires.\n     * @see {@link WebexPlugin#ready}\n     * @instance\n     * @memberof Credentials\n     * @type {boolean}\n     */\n    ready: {\n      default: false,\n      type: 'boolean'\n    },\n    refreshTimer: {\n      default: undefined,\n      type: 'any'\n    }\n  },\n\n  /**\n   * Generates an OAuth Login URL. Prefers the api.ciscospark.com proxy if the\n   * instance is initialize with an authorizatUrl, but fallsback to idbroker\n   * as the base otherwise.\n   * @instance\n   * @memberof Credentials\n   * @param {Object} [options={}]\n   * @returns {string}\n   */\n  buildLoginUrl: function buildLoginUrl() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      clientType: 'public'\n    };\n    /* eslint-disable camelcase */\n\n    if (options.state && !(0, _isObject3.default)(options.state)) {\n      throw new Error('if specified, `options.state` must be an object');\n    }\n\n    options.client_id = this.config.client_id;\n    options.redirect_uri = this.config.redirect_uri;\n    options.scope = this.config.scope;\n    options = (0, _cloneDeep3.default)(options);\n\n    if (!options.response_type) {\n      options.response_type = options.clientType === 'public' ? 'token' : 'code';\n    }\n\n    (0, _deleteProperty2.default)(options, 'clientType');\n\n    if (options.state) {\n      if (!(0, _isEmpty3.default)(options.state)) {\n        options.state = _common.base64.toBase64Url((0, _stringify2.default)(options.state));\n      } else {\n        delete options.state;\n      }\n    }\n\n    return this.config.authorizeUrl + '?' + _querystring2.default.stringify(options);\n    /* eslint-enable camelcase */\n  },\n\n  /**\n   * Get the determined OrgId.\n   *\n   * @throws {Error} - If the OrgId could not be determined.\n   * @returns {string} - The OrgId.\n   */\n  getOrgId: function getOrgId() {\n    this.logger.info('credentials: attempting to retrieve the OrgId from token');\n\n    try {\n      // Attempt to extract a client-authenticated token's OrgId.\n      this.logger.info('credentials: trying to extract OrgId from JWT');\n      return this.extractOrgIdFromJWT(this.supertoken.access_token);\n    } catch (e) {\n      // Attempt to extract a user token's OrgId.\n      this.logger.info('credentials: could not extract OrgId from JWT');\n      this.logger.info('credentials: attempting to extract OrgId from user token');\n      return this.extractOrgIdFromUserToken(this.supertoken.access_token);\n    }\n  },\n\n  /**\n   * Extract the OrgId [realm] from a provided JWT.\n   *\n   * @private\n   * @param {string} token - The JWT to extract the OrgId from.\n   * @throws {Error} - If the token does not pass JWT general/realm validation.\n   * @returns {string} - The OrgId.\n   */\n  extractOrgIdFromJWT: function extractOrgIdFromJWT() {\n    var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ''; // Decoded the provided token.\n\n    var decodedJWT = _jsonwebtoken2.default.decode(token); // Validate that the provided token is a JWT.\n\n\n    if (!decodedJWT) {\n      throw new Error('unable to extract the OrgId from the provided JWT');\n    }\n\n    if (!decodedJWT.realm) {\n      throw new Error('the provided JWT does not contain an OrgId');\n    } // Return the OrgId [realm].\n\n\n    return decodedJWT.realm;\n  },\n\n  /**\n   * Extract the OrgId [realm] from a provided user token.\n   *\n   * @private\n   * @param {string} token - The user token to extract the OrgId from.\n   * @throws {Error} - Will throw an error if the provided token is invalid.\n   * @returns {string} - The OrgId.\n   */\n  extractOrgIdFromUserToken: function extractOrgIdFromUserToken() {\n    var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ''; // Split the provided token into subsections.\n\n    var fields = token.split('_'); // Validate that the provided token has the proper amount of sections.\n\n    if (fields.length !== 3) {\n      throw new Error('the provided token is not a valid format');\n    } // Return the token section that contains the OrgId.\n\n\n    return fields[2];\n  },\n\n  /**\n   * Generates a Logout URL\n   * @instance\n   * @memberof Credentials\n   * @param {Object} [options={}]\n   * @returns {[type]}\n   */\n  buildLogoutUrl: function buildLogoutUrl() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.config.logoutUrl + '?' + _querystring2.default.stringify((0, _assign2.default)({\n      cisService: this.config.service,\n      goto: this.config.redirect_uri\n    }, options));\n  },\n\n  /**\n   * Generates a number between 60% - 90% of expired value\n   * @instance\n   * @memberof Credentials\n   * @param {number} expiration\n   * @private\n   * @returns {number}\n   */\n  calcRefreshTimeout: function calcRefreshTimeout(expiration) {\n    return Math.floor((Math.floor(Math.random() * 4) + 6) / 10 * expiration);\n  },\n  constructor: function constructor() {\n    var _this = this; // HACK to deal with the fact that AmpersandState#dataTypes#set is a pure\n    // function.\n\n\n    this._dataTypes = (0, _cloneDeep3.default)(this._dataTypes);\n    (0, _keys2.default)(this._dataTypes).forEach(function (key) {\n      if (_this._dataTypes[key].set) {\n        _this._dataTypes[key].set = _this._dataTypes[key].set.bind(_this);\n      }\n    }); // END HACK\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    (0, _apply2.default)(_webexPlugin2.default, this, args);\n  },\n\n  /**\n   * Downscopes a token\n   * @instance\n   * @memberof Credentials\n   * @param {string} scope\n   * @private\n   * @returns {Promise<Token>}\n   */\n  downscope: function downscope(scope) {\n    var _this2 = this;\n\n    return this.supertoken.downscope(scope).catch(function (reason) {\n      _this2.logger.trace('credentials: failed to downscope supertoken to ' + scope, reason);\n\n      _this2.logger.trace('credentials: falling back to supertoken for ' + scope);\n\n      return _promise2.default.resolve(new _token2.default((0, _assign2.default)({\n        scope: scope\n      }, _this2.supertoken.serialize())), {\n        parent: _this2\n      });\n    });\n  },\n\n  /**\n   * Requests a client credentials grant and returns the token. Given the\n   * limited use for such tokens as this time, this method does not cache its\n   * token.\n   * @instance\n   * @memberof Credentials\n   * @param {Object} options\n   * @returns {Promise<Token>}\n   */\n  getClientToken: function getClientToken() {\n    var _this3 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.logger.info('credentials: requesting client credentials grant');\n    return this.webex.request({\n      /* eslint-disable camelcase */\n      method: 'POST',\n      uri: options.uri || this.config.tokenUrl,\n      form: {\n        grant_type: 'client_credentials',\n        scope: options.scope || 'webexsquare:admin',\n        self_contained_token: true\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n      /* eslint-enable camelcase */\n\n    }).then(function (res) {\n      return new _token2.default(res.body, {\n        parent: _this3\n      });\n    }).catch(function (res) {\n      if (res.statusCode !== 400) {\n        return _promise2.default.reject(res);\n      }\n\n      var ErrorConstructor = _grantErrors2.default.select(res.body.error);\n\n      return _promise2.default.reject(new ErrorConstructor(res._res || res));\n    });\n  },\n\n  /**\n   * Resolves with a token with the specified scopes. If no scope is specified,\n   * defaults to omit(webex.credentials.scope, 'spark:kms'). If no such token is\n   * available, downscopes the supertoken to that scope.\n   * @instance\n   * @memberof Credentials\n   * @param {string} scope\n   * @returns {Promise<Token>}\n   */\n  getUserToken: function getUserToken(scope) {\n    var _this4 = this;\n\n    return _promise2.default.resolve(!this.isRefreshing || new _promise2.default(function (resolve) {\n      _this4.logger.info('credentials: token refresh inflight; delaying getUserToken until refresh completes');\n\n      _this4.once('change:isRefreshing', function () {\n        _this4.logger.info('credentials: token refresh complete; reinvoking getUserToken');\n\n        resolve();\n      });\n    })).then(function () {\n      if (!_this4.canAuthorize) {\n        _this4.logger.info('credentials: cannot produce an access token from current state');\n\n        return _promise2.default.reject(new Error('Current state cannot produce an access token'));\n      }\n\n      if (!scope) {\n        scope = (0, _scope.filterScope)('spark:kms', _this4.config.scope);\n      }\n\n      scope = (0, _scope.sortScope)(scope);\n\n      if (scope === (0, _scope.sortScope)(_this4.config.scope)) {\n        return _promise2.default.resolve(_this4.supertoken);\n      }\n\n      var token = _this4.userTokens.get(scope); // we should also check for the token.access_token since token object does\n      // not get cleared on unsetting while logging out.\n\n\n      if (!token || !token.access_token) {\n        return _this4.downscope(scope).then((0, _common.tap)(function (t) {\n          return _this4.userTokens.add(t);\n        }));\n      }\n\n      return _promise2.default.resolve(token);\n    });\n  },\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof Credentials\n   * @param {Object} attrs\n   * @param {Object} options\n   * @private\n   * @returns {Credentials}\n   */\n  initialize: function initialize(attrs, options) {\n    var _this5 = this;\n\n    if (attrs) {\n      if (typeof attrs === 'string') {\n        this.supertoken = attrs;\n      }\n\n      if (attrs.access_token) {\n        this.supertoken = attrs;\n      }\n\n      if (attrs.authorization) {\n        if (attrs.authorization.supertoken) {\n          this.supertoken = attrs.authorization.supertoken;\n        } else {\n          this.supertoken = attrs.authorization;\n        }\n      } // schedule refresh\n\n\n      if (this.supertoken && this.supertoken.expires) {\n        this.scheduleRefresh(this.supertoken.expires);\n      }\n    }\n\n    (0, _apply2.default)(_webexPlugin2.default.prototype.initialize, this, [attrs, options]);\n    this.listenToOnce(this.parent, 'change:config', function () {\n      if (_this5.config.authorizationString) {\n        var parsed = _url2.default.parse(_this5.config.authorizationString, true);\n        /* eslint-disable camelcase */\n\n\n        _this5.config.client_id = parsed.query.client_id;\n        _this5.config.redirect_uri = parsed.query.redirect_uri;\n        _this5.config.scope = parsed.query.scope;\n        _this5.config.authorizeUrl = parsed.href.substr(0, parsed.href.indexOf('?'));\n        /* eslint-enable camelcase */\n      }\n    });\n    this.webex.once('loaded', function () {\n      _this5.ready = true;\n    });\n  },\n\n  /**\n   * Clears all tokens from store them from the stores.\n   *\n   * This is no longer quite the right name for this method, but all of the\n   * alternatives I'm coming up with are already taken.\n   * @instance\n   * @memberof Credentials\n   * @returns {Promise}\n   */\n  invalidate: function invalidate() {\n    this.logger.info('credentials: invalidating tokens'); // clear refresh timer\n\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.unset('refreshTimer');\n    }\n\n    try {\n      this.unset('supertoken');\n    } catch (err) {\n      this.logger.warn('credentials: failed to clear supertoken', err);\n    }\n\n    while (this.userTokens.models.length) {\n      try {\n        this.userTokens.remove(this.userTokens.models[0]);\n      } catch (err) {\n        this.logger.warn('credentials: failed to remove user token', err);\n      }\n    }\n\n    this.logger.info('credentials: finished removing tokens'); // Return a promise to give the storage layer a tick or two to clear\n    // localStorage\n\n    return _promise2.default.resolve();\n  },\n\n  /**\n   * Removes the supertoken and child tokens, then refreshes the supertoken;\n   * subsequent calls to {@link Credentials#getUserToken()} will re-downscope\n   * child tokens. Enqueus revocation of previous previousTokens. Yes, that's\n   * the correct number of \"previous\"es.\n   * @instance\n   * @memberof Credentials\n   * @returns {Promise}\n   */\n  refresh: function refresh() {\n    var _this6 = this;\n\n    this.logger.info('credentials: refresh requested');\n    var supertoken = this.supertoken;\n    var tokens = (0, _clone3.default)(this.userTokens.models); // This is kind of a leaky abstraction, since it relies on the authorization\n    // plugin, but the only alternatives I see are\n    // 1. put all JWT support in core\n    // 2. have separate jwt and non-jwt auth plugins\n    // while I like #2 from a code simplicity standpoint, the third-party DX\n    // isn't great\n\n    if (this.config.jwtRefreshCallback) {\n      return this.config.jwtRefreshCallback(this.webex).then(function (jwt) {\n        return _this6.webex.authorization.requestAccessTokenFromJwt({\n          jwt: jwt\n        });\n      });\n    }\n\n    if (this.webex.internal.services) {\n      this.webex.internal.services.updateCredentialsConfig();\n    }\n\n    return supertoken.refresh().then(function (st) {\n      // clear refresh timer\n      if (_this6.refreshTimer) {\n        clearTimeout(_this6.refreshTimer);\n\n        _this6.unset('refreshTimer');\n      }\n\n      _this6.supertoken = st;\n      return _promise2.default.all(tokens.map(function (token) {\n        return _this6.downscope(token.scope) // eslint-disable-next-line max-nested-callbacks\n        .then(function (t) {\n          _this6.logger.info('credentials: revoking token for ' + token.scope);\n\n          return token.revoke().catch(function (err) {\n            _this6.logger.warn('credentials: failed to revoke user token', err);\n          }).then(function () {\n            _this6.userTokens.remove(token.scope);\n\n            _this6.userTokens.add(t);\n          });\n        });\n      }));\n    }).then(function () {\n      _this6.scheduleRefresh(_this6.supertoken.expires);\n    }).catch(function (error) {\n      var InvalidRequestError = _grantErrors2.default.InvalidRequestError;\n\n      if (error instanceof InvalidRequestError) {\n        // Error: The refresh token provided is expired, revoked, malformed, or invalid. Hence emit an event to the client, an opportunity to logout.\n        _this6.unset('supertoken');\n\n        while (_this6.userTokens.models.length) {\n          try {\n            _this6.userTokens.remove(_this6.userTokens.models[0]);\n          } catch (err) {\n            _this6.logger.warn('credentials: failed to remove user token', err);\n          }\n        }\n\n        _this6.webex.trigger('client:InvalidRequestError');\n      }\n\n      return _promise2.default.reject(error);\n    });\n  },\n\n  /**\n   * Schedules a token refresh or refreshes the token if token has expired\n   * @instance\n   * @memberof Credentials\n   * @param {number} expires\n   * @private\n   * @returns {undefined}\n   */\n  scheduleRefresh: function scheduleRefresh(expires) {\n    var _this7 = this;\n\n    var expiresIn = expires - Date.now();\n\n    if (expiresIn > 0) {\n      var timeoutLength = this.calcRefreshTimeout(expiresIn);\n      this.refreshTimer = (0, _commonTimers.safeSetTimeout)(function () {\n        return _this7.refresh();\n      }, timeoutLength);\n    } else {\n      this.refresh();\n    }\n  },\n  version: '1.80.172'\n}, (_applyDecoratedDescriptor(_obj, 'getUserToken', [_dec, _dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'getUserToken'), _obj), _applyDecoratedDescriptor(_obj, 'initialize', [_dec3], (0, _getOwnPropertyDescriptor2.default)(_obj, 'initialize'), _obj), _applyDecoratedDescriptor(_obj, 'invalidate', [_common.oneFlight, _dec4], (0, _getOwnPropertyDescriptor2.default)(_obj, 'invalidate'), _obj), _applyDecoratedDescriptor(_obj, 'refresh', [_common.oneFlight, _dec5, _dec6], (0, _getOwnPropertyDescriptor2.default)(_obj, 'refresh'), _obj)), _obj)));\n\nexports.default = Credentials;","map":{"version":3,"sources":["credentials.js"],"names":["Credentials","collections","userTokens","TokenCollection","dataTypes","token","Token","dataType","derived","canAuthorize","deps","fn","Boolean","canRefresh","props","supertoken","prop","namespace","session","isRefreshing","default","type","ready","refreshTimer","buildLoginUrl","options","clientType","base64","querystring","getOrgId","extractOrgIdFromJWT","decodedJWT","jwt","extractOrgIdFromUserToken","fields","buildLogoutUrl","cisService","goto","redirect_uri","calcRefreshTimeout","Math","constructor","args","WebexPlugin","downscope","scope","parent","getClientToken","method","uri","form","grant_type","self_contained_token","auth","user","pass","sendImmediately","shouldRefreshAccessToken","res","ErrorConstructor","grantErrors","keyFactory","getUserToken","resolve","initialize","attrs","parsed","url","oneFlight","invalidate","clearTimeout","refresh","tokens","InvalidRequestError","error","scheduleRefresh","expiresIn","expires","Date","timeoutLength"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport querystring from 'querystring';\nimport url from 'url';\n\nimport jwt from 'jsonwebtoken';\nimport {\n  base64,\n  makeStateDataType,\n  oneFlight,\n  tap,\n  whileInFlight\n} from '@webex/common';\nimport {safeSetTimeout} from '@webex/common-timers';\nimport {clone, cloneDeep, isObject, isEmpty} from 'lodash';\n\nimport WebexPlugin from '../webex-plugin';\nimport {persist, waitForValue} from '../storage/decorators';\n\nimport grantErrors from './grant-errors';\nimport {filterScope, sortScope} from './scope';\nimport Token from './token';\nimport TokenCollection from './token-collection';\n\n/**\n * @class\n */\nconst Credentials = WebexPlugin.extend({\n  collections: {\n    userTokens: TokenCollection\n  },\n\n  dataTypes: {\n    token: makeStateDataType(Token, 'token').dataType\n  },\n\n  derived: {\n    canAuthorize: {\n      deps: [\n        'supertoken',\n        'supertoken.canAuthorize',\n        'canRefresh'\n      ],\n      fn() {\n        return Boolean(this.supertoken && this.supertoken.canAuthorize || this.canRefresh);\n      }\n    },\n    canRefresh: {\n      deps: [\n        'supertoken',\n        'supertoken.canRefresh'\n      ],\n      fn() {\n        // If we're operating in JWT mode, we have to delegate to the consumer\n        if (this.config.jwtRefreshCallback) {\n          return true;\n        }\n\n        return Boolean(this.supertoken && this.supertoken.canRefresh);\n      }\n    }\n  },\n\n  props: {\n    supertoken: makeStateDataType(Token, 'token').prop\n  },\n\n  namespace: 'Credentials',\n\n  session: {\n    isRefreshing: {\n      default: false,\n      type: 'boolean'\n    },\n    /**\n     * Becomes `true` once the {@link loaded} event fires.\n     * @see {@link WebexPlugin#ready}\n     * @instance\n     * @memberof Credentials\n     * @type {boolean}\n     */\n    ready: {\n      default: false,\n      type: 'boolean'\n    },\n    refreshTimer: {\n      default: undefined,\n      type: 'any'\n    }\n  },\n\n  /**\n   * Generates an OAuth Login URL. Prefers the api.ciscospark.com proxy if the\n   * instance is initialize with an authorizatUrl, but fallsback to idbroker\n   * as the base otherwise.\n   * @instance\n   * @memberof Credentials\n   * @param {Object} [options={}]\n   * @returns {string}\n   */\n  buildLoginUrl(options = {clientType: 'public'}) {\n    /* eslint-disable camelcase */\n    if (options.state && !isObject(options.state)) {\n      throw new Error('if specified, `options.state` must be an object');\n    }\n\n    options.client_id = this.config.client_id;\n    options.redirect_uri = this.config.redirect_uri;\n    options.scope = this.config.scope;\n\n    options = cloneDeep(options);\n\n    if (!options.response_type) {\n      options.response_type = options.clientType === 'public' ? 'token' : 'code';\n    }\n    Reflect.deleteProperty(options, 'clientType');\n\n    if (options.state) {\n      if (!isEmpty(options.state)) {\n        options.state = base64.toBase64Url(JSON.stringify(options.state));\n      }\n      else {\n        delete options.state;\n      }\n    }\n\n    return `${this.config.authorizeUrl}?${querystring.stringify(options)}`;\n    /* eslint-enable camelcase */\n  },\n\n  /**\n   * Get the determined OrgId.\n   *\n   * @throws {Error} - If the OrgId could not be determined.\n   * @returns {string} - The OrgId.\n   */\n  getOrgId() {\n    this.logger.info(\n      'credentials: attempting to retrieve the OrgId from token'\n    );\n\n    try {\n      // Attempt to extract a client-authenticated token's OrgId.\n      this.logger.info('credentials: trying to extract OrgId from JWT');\n\n      return this.extractOrgIdFromJWT(this.supertoken.access_token);\n    }\n    catch (e) {\n      // Attempt to extract a user token's OrgId.\n      this.logger.info('credentials: could not extract OrgId from JWT');\n      this.logger.info(\n        'credentials: attempting to extract OrgId from user token'\n      );\n\n      return this.extractOrgIdFromUserToken(this.supertoken.access_token);\n    }\n  },\n\n  /**\n   * Extract the OrgId [realm] from a provided JWT.\n   *\n   * @private\n   * @param {string} token - The JWT to extract the OrgId from.\n   * @throws {Error} - If the token does not pass JWT general/realm validation.\n   * @returns {string} - The OrgId.\n   */\n  extractOrgIdFromJWT(token = '') {\n    // Decoded the provided token.\n    const decodedJWT = jwt.decode(token);\n\n    // Validate that the provided token is a JWT.\n    if (!decodedJWT) {\n      throw new Error('unable to extract the OrgId from the provided JWT');\n    }\n\n    if (!decodedJWT.realm) {\n      throw new Error('the provided JWT does not contain an OrgId');\n    }\n\n    // Return the OrgId [realm].\n    return decodedJWT.realm;\n  },\n\n  /**\n   * Extract the OrgId [realm] from a provided user token.\n   *\n   * @private\n   * @param {string} token - The user token to extract the OrgId from.\n   * @throws {Error} - Will throw an error if the provided token is invalid.\n   * @returns {string} - The OrgId.\n   */\n  extractOrgIdFromUserToken(token = '') {\n    // Split the provided token into subsections.\n    const fields = token.split('_');\n\n    // Validate that the provided token has the proper amount of sections.\n    if (fields.length !== 3) {\n      throw new Error('the provided token is not a valid format');\n    }\n\n    // Return the token section that contains the OrgId.\n    return fields[2];\n  },\n\n  /**\n   * Generates a Logout URL\n   * @instance\n   * @memberof Credentials\n   * @param {Object} [options={}]\n   * @returns {[type]}\n   */\n  buildLogoutUrl(options = {}) {\n    return `${this.config.logoutUrl}?${querystring.stringify(Object.assign({\n      cisService: this.config.service,\n      goto: this.config.redirect_uri\n    }, options))}`;\n  },\n\n  /**\n   * Generates a number between 60% - 90% of expired value\n   * @instance\n   * @memberof Credentials\n   * @param {number} expiration\n   * @private\n   * @returns {number}\n   */\n  calcRefreshTimeout(expiration) {\n    return Math.floor((Math.floor(Math.random() * 4) + 6) / 10 * expiration);\n  },\n\n  constructor(...args) {\n    // HACK to deal with the fact that AmpersandState#dataTypes#set is a pure\n    // function.\n    this._dataTypes = cloneDeep(this._dataTypes);\n    Object.keys(this._dataTypes).forEach((key) => {\n      if (this._dataTypes[key].set) {\n        this._dataTypes[key].set = this._dataTypes[key].set.bind(this);\n      }\n    });\n    // END HACK\n    Reflect.apply(WebexPlugin, this, args);\n  },\n\n  /**\n   * Downscopes a token\n   * @instance\n   * @memberof Credentials\n   * @param {string} scope\n   * @private\n   * @returns {Promise<Token>}\n   */\n  downscope(scope) {\n    return this.supertoken.downscope(scope)\n      .catch((reason) => {\n        this.logger.trace(`credentials: failed to downscope supertoken to ${scope}`, reason);\n        this.logger.trace(`credentials: falling back to supertoken for ${scope}`);\n\n        return Promise.resolve(new Token(Object.assign({scope}, this.supertoken.serialize())), {parent: this});\n      });\n  },\n\n  /**\n   * Requests a client credentials grant and returns the token. Given the\n   * limited use for such tokens as this time, this method does not cache its\n   * token.\n   * @instance\n   * @memberof Credentials\n   * @param {Object} options\n   * @returns {Promise<Token>}\n   */\n  getClientToken(options = {}) {\n    this.logger.info('credentials: requesting client credentials grant');\n\n    return this.webex.request({\n      /* eslint-disable camelcase */\n      method: 'POST',\n      uri: options.uri || this.config.tokenUrl,\n      form: {\n        grant_type: 'client_credentials',\n        scope: options.scope || 'webexsquare:admin',\n        self_contained_token: true\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n      /* eslint-enable camelcase */\n    })\n      .then((res) => new Token(res.body, {parent: this}))\n      .catch((res) => {\n        if (res.statusCode !== 400) {\n          return Promise.reject(res);\n        }\n\n        const ErrorConstructor = grantErrors.select(res.body.error);\n\n        return Promise.reject(new ErrorConstructor(res._res || res));\n      });\n  },\n\n  @oneFlight({keyFactory: (scope) => scope})\n  @waitForValue('@')\n  /**\n   * Resolves with a token with the specified scopes. If no scope is specified,\n   * defaults to omit(webex.credentials.scope, 'spark:kms'). If no such token is\n   * available, downscopes the supertoken to that scope.\n   * @instance\n   * @memberof Credentials\n   * @param {string} scope\n   * @returns {Promise<Token>}\n   */\n  getUserToken(scope) {\n    return Promise.resolve(!this.isRefreshing || new Promise((resolve) => {\n      this.logger.info('credentials: token refresh inflight; delaying getUserToken until refresh completes');\n      this.once('change:isRefreshing', () => {\n        this.logger.info('credentials: token refresh complete; reinvoking getUserToken');\n        resolve();\n      });\n    }))\n      .then(() => {\n        if (!this.canAuthorize) {\n          this.logger.info('credentials: cannot produce an access token from current state');\n\n          return Promise.reject(new Error('Current state cannot produce an access token'));\n        }\n\n        if (!scope) {\n          scope = filterScope('spark:kms', this.config.scope);\n        }\n\n        scope = sortScope(scope);\n\n        if (scope === sortScope(this.config.scope)) {\n          return Promise.resolve(this.supertoken);\n        }\n\n        const token = this.userTokens.get(scope);\n\n        // we should also check for the token.access_token since token object does\n        // not get cleared on unsetting while logging out.\n        if (!token || !token.access_token) {\n          return this.downscope(scope)\n            .then(tap((t) => this.userTokens.add(t)));\n        }\n\n        return Promise.resolve(token);\n      });\n  },\n\n  @persist('@')\n  /**\n   * Initializer\n   * @instance\n   * @memberof Credentials\n   * @param {Object} attrs\n   * @param {Object} options\n   * @private\n   * @returns {Credentials}\n   */\n  initialize(attrs, options) {\n    if (attrs) {\n      if (typeof attrs === 'string') {\n        this.supertoken = attrs;\n      }\n\n      if (attrs.access_token) {\n        this.supertoken = attrs;\n      }\n\n      if (attrs.authorization) {\n        if (attrs.authorization.supertoken) {\n          this.supertoken = attrs.authorization.supertoken;\n        }\n        else {\n          this.supertoken = attrs.authorization;\n        }\n      }\n\n      // schedule refresh\n      if (this.supertoken && this.supertoken.expires) {\n        this.scheduleRefresh(this.supertoken.expires);\n      }\n    }\n\n    Reflect.apply(WebexPlugin.prototype.initialize, this, [attrs, options]);\n\n    this.listenToOnce(this.parent, 'change:config', () => {\n      if (this.config.authorizationString) {\n        const parsed = url.parse(this.config.authorizationString, true);\n\n        /* eslint-disable camelcase */\n        this.config.client_id = parsed.query.client_id;\n        this.config.redirect_uri = parsed.query.redirect_uri;\n        this.config.scope = parsed.query.scope;\n        this.config.authorizeUrl = parsed.href.substr(0, parsed.href.indexOf('?'));\n        /* eslint-enable camelcase */\n      }\n    });\n\n    this.webex.once('loaded', () => {\n      this.ready = true;\n    });\n  },\n\n  @oneFlight\n  @waitForValue('@')\n  /**\n   * Clears all tokens from store them from the stores.\n   *\n   * This is no longer quite the right name for this method, but all of the\n   * alternatives I'm coming up with are already taken.\n   * @instance\n   * @memberof Credentials\n   * @returns {Promise}\n   */\n  invalidate() {\n    this.logger.info('credentials: invalidating tokens');\n\n    // clear refresh timer\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.unset('refreshTimer');\n    }\n\n    try {\n      this.unset('supertoken');\n    }\n    catch (err) {\n      this.logger.warn('credentials: failed to clear supertoken', err);\n    }\n\n    while (this.userTokens.models.length) {\n      try {\n        this.userTokens.remove(this.userTokens.models[0]);\n      }\n      catch (err) {\n        this.logger.warn('credentials: failed to remove user token', err);\n      }\n    }\n\n    this.logger.info('credentials: finished removing tokens');\n\n    // Return a promise to give the storage layer a tick or two to clear\n    // localStorage\n    return Promise.resolve();\n  },\n\n  @oneFlight\n  @whileInFlight('isRefreshing')\n  @waitForValue('@')\n  /**\n   * Removes the supertoken and child tokens, then refreshes the supertoken;\n   * subsequent calls to {@link Credentials#getUserToken()} will re-downscope\n   * child tokens. Enqueus revocation of previous previousTokens. Yes, that's\n   * the correct number of \"previous\"es.\n   * @instance\n   * @memberof Credentials\n   * @returns {Promise}\n   */\n  refresh() {\n    this.logger.info('credentials: refresh requested');\n\n    const {supertoken} = this;\n    const tokens = clone(this.userTokens.models);\n\n    // This is kind of a leaky abstraction, since it relies on the authorization\n    // plugin, but the only alternatives I see are\n    // 1. put all JWT support in core\n    // 2. have separate jwt and non-jwt auth plugins\n    // while I like #2 from a code simplicity standpoint, the third-party DX\n    // isn't great\n    if (this.config.jwtRefreshCallback) {\n      return this.config.jwtRefreshCallback(this.webex)\n        .then((jwt) => this.webex.authorization.requestAccessTokenFromJwt({jwt}));\n    }\n\n    if (this.webex.internal.services) {\n      this.webex.internal.services.updateCredentialsConfig();\n    }\n\n    return supertoken.refresh()\n      .then((st) => {\n        // clear refresh timer\n        if (this.refreshTimer) {\n          clearTimeout(this.refreshTimer);\n          this.unset('refreshTimer');\n        }\n        this.supertoken = st;\n\n        return Promise.all(tokens.map((token) => this.downscope(token.scope)\n          // eslint-disable-next-line max-nested-callbacks\n          .then((t) => {\n            this.logger.info(`credentials: revoking token for ${token.scope}`);\n\n            return token.revoke()\n              .catch((err) => {\n                this.logger.warn('credentials: failed to revoke user token', err);\n              })\n              .then(() => {\n                this.userTokens.remove(token.scope);\n                this.userTokens.add(t);\n              });\n          })));\n      })\n      .then(() => {\n        this.scheduleRefresh(this.supertoken.expires);\n      })\n      .catch((error) => {\n        const {InvalidRequestError} = grantErrors;\n\n        if (error instanceof InvalidRequestError) {\n          // Error: The refresh token provided is expired, revoked, malformed, or invalid. Hence emit an event to the client, an opportunity to logout.\n          this.unset('supertoken');\n          while (this.userTokens.models.length) {\n            try {\n              this.userTokens.remove(this.userTokens.models[0]);\n            }\n            catch (err) {\n              this.logger.warn('credentials: failed to remove user token', err);\n            }\n          }\n          this.webex.trigger('client:InvalidRequestError');\n        }\n\n        return Promise.reject(error);\n      });\n  },\n\n  /**\n   * Schedules a token refresh or refreshes the token if token has expired\n   * @instance\n   * @memberof Credentials\n   * @param {number} expires\n   * @private\n   * @returns {undefined}\n   */\n  scheduleRefresh(expires) {\n    const expiresIn = expires - Date.now();\n\n    if (expiresIn > 0) {\n      const timeoutLength = this.calcRefreshTimeout(expiresIn);\n\n      this.refreshTimer = safeSetTimeout(() => this.refresh(), timeoutLength);\n    }\n    else {\n      this.refresh();\n    }\n  }\n\n});\n\nexport default Credentials;\n"]},"metadata":{},"sourceType":"script"}