{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nrequire('@webex/internal-plugin-device');\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _presenceBatcher = require('./presence-batcher');\n\nvar _presenceBatcher2 = _interopRequireDefault(_presenceBatcher);\n\nvar _presenceWorker = require('./presence-worker');\n\nvar _presenceWorker2 = _interopRequireDefault(_presenceWorker);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar defaultSubscriptionTtl = 600;\nvar USER = 'user';\nvar USER_PRESENCE_ENABLED = 'user-presence-enabled';\n/**\n * @class\n * @extends WebexPlugin\n */\n\nvar Presence = _webexCore.WebexPlugin.extend({\n  namespace: 'Presence',\n  children: {\n    batcher: _presenceBatcher2.default\n  },\n  session: {\n    worker: {\n      default: function _default() {\n        return new _presenceWorker2.default();\n      },\n      type: 'any'\n    }\n  },\n\n  /**\n   * Initialize the presence worker for client\n   * @returns {undefined}\n   */\n  initialize: function initialize() {\n    var _this = this;\n\n    this.webex.once('ready', function () {\n      if (_this.config.initializeWorker) {\n        _this.worker.initialize(_this.webex);\n      }\n    });\n  },\n\n  /**\n   * Trigger an event.\n   * @param {string} event\n   * @param {string} payload\n   * @returns {undefined}\n   */\n  emitEvent: function emitEvent(event, payload) {\n    if (payload.type && payload.payload) {\n      this.trigger(event, payload);\n    }\n  },\n\n  /**\n   * Enables presence feature\n   * @returns {Promise<boolean>} resolves with true, if successful\n   */\n  enable: function enable() {\n    return this.webex.internal.feature.setFeature(USER, USER_PRESENCE_ENABLED, true).then(function (response) {\n      return response.value;\n    });\n  },\n\n  /**\n   * Disables presence feature\n   * @returns {Promise<boolean>} resolves with false, if successful\n   */\n  disable: function disable() {\n    return this.webex.internal.feature.setFeature(USER, USER_PRESENCE_ENABLED, false).then(function (response) {\n      return response.value;\n    });\n  },\n\n  /**\n   * Returns true if presence is enabled, false otherwise\n   * @returns {Promise<boolean>} resolves with true if presence is enabled\n   */\n  isEnabled: function isEnabled() {\n    return this.webex.internal.feature.getFeature(USER, USER_PRESENCE_ENABLED);\n  },\n\n  /**\n   * The status object\n   * @typedef {Object} PresenceStatusObject\n   * @property {string} url: Public resource identifier for presence\n   * @property {string} subject: User ID for the user the returned composed presence represents\n   * @property {string} status: Current composed presence state\n   * @property {string} statusTime: DateTime in RFC3339 format that the current status began\n   * @property {string} lastActive: DateTime in RFC3339 format that the service last saw activity from the user.\n   * @property {string} expires: DEPRECATED - DateTime in RFC3339 format that represents when the current\n   * status will expire. Will not exist if expiresTTL is -1.\n   * @property {Number} expiresTTL: TTL in seconds until the status will expire. If TTL is -1 the current\n   * status has no known expiration.\n   * @property {string} expiresTime: DateTime in RFC3339 format that the current status will expire. Missing\n   * field means no known expiration.\n   * @property {Object} vectorCounters: Used for packet ordering and tracking.\n   * @property {Boolean} suppressNotifications: Indicates if notification suppresion is recommended for this status.\n   * @property {string} lastSeenDeviceUrl: Resource Identifier of the last device to post presence activity for\n   * this user.\n   */\n\n  /**\n   * Gets the current presence status of a given person id\n   * @param {string} personId\n   * @returns {Promise<PresenceStatusObject>} resolves with status object of person\n   */\n  get: function get(personId) {\n    if (!personId) {\n      return _promise2.default.reject(new Error('A person id is required'));\n    }\n\n    return this.webex.request({\n      method: 'GET',\n      service: 'apheleia',\n      resource: 'compositions?userId=' + personId\n    }).then(function (response) {\n      return response.body;\n    });\n  },\n\n  /**\n  * @typedef {Object} PresenceStatusesObject\n  * @property {Array.<PresenceStatusObject>} statusList\n   */\n\n  /**\n   * Gets the current presence statuses of an array of people ids\n   * @param {Array} personIds\n   * @returns {Promise<PresenceStatusesObject>} resolves with an object with key of `statusList` array\n   */\n  list: function list(personIds) {\n    var _this2 = this;\n\n    if (!personIds || !Array.isArray(personIds)) {\n      return _promise2.default.reject(new Error('An array of person ids is required'));\n    }\n\n    return _promise2.default.all(personIds.map(function (id) {\n      return _this2.batcher.request(id);\n    })).then(function (presences) {\n      return {\n        statusList: presences\n      };\n    });\n  },\n\n  /**\n   * Subscribes to a person's presence status updates\n   * Updates are sent via mercury events `apheleia.subscription_update`\n   * @param {string | Array} personIds\n   * @param {number} subscriptionTtl - Requested length of subscriptions in seconds.\n   * @returns {Promise}\n   */\n  subscribe: function subscribe(personIds) {\n    var _this3 = this;\n\n    var subscriptionTtl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultSubscriptionTtl;\n    var subjects = void 0;\n    var batches = [];\n    var batchLimit = 50;\n\n    if (!personIds) {\n      return _promise2.default.reject(new Error('A person id is required'));\n    }\n\n    if (Array.isArray(personIds)) {\n      subjects = personIds;\n    } else {\n      subjects = [personIds];\n    } // Limit batches to 50 ids per request\n\n\n    for (var i = 0; i < subjects.length; i += batchLimit) {\n      batches.push(subjects.slice(i, i + batchLimit));\n    }\n\n    return _promise2.default.all(batches.map(function (ids) {\n      return _this3.webex.request({\n        method: 'POST',\n        api: 'apheleia',\n        resource: 'subscriptions',\n        body: {\n          subjects: ids,\n          subscriptionTtl: subscriptionTtl,\n          includeStatus: true\n        }\n      }).then(function (response) {\n        return response.body.responses;\n      });\n    })).then(function (idBatches) {\n      var _ref;\n\n      return {\n        responses: (_ref = []).concat.apply(_ref, (0, _toConsumableArray3.default)(idBatches))\n      };\n    });\n  },\n\n  /**\n   * Unsubscribes from a person or group of people's presence subscription\n   * @param {string | Array} personIds\n   * @returns {Promise}\n   */\n  unsubscribe: function unsubscribe(personIds) {\n    var subjects = void 0;\n\n    if (!personIds) {\n      return _promise2.default.reject(new Error('A person id is required'));\n    }\n\n    if (Array.isArray(personIds)) {\n      subjects = personIds;\n    } else {\n      subjects = [personIds];\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      api: 'apheleia',\n      resource: 'subscriptions',\n      body: {\n        subjects: subjects,\n        subscriptionTtl: 0,\n        includeStatus: true\n      }\n    });\n  },\n\n  /**\n   * Sets the status of the current user\n   * @param {string} status - active | inactive | ooo | dnd\n   * @param {number} ttl - Time To Live for the event in seconds.\n   * @returns {Promise}\n   */\n  setStatus: function setStatus(status, ttl) {\n    if (!status) {\n      return _promise2.default.reject(new Error('A status is required'));\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      api: 'apheleia',\n      resource: 'events',\n      body: {\n        subject: this.webex.internal.device.userId,\n        eventType: status,\n        ttl: ttl\n      }\n    }).then(function (response) {\n      return response.body;\n    });\n  },\n\n  /**\n   * Retrieves and subscribes to a user's presence.\n   * @param {string} id\n   * @returns {undefined}\n   */\n  enqueue: function enqueue(id) {\n    return this.worker.enqueue(id);\n  },\n\n  /**\n   * Retract from subscribing to a user's presence.\n   * @param {string} id\n   * @returns {undefined}\n   */\n  dequeue: function dequeue(id) {\n    return this.worker.dequeue(id);\n  },\n  version: '1.80.172'\n});\n\nexports.default = Presence;","map":{"version":3,"sources":["presence.js"],"names":["defaultSubscriptionTtl","USER","USER_PRESENCE_ENABLED","Presence","namespace","children","batcher","PresenceBatcher","session","worker","default","PresenceWorker","type","initialize","emitEvent","payload","enable","response","disable","isEnabled","get","method","service","resource","personId","list","Array","statusList","subscribe","subscriptionTtl","subjects","batches","batchLimit","i","api","body","includeStatus","responses","unsubscribe","setStatus","subject","eventType","ttl","enqueue","dequeue"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport '@webex/internal-plugin-device';\n\nimport {WebexPlugin} from '@webex/webex-core';\n\nimport PresenceBatcher from './presence-batcher';\nimport PresenceWorker from './presence-worker';\n\nconst defaultSubscriptionTtl = 600;\nconst USER = 'user';\nconst USER_PRESENCE_ENABLED = 'user-presence-enabled';\n\n/**\n * @class\n * @extends WebexPlugin\n */\nconst Presence = WebexPlugin.extend({\n  namespace: 'Presence',\n\n  children: {\n    batcher: PresenceBatcher\n  },\n\n  session: {\n    worker: {\n      default() {\n        return new PresenceWorker();\n      },\n      type: 'any'\n    }\n  },\n\n  /**\n   * Initialize the presence worker for client\n   * @returns {undefined}\n   */\n  initialize() {\n    this.webex.once('ready', () => {\n      if (this.config.initializeWorker) {\n        this.worker.initialize(this.webex);\n      }\n    });\n  },\n\n  /**\n   * Trigger an event.\n   * @param {string} event\n   * @param {string} payload\n   * @returns {undefined}\n   */\n  emitEvent(event, payload) {\n    if (payload.type && payload.payload) {\n      this.trigger(event, payload);\n    }\n  },\n\n  /**\n   * Enables presence feature\n   * @returns {Promise<boolean>} resolves with true, if successful\n   */\n  enable() {\n    return this.webex.internal.feature.setFeature(USER, USER_PRESENCE_ENABLED, true)\n      .then((response) => response.value);\n  },\n\n  /**\n   * Disables presence feature\n   * @returns {Promise<boolean>} resolves with false, if successful\n   */\n  disable() {\n    return this.webex.internal.feature.setFeature(USER, USER_PRESENCE_ENABLED, false)\n      .then((response) => response.value);\n  },\n\n  /**\n   * Returns true if presence is enabled, false otherwise\n   * @returns {Promise<boolean>} resolves with true if presence is enabled\n   */\n  isEnabled() {\n    return this.webex.internal.feature.getFeature(USER, USER_PRESENCE_ENABLED);\n  },\n\n  /**\n   * The status object\n   * @typedef {Object} PresenceStatusObject\n   * @property {string} url: Public resource identifier for presence\n   * @property {string} subject: User ID for the user the returned composed presence represents\n   * @property {string} status: Current composed presence state\n   * @property {string} statusTime: DateTime in RFC3339 format that the current status began\n   * @property {string} lastActive: DateTime in RFC3339 format that the service last saw activity from the user.\n   * @property {string} expires: DEPRECATED - DateTime in RFC3339 format that represents when the current\n   * status will expire. Will not exist if expiresTTL is -1.\n   * @property {Number} expiresTTL: TTL in seconds until the status will expire. If TTL is -1 the current\n   * status has no known expiration.\n   * @property {string} expiresTime: DateTime in RFC3339 format that the current status will expire. Missing\n   * field means no known expiration.\n   * @property {Object} vectorCounters: Used for packet ordering and tracking.\n   * @property {Boolean} suppressNotifications: Indicates if notification suppresion is recommended for this status.\n   * @property {string} lastSeenDeviceUrl: Resource Identifier of the last device to post presence activity for\n   * this user.\n   */\n\n  /**\n   * Gets the current presence status of a given person id\n   * @param {string} personId\n   * @returns {Promise<PresenceStatusObject>} resolves with status object of person\n   */\n  get(personId) {\n    if (!personId) {\n      return Promise.reject(new Error('A person id is required'));\n    }\n\n    return this.webex.request({\n      method: 'GET',\n      service: 'apheleia',\n      resource: `compositions?userId=${personId}`\n    })\n      .then((response) => response.body);\n  },\n\n  /**\n  * @typedef {Object} PresenceStatusesObject\n  * @property {Array.<PresenceStatusObject>} statusList\n   */\n  /**\n   * Gets the current presence statuses of an array of people ids\n   * @param {Array} personIds\n   * @returns {Promise<PresenceStatusesObject>} resolves with an object with key of `statusList` array\n   */\n  list(personIds) {\n    if (!personIds || !Array.isArray(personIds)) {\n      return Promise.reject(new Error('An array of person ids is required'));\n    }\n\n    return Promise.all(personIds.map((id) =>\n      this.batcher.request(id)))\n      .then((presences) => ({statusList: presences}));\n  },\n\n  /**\n   * Subscribes to a person's presence status updates\n   * Updates are sent via mercury events `apheleia.subscription_update`\n   * @param {string | Array} personIds\n   * @param {number} subscriptionTtl - Requested length of subscriptions in seconds.\n   * @returns {Promise}\n   */\n  subscribe(personIds, subscriptionTtl = defaultSubscriptionTtl) {\n    let subjects;\n    const batches = [];\n    const batchLimit = 50;\n\n    if (!personIds) {\n      return Promise.reject(new Error('A person id is required'));\n    }\n    if (Array.isArray(personIds)) {\n      subjects = personIds;\n    }\n    else {\n      subjects = [personIds];\n    }\n    // Limit batches to 50 ids per request\n    for (let i = 0; i < subjects.length; i += batchLimit) {\n      batches.push(subjects.slice(i, i + batchLimit));\n    }\n\n    return Promise.all(batches.map((ids) =>\n      this.webex.request({\n        method: 'POST',\n        api: 'apheleia',\n        resource: 'subscriptions',\n        body: {\n          subjects: ids,\n          subscriptionTtl,\n          includeStatus: true\n        }\n      })\n        .then((response) => response.body.responses)))\n      .then((idBatches) => ({responses: [].concat(...idBatches)}));\n  },\n\n  /**\n   * Unsubscribes from a person or group of people's presence subscription\n   * @param {string | Array} personIds\n   * @returns {Promise}\n   */\n  unsubscribe(personIds) {\n    let subjects;\n\n    if (!personIds) {\n      return Promise.reject(new Error('A person id is required'));\n    }\n    if (Array.isArray(personIds)) {\n      subjects = personIds;\n    }\n    else {\n      subjects = [personIds];\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      api: 'apheleia',\n      resource: 'subscriptions',\n      body: {\n        subjects,\n        subscriptionTtl: 0,\n        includeStatus: true\n      }\n    });\n  },\n\n  /**\n   * Sets the status of the current user\n   * @param {string} status - active | inactive | ooo | dnd\n   * @param {number} ttl - Time To Live for the event in seconds.\n   * @returns {Promise}\n   */\n  setStatus(status, ttl) {\n    if (!status) {\n      return Promise.reject(new Error('A status is required'));\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      api: 'apheleia',\n      resource: 'events',\n      body: {\n        subject: this.webex.internal.device.userId,\n        eventType: status,\n        ttl\n      }\n    })\n      .then((response) => response.body);\n  },\n\n  /**\n   * Retrieves and subscribes to a user's presence.\n   * @param {string} id\n   * @returns {undefined}\n   */\n  enqueue(id) {\n    return this.worker.enqueue(id);\n  },\n\n  /**\n   * Retract from subscribing to a user's presence.\n   * @param {string} id\n   * @returns {undefined}\n   */\n  dequeue(id) {\n    return this.worker.dequeue(id);\n  }\n});\n\nexport default Presence;\n"]},"metadata":{},"sourceType":"script"}