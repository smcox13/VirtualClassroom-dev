{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _defineProperty2 = require('babel-runtime/helpers/defineProperty');\n\nvar _defineProperty3 = _interopRequireDefault(_defineProperty2);\n\nvar _typeof2 = require('babel-runtime/helpers/typeof');\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _set = require('babel-runtime/core-js/set');\n\nvar _set2 = _interopRequireDefault(_set);\n\nvar _map = require('babel-runtime/core-js/map');\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _wrap2 = require('lodash/wrap');\n\nvar _wrap3 = _interopRequireDefault(_wrap2);\n\nvar _result2 = require('lodash/result');\n\nvar _result3 = _interopRequireDefault(_result2);\n\nvar _identity2 = require('lodash/identity');\n\nvar _identity3 = _interopRequireDefault(_identity2);\n\nvar _debounce2 = require('lodash/debounce');\n\nvar _debounce3 = _interopRequireDefault(_debounce2);\n\nvar _curry2 = require('lodash/curry');\n\nvar _curry3 = _interopRequireDefault(_curry2);\n\nexports.persist = persist;\nexports.waitForValue = waitForValue;\n\nvar _errors = require('./errors');\n\nvar _common = require('@webex/common');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Stores the result of fn before returning it\n * @param  {string} key\n * @private\n * @returns {Promise} resolves with the result of fn\n */\n\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint no-invalid-this: [0] */\n\n\nfunction persist() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (args.length === 3) {\n    return persist('@').apply(undefined, args);\n  }\n\n  var key = args[0],\n      decider = args[1];\n  return function persistDecorator(target, prop, descriptor) {\n    if (prop !== 'initialize') {\n      // Once we have class-based alternative to AmpersandState, it should be\n      // detected here.\n      throw new TypeError('@persist can only currently be applied to AmpersandState objects or their derivatives and must be applied to the initialize method');\n    }\n\n    descriptor.value = (0, _wrap3.default)(descriptor.value, function persistExecutor(fn) {\n      var _this = this;\n\n      for (var _len2 = arguments.length, initializeArgs = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        initializeArgs[_key2 - 1] = arguments[_key2];\n      }\n\n      var ret = (0, _apply2.default)(fn, this, initializeArgs);\n      var changeEvent = key === '@' ? 'change' : 'change:' + key; // Some scenarios will lead to lots of change events on a single tick; we\n      // really only care about writing once things have stopped changing. with\n      // a debounce of zero, we're effectively coalescing all the changes\n      // triggered by a single call to set() and commiting them on the next tick\n      // eslint-disable-next-line no-invalid-this\n\n      this.on(changeEvent, (0, _debounce3.default)(function () {\n        var shouldPersist = !decider || _apply2.default.apply(Reflect, [decider, _this].concat(initializeArgs));\n\n        if (!shouldPersist) {\n          return _promise2.default.resolve();\n        }\n\n        if (key === '@') {\n          // eslint-disable-next-line no-invalid-this\n          return _this.boundedStorage.put(key, _this);\n        } // eslint-disable-next-line no-invalid-this\n\n\n        return _this.boundedStorage.put(key, _this[key]);\n      }, 0));\n      return ret;\n    });\n    prepareInitialize(target, prop);\n  };\n}\n\nvar M = _map2.default;\nvar S = _set2.default;\nvar BlockingKeyMap = (0, _common.make)(M, M, S);\nvar blockingKeys = new BlockingKeyMap();\n/**\n * Prevents fn from executing until key has been (attempted to be) loaded\n * @param {string} key\n * @param {Function} fn\n * @private\n * @returns {Promise} result of fn\n */\n\nfunction waitForValue(key) {\n  if (!key) {\n    throw new Error('`key` is required');\n  }\n\n  return function waitForValueDecorator(target, prop, descriptor) {\n    blockingKeys.add(target, prop, key);\n    descriptor.value = (0, _wrap3.default)(descriptor.value, function waitForValueExecutor(fn) {\n      var _this2 = this;\n\n      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n\n      var keys = blockingKeys.get(target, prop);\n      return _promise2.default.all([].concat((0, _toConsumableArray3.default)(keys)).map(function (k) {\n        return _this2.boundedStorage.waitFor(k);\n      })).then(function () {\n        return (0, _apply2.default)(fn, _this2, args);\n      });\n    }); // This *should* make decorators compatible with AmpersandState class\n    // definitions\n\n    if ((typeof target === 'undefined' ? 'undefined' : (0, _typeof3.default)(target)) === 'object' && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    prepareInitialize(target, prop);\n    return descriptor;\n  };\n}\n\nvar inited = new _set2.default();\n/**\n * finds a means of identitying the `target` param passed to\n * `prepareInitialize()`. When possible, avoids duplicate `init()` calls if\n * namespaces collide\n *\n * @param {Object|Constructor} target\n * @private\n * @returns {String|Constructor}\n */\n\nfunction identifyTarget(target) {\n  if (target.namespace) {\n    return target.namespace;\n  }\n\n  return target;\n}\n\nvar stack = new _set2.default();\n/**\n * @param {Function} target\n * @param {string} prop\n * @private\n * @returns {undefined}\n */\n\nfunction prepareInitialize(target, prop) {\n  var id = identifyTarget(target);\n\n  if (!inited.has(id)) {\n    inited.add(id);\n\n    if (target.initialize) {\n      target.initialize = (0, _wrap3.default)(target.initialize, function applyInit(fn) {\n        for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n          args[_key4 - 1] = arguments[_key4];\n        }\n\n        var ret = (0, _apply2.default)(fn, this, args);\n        (0, _apply2.default)(init, this, args);\n        return ret;\n      });\n      return;\n    }\n\n    target.initialize = init;\n  }\n  /**\n   * @private\n   * @returns {undefined}\n   */\n\n\n  function init() {\n    var self = this;\n    var namespace = this.getNamespace();\n    this.webex.initialize = (0, _wrap3.default)(this.webex.initialize || _identity3.default, function applyInit(fn) {\n      var _this3 = this; // Call webex's initalize method first\n      // Reminder: in order for MockWebex to accept initial storage data, the\n      // wrapped initialize() must be invoked before attempting to load data.\n      // Reminder: context here is `webex`, not `self`.\n\n\n      stack.add(namespace);\n\n      for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        args[_key5 - 1] = arguments[_key5];\n      }\n\n      (0, _apply2.default)(fn, this, args); // Then prepare a function for setting values retrieved from storage\n\n      var set = (0, _curry3.default)(function (key, value) {\n        _this3.logger.debug('storage:(' + namespace + '): got `' + key + '` for first time');\n\n        if (key === '@') {\n          self.parent.set((0, _defineProperty3.default)({}, namespace.toLowerCase(), value));\n        } else if ((0, _result3.default)(self[key], 'isState')) {\n          self[key].set(value);\n        } else {\n          self.set(key, value);\n        }\n\n        _this3.logger.debug('storage:(' + namespace + '): set `' + key + '` for first time');\n      }); // And prepare an error handler for when those keys can't be found\n\n      var handle = (0, _curry3.default)(function (key, reason) {\n        if (reason instanceof _errors.NotFoundError || process.env.NODE_ENV !== 'production' && reason.toString().includes('MockNotFoundError')) {\n          _this3.logger.debug('storage(' + namespace + '): no data for `' + key + '`, continuing');\n\n          return _promise2.default.resolve();\n        }\n\n        _this3.logger.error('storage(' + namespace + '): failed to init `' + key + '`', reason);\n\n        return _promise2.default.reject(reason);\n      }); // Iterate over the list of keys marked as blocking via `@waitForValue`\n\n      var keys = blockingKeys.get(target, prop);\n      var promises = [];\n      keys.forEach(function (key) {\n        promises.push(_this3.boundedStorage.get(namespace, key).then(set(key)).catch(handle(key)));\n      });\n\n      _promise2.default.all(promises).then(function () {\n        stack.delete(namespace);\n\n        if (stack.size === 0) {\n          _this3.loaded = true;\n        }\n      });\n    });\n  }\n}","map":{"version":3,"sources":["decorators.js"],"names":["persist","args","key","decider","prop","descriptor","initializeArgs","ret","changeEvent","shouldPersist","prepareInitialize","M","S","BlockingKeyMap","blockingKeys","waitForValue","keys","target","inited","stack","id","identifyTarget","self","namespace","set","handle","reason","NotFoundError","process","promises"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint no-invalid-this: [0] */\n\nimport {\n  curry,\n  debounce,\n  identity,\n  result,\n  wrap\n} from 'lodash';\nimport {NotFoundError} from './errors';\nimport {make} from '@webex/common';\n\n/**\n * Stores the result of fn before returning it\n * @param  {string} key\n * @private\n * @returns {Promise} resolves with the result of fn\n */\nexport function persist(...args) {\n  if (args.length === 3) {\n    return persist('@')(...args);\n  }\n\n  const [key, decider] = args;\n\n  return function persistDecorator(target, prop, descriptor) {\n    if (prop !== 'initialize') {\n      // Once we have class-based alternative to AmpersandState, it should be\n      // detected here.\n      throw new TypeError('@persist can only currently be applied to AmpersandState objects or their derivatives and must be applied to the initialize method');\n    }\n\n    descriptor.value = wrap(descriptor.value, function persistExecutor(fn, ...initializeArgs) {\n      const ret = Reflect.apply(fn, this, initializeArgs);\n      const changeEvent = key === '@' ? 'change' : `change:${key}`;\n\n      // Some scenarios will lead to lots of change events on a single tick; we\n      // really only care about writing once things have stopped changing. with\n      // a debounce of zero, we're effectively coalescing all the changes\n      // triggered by a single call to set() and commiting them on the next tick\n      // eslint-disable-next-line no-invalid-this\n      this.on(changeEvent, debounce(() => {\n        const shouldPersist = !decider || Reflect.apply(decider, this, ...initializeArgs);\n\n        if (!shouldPersist) {\n          return Promise.resolve();\n        }\n        if (key === '@') {\n          // eslint-disable-next-line no-invalid-this\n          return this.boundedStorage.put(key, this);\n        }\n\n        // eslint-disable-next-line no-invalid-this\n        return this.boundedStorage.put(key, this[key]);\n      }, 0));\n\n      return ret;\n    });\n\n    prepareInitialize(target, prop);\n  };\n}\n\nconst M = Map;\nconst S = Set;\nconst BlockingKeyMap = make(M, M, S);\nconst blockingKeys = new BlockingKeyMap();\n\n/**\n * Prevents fn from executing until key has been (attempted to be) loaded\n * @param {string} key\n * @param {Function} fn\n * @private\n * @returns {Promise} result of fn\n */\nexport function waitForValue(key) {\n  if (!key) {\n    throw new Error('`key` is required');\n  }\n\n  return function waitForValueDecorator(target, prop, descriptor) {\n    blockingKeys.add(target, prop, key);\n    descriptor.value = wrap(descriptor.value, function waitForValueExecutor(fn, ...args) {\n      const keys = blockingKeys.get(target, prop);\n\n      return Promise.all([...keys].map((k) => this.boundedStorage.waitFor(k)))\n        .then(() => Reflect.apply(fn, this, args));\n    });\n\n    // This *should* make decorators compatible with AmpersandState class\n    // definitions\n    if (typeof target === 'object' && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    prepareInitialize(target, prop);\n\n    return descriptor;\n  };\n}\n\nconst inited = new Set();\n\n/**\n * finds a means of identitying the `target` param passed to\n * `prepareInitialize()`. When possible, avoids duplicate `init()` calls if\n * namespaces collide\n *\n * @param {Object|Constructor} target\n * @private\n * @returns {String|Constructor}\n */\nfunction identifyTarget(target) {\n  if (target.namespace) {\n    return target.namespace;\n  }\n\n  return target;\n}\n\nconst stack = new Set();\n\n/**\n * @param {Function} target\n * @param {string} prop\n * @private\n * @returns {undefined}\n */\nfunction prepareInitialize(target, prop) {\n  const id = identifyTarget(target);\n\n  if (!inited.has(id)) {\n    inited.add(id);\n    if (target.initialize) {\n      target.initialize = wrap(target.initialize, function applyInit(fn, ...args) {\n        const ret = Reflect.apply(fn, this, args);\n\n        Reflect.apply(init, this, args);\n\n        return ret;\n      });\n\n      return;\n    }\n\n    target.initialize = init;\n  }\n\n  /**\n   * @private\n   * @returns {undefined}\n   */\n  function init() {\n    const self = this;\n    const namespace = this.getNamespace();\n\n    this.webex.initialize = wrap(this.webex.initialize || identity, function applyInit(fn, ...args) {\n      // Call webex's initalize method first\n      // Reminder: in order for MockWebex to accept initial storage data, the\n      // wrapped initialize() must be invoked before attempting to load data.\n      // Reminder: context here is `webex`, not `self`.\n      stack.add(namespace);\n      Reflect.apply(fn, this, args);\n\n      // Then prepare a function for setting values retrieved from storage\n      const set = curry((key, value) => {\n        this.logger.debug(`storage:(${namespace}): got \\`${key}\\` for first time`);\n        if (key === '@') {\n          self.parent.set({\n            [namespace.toLowerCase()]: value\n          });\n        }\n        else if (result(self[key], 'isState')) {\n          self[key].set(value);\n        }\n        else {\n          self.set(key, value);\n        }\n        this.logger.debug(`storage:(${namespace}): set \\`${key}\\` for first time`);\n      });\n\n      // And prepare an error handler for when those keys can't be found\n      const handle = curry((key, reason) => {\n        if (reason instanceof NotFoundError || process.env.NODE_ENV !== 'production' && reason.toString().includes('MockNotFoundError')) {\n          this.logger.debug(`storage(${namespace}): no data for \\`${key}\\`, continuing`);\n\n          return Promise.resolve();\n        }\n        this.logger.error(`storage(${namespace}): failed to init \\`${key}\\``, reason);\n\n        return Promise.reject(reason);\n      });\n\n      // Iterate over the list of keys marked as blocking via `@waitForValue`\n      const keys = blockingKeys.get(target, prop);\n      const promises = [];\n\n      keys.forEach((key) => {\n        promises.push(this.boundedStorage.get(namespace, key)\n          .then(set(key))\n          .catch(handle(key)));\n      });\n\n      Promise.all(promises)\n        .then(() => {\n          stack.delete(namespace);\n          if (stack.size === 0) {\n            this.loaded = true;\n          }\n        });\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}