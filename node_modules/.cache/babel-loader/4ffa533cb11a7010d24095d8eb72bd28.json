{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nexports.default = debounce;\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n/**\n * Behaves like debounce, but additionally executes after a number of calls are\n * attempted, rather than just time\n * @param {Function} fn\n * @param {Number} wait\n * @param {Object} options\n * @returns {Function}\n */\n\n\nfunction debounce(fn, wait, options) {\n  /* eslint no-invalid-this: [0] */\n  if (!fn) {\n    throw new Error('`fn` must be a function');\n  }\n\n  if (!wait) {\n    throw new Error('`wait` is required');\n  }\n\n  options = options || {};\n\n  if (!options.maxWait) {\n    throw new Error('`options.maxWait` is required');\n  }\n\n  if (!options.maxCalls) {\n    throw new Error('`options.maxCalls` is required');\n  }\n\n  var _options = options,\n      maxCalls = _options.maxCalls,\n      maxWait = _options.maxWait;\n  var count = 0;\n  var maxWaitTimer = void 0,\n      waitTimer = void 0;\n  return function wrapper() {\n    count += 1;\n    clearTimeout(waitTimer);\n    waitTimer = setTimeout(function () {\n      return exec();\n    }, wait);\n\n    if (!maxWaitTimer) {\n      maxWaitTimer = setTimeout(function () {\n        return exec();\n      }, maxWait);\n    }\n\n    if (count >= maxCalls) {\n      (0, _apply2.default)(exec, this, []);\n    }\n  };\n  /**\n   * @private\n   * @returns {undefined}\n   */\n\n  function exec() {\n    clearTimeout(waitTimer);\n    waitTimer = null;\n    clearTimeout(maxWaitTimer);\n    maxWaitTimer = null;\n    count = 0;\n    (0, _apply2.default)(fn, this, []);\n  }\n}","map":{"version":3,"sources":["capped-debounce.js"],"names":["debounce","options","maxCalls","maxWait","count","maxWaitTimer","waitTimer","clearTimeout","exec"],"mappings":";;;;;;;;;;kBAYwBA,Q;;;;;;;AAZxB;;;;AAIA;;;;;;;;;;AAQe,SAAA,QAAA,CAAA,EAAA,EAAA,IAAA,EAAA,OAAA,EAAqC;AAClD;AAEA,MAAI,CAAJ,EAAA,EAAS;AACP,UAAM,IAAA,KAAA,CAAN,yBAAM,CAAN;AACD;;AAED,MAAI,CAAJ,IAAA,EAAW;AACT,UAAM,IAAA,KAAA,CAAN,oBAAM,CAAN;AACD;;AAEDC,EAAAA,OAAAA,GAAUA,OAAAA,IAAVA,EAAAA;;AACA,MAAI,CAACA,OAAAA,CAAL,OAAA,EAAsB;AACpB,UAAM,IAAA,KAAA,CAAN,+BAAM,CAAN;AACD;;AACD,MAAI,CAACA,OAAAA,CAAL,QAAA,EAAuB;AACrB,UAAM,IAAA,KAAA,CAAN,gCAAM,CAAN;AACD;;AAjBiD,MAAA,QAAA,GAAA,OAAA;AAAA,MAmB3CC,QAnB2C,GAAA,QAAA,CAAA,QAAA;AAAA,MAmBjCC,OAnBiC,GAAA,QAAA,CAAA,OAAA;AAoBlD,MAAIC,KAAAA,GAAJ,CAAA;AACA,MAAIC,YAAAA,GAAAA,KAAJ,CAAA;AAAA,MAAkBC,SAAAA,GAAAA,KAAlB,CAAA;AAEA,SAAO,SAAA,OAAA,GAAmB;AACxBF,IAAAA,KAAAA,IAAAA,CAAAA;AAEAG,IAAAA,YAAAA,CAAAA,SAAAA,CAAAA;AACAD,IAAAA,SAAAA,GAAY,UAAA,CAAW,YAAA;AAAA,aAAME,IAAN,EAAA;AAAX,KAAA,EAAZF,IAAY,CAAZA;;AAEA,QAAI,CAAJ,YAAA,EAAmB;AACjBD,MAAAA,YAAAA,GAAe,UAAA,CAAW,YAAA;AAAA,eAAMG,IAAN,EAAA;AAAX,OAAA,EAAfH,OAAe,CAAfA;AACD;;AAED,QAAID,KAAAA,IAAJ,QAAA,EAAuB;AACrB,OAAA,GAAA,OAAA,CAAA,OAAA,EAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AACD;AAZH,GAAA;AAeA;;;;;AAIA,WAAA,IAAA,GAAgB;AACdG,IAAAA,YAAAA,CAAAA,SAAAA,CAAAA;AACAD,IAAAA,SAAAA,GAAAA,IAAAA;AACAC,IAAAA,YAAAA,CAAAA,YAAAA,CAAAA;AACAF,IAAAA,YAAAA,GAAAA,IAAAA;AACAD,IAAAA,KAAAA,GAAAA,CAAAA;AAEA,KAAA,GAAA,OAAA,CAAA,OAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA;AACD;AACF","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n/**\n * Behaves like debounce, but additionally executes after a number of calls are\n * attempted, rather than just time\n * @param {Function} fn\n * @param {Number} wait\n * @param {Object} options\n * @returns {Function}\n */\nexport default function debounce(fn, wait, options) {\n  /* eslint no-invalid-this: [0] */\n\n  if (!fn) {\n    throw new Error('`fn` must be a function');\n  }\n\n  if (!wait) {\n    throw new Error('`wait` is required');\n  }\n\n  options = options || {};\n  if (!options.maxWait) {\n    throw new Error('`options.maxWait` is required');\n  }\n  if (!options.maxCalls) {\n    throw new Error('`options.maxCalls` is required');\n  }\n\n  const {maxCalls, maxWait} = options;\n  let count = 0;\n  let maxWaitTimer, waitTimer;\n\n  return function wrapper() {\n    count += 1;\n\n    clearTimeout(waitTimer);\n    waitTimer = setTimeout(() => exec(), wait);\n\n    if (!maxWaitTimer) {\n      maxWaitTimer = setTimeout(() => exec(), maxWait);\n    }\n\n    if (count >= maxCalls) {\n      Reflect.apply(exec, this, []);\n    }\n  };\n\n  /**\n   * @private\n   * @returns {undefined}\n   */\n  function exec() {\n    clearTimeout(waitTimer);\n    waitTimer = null;\n    clearTimeout(maxWaitTimer);\n    maxWaitTimer = null;\n    count = 0;\n\n    Reflect.apply(fn, this, []);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}