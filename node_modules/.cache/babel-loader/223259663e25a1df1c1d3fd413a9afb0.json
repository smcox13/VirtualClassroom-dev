{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _btoa = require('btoa');\n\nvar _btoa2 = _interopRequireDefault(_btoa);\n\nvar _common = require('@webex/common');\n\nvar _parameter = require('../common/errors/parameter');\n\nvar _parameter2 = _interopRequireDefault(_parameter);\n\nvar _loggerProxy = require('../common/logs/logger-proxy');\n\nvar _loggerProxy2 = _interopRequireDefault(_loggerProxy);\n\nvar _constants = require('../constants');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar MeetingInfoUtil = {};\n\nMeetingInfoUtil.getParsedUrl = function (link) {\n  try {\n    var parsedUrl = _url2.default.parse(link);\n\n    if (!parsedUrl) {\n      return false;\n    } // hack for links such as <company>.webex.com/meet/<user> without a protocol\n\n\n    if (!parsedUrl.protocol) {\n      parsedUrl = _url2.default.parse('' + _constants.HTTPS_PROTOCOL + link);\n    }\n\n    return parsedUrl;\n  } catch (error) {\n    _loggerProxy2.default.logger.warn('MeetingInfoUtil->getParsedUrl#unable to parse the URL, error: ' + error);\n\n    return null;\n  }\n};\n/**\n * Helper function to check if a string matches a known meeting link pattern\n * @param {String} value  string to parse and see if it matches a meeting link\n * @returns {Boolean}\n */\n\n\nMeetingInfoUtil.isMeetingLink = function (value) {\n  var parsedUrl = MeetingInfoUtil.getParsedUrl(value);\n  var hostNameBool = parsedUrl.hostname && parsedUrl.hostname.includes(_constants.WEBEX_DOT_COM);\n  var pathNameBool = parsedUrl.pathname && (parsedUrl.pathname.includes('/' + _constants.MEET) || parsedUrl.pathname.includes('/' + _constants.MEET_M) || parsedUrl.pathname.includes('/' + _constants.JOIN));\n  return hostNameBool && pathNameBool;\n};\n\nMeetingInfoUtil.isConversationUrl = function (value, webex) {\n  var clusterId = webex.internal.services.getClusterId(value);\n\n  if (clusterId) {\n    return clusterId.endsWith(_constants.CONVERSATION_SERVICE);\n  }\n\n  return false;\n};\n\nMeetingInfoUtil.convertLinkToSip = function (value) {\n  var parsedUrl = MeetingInfoUtil.getParsedUrl(value);\n\n  if (!parsedUrl) {\n    return null;\n  }\n\n  var user = void 0;\n\n  if (parsedUrl.pathname) {\n    var userIndex = parsedUrl.pathname.lastIndexOf('/');\n    user = parsedUrl.pathname.substring(userIndex + 1);\n  }\n\n  if (!user) {\n    return null;\n  }\n\n  var company = void 0;\n\n  if (parsedUrl.hostname) {\n    var companyIndex = parsedUrl.hostname.lastIndexOf('.' + _constants.WEBEX_DOT_COM);\n    company = parsedUrl.hostname.substring(0, companyIndex).replace(_constants.WWW_DOT, '');\n  }\n\n  if (!company) {\n    return null;\n  }\n\n  return user + '@' + company + '.' + _constants.WEBEX_DOT_COM;\n};\n\nMeetingInfoUtil.isSipUri = function (sipString) {\n  // TODO: lets remove regex from this equation and user URI matchers and such\n  // have not found a great sip uri parser library as of now\n  var sipUri = _constants.DIALER_REGEX.SIP_ADDRESS.exec(sipString);\n\n  return sipUri;\n};\n\nMeetingInfoUtil.isPhoneNumber = function (phoneNumber) {\n  var isValidNumber = _constants.DIALER_REGEX.PHONE_NUMBER.test(phoneNumber);\n\n  return isValidNumber;\n};\n\nMeetingInfoUtil.getHydraId = function (destination) {\n  var decodedDestination = (0, _common.deconstructHydraId)(destination);\n\n  if (decodedDestination && _constants.UUID_REG.test(decodedDestination.id)) {\n    if (decodedDestination.type === _constants._ROOM_) {\n      return {\n        room: true,\n        destination: decodedDestination.id\n      };\n    }\n\n    if (decodedDestination.type === _constants._PEOPLE_) {\n      return {\n        people: true,\n        destination: decodedDestination.id\n      };\n    }\n\n    return {};\n  }\n\n  return {};\n};\n\nMeetingInfoUtil.getSipUriFromHydraPersonId = function (destination, webex) {\n  return webex.people.get(destination).then(function (res) {\n    if (res.emails && res.emails.length) {\n      return res.emails[0];\n    }\n\n    throw new _parameter2.default('Hydra Id Lookup was an invalid hydra person id.');\n  }).catch(function (err) {\n    throw err;\n  });\n};\n\nMeetingInfoUtil.generateOptions = function () {\n  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(from) {\n    var destination, type, webex, options, hydraId, convoUrl;\n    return _regenerator2.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            destination = from.destination, type = from.type, webex = from.webex;\n\n            if (!type) {\n              _context.next = 3;\n              break;\n            }\n\n            return _context.abrupt('return', {\n              destination: destination,\n              type: type\n            });\n\n          case 3:\n            options = {};\n            hydraId = MeetingInfoUtil.getHydraId(destination);\n\n            if (!MeetingInfoUtil.isMeetingLink(destination)) {\n              _context.next = 10;\n              break;\n            }\n\n            options.type = _constants._MEETING_LINK_;\n            options.destination = destination;\n            _context.next = 39;\n            break;\n\n          case 10:\n            if (!MeetingInfoUtil.isSipUri(destination)) {\n              _context.next = 15;\n              break;\n            }\n\n            options.type = _constants._SIP_URI_;\n            options.destination = destination;\n            _context.next = 39;\n            break;\n\n          case 15:\n            if (!MeetingInfoUtil.isPhoneNumber(destination)) {\n              _context.next = 20;\n              break;\n            }\n\n            options.type = _constants._SIP_URI_;\n            options.destination = destination;\n            _context.next = 39;\n            break;\n\n          case 20:\n            if (!MeetingInfoUtil.isConversationUrl(destination, webex)) {\n              _context.next = 25;\n              break;\n            }\n\n            options.type = _constants._CONVERSATION_URL_;\n            options.destination = destination;\n            _context.next = 39;\n            break;\n\n          case 25:\n            if (!hydraId.people) {\n              _context.next = 30;\n              break;\n            }\n\n            options.type = _constants._SIP_URI_;\n            return _context.abrupt('return', MeetingInfoUtil.getSipUriFromHydraPersonId(hydraId.destination, webex).then(function (res) {\n              options.destination = res;\n              return _promise2.default.resolve(options);\n            }));\n\n          case 30:\n            if (!hydraId.room) {\n              _context.next = 38;\n              break;\n            }\n\n            options.type = _constants._CONVERSATION_URL_;\n            _context.next = 34;\n            return webex.internal.services.waitForCatalog('postauth');\n\n          case 34:\n            convoUrl = webex.internal.services.get('conversation') + '/' + _constants.CONVERSATIONS + '/' + hydraId.destination;\n            options.destination = convoUrl;\n            _context.next = 39;\n            break;\n\n          case 38:\n            throw new _parameter2.default('MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.');\n\n          case 39:\n            return _context.abrupt('return', _promise2.default.resolve(options));\n\n          case 40:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, undefined);\n  }));\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Helper function to build up a correct locus url depending on the value passed\n * @param {String} type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]\n * @param {Object} value ?? value.value\n * @returns {Object} returns an object with {resource, method}\n */\n\n\nMeetingInfoUtil.getResourceUrl = function (type, value) {\n  var resource = '/' + _constants.LOCI + '/' + _constants.MEETINGINFO;\n  var method = _constants.HTTP_VERBS.GET;\n  var uri = null;\n\n  switch (type) {\n    case _constants._SIP_URI_:\n    case _constants._PERSONAL_ROOM_:\n    case _constants._MEETING_ID_:\n      resource = '/' + _constants.LOCI + '/' + _constants.MEETINGINFO + '/' + value + '?' + _constants.TYPE + '=' + type + '&' + _constants.USE_URI_LOOKUP_FALSE;\n      break;\n\n    case _constants._CONVERSATION_URL_:\n      method = _constants.HTTP_VERBS.PUT;\n      break;\n\n    case _constants._LOCUS_ID_:\n      uri = value + '/' + _constants.MEETINGINFO;\n      method = _constants.HTTP_VERBS.PUT;\n      break;\n\n    case _constants._MEETING_LINK_:\n      resource = '$/' + _constants.LOCI + '/' + _constants.MEETINGINFO + '/' + (0, _btoa2.default)(value) + '?' + _constants.TYPE + '=' + _constants._MEETING_LINK_ + '&' + _constants.USE_URI_LOOKUP_FALSE;\n      break;\n\n    default:\n  }\n\n  return {\n    uri: uri,\n    resource: resource,\n    method: method\n  };\n};\n\nMeetingInfoUtil.getRequestParams = function (resourceOptions, type, value, api) {\n  var requestParams = {\n    method: resourceOptions.method,\n    api: api,\n    resource: resourceOptions.resource\n  };\n\n  if (resourceOptions.method === _constants.HTTP_VERBS.GET) {\n    // for handling URL redirections\n    requestParams.resource = requestParams.resource.concat('&' + _constants.ALTERNATE_REDIRECT_TRUE);\n  } else if (type !== _constants._LOCUS_ID_) {\n    // locus id check is a PUT not sure why\n    requestParams.resource = requestParams.resource.concat('?' + _constants.ALTERNATE_REDIRECT_TRUE);\n    requestParams.body = {\n      value: value,\n      lookupType: type\n    };\n  } else if (type === _constants._LOCUS_ID_) {\n    requestParams = {\n      method: resourceOptions.method,\n      uri: resourceOptions.uri\n    };\n  }\n\n  return requestParams;\n};\n\nexports.default = MeetingInfoUtil;","map":{"version":3,"sources":["util.js"],"names":["MeetingInfoUtil","parsedUrl","url","HTTPS_PROTOCOL","LoggerProxy","hostNameBool","WEBEX_DOT_COM","pathNameBool","MEET","MEET_M","JOIN","clusterId","webex","CONVERSATION_SERVICE","user","userIndex","company","companyIndex","WWW_DOT","sipUri","DIALER_REGEX","isValidNumber","decodedDestination","UUID_REG","_ROOM_","room","destination","_PEOPLE_","people","res","ParameterError","type","from","options","hydraId","_MEETING_LINK_","_SIP_URI_","_CONVERSATION_URL_","convoUrl","CONVERSATIONS","resource","LOCI","MEETINGINFO","method","HTTP_VERBS","uri","_PERSONAL_ROOM_","_MEETING_ID_","TYPE","USE_URI_LOOKUP_FALSE","_LOCUS_ID_","value","requestParams","resourceOptions","api","ALTERNATE_REDIRECT_TRUE","lookupType"],"mappings":"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","sourcesContent":["import url from 'url';\n\nimport btoa from 'btoa';\nimport {\n  deconstructHydraId\n} from '@webex/common';\n\nimport ParameterError from '../common/errors/parameter';\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport {\n  _SIP_URI_,\n  _PERSONAL_ROOM_,\n  _MEETING_ID_,\n  _CONVERSATION_URL_,\n  _LOCUS_ID_,\n  _MEETING_LINK_,\n  _PEOPLE_,\n  _ROOM_,\n  HTTP_VERBS,\n  USE_URI_LOOKUP_FALSE,\n  TYPE,\n  LOCI,\n  MEETINGINFO,\n  ALTERNATE_REDIRECT_TRUE,\n  DIALER_REGEX,\n  WEBEX_DOT_COM,\n  CONVERSATION_SERVICE,\n  WWW_DOT,\n  JOIN,\n  MEET,\n  MEET_M,\n  HTTPS_PROTOCOL,\n  CONVERSATIONS,\n  UUID_REG\n} from '../constants';\n\nconst MeetingInfoUtil = {};\n\nMeetingInfoUtil.getParsedUrl = (link) => {\n  try {\n    let parsedUrl = url.parse(link);\n\n    if (!parsedUrl) {\n      return false;\n    }\n    // hack for links such as <company>.webex.com/meet/<user> without a protocol\n    if (!parsedUrl.protocol) {\n      parsedUrl = url.parse(`${HTTPS_PROTOCOL}${link}`);\n    }\n\n    return parsedUrl;\n  }\n  catch (error) {\n    LoggerProxy.logger.warn(`MeetingInfoUtil->getParsedUrl#unable to parse the URL, error: ${error}`);\n\n    return null;\n  }\n};\n\n/**\n * Helper function to check if a string matches a known meeting link pattern\n * @param {String} value  string to parse and see if it matches a meeting link\n * @returns {Boolean}\n */\nMeetingInfoUtil.isMeetingLink = (value) => {\n  const parsedUrl = MeetingInfoUtil.getParsedUrl(value);\n  const hostNameBool = parsedUrl.hostname && parsedUrl.hostname.includes(WEBEX_DOT_COM);\n  const pathNameBool = parsedUrl.pathname && (parsedUrl.pathname.includes(`/${MEET}`) || parsedUrl.pathname.includes(`/${MEET_M}`) || parsedUrl.pathname.includes(`/${JOIN}`));\n\n  return hostNameBool && pathNameBool;\n};\n\nMeetingInfoUtil.isConversationUrl = (value, webex) => {\n  const clusterId = webex.internal.services.getClusterId(value);\n\n  if (clusterId) {\n    return clusterId.endsWith(CONVERSATION_SERVICE);\n  }\n\n  return false;\n};\n\nMeetingInfoUtil.convertLinkToSip = (value) => {\n  const parsedUrl = MeetingInfoUtil.getParsedUrl(value);\n\n  if (!parsedUrl) {\n    return null;\n  }\n  let user;\n\n  if (parsedUrl.pathname) {\n    const userIndex = parsedUrl.pathname.lastIndexOf('/');\n\n    user = parsedUrl.pathname.substring(userIndex + 1);\n  }\n  if (!user) {\n    return null;\n  }\n  let company;\n\n  if (parsedUrl.hostname) {\n    const companyIndex = parsedUrl.hostname.lastIndexOf(`.${WEBEX_DOT_COM}`);\n\n    company = parsedUrl.hostname.substring(0, companyIndex).replace(WWW_DOT, '');\n  }\n  if (!company) {\n    return null;\n  }\n\n  return `${user}@${company}.${WEBEX_DOT_COM}`;\n};\n\n\nMeetingInfoUtil.isSipUri = (sipString) => {\n  // TODO: lets remove regex from this equation and user URI matchers and such\n  // have not found a great sip uri parser library as of now\n  const sipUri = DIALER_REGEX.SIP_ADDRESS.exec(sipString);\n\n  return sipUri;\n};\n\nMeetingInfoUtil.isPhoneNumber = (phoneNumber) => {\n  const isValidNumber = DIALER_REGEX.PHONE_NUMBER.test(phoneNumber);\n\n  return isValidNumber;\n};\n\nMeetingInfoUtil.getHydraId = (destination) => {\n  const decodedDestination = deconstructHydraId(destination);\n\n  if (decodedDestination && UUID_REG.test(decodedDestination.id)) {\n    if (decodedDestination.type === _ROOM_) {\n      return {room: true, destination: decodedDestination.id};\n    }\n    if (decodedDestination.type === _PEOPLE_) {\n      return {people: true, destination: decodedDestination.id};\n    }\n\n    return {};\n  }\n\n  return {};\n};\n\nMeetingInfoUtil.getSipUriFromHydraPersonId = (destination, webex) => webex.people.get(destination).then((res) => {\n  if (res.emails && res.emails.length) {\n    return res.emails[0];\n  }\n  throw new ParameterError('Hydra Id Lookup was an invalid hydra person id.');\n}).catch((err) => {\n  throw err;\n});\n\nMeetingInfoUtil.generateOptions = async (from) => {\n  const {destination, type, webex} = from;\n\n  if (type) {\n    return {\n      destination,\n      type\n    };\n  }\n  const options = {};\n  const hydraId = MeetingInfoUtil.getHydraId(destination);\n\n  if (MeetingInfoUtil.isMeetingLink(destination)) {\n    options.type = _MEETING_LINK_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isSipUri(destination)) {\n    options.type = _SIP_URI_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isPhoneNumber(destination)) {\n    options.type = _SIP_URI_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isConversationUrl(destination, webex)) {\n    options.type = _CONVERSATION_URL_;\n    options.destination = destination;\n  }\n  else if (hydraId.people) {\n    options.type = _SIP_URI_;\n\n    return MeetingInfoUtil.getSipUriFromHydraPersonId(hydraId.destination, webex).then((res) => {\n      options.destination = res;\n\n      return Promise.resolve(options);\n    });\n  }\n  else if (hydraId.room) {\n    options.type = _CONVERSATION_URL_;\n    await webex.internal.services.waitForCatalog('postauth');\n    const convoUrl = `${webex.internal.services.get('conversation')}/${CONVERSATIONS}/${hydraId.destination}`;\n\n    options.destination = convoUrl;\n  }\n  else {\n    throw new ParameterError('MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.');\n  }\n\n  return Promise.resolve(options);\n};\n\n/**\n * Helper function to build up a correct locus url depending on the value passed\n * @param {String} type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]\n * @param {Object} value ?? value.value\n * @returns {Object} returns an object with {resource, method}\n */\nMeetingInfoUtil.getResourceUrl = (type, value) => {\n  let resource = `/${LOCI}/${MEETINGINFO}`;\n  let method = HTTP_VERBS.GET;\n  let uri = null;\n\n  switch (type) {\n    case _SIP_URI_:\n    case _PERSONAL_ROOM_:\n    case _MEETING_ID_:\n      resource = `/${LOCI}/${MEETINGINFO}/${value}?${TYPE}=${type}&${USE_URI_LOOKUP_FALSE}`;\n      break;\n    case _CONVERSATION_URL_:\n      method = HTTP_VERBS.PUT;\n      break;\n    case _LOCUS_ID_:\n      uri = `${value}/${MEETINGINFO}`;\n      method = HTTP_VERBS.PUT;\n      break;\n    case _MEETING_LINK_:\n      resource = `$/${LOCI}/${MEETINGINFO}/${btoa(value)}?${TYPE}=${_MEETING_LINK_}&${USE_URI_LOOKUP_FALSE}`;\n      break;\n    default:\n  }\n\n  return {\n    uri,\n    resource,\n    method\n  };\n};\n\nMeetingInfoUtil.getRequestParams = (resourceOptions, type, value, api) => {\n  let requestParams = {\n    method: resourceOptions.method,\n    api,\n    resource: resourceOptions.resource\n  };\n\n  if (resourceOptions.method === HTTP_VERBS.GET) {\n    // for handling URL redirections\n    requestParams.resource = requestParams.resource.concat(`&${ALTERNATE_REDIRECT_TRUE}`);\n  }\n  else\n  if (type !== _LOCUS_ID_) {\n    // locus id check is a PUT not sure why\n    requestParams.resource = requestParams.resource.concat(`?${ALTERNATE_REDIRECT_TRUE}`);\n    requestParams.body = {\n      value,\n      lookupType: type\n    };\n  }\n  else if (type === _LOCUS_ID_) {\n    requestParams = {\n      method: resourceOptions.method,\n      uri: resourceOptions.uri\n    };\n  }\n\n  return requestParams;\n};\n\nexport default MeetingInfoUtil;\n"]},"metadata":{},"sourceType":"script"}