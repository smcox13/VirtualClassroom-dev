{"ast":null,"code":"/*$AMPERSAND_VERSION*/\nvar runOnce = require('lodash/once');\n\nvar keys = require('lodash/keys');\n\nvar isEmpty = require('lodash/isEmpty');\n\nvar assign = require('lodash/assign');\n\nvar forEach = require('lodash/forEach');\n\nvar slice = Array.prototype.slice;\n\nvar utils = require('./libs/utils');\n\nvar Events = {\n  // Bind an event to a `callback` function. Passing `\"all\"` will bind\n  // the callback to all events fired.\n  on: function (name, callback, context) {\n    if (!utils.eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n    this._events || (this._events = {});\n    var events = this._events[name] || (this._events[name] = []);\n    events.push({\n      callback: callback,\n      context: context,\n      ctx: context || this\n    });\n    return this;\n  },\n  // Bind an event to only be triggered a single time. After the first time\n  // the callback is invoked, it will be removed.\n  once: function (name, callback, context) {\n    if (!utils.eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\n    var self = this;\n    var once = runOnce(function () {\n      self.off(name, once);\n      callback.apply(this, arguments);\n    });\n    once._callback = callback;\n    return this.on(name, once, context);\n  },\n  // Remove one or many callbacks. If `context` is null, removes all\n  // callbacks with that function. If `callback` is null, removes all\n  // callbacks for the event. If `name` is null, removes all bound\n  // callbacks for all events.\n  off: function (name, callback, context) {\n    var retain, ev, events, names, i, l, j, k;\n    if (!this._events || !utils.eventsApi(this, 'off', name, [callback, context])) return this;\n\n    if (!name && !callback && !context) {\n      this._events = void 0;\n      return this;\n    }\n\n    names = name ? [name] : keys(this._events);\n\n    for (i = 0, l = names.length; i < l; i++) {\n      name = names[i];\n\n      if (events = this._events[name]) {\n        this._events[name] = retain = [];\n\n        if (callback || context) {\n          for (j = 0, k = events.length; j < k; j++) {\n            ev = events[j];\n\n            if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {\n              retain.push(ev);\n            }\n          }\n        }\n\n        if (!retain.length) delete this._events[name];\n      }\n    }\n\n    return this;\n  },\n  // Trigger one or many events, firing all bound callbacks. Callbacks are\n  // passed the same arguments as `trigger` is, apart from the event name\n  // (unless you're listening on `\"all\"`, which will cause your callback to\n  // receive the true name of the event as the first argument).\n  trigger: function (name) {\n    if (!this._events) return this;\n    var args = slice.call(arguments, 1);\n    if (!utils.eventsApi(this, 'trigger', name, args)) return this;\n    var events = this._events[name];\n    var allEvents = this._events.all;\n    if (events) utils.triggerEvents(events, args);\n    if (allEvents) utils.triggerEvents(allEvents, arguments);\n    return this;\n  },\n  // Tell this object to stop listening to either specific events ... or\n  // to every object it's currently listening to.\n  stopListening: function (obj, name, callback) {\n    var listeningTo = this._listeningTo;\n    if (!listeningTo) return this;\n    var remove = !name && !callback;\n    if (!callback && typeof name === 'object') callback = this;\n    if (obj) (listeningTo = {})[obj._listenId] = obj;\n    var self = this;\n    forEach(listeningTo, function (item, id) {\n      item.off(name, callback, self);\n      if (remove || isEmpty(item._events)) delete self._listeningTo[id];\n    });\n    return this;\n  },\n  // extend an object with event capabilities if passed\n  // or just return a new one.\n  createEmitter: function (obj) {\n    return assign(obj || {}, Events);\n  },\n  listenTo: utils.createListenMethod('on'),\n  listenToOnce: utils.createListenMethod('once'),\n  listenToAndRun: function (obj, name, callback) {\n    this.listenTo.apply(this, arguments);\n    if (!callback && typeof name === 'object') callback = this;\n    callback.apply(this);\n    return this;\n  }\n}; // setup aliases\n\nEvents.bind = Events.on;\nEvents.unbind = Events.off;\nEvents.removeListener = Events.off;\nEvents.removeAllListeners = Events.off;\nEvents.emit = Events.trigger;\nmodule.exports = Events;","map":{"version":3,"sources":["/Users/pratison/Work/Cisco/Education/React/education-webex/node_modules/ampersand-events/ampersand-events.js"],"names":["runOnce","require","keys","isEmpty","assign","forEach","slice","Array","prototype","utils","Events","on","name","callback","context","eventsApi","_events","events","push","ctx","once","self","off","apply","arguments","_callback","retain","ev","names","i","l","j","k","length","trigger","args","call","allEvents","all","triggerEvents","stopListening","obj","listeningTo","_listeningTo","remove","_listenId","item","id","createEmitter","listenTo","createListenMethod","listenToOnce","listenToAndRun","bind","unbind","removeListener","removeAllListeners","emit","module","exports"],"mappings":"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","sourcesContent":["/*$AMPERSAND_VERSION*/\nvar runOnce = require('lodash/once');\nvar keys = require('lodash/keys');\nvar isEmpty = require('lodash/isEmpty');\nvar assign = require('lodash/assign');\nvar forEach = require('lodash/forEach');\nvar slice = Array.prototype.slice;\n\nvar utils = require('./libs/utils');\n\nvar Events = {\n    // Bind an event to a `callback` function. Passing `\"all\"` will bind\n    // the callback to all events fired.\n    on: function (name, callback, context) {\n        if (!utils.eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n        this._events || (this._events = {});\n        var events = this._events[name] || (this._events[name] = []);\n        events.push({callback: callback, context: context, ctx: context || this});\n        return this;\n    },\n\n    // Bind an event to only be triggered a single time. After the first time\n    // the callback is invoked, it will be removed.\n    once: function (name, callback, context) {\n        if (!utils.eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\n        var self = this;\n        var once = runOnce(function () {\n            self.off(name, once);\n            callback.apply(this, arguments);\n        });\n        once._callback = callback;\n        return this.on(name, once, context);\n    },\n\n    // Remove one or many callbacks. If `context` is null, removes all\n    // callbacks with that function. If `callback` is null, removes all\n    // callbacks for the event. If `name` is null, removes all bound\n    // callbacks for all events.\n    off: function (name, callback, context) {\n        var retain, ev, events, names, i, l, j, k;\n        if (!this._events || !utils.eventsApi(this, 'off', name, [callback, context])) return this;\n        if (!name && !callback && !context) {\n            this._events = void 0;\n            return this;\n        }\n        names = name ? [name] : keys(this._events);\n        for (i = 0, l = names.length; i < l; i++) {\n            name = names[i];\n            if (events = this._events[name]) {\n                this._events[name] = retain = [];\n                if (callback || context) {\n                    for (j = 0, k = events.length; j < k; j++) {\n                        ev = events[j];\n                        if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||\n                                (context && context !== ev.context)) {\n                            retain.push(ev);\n                        }\n                    }\n                }\n                if (!retain.length) delete this._events[name];\n            }\n        }\n\n        return this;\n    },\n\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\n    // passed the same arguments as `trigger` is, apart from the event name\n    // (unless you're listening on `\"all\"`, which will cause your callback to\n    // receive the true name of the event as the first argument).\n    trigger: function (name) {\n        if (!this._events) return this;\n        var args = slice.call(arguments, 1);\n        if (!utils.eventsApi(this, 'trigger', name, args)) return this;\n        var events = this._events[name];\n        var allEvents = this._events.all;\n        if (events) utils.triggerEvents(events, args);\n        if (allEvents) utils.triggerEvents(allEvents, arguments);\n        return this;\n    },\n\n    // Tell this object to stop listening to either specific events ... or\n    // to every object it's currently listening to.\n    stopListening: function (obj, name, callback) {\n        var listeningTo = this._listeningTo;\n        if (!listeningTo) return this;\n        var remove = !name && !callback;\n        if (!callback && typeof name === 'object') callback = this;\n        if (obj) (listeningTo = {})[obj._listenId] = obj;\n        var self = this;\n        forEach(listeningTo, function (item, id) {\n            item.off(name, callback, self);\n            if (remove || isEmpty(item._events)) delete self._listeningTo[id];\n        });\n        return this;\n    },\n\n    // extend an object with event capabilities if passed\n    // or just return a new one.\n    createEmitter: function (obj) {\n        return assign(obj || {}, Events);\n    },\n\n    listenTo: utils.createListenMethod('on'),\n\n    listenToOnce: utils.createListenMethod('once'),\n\n    listenToAndRun: function (obj, name, callback) {\n        this.listenTo.apply(this, arguments);\n        if (!callback && typeof name === 'object') callback = this;\n        callback.apply(this);\n        return this;\n    }\n};\n\n// setup aliases\nEvents.bind = Events.on;\nEvents.unbind = Events.off;\nEvents.removeListener = Events.off;\nEvents.removeAllListeners = Events.off;\nEvents.emit = Events.trigger;\n\nmodule.exports = Events;\n"]},"metadata":{},"sourceType":"script"}