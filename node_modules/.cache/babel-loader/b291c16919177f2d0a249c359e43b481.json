{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _forEach2 = require('lodash/forEach');\n\nvar _forEach3 = _interopRequireDefault(_forEach2);\n\nvar _find2 = require('lodash/find');\n\nvar _find3 = _interopRequireDefault(_find2);\n\nvar _keys2 = require('lodash/keys');\n\nvar _keys3 = _interopRequireDefault(_keys2);\n\nvar _bowser = require('bowser');\n\nvar _bowser2 = _interopRequireDefault(_bowser);\n\nvar _constants = require('../constants');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar StatsTransformer = {\n  isFF: _bowser2.default.name.toLowerCase() === 'firefox'\n}; // convert the ids from the parsed stats objects into understandable keys\n\nStatsTransformer.simplify = function (stat) {\n  return (0, _find3.default)((0, _keys3.default)(StatsTransformer.isFF ? _constants.DEFAULT_FF_TRANSFORM_REGEX : _constants.DEFAULT_TRANSFORM_REGEX), function (key) {\n    var value = void 0;\n\n    if (StatsTransformer.isFF) {\n      // FF stats are formatted poorly so we have to take what we can get\n      value = _constants.DEFAULT_FF_TRANSFORM_REGEX[key].regex.test('' + stat.type + (stat.kind ? '_' + stat.kind : '') + '_' + stat.id) ? key : false;\n    } else {\n      // no other parameters necessary besides id\n      value = _constants.DEFAULT_TRANSFORM_REGEX[key].regex.test(stat.id) ? key : false;\n    }\n\n    if (value) {\n      // others were included but have a value that exclude them from the list because of duplicates that weren't chosen\n      if (_constants.DEFAULT_TRANSFORM_REGEX[value].decider) {\n        if (stat[_constants.DEFAULT_TRANSFORM_REGEX[value].decider] !== _constants.DEFAULT_TRANSFORM_REGEX[value].selector) {\n          value = false;\n        }\n\n        return value;\n      } // // some types need to check against a type field as well\n\n\n      if (_constants.DEFAULT_TRANSFORM_REGEX[value].profiler) {\n        var mapStatToReadableType = stat[_constants.DEFAULT_TRANSFORM_REGEX[value].profiler.type];\n\n        if (!(mapStatToReadableType && mapStatToReadableType.includes(_constants.DEFAULT_TRANSFORM_REGEX[value].profiler.value) && value.toLowerCase().includes(_constants.DEFAULT_TRANSFORM_REGEX[value].profiler.value))) {\n          value = false;\n          return value;\n        }\n      }\n    }\n\n    return value;\n  });\n}; // parse the RTCStatsReport, extracting only the data we care about\n\n\nStatsTransformer.parse = function (report) {\n  var target = {}; // from the stats object\n  // get the rtc stats report\n\n  if (report && report.forEach && report.size > 0) {\n    report.forEach(function (stat) {\n      // each report has internal data\n      if (stat && stat.type) {\n        // pull only certain types\n        if (_constants.DEFAULT_GET_STATS_FILTER.types.includes(stat.type)) {\n          // insert into the target the statistic mapped to it's statical id\n          target[stat.id] = stat;\n        }\n      }\n    });\n  }\n\n  return target;\n};\n\nStatsTransformer.convert = function (parsed, options) {\n  // supply your own simplification function (rather than id as the key)\n  if (options.simplifyFn) {\n    return options.simplifyFn(parsed);\n  } // else use ours that stores things like rtcOutAudio, rtpInVideo, etc\n\n\n  var target = {};\n  (0, _forEach3.default)(parsed, function (stat) {\n    var key = StatsTransformer.simplify(stat);\n\n    if (key) {\n      target[key] = stat;\n    }\n  });\n  return target;\n}; // transform the RTCStatsReport into a much more readable, processable format\n\n\nStatsTransformer.transform = function (report) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    simplifyFn: undefined\n  };\n  var data = void 0; // first parse it and cut out not necessary data\n\n  var parsed = StatsTransformer.parse(report); // either convert the data or store each stat with it's id mapped as the key to the stat object itself\n\n  if (_constants.DEFAULT_TRANSFORM_REGEX) {\n    data = StatsTransformer.convert(parsed, options);\n  } else {\n    data = parsed;\n  }\n\n  return data;\n};\n\nexports.default = StatsTransformer;","map":{"version":3,"sources":["transformer.js"],"names":["StatsTransformer","isFF","bowser","DEFAULT_FF_TRANSFORM_REGEX","DEFAULT_TRANSFORM_REGEX","value","stat","mapStatToReadableType","target","report","DEFAULT_GET_STATS_FILTER","options","key","simplifyFn","data","parsed"],"mappings":"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","sourcesContent":["import {keys, find, forEach} from 'lodash';\nimport bowser from 'bowser';\n\nimport {DEFAULT_TRANSFORM_REGEX, DEFAULT_FF_TRANSFORM_REGEX, DEFAULT_GET_STATS_FILTER} from '../constants';\n\nconst StatsTransformer = {\n  isFF: bowser.name.toLowerCase() === 'firefox'\n};\n\n// convert the ids from the parsed stats objects into understandable keys\nStatsTransformer.simplify = (stat) => find(keys(StatsTransformer.isFF ? DEFAULT_FF_TRANSFORM_REGEX : DEFAULT_TRANSFORM_REGEX), (key) => {\n  let value;\n\n  if (StatsTransformer.isFF) {\n    // FF stats are formatted poorly so we have to take what we can get\n    value = (DEFAULT_FF_TRANSFORM_REGEX[key].regex.test(`${stat.type}${stat.kind ? `_${stat.kind}` : ''}_${stat.id}`) ? key : false);\n  }\n  else {\n    // no other parameters necessary besides id\n    value = (DEFAULT_TRANSFORM_REGEX[key].regex.test(stat.id) ? key : false);\n  }\n\n  if (value) {\n    // others were included but have a value that exclude them from the list because of duplicates that weren't chosen\n    if (DEFAULT_TRANSFORM_REGEX[value].decider) {\n      if (stat[DEFAULT_TRANSFORM_REGEX[value].decider] !== DEFAULT_TRANSFORM_REGEX[value].selector) {\n        value = false;\n      }\n\n      return value;\n    }\n    // // some types need to check against a type field as well\n    if (DEFAULT_TRANSFORM_REGEX[value].profiler) {\n      const mapStatToReadableType = stat[DEFAULT_TRANSFORM_REGEX[value].profiler.type];\n\n      if (!((mapStatToReadableType && mapStatToReadableType.includes(DEFAULT_TRANSFORM_REGEX[value].profiler.value)) &&\n      (value.toLowerCase().includes(DEFAULT_TRANSFORM_REGEX[value].profiler.value)))) {\n        value = false;\n\n        return value;\n      }\n    }\n  }\n\n  return value;\n});\n\n// parse the RTCStatsReport, extracting only the data we care about\nStatsTransformer.parse = (report) => {\n  const target = {};\n\n  // from the stats object\n  // get the rtc stats report\n  if (report && report.forEach && report.size > 0) {\n    report.forEach((stat) => {\n      // each report has internal data\n      if (stat && stat.type) {\n        // pull only certain types\n        if (DEFAULT_GET_STATS_FILTER.types.includes(stat.type)) {\n          // insert into the target the statistic mapped to it's statical id\n          target[stat.id] = stat;\n        }\n      }\n    });\n  }\n\n  return target;\n};\n\nStatsTransformer.convert = (parsed, options) => {\n  // supply your own simplification function (rather than id as the key)\n  if (options.simplifyFn) {\n    return options.simplifyFn(parsed);\n  }\n  // else use ours that stores things like rtcOutAudio, rtpInVideo, etc\n  const target = {};\n\n  forEach(parsed, (stat) => {\n    const key = StatsTransformer.simplify(stat);\n\n    if (key) {\n      target[key] = stat;\n    }\n  });\n\n  return target;\n};\n\n// transform the RTCStatsReport into a much more readable, processable format\nStatsTransformer.transform = (report, options = {simplifyFn: undefined}) => {\n  let data;\n  // first parse it and cut out not necessary data\n  const parsed = StatsTransformer.parse(report);\n\n  // either convert the data or store each stat with it's id mapped as the key to the stat object itself\n  if (DEFAULT_TRANSFORM_REGEX) {\n    data = StatsTransformer.convert(parsed, options);\n  }\n  else {\n    data = parsed;\n  }\n\n  return data;\n};\nexport default StatsTransformer;\n"]},"metadata":{},"sourceType":"script"}