{"ast":null,"code":"var slice = Array.prototype.slice; // our constructor\n\nfunction KeyTreeStore(options) {\n  options = options || {};\n\n  if (typeof options !== 'object') {\n    throw new TypeError('Options must be an object');\n  }\n\n  var DEFAULT_SEPARATOR = '.';\n  this.storage = {};\n  this.separator = options.separator || DEFAULT_SEPARATOR;\n} // add an object to the store\n\n\nKeyTreeStore.prototype.add = function (keypath, obj) {\n  var arr = this.storage[keypath] || (this.storage[keypath] = []);\n  arr.push(obj);\n}; // remove an object\n\n\nKeyTreeStore.prototype.remove = function (obj) {\n  var path, arr;\n\n  for (path in this.storage) {\n    arr = this.storage[path];\n    arr.some(function (item, index) {\n      if (item === obj) {\n        arr.splice(index, 1);\n        return true;\n      }\n    });\n  }\n}; // get array of all all relevant functions, without keys\n\n\nKeyTreeStore.prototype.get = function (keypath) {\n  var res = [];\n  var key;\n\n  for (key in this.storage) {\n    if (!keypath || keypath === key || key.indexOf(keypath + this.separator) === 0) {\n      res = res.concat(this.storage[key]);\n    }\n  }\n\n  return res;\n}; // get all results that match keypath but still grouped by key\n\n\nKeyTreeStore.prototype.getGrouped = function (keypath) {\n  var res = {};\n  var key;\n\n  for (key in this.storage) {\n    if (!keypath || keypath === key || key.indexOf(keypath + this.separator) === 0) {\n      res[key] = slice.call(this.storage[key]);\n    }\n  }\n\n  return res;\n}; // get all results that match keypath but still grouped by key\n\n\nKeyTreeStore.prototype.getAll = function (keypath) {\n  var res = {};\n  var key;\n\n  for (key in this.storage) {\n    if (keypath === key || key.indexOf(keypath + this.separator) === 0) {\n      res[key] = slice.call(this.storage[key]);\n    }\n  }\n\n  return res;\n}; // run all matches with optional context\n\n\nKeyTreeStore.prototype.run = function (keypath, context) {\n  var args = slice.call(arguments, 2);\n  this.get(keypath).forEach(function (fn) {\n    fn.apply(context || this, args);\n  });\n};\n\nmodule.exports = KeyTreeStore;","map":{"version":3,"sources":["/Users/pratison/Work/Cisco/Education/React/education-webex/node_modules/key-tree-store/key-tree-store.js"],"names":["slice","Array","prototype","KeyTreeStore","options","TypeError","DEFAULT_SEPARATOR","storage","separator","add","keypath","obj","arr","push","remove","path","some","item","index","splice","get","res","key","indexOf","concat","getGrouped","call","getAll","run","context","args","arguments","forEach","fn","apply","module","exports"],"mappings":"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","sourcesContent":["var slice = Array.prototype.slice;\n\n// our constructor\nfunction KeyTreeStore(options) {\n    options = options || {};\n    if (typeof options !== 'object') {\n        throw new TypeError('Options must be an object');\n    }\n    var DEFAULT_SEPARATOR = '.';\n\n    this.storage = {};\n    this.separator = options.separator || DEFAULT_SEPARATOR;\n}\n\n// add an object to the store\nKeyTreeStore.prototype.add = function (keypath, obj) {\n    var arr = this.storage[keypath] || (this.storage[keypath] = []);\n    arr.push(obj);\n};\n\n// remove an object\nKeyTreeStore.prototype.remove = function (obj) {\n    var path, arr;\n    for (path in this.storage) {\n        arr = this.storage[path];\n        arr.some(function (item, index) {\n            if (item === obj) {\n                arr.splice(index, 1);\n                return true;\n            }\n        });\n    }\n};\n\n// get array of all all relevant functions, without keys\nKeyTreeStore.prototype.get = function (keypath) {\n    var res = [];\n    var key;\n\n    for (key in this.storage) {\n        if (!keypath || keypath === key || key.indexOf(keypath + this.separator) === 0) {\n            res = res.concat(this.storage[key]);\n        }\n    }\n\n    return res;\n};\n\n// get all results that match keypath but still grouped by key\nKeyTreeStore.prototype.getGrouped = function (keypath) {\n    var res = {};\n    var key;\n\n    for (key in this.storage) {\n        if (!keypath || keypath === key || key.indexOf(keypath + this.separator) === 0) {\n            res[key] = slice.call(this.storage[key]);\n        }\n    }\n\n    return res;\n};\n\n// get all results that match keypath but still grouped by key\nKeyTreeStore.prototype.getAll = function (keypath) {\n    var res = {};\n    var key;\n\n    for (key in this.storage) {\n        if (keypath === key || key.indexOf(keypath + this.separator) === 0) {\n            res[key] = slice.call(this.storage[key]);\n        }\n    }\n\n    return res;\n};\n\n// run all matches with optional context\nKeyTreeStore.prototype.run = function (keypath, context) {\n    var args = slice.call(arguments, 2);\n    this.get(keypath).forEach(function (fn) {\n        fn.apply(context || this, args);\n    });\n};\n\nmodule.exports = KeyTreeStore;\n"]},"metadata":{},"sourceType":"script"}