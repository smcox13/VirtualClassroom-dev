{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _loggerProxy = require('../common/logs/logger-proxy');\n\nvar _loggerProxy2 = _interopRequireDefault(_loggerProxy);\n\nvar _peerConnectionManager = require('../peer-connection-manager');\n\nvar _peerConnectionManager2 = _interopRequireDefault(_peerConnectionManager);\n\nvar _util = require('../media/util');\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _constants = require('../constants');\n\nvar _request = require('./request');\n\nvar _request2 = _interopRequireDefault(_request);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * @class Reachability\n * @export\n */\n\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* globals window */\n\n\nvar Reachability = function (_StatelessWebexPlugin) {\n  (0, _inherits3.default)(Reachability, _StatelessWebexPlugin);\n\n  function Reachability(attrs, options) {\n    (0, _classCallCheck3.default)(this, Reachability);\n    /**\n     * internal request object for the server\n     * @instance\n     * @type {Array}\n     * @private\n     * @memberof Reachability\n     */\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Reachability.__proto__ || (0, _getPrototypeOf2.default)(Reachability)).call(this, {}, options));\n\n    _this.namespace = _constants.MEETINGS;\n\n    _this.setup = function () {\n      _this.processedClusterResults = [];\n      _this.peerConnectionMap = {};\n    };\n\n    _this.gatherReachability = function () {\n      _this.setup(); // Reset reachability result to empty to ensure no stale data\n\n\n      try {\n        window.localStorage.setItem(_constants.REACHABILITY.localStorage, (0, _stringify2.default)({})); // Get clusters from Orpheus\n\n        return _this.reachabilityRequest.getClusters().then(function (clusters) {\n          return (// Perform Reachability Check\n            _this.performReachabilityCheck(clusters).then(function (response) {\n              window.localStorage.setItem(_constants.REACHABILITY.localStorage, (0, _stringify2.default)(response));\n              return response;\n            })\n          );\n        }).catch(function (error) {\n          _loggerProxy2.default.logger.error('Reachability->gatherReachability#Error in calling getClusters(): ' + error);\n\n          return {};\n        });\n      } catch (error) {\n        _loggerProxy2.default.logger.error('Reachability->gatherReachability#Error in accessing LocalStorage: ' + error);\n\n        return {};\n      }\n    };\n\n    _this.performReachabilityCheck = function (clusterList) {\n      if (!clusterList || !clusterList.length) {\n        return _promise2.default.resolve({});\n      }\n\n      var localSDPList = [];\n      return new _promise2.default(function (resolve) {\n        _this.getLocalSDPForClusters(clusterList).then(function (localSDPData) {\n          if (!localSDPData || !(0, _keys2.default)(localSDPData).length || !localSDPData.localSDPList || !localSDPData.peerConnection) {\n            // TODO: handle the error condition properly and try retry\n            _loggerProxy2.default.logger.info('Reachability->performReachabilityCheck#Local SDP is empty or has missing elements..returning');\n\n            resolve({});\n          }\n\n          _this.peerConnectionMap = localSDPData.peerConnection;\n          localSDPList = localSDPData.localSDPList;\n\n          _this.setRemoteOfferForEachCluster(localSDPList).then(function (response) {\n            resolve(response);\n          });\n        }).catch(function (error) {\n          _loggerProxy2.default.logger.error('Reachability->performReachabilityCheck#Error in getLocalSDPForClusters: ' + error);\n\n          resolve({});\n        });\n      });\n    };\n\n    _this.setRemoteOfferForEachCluster = function (localSDPList) {\n      var iceResult = {};\n      return new _promise2.default(function (resolve) {\n        _this.reachabilityRequest.remoteSDPForClusters(localSDPList).then(function (remoteSDPResponse) {\n          var remoteSDPList = remoteSDPResponse.answers;\n\n          if (!remoteSDPList || !remoteSDPList.length) {\n            _loggerProxy2.default.logger.info('Reachability->setRemoteOfferForEachCluster#Remote SDP is empty.');\n\n            _this.cleanUpPeerConnections(_this.peerConnectionMap);\n\n            resolve({});\n          }\n\n          remoteSDPList.forEach(function (remoteSdp) {\n            var jsonObj = remoteSdp;\n            var clusterId = jsonObj.clusterId;\n\n            if (jsonObj && jsonObj.sdp) {\n              var pc = _this.peerConnectionMap[clusterId];\n\n              _this.setIceCallBackHandlers(pc).then(function (iceStatsResult) {\n                iceStatsResult.clusterId = clusterId;\n\n                _this.processedClusterResults.push(iceStatsResult.clusterId);\n\n                iceResult[iceStatsResult.clusterId] = {\n                  start: iceStatsResult.iceStats.start,\n                  stop: iceStatsResult.iceStats.stop\n                };\n\n                if (_this.processedClusterResults.length === remoteSDPList.length) {\n                  var reachabilityResult = _this.parseIceResultToReachabilityResult(iceResult);\n\n                  _loggerProxy2.default.logger.info('Reachability->setRemoteOfferForEachCluster#Returning reachability result' + (0, _stringify2.default)(reachabilityResult));\n\n                  resolve(reachabilityResult);\n                }\n              }).catch(function (error) {\n                _loggerProxy2.default.logger.error('Reachability->setRemoteOfferForEachCluster#Error in setIceCallBackHandlers(): ' + error);\n\n                _this.cleanUpPeerConnections(_this.peerConnectionMap);\n\n                resolve({});\n              });\n\n              _peerConnectionManager2.default.setRemoteSessionDetails(pc, _constants.ANSWER, jsonObj.sdp);\n            } else {\n              _loggerProxy2.default.logger.error('Reachability->setRemoteOfferForEachCluster# Error in getting remote sdp.');\n\n              _this.processedClusterResults.push(clusterId);\n\n              if (_this.processedClusterResults.length === remoteSDPList.length) {\n                _this.cleanUpPeerConnections(_this.peerConnectionMap);\n\n                resolve({});\n              }\n            }\n          });\n        }).catch(function (error) {\n          _loggerProxy2.default.logger.error('Reachability->setRemoteOfferForEachCluster#Error in remoteSDPForClusters!:' + error);\n\n          _this.cleanUpPeerConnections(_this.peerConnectionMap);\n\n          resolve({});\n        });\n      });\n    };\n\n    _this.getLocalSDPForClusters = function (clusterList) {\n      var localSDPData = {};\n      var localSDPList = [];\n      var peerConnectionMap = {};\n      return new _promise2.default(function (resolve, reject) {\n        clusterList.forEach(function (cluster) {\n          var clusterId = cluster;\n\n          _peerConnectionManager2.default.createOffer(_util2.default.createPeerConnection()).then(function (peerConnection) {\n            peerConnectionMap[clusterId] = peerConnection;\n            var localSDP = {\n              sdp: peerConnection.sdp,\n              clusterId: clusterId\n            };\n            localSDPList.push(localSDP);\n\n            if (localSDPList.length === clusterList.length) {\n              localSDPData.peerConnection = peerConnectionMap;\n              localSDPData.localSDPList = localSDPList;\n              resolve(localSDPData);\n            }\n          }).catch(function (error) {\n            _loggerProxy2.default.logger.error('Reachability->getLocalSDPForClusters#Error in getLocalSDP : ' + error);\n\n            reject(error);\n          });\n        });\n      });\n    };\n\n    _this.parseIceResultToReachabilityResult = function (iceResult) {\n      if (!iceResult || !(0, _keys2.default)(iceResult).length) {\n        return {};\n      }\n\n      var result = {};\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(iceResult)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var clusterId = _step.value;\n          var reachability = {};\n\n          if (iceResult[clusterId].start > 0 && iceResult[clusterId].stop > 0) {\n            var latency = iceResult[clusterId].stop - iceResult[clusterId].start;\n            reachability = {\n              reachable: true,\n              latencyInMilliseconds: latency\n            };\n          } else {\n            reachability = {\n              reachable: false\n            };\n          }\n\n          result[clusterId] = {\n            udp: reachability\n          };\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return result;\n    };\n\n    _this.cleanUpPeerConnections = function (peerConnectionMap) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(peerConnectionMap)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var key = _step2.value;\n          var pc = peerConnectionMap[key];\n\n          if (pc) {\n            _loggerProxy2.default.logger.info('Reachability->cleanUpPeerConnections#Cleaning up peer connection created for cluster : ' + key);\n\n            pc.close();\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    };\n\n    _this.setIceCallBackHandlers = function (pc) {\n      var timeout = null;\n      var iceStats = {\n        start: 0,\n        stop: 0\n      };\n      return new _promise2.default(function (resolve) {\n        function iceComplete(isSuccessful, timeout, iceStats) {\n          if (isSuccessful) {\n            if (timeout) {\n              window.clearTimeout(timeout);\n              timeout = undefined;\n            }\n          }\n\n          pc.close();\n          resolve({\n            iceStats: iceStats\n          });\n        }\n\n        timeout = window.setTimeout(function () {\n          _loggerProxy2.default.logger.warn('Reachability->iceCallBackHandler#' + _this.clusterId + ' ice handler timed out.');\n\n          iceComplete(false, timeout, iceStats);\n        }, 5000);\n\n        pc.oniceconnectionstatechange = function () {\n          if (pc) {\n            if (pc.iceConnectionState === _constants.ICE_STATE.CHECKING) {\n              iceStats.start = Date.now();\n            }\n\n            if (pc.iceConnectionState === _constants.ICE_STATE.CONNECTED) {\n              iceStats.stop = Date.now();\n              iceComplete(true, timeout, iceStats);\n            }\n\n            if (pc.iceConnectionState === _constants.ICE_STATE.FAILED) {\n              iceComplete(false, timeout, iceStats);\n            }\n          }\n        };\n      });\n    };\n\n    _this.getClusters = function () {\n      return _this.reachabilityRequest.getClusters();\n    };\n\n    _this.reachabilityRequest = new _request2.default({}, options);\n    return _this;\n  }\n  /**\n   * utility function\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n\n  /**\n   * fetches reachability data\n   * @returns {Object} reachability data\n   * @public\n   * @memberof Reachability\n   */\n\n  /**\n   * fetches reachability data\n   * @param {object} clusterList\n   * @returns {object} reachability check results\n   * @private\n   * @memberof Reachability\n   */\n\n  /**\n   * sets remote offer for each clusters\n   * @param {object} localSDPList local SDP generated\n   * @returns {object} reachability check results\n   * @private\n   * @memberof Reachability\n   */\n\n  /**\n   * creates offer and generates localSDP\n   * @param {object} clusterList cluster List\n   * @returns {object} localSDPData\n   * @private\n   * @memberof Reachability\n   */\n\n  /**\n   * Calculates time to establish connection\n   * @param {object} iceResult iceResults\n   * @returns {object} result\n   * @private\n   * @memberof Reachability\n   */\n\n  /**\n   * cleans all the peerconnection\n   * @param {object} peerConnectionMap peerconnectionList\n   * @returns {object} localSDPData\n   * @private\n   * @memberof Reachability\n   */\n\n  /**\n   * sets the success callback for peerconnection\n   * @param {object} pc peerconnection\n   * @returns {object} iceState\n   * @private\n   * @memberof Reachability\n   */\n\n  /**\n   * proxy to the server request for clusters\n   * @returns {Promise}\n   * @private\n   * @memberof Reachability\n   */\n\n\n  return Reachability;\n}(_webexCore.StatelessWebexPlugin);\n\nexports.default = Reachability;","map":{"version":3,"sources":["index.js"],"names":["Reachability","StatelessWebexPlugin","namespace","MEETINGS","ReachabilityRequest","window","REACHABILITY","LoggerProxy","clusterList","localSDPList","localSDPData","resolve","iceResult","remoteSDPList","remoteSDPResponse","jsonObj","clusterId","pc","iceStatsResult","start","stop","reachabilityResult","peerConnectionManager","ANSWER","peerConnectionMap","MediaUtil","localSDP","sdp","peerConnection","reject","result","reachability","latency","reachable","latencyInMilliseconds","udp","key","timeout","iceStats","iceComplete","ICE_STATE","Date"],"mappings":"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","sourcesContent":["\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* globals window */\nimport {StatelessWebexPlugin} from '@webex/webex-core';\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport peerConnectionManager from '../peer-connection-manager';\nimport MediaUtil from '../media/util';\nimport {ICE_STATE, MEETINGS, REACHABILITY, ANSWER} from '../constants';\n\nimport ReachabilityRequest from './request';\n\n/**\n * @class Reachability\n * @export\n */\nexport default class Reachability extends StatelessWebexPlugin {\n  namespace = MEETINGS;\n\n  constructor(attrs, options) {\n    super({}, options);\n    /**\n     * internal request object for the server\n     * @instance\n     * @type {Array}\n     * @private\n     * @memberof Reachability\n     */\n    this.reachabilityRequest = new ReachabilityRequest({}, options);\n  }\n\n  /**\n   * utility function\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  setup = () => {\n    this.processedClusterResults = [];\n    this.peerConnectionMap = {};\n  }\n\n  /**\n   * fetches reachability data\n   * @returns {Object} reachability data\n   * @public\n   * @memberof Reachability\n   */\n  gatherReachability = () => {\n    this.setup();\n    // Reset reachability result to empty to ensure no stale data\n    try {\n      window.localStorage.setItem(REACHABILITY.localStorage, JSON.stringify({}));\n\n      // Get clusters from Orpheus\n      return this.reachabilityRequest.getClusters()\n        .then((clusters) =>\n          // Perform Reachability Check\n          this.performReachabilityCheck(clusters)\n            .then((response) => {\n              window.localStorage.setItem(REACHABILITY.localStorage, JSON.stringify(response));\n\n              return response;\n            }))\n        .catch((error) => {\n          LoggerProxy.logger.error(`Reachability->gatherReachability#Error in calling getClusters(): ${error}`);\n\n          return {};\n        });\n    }\n    catch (error) {\n      LoggerProxy.logger.error(`Reachability->gatherReachability#Error in accessing LocalStorage: ${error}`);\n\n      return {};\n    }\n  };\n\n  /**\n   * fetches reachability data\n   * @param {object} clusterList\n   * @returns {object} reachability check results\n   * @private\n   * @memberof Reachability\n   */\n  performReachabilityCheck = (clusterList) => {\n    if (!clusterList || !clusterList.length) {\n      return Promise.resolve({});\n    }\n\n    let localSDPList = [];\n\n    return new Promise(((resolve) => {\n      this.getLocalSDPForClusters(clusterList)\n        .then((localSDPData) => {\n          if (!localSDPData || !Object.keys(localSDPData).length || !localSDPData.localSDPList || !localSDPData.peerConnection) {\n            // TODO: handle the error condition properly and try retry\n            LoggerProxy.logger.info('Reachability->performReachabilityCheck#Local SDP is empty or has missing elements..returning');\n            resolve({});\n          }\n\n          this.peerConnectionMap = localSDPData.peerConnection;\n          ({localSDPList} = localSDPData);\n          this.setRemoteOfferForEachCluster(localSDPList)\n            .then((response) => {\n              resolve(response);\n            });\n        })\n        .catch((error) => {\n          LoggerProxy.logger.error(`Reachability->performReachabilityCheck#Error in getLocalSDPForClusters: ${error}`);\n          resolve({});\n        });\n    }));\n  };\n\n  /**\n   * sets remote offer for each clusters\n   * @param {object} localSDPList local SDP generated\n   * @returns {object} reachability check results\n   * @private\n   * @memberof Reachability\n   */\n  setRemoteOfferForEachCluster = (localSDPList) => {\n    const iceResult = {};\n\n    return new Promise((resolve) => {\n      this.reachabilityRequest.remoteSDPForClusters(localSDPList)\n        .then((remoteSDPResponse) => {\n          const remoteSDPList = remoteSDPResponse.answers;\n\n          if (!remoteSDPList || !remoteSDPList.length) {\n            LoggerProxy.logger.info('Reachability->setRemoteOfferForEachCluster#Remote SDP is empty.');\n            this.cleanUpPeerConnections(this.peerConnectionMap);\n            resolve({});\n          }\n          remoteSDPList.forEach((remoteSdp) => {\n            const jsonObj = remoteSdp;\n            const {clusterId} = jsonObj;\n\n            if (jsonObj && jsonObj.sdp) {\n              const pc = this.peerConnectionMap[clusterId];\n\n              this.setIceCallBackHandlers(pc)\n                .then((iceStatsResult) => {\n                  iceStatsResult.clusterId = clusterId;\n                  this.processedClusterResults.push(iceStatsResult.clusterId);\n                  iceResult[iceStatsResult.clusterId] = {\n                    start: iceStatsResult.iceStats.start,\n                    stop: iceStatsResult.iceStats.stop\n                  };\n                  if (this.processedClusterResults.length === remoteSDPList.length) {\n                    const reachabilityResult = this.parseIceResultToReachabilityResult(iceResult);\n\n                    LoggerProxy.logger.info(`Reachability->setRemoteOfferForEachCluster#Returning reachability result${JSON.stringify(reachabilityResult)}`);\n                    resolve(reachabilityResult);\n                  }\n                })\n                .catch((error) => {\n                  LoggerProxy.logger.error(`Reachability->setRemoteOfferForEachCluster#Error in setIceCallBackHandlers(): ${error}`);\n                  this.cleanUpPeerConnections(this.peerConnectionMap);\n                  resolve({});\n                });\n              peerConnectionManager.setRemoteSessionDetails(pc, ANSWER, jsonObj.sdp);\n            }\n            else {\n              LoggerProxy.logger.error('Reachability->setRemoteOfferForEachCluster# Error in getting remote sdp.');\n              this.processedClusterResults.push(clusterId);\n              if (this.processedClusterResults.length === remoteSDPList.length) {\n                this.cleanUpPeerConnections(this.peerConnectionMap);\n                resolve({});\n              }\n            }\n          });\n        })\n        .catch((error) => {\n          LoggerProxy.logger.error(`Reachability->setRemoteOfferForEachCluster#Error in remoteSDPForClusters!:${error}`);\n          this.cleanUpPeerConnections(this.peerConnectionMap);\n          resolve({});\n        });\n    });\n  }\n\n  /**\n   * creates offer and generates localSDP\n   * @param {object} clusterList cluster List\n   * @returns {object} localSDPData\n   * @private\n   * @memberof Reachability\n   */\n  getLocalSDPForClusters = (clusterList) => {\n    const localSDPData = {};\n    const localSDPList = [];\n    const peerConnectionMap = {};\n\n    return new Promise(((resolve, reject) => {\n      clusterList.forEach((cluster) => {\n        const clusterId = cluster;\n\n        peerConnectionManager.createOffer(MediaUtil.createPeerConnection())\n          .then((peerConnection) => {\n            peerConnectionMap[clusterId] = peerConnection;\n\n            const localSDP = {\n              sdp: peerConnection.sdp,\n              clusterId\n            };\n\n            localSDPList.push(localSDP);\n\n            if (localSDPList.length === clusterList.length) {\n              localSDPData.peerConnection = peerConnectionMap;\n              localSDPData.localSDPList = localSDPList;\n              resolve(localSDPData);\n            }\n          })\n          .catch((error) => {\n            LoggerProxy.logger.error(`Reachability->getLocalSDPForClusters#Error in getLocalSDP : ${error}`);\n            reject(error);\n          });\n      });\n    }));\n  };\n\n  /**\n   * Calculates time to establish connection\n   * @param {object} iceResult iceResults\n   * @returns {object} result\n   * @private\n   * @memberof Reachability\n   */\n  parseIceResultToReachabilityResult = (iceResult) => {\n    if (!iceResult || !Object.keys(iceResult).length) {\n      return {};\n    }\n    const result = {};\n\n    for (const clusterId of Object.keys(iceResult)) {\n      let reachability = {};\n\n      if (iceResult[clusterId].start > 0 && iceResult[clusterId].stop > 0) {\n        const latency = iceResult[clusterId].stop - iceResult[clusterId].start;\n\n        reachability = {\n          reachable: true,\n          latencyInMilliseconds: latency\n        };\n      }\n      else {\n        reachability = {reachable: false};\n      }\n      result[clusterId] = {udp: reachability};\n    }\n\n    return result;\n  };\n\n  /**\n   * cleans all the peerconnection\n   * @param {object} peerConnectionMap peerconnectionList\n   * @returns {object} localSDPData\n   * @private\n   * @memberof Reachability\n   */\n  cleanUpPeerConnections = (peerConnectionMap) => {\n    for (const key of Object.keys(peerConnectionMap)) {\n      const pc = peerConnectionMap[key];\n\n      if (pc) {\n        LoggerProxy.logger.info(`Reachability->cleanUpPeerConnections#Cleaning up peer connection created for cluster : ${key}`);\n        pc.close();\n      }\n    }\n  };\n\n  /**\n   * sets the success callback for peerconnection\n   * @param {object} pc peerconnection\n   * @returns {object} iceState\n   * @private\n   * @memberof Reachability\n   */\n  setIceCallBackHandlers = (pc) => {\n    let timeout = null;\n    const iceStats = {start: 0, stop: 0};\n\n    return new Promise(((resolve) => {\n      function iceComplete(isSuccessful, timeout, iceStats) {\n        if (isSuccessful) {\n          if (timeout) {\n            window.clearTimeout(timeout);\n            timeout = undefined;\n          }\n        }\n        pc.close();\n        resolve({iceStats});\n      }\n\n      timeout = window.setTimeout(() => {\n        LoggerProxy.logger.warn(`Reachability->iceCallBackHandler#${this.clusterId} ice handler timed out.`);\n        iceComplete(false, timeout, iceStats);\n      }, 5000);\n\n      pc.oniceconnectionstatechange = () => {\n        if (pc) {\n          if (pc.iceConnectionState === ICE_STATE.CHECKING) {\n            iceStats.start = Date.now();\n          }\n          if (pc.iceConnectionState === ICE_STATE.CONNECTED) {\n            iceStats.stop = Date.now();\n            iceComplete(true, timeout, iceStats);\n          }\n          if (pc.iceConnectionState === ICE_STATE.FAILED) {\n            iceComplete(false, timeout, iceStats);\n          }\n        }\n      };\n    }));\n  };\n\n  /**\n   * proxy to the server request for clusters\n   * @returns {Promise}\n   * @private\n   * @memberof Reachability\n   */\n  getClusters = () => this.reachabilityRequest.getClusters()\n}\n"]},"metadata":{},"sourceType":"script"}