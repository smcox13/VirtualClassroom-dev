{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _min2 = require('lodash/min');\n\nvar _min3 = _interopRequireDefault(_min2);\n\nvar _utils = require('../locus-info/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _constants = require('../constants');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar Parser = {}; // https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Delta-Events\n\nParser.updateWithDeltaLocus = function (deltaLocus, meeting) {\n  if (!(deltaLocus.sequence && deltaLocus.sequence.rangeStart <= deltaLocus.sequence.rangeEnd && deltaLocus.sequence.rangeEnd <= (0, _min3.default)(deltaLocus.sequence.entries))) {\n    return null;\n  } // Its a new meeting and has incomplete information\n\n\n  if (!meeting.locusInfo.baseSequence) {\n    return meeting.meetingRequest.getFullLocus({\n      desync: true,\n      locusUrl: meeting.locusUrl\n    }).then(function (res) {\n      if (res && res.body) {\n        res.body.baseSequence = deltaLocus.baseSequence; // TODO: verify baseSequence age and update as necessary\n\n        meeting.locusInfo.onFullLocus(res.body);\n      } // Sending EQ if there is an error as next request will fixe it\n\n\n      return _constants.DELTAEVENT.EQ;\n    });\n  } // THIS IS A NEW MEETING OBJECT\n  // // If meeting has no sequence, it means just initialized and will apply whatever in locus DTO\n  // if (isNewMeeting || !this.locus.sequence) {\n  //   meeting._updateWithDeltaLocus(deltaLocus, emitter);\n  //   meeting.locusDesync = false;\n  //   meeting.needToGetFullLocus = false;\n  //   return DELTAEVENT.GT;\n  // }\n\n\n  if (!deltaLocus.sequence) {} // TODO: force update\n  // TODO: If this was the first event, the client will not have a syncURL\n  // in its working copy to do a GET on. In this case clients should do a GET on locusUrl contained in the DTO\n\n\n  var res = void 0;\n  var resBase = void 0;\n  res = _utils2.default.compareLocus(deltaLocus.sequence, meeting.locusInfo.sequence); // In-coming locus is greater than working copy, need to compare with base if there\n  // is base sequence except the first delta locus event\n\n  if (res === _constants.DELTAEVENT.GT && deltaLocus.baseSequence && meeting.locusInfo.syncUrl) {\n    resBase = _utils2.default.compareLocus(deltaLocus.baseSequence, meeting.locusInfo.sequence);\n\n    if (resBase === _constants.DELTAEVENT.LT || resBase === _constants.DELTAEVENT.CF) {\n      res = _constants.DELTAEVENT.CF;\n    }\n  } // Special case for OBTP with meeting size equal or over 5. Locus might change this later\n  // This is a temporary fix. I will find a better solution later.\n\n\n  if (!deltaLocus.baseSequence && res === _constants.DELTAEVENT.EQ && deltaLocus.fullState.state === _constants.LOCUS.STATE.INITIALIZING && deltaLocus.sequence.rangeStart === 0 && deltaLocus.sequence.rangeEnd === 0 && deltaLocus.sequence.entries.length === 0) {\n    res = _constants.DELTAEVENT.GT;\n  }\n\n  switch (res) {\n    case _constants.DELTAEVENT.LT:\n    case _constants.DELTAEVENT.EQ:\n      meeting.locusDesync = false;\n      meeting.needToGetFullLocus = false;\n      break;\n\n    case _constants.DELTAEVENT.CF:\n      _utils2.default.generateSyncDebugFlag(meeting, deltaLocus);\n\n      if (meeting.locusDesync) {\n        meeting.meetingRequest.getFullLocus({\n          desync: true,\n          locusUrl: meeting.locusUrl\n        }).then(function (res) {\n          meeting.locusInfo.onFullLocus(res.body);\n        });\n      } else {\n        meeting.locusDesync = true;\n        Parser.syncMeeting(meeting, deltaLocus);\n      }\n\n      break;\n\n    case _constants.DELTAEVENT.GT:\n      meeting.locusInfo.onDeltaLocus(deltaLocus); // Turn off desync in case this delta locus comes from a sync request\n\n      meeting.locusDesync = false;\n      meeting.needToGetFullLocus = false;\n      break;\n\n    default:\n  }\n\n  return res;\n};\n\nParser.syncMeeting = function (meeting, deltaLocus) {\n  if (meeting && meeting.locusInfo && meeting.locusInfo.syncUrl && meeting.locusInfo.fullState && meeting.locusInfo.fullState.state !== _constants.LOCUS.STATE.INACTIVE) {\n    // found that the locus syncs were happening even after 4 hrs of meeting\n    // completion, resulting in 403 errors. This check ensures we call\n    // syncing only if the locus state is not INACTIVE.\n    meeting.meetingRequest.syncMeeting({\n      syncUrl: deltaLocus.syncUrl,\n      desync: meeting.desync\n    }).then(function (res) {\n      meeting.locusInfo.onDeltaLocus(res.body);\n    });\n  }\n};\n\nexports.default = Parser;","map":{"version":3,"sources":["parser.js"],"names":["Parser","deltaLocus","meeting","desync","locusUrl","res","DELTAEVENT","resBase","LocusUtil","LOCUS","syncUrl"],"mappings":"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","sourcesContent":["import {min} from 'lodash';\n\nimport LocusUtil from '../locus-info/utils';\nimport {DELTAEVENT, LOCUS} from '../constants';\n\nconst Parser = {};\n\n// https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Delta-Events\nParser.updateWithDeltaLocus = (deltaLocus, meeting) => {\n  if (!(deltaLocus.sequence && (deltaLocus.sequence.rangeStart <= deltaLocus.sequence.rangeEnd) && (deltaLocus.sequence.rangeEnd <= min(deltaLocus.sequence.entries)))) {\n    return null;\n  }\n\n  // Its a new meeting and has incomplete information\n  if (!meeting.locusInfo.baseSequence) {\n    return meeting.meetingRequest.getFullLocus({\n      desync: true,\n      locusUrl: meeting.locusUrl\n    }).then((res) => {\n      if (res && res.body) {\n        res.body.baseSequence = deltaLocus.baseSequence; // TODO: verify baseSequence age and update as necessary\n        meeting.locusInfo.onFullLocus(res.body);\n      }\n\n      // Sending EQ if there is an error as next request will fixe it\n      return DELTAEVENT.EQ;\n    });\n  }\n\n  // THIS IS A NEW MEETING OBJECT\n  // // If meeting has no sequence, it means just initialized and will apply whatever in locus DTO\n  // if (isNewMeeting || !this.locus.sequence) {\n  //   meeting._updateWithDeltaLocus(deltaLocus, emitter);\n  //   meeting.locusDesync = false;\n  //   meeting.needToGetFullLocus = false;\n  //   return DELTAEVENT.GT;\n  // }\n\n  if (!deltaLocus.sequence) {\n    // TODO: force update\n  }\n\n  // TODO: If this was the first event, the client will not have a syncURL\n  // in its working copy to do a GET on. In this case clients should do a GET on locusUrl contained in the DTO\n\n  let res;\n  let resBase;\n\n  res = LocusUtil.compareLocus(deltaLocus.sequence, meeting.locusInfo.sequence);\n  // In-coming locus is greater than working copy, need to compare with base if there\n  // is base sequence except the first delta locus event\n  if (res === DELTAEVENT.GT && deltaLocus.baseSequence && meeting.locusInfo.syncUrl) {\n    resBase = LocusUtil.compareLocus(deltaLocus.baseSequence, meeting.locusInfo.sequence);\n    if (resBase === DELTAEVENT.LT || resBase === DELTAEVENT.CF) {\n      res = DELTAEVENT.CF;\n    }\n  }\n  // Special case for OBTP with meeting size equal or over 5. Locus might change this later\n  // This is a temporary fix. I will find a better solution later.\n  if (!deltaLocus.baseSequence && res === DELTAEVENT.EQ && deltaLocus.fullState.state === LOCUS.STATE.INITIALIZING &&\n        deltaLocus.sequence.rangeStart === 0 && deltaLocus.sequence.rangeEnd === 0 &&\n        deltaLocus.sequence.entries.length === 0) {\n    res = DELTAEVENT.GT;\n  }\n  switch (res) {\n    case DELTAEVENT.LT:\n    case DELTAEVENT.EQ:\n      meeting.locusDesync = false;\n      meeting.needToGetFullLocus = false;\n      break;\n    case DELTAEVENT.CF:\n      LocusUtil.generateSyncDebugFlag(meeting, deltaLocus);\n      if (meeting.locusDesync) {\n        meeting.meetingRequest.getFullLocus({\n          desync: true,\n          locusUrl: meeting.locusUrl\n        }).then((res) => {\n          meeting.locusInfo.onFullLocus(res.body);\n        });\n      }\n      else {\n        meeting.locusDesync = true;\n        Parser.syncMeeting(meeting, deltaLocus);\n      }\n      break;\n    case DELTAEVENT.GT:\n      meeting.locusInfo.onDeltaLocus(deltaLocus);\n      // Turn off desync in case this delta locus comes from a sync request\n      meeting.locusDesync = false;\n      meeting.needToGetFullLocus = false;\n      break;\n    default:\n  }\n\n  return res;\n};\n\n\nParser.syncMeeting = (meeting, deltaLocus) => {\n  if (meeting &&\n        meeting.locusInfo &&\n        meeting.locusInfo.syncUrl &&\n        meeting.locusInfo.fullState &&\n        meeting.locusInfo.fullState.state !== LOCUS.STATE.INACTIVE) {\n    // found that the locus syncs were happening even after 4 hrs of meeting\n    // completion, resulting in 403 errors. This check ensures we call\n    // syncing only if the locus state is not INACTIVE.\n    meeting.meetingRequest.syncMeeting({\n      syncUrl: deltaLocus.syncUrl,\n      desync: meeting.desync\n    })\n      .then((res) => {\n        meeting.locusInfo.onDeltaLocus(res.body);\n      });\n  }\n};\n\nexport default Parser;\n"]},"metadata":{},"sourceType":"script"}