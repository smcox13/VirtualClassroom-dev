{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof2 = require('babel-runtime/helpers/typeof');\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _wrap2 = require('lodash/wrap');\n\nvar _wrap3 = _interopRequireDefault(_wrap2);\n\nvar _isFunction2 = require('lodash/isFunction');\n\nvar _isFunction3 = _interopRequireDefault(_isFunction2);\n\nvar _defaults2 = require('lodash/defaults');\n\nvar _defaults3 = _interopRequireDefault(_defaults2);\n\nexports.default = retry;\n\nvar _events = require('events');\n\nvar _backoff = require('backoff');\n\nvar _backoff2 = _interopRequireDefault(_backoff);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* eslint max-nested-callbacks: [0] */\n\n/**\n * Makes a promise-returning method retryable according to the specified backoff\n * pattern\n * @param {Object} options\n * @param {boolean} options.backoff\n * @param {number} options.delay\n * @param {number} options.initialDelay\n * @param {number} options.maxAttempts\n * @param {number} options.maxDelay\n *\n * @returns {Function}\n */\n\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nfunction retry() {\n  for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {\n    params[_key] = arguments[_key];\n  }\n\n  var options = params[0] || {};\n  options = (0, _assign2.default)({}, options);\n  (0, _defaults3.default)(options, {\n    backoff: true,\n    delay: 1,\n    maxAttempts: 3\n  });\n  var strategyOptions = void 0;\n\n  if (options.backoff) {\n    strategyOptions = {\n      initialDelay: options.delay,\n      maxDelay: options.maxDelay\n    };\n  } else {\n    strategyOptions = {\n      initialDelay: 1,\n      maxDelay: 1\n    };\n  }\n\n  if (params.length === 3) {\n    return (0, _apply2.default)(retryDecorator, null, params);\n  }\n\n  return retryDecorator;\n  /**\n   * @param {Object} target\n   * @param {string} prop\n   * @param {Object} descriptor\n   * @private\n   * @returns {Object}\n   */\n\n  function retryDecorator(target, prop, descriptor) {\n    descriptor.value = (0, _wrap3.default)(descriptor.value, function retryExecutor(fn) {\n      var _this = this;\n\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      var emitter = new _events.EventEmitter();\n      var promise = new _promise2.default(function (resolve, reject) {\n        // backoff.call is not Function.prototype.call; it's an unfortunate naming\n        // collision.\n\n        /* eslint prefer-reflect: [0] */\n        var call = _backoff2.default.call(function (cb) {\n          /* eslint no-invalid-this: [0] */\n          var innerPromise = (0, _apply2.default)(fn, _this, args);\n\n          if ((0, _isFunction3.default)(innerPromise.on)) {\n            innerPromise.on('progress', emitter.emit.bind(emitter, 'progress'));\n            innerPromise.on('upload-progress', emitter.emit.bind(emitter, 'upload-progress'));\n            innerPromise.on('download-progress', emitter.emit.bind(emitter, 'download-progress'));\n          }\n\n          return innerPromise.then(function (res) {\n            cb(null, res);\n          }).catch(function (reason) {\n            if (!reason) {\n              reason = new Error('retryable method failed without providing an error object');\n            }\n\n            cb(reason);\n          });\n        }, function (err, res) {\n          if (err) {\n            return reject(err);\n          }\n\n          return resolve(res);\n        });\n\n        call.setStrategy(new _backoff2.default.ExponentialStrategy(strategyOptions));\n\n        if (options.maxAttempts) {\n          call.failAfter(options.maxAttempts - 1);\n        }\n\n        call.start();\n      });\n\n      promise.on = function on(key, callback) {\n        emitter.on(key, callback);\n        return promise;\n      };\n\n      return promise;\n    }); // This *should* make decorators compatible with AmpersandState class\n    // definitions\n\n    if ((typeof target === 'undefined' ? 'undefined' : (0, _typeof3.default)(target)) === 'object' && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    return descriptor;\n  }\n}","map":{"version":3,"sources":["retry.js"],"names":["retry","params","options","backoff","delay","maxAttempts","strategyOptions","initialDelay","maxDelay","descriptor","args","emitter","EventEmitter","promise","call","innerPromise","cb","reason","reject","resolve","target"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {EventEmitter} from 'events';\nimport {defaults, isFunction, wrap} from 'lodash';\nimport backoff from 'backoff';\n\n/* eslint max-nested-callbacks: [0] */\n\n/**\n * Makes a promise-returning method retryable according to the specified backoff\n * pattern\n * @param {Object} options\n * @param {boolean} options.backoff\n * @param {number} options.delay\n * @param {number} options.initialDelay\n * @param {number} options.maxAttempts\n * @param {number} options.maxDelay\n *\n * @returns {Function}\n */\nexport default function retry(...params) {\n  let options = params[0] || {};\n\n  options = Object.assign({}, options);\n  defaults(options, {\n    backoff: true,\n    delay: 1,\n    maxAttempts: 3\n  });\n\n  let strategyOptions;\n\n  if (options.backoff) {\n    strategyOptions = {\n      initialDelay: options.delay,\n      maxDelay: options.maxDelay\n    };\n  }\n  else {\n    strategyOptions = {\n      initialDelay: 1,\n      maxDelay: 1\n    };\n  }\n\n  if (params.length === 3) {\n    return Reflect.apply(retryDecorator, null, params);\n  }\n\n  return retryDecorator;\n\n  /**\n   * @param {Object} target\n   * @param {string} prop\n   * @param {Object} descriptor\n   * @private\n   * @returns {Object}\n   */\n  function retryDecorator(target, prop, descriptor) {\n    descriptor.value = wrap(descriptor.value, function retryExecutor(fn, ...args) {\n      const emitter = new EventEmitter();\n      const promise = new Promise((resolve, reject) => {\n        // backoff.call is not Function.prototype.call; it's an unfortunate naming\n        // collision.\n        /* eslint prefer-reflect: [0] */\n        const call = backoff.call(\n          (cb) => {\n            /* eslint no-invalid-this: [0] */\n            const innerPromise = Reflect.apply(fn, this, args);\n\n            if (isFunction(innerPromise.on)) {\n              innerPromise.on('progress', emitter.emit.bind(emitter, 'progress'));\n              innerPromise.on('upload-progress', emitter.emit.bind(emitter, 'upload-progress'));\n              innerPromise.on('download-progress', emitter.emit.bind(emitter, 'download-progress'));\n            }\n\n            return innerPromise\n              .then((res) => {\n                cb(null, res);\n              })\n              .catch((reason) => {\n                if (!reason) {\n                  reason = new Error('retryable method failed without providing an error object');\n                }\n                cb(reason);\n              });\n          },\n          (err, res) => {\n            if (err) {\n              return reject(err);\n            }\n\n            return resolve(res);\n          }\n        );\n\n        call.setStrategy(new backoff.ExponentialStrategy(strategyOptions));\n        if (options.maxAttempts) {\n          call.failAfter(options.maxAttempts - 1);\n        }\n\n        call.start();\n      });\n\n      promise.on = function on(key, callback) {\n        emitter.on(key, callback);\n\n        return promise;\n      };\n\n      return promise;\n    });\n\n    // This *should* make decorators compatible with AmpersandState class\n    // definitions\n    if (typeof target === 'object' && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    return descriptor;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}