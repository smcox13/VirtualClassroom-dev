{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _isFinite2 = require('lodash/isFinite');\n\nvar _isFinite3 = _interopRequireDefault(_isFinite2);\n\nvar _keys2 = require('lodash/keys');\n\nvar _keys3 = _interopRequireDefault(_keys2);\n\nvar _constants = require('../constants');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar StatsCalculator = {};\n/**\n * Calculate an interval of values between 2 data points, using updated as the \"latest\" so updated - previous = interval\n * @param {WebRTCData} previous\n * @param {WebRTCData} updated\n * @returns {Object} interval: {StringKey: IntervalValue, ..., n}\n * @public\n */\n\nStatsCalculator.difference = function (previous, updated) {\n  // if there was no previous, just take the updated\n  if (!previous || !previous.data || !previous.data.getData || (0, _keys3.default)(previous.data.getData()).length === 0) {\n    return updated;\n  }\n\n  var interval = {}; // get inside the data from the filtered report\n\n  (0, _keys3.default)(updated.data.getData()).forEach(function (key) {\n    interval[key] = interval[key] ? interval[key] : {};\n    (0, _keys3.default)(updated.data.getData()[key]).forEach(function (stat) {\n      var value = updated.data.getData()[key][stat]; // only use some simple data points that are numbers and aren't silly things like timestamp\n\n      if ((0, _isFinite3.default)(value) && !(_constants.DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {\n        // if there was nothing there before, just return the updated data\n        if (!previous.data.getData()[key] || !previous.data.getData()[key][stat]) {\n          interval[key][stat] = value;\n        } // subract and store\n        else {\n            value -= previous.data.getData()[key][stat];\n            interval[key][stat] = value;\n          }\n      }\n    });\n  });\n  return interval;\n};\n/**\n * Calculate an aggregate of values between an old summary and a new data point, using summary as the base to add to so aggregate = summary + data\n * @param {WebRTCData} data\n * @param {Object} summary\n * @returns {Object} aggregate {StringKey: SummedValue, ..., n}\n * @public\n */\n\n\nStatsCalculator.sum = function (data, summary) {\n  var aggregate = summary; // get inside the data from the filtered report\n\n  (0, _keys3.default)(data.data.getData()).forEach(function (key) {\n    (0, _keys3.default)(data.data.getData()[key]).forEach(function (stat) {\n      var value = data.data.getData()[key][stat]; // only use some simple data points that are numbers and aren't silly things like timestamp\n\n      if ((0, _isFinite3.default)(value) && !(_constants.DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {\n        // if there was something there before, add to that value\n        if (aggregate[key][stat]) {\n          aggregate[key][stat] += value;\n        } // set up the value as the new data point\n        else {\n            aggregate[key][stat] = value;\n          }\n      }\n    });\n  });\n  return aggregate;\n};\n\nexports.default = StatsCalculator;","map":{"version":3,"sources":["calculator.js"],"names":["StatsCalculator","previous","interval","updated","value","DEFAULT_EXCLUDED_STATS","aggregate","data"],"mappings":"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","sourcesContent":["import {keys, isFinite} from 'lodash';\n\nimport {DEFAULT_EXCLUDED_STATS} from '../constants';\n\nconst StatsCalculator = {};\n\n/**\n * Calculate an interval of values between 2 data points, using updated as the \"latest\" so updated - previous = interval\n * @param {WebRTCData} previous\n * @param {WebRTCData} updated\n * @returns {Object} interval: {StringKey: IntervalValue, ..., n}\n * @public\n */\nStatsCalculator.difference = (previous, updated) => {\n  // if there was no previous, just take the updated\n  if (!previous || !previous.data || !previous.data.getData || keys(previous.data.getData()).length === 0) {\n    return updated;\n  }\n  const interval = {};\n\n  // get inside the data from the filtered report\n  keys(updated.data.getData()).forEach((key) => {\n    interval[key] = interval[key] ? interval[key] : {};\n    keys(updated.data.getData()[key]).forEach((stat) => {\n      let value = updated.data.getData()[key][stat];\n\n      // only use some simple data points that are numbers and aren't silly things like timestamp\n      if (isFinite(value) && !(DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {\n        // if there was nothing there before, just return the updated data\n        if (!previous.data.getData()[key] || !previous.data.getData()[key][stat]) {\n          interval[key][stat] = value;\n        }\n        // subract and store\n        else {\n          value -= previous.data.getData()[key][stat];\n          interval[key][stat] = value;\n        }\n      }\n    });\n  });\n\n  return interval;\n};\n\n/**\n * Calculate an aggregate of values between an old summary and a new data point, using summary as the base to add to so aggregate = summary + data\n * @param {WebRTCData} data\n * @param {Object} summary\n * @returns {Object} aggregate {StringKey: SummedValue, ..., n}\n * @public\n */\nStatsCalculator.sum = (data, summary) => {\n  const aggregate = summary;\n\n  // get inside the data from the filtered report\n  keys(data.data.getData()).forEach((key) => {\n    keys(data.data.getData()[key]).forEach((stat) => {\n      const value = data.data.getData()[key][stat];\n\n      // only use some simple data points that are numbers and aren't silly things like timestamp\n      if (isFinite(value) && !(DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {\n        // if there was something there before, add to that value\n        if (aggregate[key][stat]) {\n          aggregate[key][stat] += value;\n        }\n        // set up the value as the new data point\n        else {\n          aggregate[key][stat] = value;\n        }\n      }\n    });\n  });\n\n  return aggregate;\n};\n\nexport default StatsCalculator;\n"]},"metadata":{},"sourceType":"script"}