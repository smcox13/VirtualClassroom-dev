{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nvar _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');\n\nvar _deleteProperty2 = _interopRequireDefault(_deleteProperty);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _omit2 = require('lodash/omit');\n\nvar _omit3 = _interopRequireDefault(_omit2);\n\nvar _isEmpty2 = require('lodash/isEmpty');\n\nvar _isEmpty3 = _interopRequireDefault(_isEmpty2);\n\nvar _cloneDeep2 = require('lodash/cloneDeep');\n\nvar _cloneDeep3 = _interopRequireDefault(_cloneDeep2);\n\nvar _dec, _dec2, _desc, _value, _obj;\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint camelcase: [0] */\n\n\nvar _querystring = require('querystring');\n\nvar _querystring2 = _interopRequireDefault(_querystring);\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _common = require('@webex/common');\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _uuid = require('uuid');\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n\nvar OAUTH2_CSRF_TOKEN = 'oauth2-csrf-token';\n\nvar EMPTY_OBJECT_STRING = _common.base64.encode((0, _stringify2.default)({}));\n/**\n * Browser support for OAuth2. Automatically parses the URL hash for an access\n * token\n * @class\n * @name AuthorizationBrowser\n */\n\n\nvar Authorization = _webexCore.WebexPlugin.extend((_dec = (0, _common.whileInFlight)('isAuthorizing'), _dec2 = (0, _common.whileInFlight)('isAuthorizing'), (_obj = {\n  derived: {\n    /**\n     * Alias of {@link AuthorizationBrowser#isAuthorizing}\n     * @instance\n     * @memberof AuthorizationBrowser\n     * @type {boolean}\n     */\n    isAuthenticating: {\n      deps: ['isAuthorizing'],\n      fn: function fn() {\n        return this.isAuthorizing;\n      }\n    }\n  },\n  session: {\n    /**\n     * Indicates if an Authorization Code exchange is inflight\n     * @instance\n     * @memberof AuthorizationBrowser\n     * @type {boolean}\n     */\n    isAuthorizing: {\n      default: false,\n      type: 'boolean'\n    },\n    ready: {\n      default: false,\n      type: 'boolean'\n    }\n  },\n  namespace: 'Credentials',\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} attrs {@link AmpersandState}\n   * @param {boolean} attrs.parse Controls whether or not the the url should get\n   * parsed for an access token\n   * @private\n   * @returns {Authorization}\n   */\n  // eslint-disable-next-line complexity\n  initialize: function initialize(attrs, options) {\n    var _this = this;\n\n    var ret = (0, _apply2.default)(_webexCore.WebexPlugin.prototype.initialize, this, [attrs, options]); // Reminder, we can't do parse based on config, because config is not\n    // available until nextTick and we want to be able to throw errors found in\n    // the url.\n\n    if (attrs.parse === false) {\n      this.ready = true;\n      return ret;\n    }\n\n    var location = _url2.default.parse(this.webex.getWindow().location.href, true);\n\n    this._checkForErrors(location);\n\n    var hash = location.hash;\n\n    if (!hash) {\n      this.ready = true;\n      return ret;\n    }\n\n    if (hash.includes('#')) {\n      hash = hash.substr(1);\n    }\n\n    location.hash = _querystring2.default.parse(hash);\n\n    if (location.hash.state) {\n      location.hash.state = JSON.parse(_common.base64.decode(location.hash.state));\n    }\n\n    var tokenData = this._parseHash(location);\n\n    if (!tokenData) {\n      return ret;\n    }\n\n    this._cleanUrl(location); // Wait until nextTick in case `credentials` hasn't initialized yet\n\n\n    process.nextTick(function () {\n      _this.webex.credentials.set({\n        supertoken: tokenData\n      });\n\n      _this.ready = true;\n    });\n    return ret;\n  },\n\n  /**\n   * Kicks off an oauth flow\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateLogin: function initiateLogin() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.state = options.state || {};\n    options.state.csrf_token = this._generateSecurityToken(); // If we're not explicitly a confidential client, assume we're a public\n    // client\n\n    if (this.config.clientType === 'confidential') {\n      return this.initiateAuthorizationCodeGrant(options);\n    }\n\n    return this.initiateImplicitGrant(options);\n  },\n\n  /**\n   * Kicks off the Authorization Code grant flow. Typically called via\n   * {@link AuthorizationBrowser#initiateLogin}\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateImplicitGrant: function initiateImplicitGrant(options) {\n    this.logger.info('authorization: initiating implicit grant flow');\n    this.webex.getWindow().location = this.webex.credentials.buildLoginUrl((0, _assign2.default)({\n      response_type: 'token'\n    }, options));\n    return _promise2.default.resolve();\n  },\n\n  /**\n   * Kicks off the Implicit Code grant flow. Typically called via\n   * {@link AuthorizationBrowser#initiateLogin}\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateAuthorizationCodeGrant: function initiateAuthorizationCodeGrant(options) {\n    this.logger.info('authorization: initiating authorization code grant flow');\n    this.webex.getWindow().location = this.webex.credentials.buildLoginUrl((0, _assign2.default)({\n      response_type: 'code'\n    }, options));\n    return _promise2.default.resolve();\n  },\n\n  /**\n   * Requests a Webex Teams access token for a user already authenticated into\n   * your product.\n   *\n   * Note: You'll need to supply a jwtRefreshCallback of the form\n   * `Promise<jwt> = jwtRefreshCallback(webex)` for automatic token refresh to\n   * work.\n   *\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @param {Object} options.jwt This is a jwt generated by your backend that\n   * identifies a user in your system\n   * @returns {Promise}\n   */\n  requestAccessTokenFromJwt: function requestAccessTokenFromJwt(_ref) {\n    var _this2 = this;\n\n    var jwt = _ref.jwt;\n    var hydraUri = this.webex.internal.services.get('hydra', true);\n\n    if (hydraUri) {\n      // add a `/` to hydra's uri from the services catalog so that\n      // it matches the current env service format.\n      hydraUri += '/';\n    }\n\n    hydraUri = hydraUri || process.env.HYDRA_SERVICE_URL || 'https://api.ciscospark.com/v1/';\n    return this.webex.request({\n      method: 'POST',\n      uri: hydraUri + 'jwt/login',\n      headers: {\n        authorization: jwt\n      }\n    }).then(function (_ref2) {\n      var body = _ref2.body;\n      return {\n        access_token: body.token,\n        token_type: 'Bearer',\n        expires_in: body.expiresIn\n      };\n    }).then(function (token) {\n      _this2.webex.credentials.set({\n        supertoken: token\n      });\n    }).then(function () {\n      return _this2.webex.internal.services.initServiceCatalogs();\n    });\n  },\n\n  /**\n   * Called by {@link WebexCore#logout()}. Redirects to the logout page\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @param {boolean} options.noRedirect if true, does not redirect\n   * @returns {Promise}\n   */\n  logout: function logout() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!options.noRedirect) {\n      this.webex.getWindow().location = this.webex.credentials.buildLogoutUrl(options);\n    }\n  },\n\n  /**\n   * Checks if the result of the login redirect contains an error string\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} location\n   * @private\n   * @returns {Promise}\n   */\n  _checkForErrors: function _checkForErrors(location) {\n    var query = location.query;\n\n    if (query && query.error) {\n      var ErrorConstructor = _webexCore.grantErrors.select(query.error);\n\n      throw new ErrorConstructor(query);\n    }\n  },\n\n  /**\n   * Removes no-longer needed values from the url (access token, csrf token, etc)\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} location\n   * @private\n   * @returns {Promise}\n   */\n  _cleanUrl: function _cleanUrl(location) {\n    location = (0, _cloneDeep3.default)(location);\n\n    if (this.webex.getWindow().history && this.webex.getWindow().history.replaceState) {\n      ['access_token', 'token_type', 'expires_in', 'refresh_token', 'refresh_token_expires_in'].forEach(function (key) {\n        return (0, _deleteProperty2.default)(location.hash, key);\n      });\n\n      if (!(0, _isEmpty3.default)(location.hash.state)) {\n        location.hash.state = _common.base64.encode((0, _stringify2.default)((0, _omit3.default)(location.hash.state, 'csrf_token')));\n\n        if (location.hash.state === EMPTY_OBJECT_STRING) {\n          (0, _deleteProperty2.default)(location.hash, 'state');\n        }\n      } else {\n        (0, _deleteProperty2.default)(location.hash, 'state');\n      }\n\n      location.hash = _querystring2.default.stringify(location.hash);\n      this.webex.getWindow().history.replaceState({}, null, _url2.default.format(location));\n    }\n  },\n\n  /**\n   * Generates a CSRF token and sticks in in sessionStorage\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @private\n   * @returns {Promise}\n   */\n  _generateSecurityToken: function _generateSecurityToken() {\n    this.logger.info('authorization: generating csrf token');\n\n    var token = _uuid2.default.v4();\n\n    this.webex.getWindow().sessionStorage.setItem('oauth2-csrf-token', token);\n    return token;\n  },\n\n  /**\n   * Parses the url hash into an access token object\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} location\n   * @private\n   * @returns {Object}\n   */\n  _parseHash: function _parseHash(location) {\n    var hash = (0, _cloneDeep3.default)(location.hash);\n\n    if (hash) {\n      this._verifySecurityToken(hash);\n    }\n\n    if (!hash.access_token) {\n      this.ready = true;\n      return undefined;\n    }\n\n    if (hash.expires_in) {\n      hash.expires_in = parseInt(hash.expires_in, 10);\n    }\n\n    if (hash.refresh_token_expires_in) {\n      hash.refresh_token_expires_in = parseInt(hash.refresh_token_expires_in, 10);\n    }\n\n    return hash;\n  },\n\n  /**\n   * Checks if the CSRF token in sessionStorage is the same as the one returned\n   * in the url.\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} hash\n   * @private\n   * @returns {Promise}\n   */\n  _verifySecurityToken: function _verifySecurityToken(hash) {\n    var sessionToken = this.webex.getWindow().sessionStorage.getItem(OAUTH2_CSRF_TOKEN);\n    this.webex.getWindow().sessionStorage.removeItem(OAUTH2_CSRF_TOKEN);\n\n    if (!sessionToken) {\n      return;\n    }\n\n    if (!hash.state) {\n      throw new Error('Expected CSRF token ' + sessionToken + ', but not found in redirect hash');\n    }\n\n    if (!hash.state.csrf_token) {\n      throw new Error('Expected CSRF token ' + sessionToken + ', but not found in redirect hash');\n    }\n\n    var token = hash.state.csrf_token;\n\n    if (token !== sessionToken) {\n      throw new Error('CSRF token ' + token + ' does not match stored token ' + sessionToken);\n    }\n  },\n  version: '1.80.172'\n}, (_applyDecoratedDescriptor(_obj, 'initiateImplicitGrant', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'initiateImplicitGrant'), _obj), _applyDecoratedDescriptor(_obj, 'initiateAuthorizationCodeGrant', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'initiateAuthorizationCodeGrant'), _obj), _applyDecoratedDescriptor(_obj, 'requestAccessTokenFromJwt', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'requestAccessTokenFromJwt'), _obj)), _obj)));\n\nexports.default = Authorization;","map":{"version":3,"sources":["authorization.js"],"names":["OAUTH2_CSRF_TOKEN","EMPTY_OBJECT_STRING","base64","Authorization","derived","isAuthenticating","deps","fn","session","isAuthorizing","default","type","ready","namespace","initialize","ret","WebexPlugin","attrs","location","url","hash","querystring","JSON","tokenData","process","supertoken","initiateLogin","options","initiateImplicitGrant","response_type","initiateAuthorizationCodeGrant","oneFlight","requestAccessTokenFromJwt","jwt","hydraUri","method","uri","headers","authorization","body","access_token","token_type","expires_in","expiresIn","token","logout","_checkForErrors","query","ErrorConstructor","grantErrors","_cleanUrl","_generateSecurityToken","uuid","_parseHash","parseInt","_verifySecurityToken","sessionToken"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint camelcase: [0] */\n\nimport querystring from 'querystring';\nimport url from 'url';\n\nimport {base64, oneFlight, whileInFlight} from '@webex/common';\nimport {grantErrors, WebexPlugin} from '@webex/webex-core';\nimport {cloneDeep, isEmpty, omit} from 'lodash';\nimport uuid from 'uuid';\n\nconst OAUTH2_CSRF_TOKEN = 'oauth2-csrf-token';\nconst EMPTY_OBJECT_STRING = base64.encode(JSON.stringify({}));\n\n/**\n * Browser support for OAuth2. Automatically parses the URL hash for an access\n * token\n * @class\n * @name AuthorizationBrowser\n */\nconst Authorization = WebexPlugin.extend({\n  derived: {\n    /**\n     * Alias of {@link AuthorizationBrowser#isAuthorizing}\n     * @instance\n     * @memberof AuthorizationBrowser\n     * @type {boolean}\n     */\n    isAuthenticating: {\n      deps: ['isAuthorizing'],\n      fn() {\n        return this.isAuthorizing;\n      }\n    }\n  },\n\n  session: {\n    /**\n     * Indicates if an Authorization Code exchange is inflight\n     * @instance\n     * @memberof AuthorizationBrowser\n     * @type {boolean}\n     */\n    isAuthorizing: {\n      default: false,\n      type: 'boolean'\n    },\n    ready: {\n      default: false,\n      type: 'boolean'\n    }\n  },\n\n  namespace: 'Credentials',\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} attrs {@link AmpersandState}\n   * @param {boolean} attrs.parse Controls whether or not the the url should get\n   * parsed for an access token\n   * @private\n   * @returns {Authorization}\n   */\n  // eslint-disable-next-line complexity\n  initialize(attrs, options) {\n    const ret = Reflect.apply(WebexPlugin.prototype.initialize, this, [attrs, options]);\n\n    // Reminder, we can't do parse based on config, because config is not\n    // available until nextTick and we want to be able to throw errors found in\n    // the url.\n    if (attrs.parse === false) {\n      this.ready = true;\n\n      return ret;\n    }\n    const location = url.parse(this.webex.getWindow().location.href, true);\n\n    this._checkForErrors(location);\n\n    let {hash} = location;\n\n    if (!hash) {\n      this.ready = true;\n\n      return ret;\n    }\n    if (hash.includes('#')) {\n      hash = hash.substr(1);\n    }\n    location.hash = querystring.parse(hash);\n    if (location.hash.state) {\n      location.hash.state = JSON.parse(base64.decode(location.hash.state));\n    }\n    const tokenData = this._parseHash(location);\n\n    if (!tokenData) {\n      return ret;\n    }\n    this._cleanUrl(location);\n\n    // Wait until nextTick in case `credentials` hasn't initialized yet\n    process.nextTick(() => {\n      this.webex.credentials.set({supertoken: tokenData});\n      this.ready = true;\n    });\n\n    return ret;\n  },\n\n  /**\n   * Kicks off an oauth flow\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateLogin(options = {}) {\n    options.state = options.state || {};\n    options.state.csrf_token = this._generateSecurityToken();\n\n    // If we're not explicitly a confidential client, assume we're a public\n    // client\n    if (this.config.clientType === 'confidential') {\n      return this.initiateAuthorizationCodeGrant(options);\n    }\n\n    return this.initiateImplicitGrant(options);\n  },\n\n  @whileInFlight('isAuthorizing')\n  /**\n   * Kicks off the Authorization Code grant flow. Typically called via\n   * {@link AuthorizationBrowser#initiateLogin}\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateImplicitGrant(options) {\n    this.logger.info('authorization: initiating implicit grant flow');\n    this.webex.getWindow().location = this.webex.credentials.buildLoginUrl(Object.assign({response_type: 'token'}, options));\n\n    return Promise.resolve();\n  },\n\n  @whileInFlight('isAuthorizing')\n  /**\n   * Kicks off the Implicit Code grant flow. Typically called via\n   * {@link AuthorizationBrowser#initiateLogin}\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateAuthorizationCodeGrant(options) {\n    this.logger.info('authorization: initiating authorization code grant flow');\n    this.webex.getWindow().location = this.webex.credentials.buildLoginUrl(Object.assign({response_type: 'code'}, options));\n\n    return Promise.resolve();\n  },\n\n  @oneFlight\n  /**\n   * Requests a Webex Teams access token for a user already authenticated into\n   * your product.\n   *\n   * Note: You'll need to supply a jwtRefreshCallback of the form\n   * `Promise<jwt> = jwtRefreshCallback(webex)` for automatic token refresh to\n   * work.\n   *\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @param {Object} options.jwt This is a jwt generated by your backend that\n   * identifies a user in your system\n   * @returns {Promise}\n   */\n  requestAccessTokenFromJwt({jwt}) {\n    let hydraUri = this.webex.internal.services.get('hydra', true);\n\n    if (hydraUri) {\n      // add a `/` to hydra's uri from the services catalog so that\n      // it matches the current env service format.\n      hydraUri += '/';\n    }\n\n    hydraUri = hydraUri ||\n      process.env.HYDRA_SERVICE_URL ||\n      'https://api.ciscospark.com/v1/';\n\n    return this.webex.request({\n      method: 'POST',\n      uri: `${hydraUri}jwt/login`,\n      headers: {\n        authorization: jwt\n      }\n    })\n      .then(({body}) => ({\n        access_token: body.token,\n        token_type: 'Bearer',\n        expires_in: body.expiresIn\n      }))\n      .then((token) => {\n        this.webex.credentials.set({\n          supertoken: token\n        });\n      })\n      .then(() => this.webex.internal.services.initServiceCatalogs());\n  },\n\n  /**\n   * Called by {@link WebexCore#logout()}. Redirects to the logout page\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @param {boolean} options.noRedirect if true, does not redirect\n   * @returns {Promise}\n   */\n  logout(options = {}) {\n    if (!options.noRedirect) {\n      this.webex.getWindow().location = this.webex.credentials.buildLogoutUrl(options);\n    }\n  },\n\n  /**\n   * Checks if the result of the login redirect contains an error string\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} location\n   * @private\n   * @returns {Promise}\n   */\n  _checkForErrors(location) {\n    const {query} = location;\n\n    if (query && query.error) {\n      const ErrorConstructor = grantErrors.select(query.error);\n\n      throw new ErrorConstructor(query);\n    }\n  },\n\n  /**\n   * Removes no-longer needed values from the url (access token, csrf token, etc)\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} location\n   * @private\n   * @returns {Promise}\n   */\n  _cleanUrl(location) {\n    location = cloneDeep(location);\n    if (this.webex.getWindow().history && this.webex.getWindow().history.replaceState) {\n      [\n        'access_token',\n        'token_type',\n        'expires_in',\n        'refresh_token',\n        'refresh_token_expires_in'\n      ].forEach((key) => Reflect.deleteProperty(location.hash, key));\n      if (!isEmpty(location.hash.state)) {\n        location.hash.state = base64.encode(JSON.stringify(omit(location.hash.state, 'csrf_token')));\n        if (location.hash.state === EMPTY_OBJECT_STRING) {\n          Reflect.deleteProperty(location.hash, 'state');\n        }\n      }\n      else {\n        Reflect.deleteProperty(location.hash, 'state');\n      }\n      location.hash = querystring.stringify(location.hash);\n      this.webex.getWindow().history.replaceState({}, null, url.format(location));\n    }\n  },\n\n  /**\n   * Generates a CSRF token and sticks in in sessionStorage\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @private\n   * @returns {Promise}\n   */\n  _generateSecurityToken() {\n    this.logger.info('authorization: generating csrf token');\n\n    const token = uuid.v4();\n\n    this.webex.getWindow().sessionStorage.setItem('oauth2-csrf-token', token);\n\n    return token;\n  },\n\n  /**\n   * Parses the url hash into an access token object\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} location\n   * @private\n   * @returns {Object}\n   */\n  _parseHash(location) {\n    const hash = cloneDeep(location.hash);\n\n    if (hash) {\n      this._verifySecurityToken(hash);\n    }\n    if (!hash.access_token) {\n      this.ready = true;\n\n      return undefined;\n    }\n    if (hash.expires_in) {\n      hash.expires_in = parseInt(hash.expires_in, 10);\n    }\n    if (hash.refresh_token_expires_in) {\n      hash.refresh_token_expires_in = parseInt(hash.refresh_token_expires_in, 10);\n    }\n\n    return hash;\n  },\n\n  /**\n   * Checks if the CSRF token in sessionStorage is the same as the one returned\n   * in the url.\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} hash\n   * @private\n   * @returns {Promise}\n   */\n  _verifySecurityToken(hash) {\n    const sessionToken = this.webex.getWindow().sessionStorage.getItem(OAUTH2_CSRF_TOKEN);\n\n    this.webex.getWindow().sessionStorage.removeItem(OAUTH2_CSRF_TOKEN);\n    if (!sessionToken) {\n      return;\n    }\n\n    if (!hash.state) {\n      throw new Error(`Expected CSRF token ${sessionToken}, but not found in redirect hash`);\n    }\n\n    if (!hash.state.csrf_token) {\n      throw new Error(`Expected CSRF token ${sessionToken}, but not found in redirect hash`);\n    }\n\n    const token = hash.state.csrf_token;\n\n    if (token !== sessionToken) {\n      throw new Error(`CSRF token ${token} does not match stored token ${sessionToken}`);\n    }\n  }\n});\n\nexport default Authorization;\n"]},"metadata":{},"sourceType":"script"}