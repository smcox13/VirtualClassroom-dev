{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _forEach2 = require('lodash/forEach');\n\nvar _forEach3 = _interopRequireDefault(_forEach2);\n\nrequire('@webex/internal-plugin-mercury');\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _metrics = require('../metrics');\n\nvar _metrics2 = _interopRequireDefault(_metrics);\n\nvar _config = require('../metrics/config');\n\nvar _loggerConfig = require('../common/logs/logger-config');\n\nvar _loggerConfig2 = _interopRequireDefault(_loggerConfig);\n\nvar _config2 = require('../common/config');\n\nvar _config3 = _interopRequireDefault(_config2);\n\nvar _loggerProxy = require('../common/logs/logger-proxy');\n\nvar _loggerProxy2 = _interopRequireDefault(_loggerProxy);\n\nvar _triggerProxy = require('../common/events/trigger-proxy');\n\nvar _triggerProxy2 = _interopRequireDefault(_triggerProxy);\n\nvar _constants = require('../constants');\n\nvar _meetingInfo = require('../meeting-info');\n\nvar _meetingInfo2 = _interopRequireDefault(_meetingInfo);\n\nvar _meeting = require('../meeting');\n\nvar _meeting2 = _interopRequireDefault(_meeting);\n\nvar _personalMeetingRoom = require('../personal-meeting-room');\n\nvar _personalMeetingRoom2 = _interopRequireDefault(_personalMeetingRoom);\n\nvar _reachability = require('../reachability');\n\nvar _reachability2 = _interopRequireDefault(_reachability);\n\nvar _request = require('../meetings/request');\n\nvar _request2 = _interopRequireDefault(_request);\n\nvar _analyzer = require('../analyzer/analyzer');\n\nvar _analyzer2 = _interopRequireDefault(_analyzer);\n\nvar _calculator = require('../analyzer/calculator');\n\nvar _calculator2 = _interopRequireDefault(_calculator);\n\nvar _collection = require('./collection');\n\nvar _collection2 = _interopRequireDefault(_collection);\n\nvar _util = require('./util');\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n   * Meetings Ready Event\n   * Emitted when the meetings instance on webex is ready\n   * @event meetings:ready\n   * @instance\n   * @memberof Meetings\n   */\n\n/**\n * Meetings Registered Event\n * Emitted when the meetings instance has been registered and listening\n * @event meetings:registered\n * @instance\n * @memberof Meetings\n */\n\n/**\n    * Meeting Removed Event\n    * Emitted when a meeting was removed from the cache of meetings\n    * @event meeting:removed\n    * @instance\n    * @type {Object}\n    * @property {String} meetingId the removed meeting\n    * @property {Object} response the server response\n    * @property {String} type what type of meeting it was\n    * @memberof Meetings\n    */\n\n/**\n    * Meeting Added Event\n    * Emitted when a meeting was added to the cache of meetings\n    * @event meeting:added\n    * @instance\n    * @type {Object}\n    * @property {String} meetingId the added meeting\n    * @property {String} type what type of meeting it was\n    * @memberof Meetings\n    */\n\n/**\n   * Maintain a cache of meetings and sync with services.\n   * @class\n   */\n\n/*!\n  * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n*/\n\n\nvar Meetings = function (_WebexPlugin) {\n  (0, _inherits3.default)(Meetings, _WebexPlugin);\n  /**\n   * Initializes the Meetings Plugin\n   * @constructor\n   * @public\n   * @memberof Meetings\n   */\n\n  function Meetings() {\n    var _ref;\n\n    (0, _classCallCheck3.default)(this, Meetings);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    /**\n     * The MeetingInfo object to interact with server\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof Meetings\n     */\n\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = Meetings.__proto__ || (0, _getPrototypeOf2.default)(Meetings)).call.apply(_ref, [this].concat(args)));\n\n    _this.namespace = _constants.MEETINGS;\n    _this.meetingInfo = new _meetingInfo2.default({}, {\n      parent: _this.webex\n    });\n    /**\n     * The Meetings request to interact with server\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof Meetings\n     */\n\n    _this.request = new _request2.default({}, {\n      parent: _this.webex\n    });\n    _this.meetingCollection = new _collection2.default();\n    /**\n     * The PersonalMeetingRoom object to interact with server\n     * @instance\n     * @type {Object}\n     * @public\n     * @memberof Meetings\n     */\n\n    _this.personalMeetingRoom = new _personalMeetingRoom2.default({}, {\n      parent: _this.webex\n    });\n    /**\n     * The Reachability object to interact with server, starts as null until {@link Meeting#setReachability} is called\n     * starts as null\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof Meetings\n     */\n\n    _this.reachability = null;\n    /**\n     * If the meetings plugin has been registered and listening via {@link Meetings#register}\n     * @instance\n     * @type {Boolean}\n     * @public\n     * @memberof Meetings\n     */\n\n    _this.registered = false;\n\n    _this.onReady();\n\n    _metrics2.default.initialSetup(_this.meetingCollection, _this.webex.version);\n\n    return _this;\n  }\n  /**\n   * handle locus events and takes meeting actions with them as they come in\n   * @param {Object} data a locus event\n   * @param {String} data.locusUrl\n   * @param {Object} data.locus\n   * @param {String} data.eventType\n   * @returns {undefined}\n   * @private\n   * @memberof Meetings\n   */\n\n\n  (0, _createClass3.default)(Meetings, [{\n    key: 'handleLocusEvent',\n    value: function handleLocusEvent(data) {\n      var _this2 = this;\n\n      var meeting = null; // getting meeting by correlationId. This will happen for the new event\n      // Either the locus\n      // TODO : Add check for the callBack Address\n\n      meeting = this.meetingCollection.getByKey(_constants.LOCUS_URL, data.locusUrl) || this.meetingCollection.getByKey(_constants.CORRELATION_ID, _util2.default.checkForCorrelationId(this.webex.internal.device.url, data.locus)) || this.meetingCollection.getByKey(_constants.SIP_URI, data.locus.self && data.locus.self.callbackInfo && data.locus.self.callbackInfo.callbackAddress);\n\n      if (!meeting) {\n        // TODO: create meeting when we get a meeting object\n        // const checkForEnded = (locus) => {\n        // TODO: you already ended the meeting but you got an event later\n        // Mainly for 1:1 Callsor meeting\n        // Happens mainly after refresh\n        // 1:1 Meeting\n        // 1)  You ended a call before but you got a mercury event\n        // Make sure end the call and cleanup the meeting only if the mercury\n        // event says so\n        // 2) Maintain lastSync time in the meetings object which helps to compare\n        // If the meeting came befor or after the sync . ANy meeting start time before the sync time is invalid\n        // For space Meeting\n        // Check the locus object and see who has joined\n        // };\n        // rather then locus object change to locus url\n        if (data.locus && data.locus.fullState && data.locus.fullState.state === _constants.LOCUS.STATE.INACTIVE) {\n          // just ignore the event as its already ended and not active\n          _loggerProxy2.default.logger.warn('Meetings->handleLocusEvent#Locus event received for meeting, after it was ended.');\n\n          return;\n        } // When its wireless share or guest and user leaves the meeting we dont have to keep the meeting object\n        // Any future events will be neglected\n\n\n        if (data.locus && data.locus.self && data.locus.self.state === _constants._LEFT_ && data.locus.self.removed === true) {\n          // just ignore the event as its already ended and not active\n          _loggerProxy2.default.logger.warn('Meetings->handleLocusEvent#Locus event received for meeting, after it was ended.');\n\n          return;\n        }\n\n        this.create(data.locus, _constants._LOCUS_ID_).then(function (newMeeting) {\n          meeting = newMeeting;\n\n          if (data.eventType === _constants.LOCUSEVENT.DIFFERENCE) {\n            // its a delta object and we have a new meeting\n            meeting.locusInfo.initialSetup(data.locus, meeting);\n          } else {\n            // Its a new meeting and have a fresh locus object\n            meeting.locusInfo.initialSetup(data.locus);\n          }\n        }).finally(function () {\n          // There will be cases where locus event comes in gets created and deleted because its a 1:1 and meeting gets deleted\n          // because the other user left so before sending 'added' event make sure it exists in the collection\n          if (_this2.getMeetingByType(_constants._ID_, meeting.id)) {\n            // Had to put `meeting:added here as the parsing of the locus object is done here\n            _metrics2.default.postEvent({\n              event: _config.eventType.NOTIFICATION_RECEIVED,\n              meeting: meeting,\n              data: {\n                trigger: _config.trigger.MERCURY_EVENT\n              }\n            });\n\n            _metrics2.default.postEvent({\n              event: _config.eventType.REMOTE_STARTED,\n              meeting: meeting,\n              data: {\n                trigger: _config.trigger.MERCURY_EVENT\n              }\n            });\n\n            _triggerProxy2.default.trigger(_this2, {\n              file: 'meetings',\n              function: 'handleLocusEvent'\n            }, _constants.EVENT_TRIGGERS.MEETING_ADDED, {\n              meeting: meeting,\n              type: meeting.type === _constants._MEETING_ ? _constants._JOIN_ : _constants._INCOMING_\n            });\n          } else {\n            // Meeting got added but was not found in the collection. It might have got destroyed\n            _loggerProxy2.default.logger.warn('Meetings->handleLocusEvent#Created and destroyed meeting object before sending an event');\n          }\n        });\n      } else {\n        _metrics2.default.postEvent({\n          event: _config.eventType.NOTIFICATION_RECEIVED,\n          meeting: meeting,\n          data: {\n            trigger: _config.trigger.MERCURY_EVENT\n          }\n        });\n\n        meeting.locusInfo.parse(meeting, data);\n      }\n    }\n    /**\n     * handles locus events through mercury that are not roap\n     * @param {Object} envelope\n     * @param {Object} envelope.data\n     * @param {String} envelope.data.eventType\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'handleLocusMercury',\n    value: function handleLocusMercury(envelope) {\n      var data = envelope.data;\n      var eventType = data.eventType;\n\n      if (eventType && eventType !== _constants.LOCUSEVENT.MESSAGE_ROAP) {\n        this.handleLocusEvent(data);\n      }\n    }\n    /**\n     * registers for locus and roap mercury events\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'listenForEvents',\n    value: function listenForEvents() {\n      var _this3 = this;\n\n      this.webex.internal.mercury.on(_constants.LOCUSEVENT.LOCUS_MERCURY, function (envelope) {\n        _this3.handleLocusMercury(envelope);\n      });\n      this.webex.internal.mercury.on(_constants.ROAP.ROAP_MERCURY, function (envelope) {\n        _util2.default.handleRoapMercury(envelope, _this3.meetingCollection);\n      });\n      this.webex.internal.mercury.on(_constants.ONLINE, function () {\n        _this3.syncMeetings();\n      });\n    }\n    /**\n     * stops listening for locus and roap mercury events\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'stopListeningForEvents',\n    value: function stopListeningForEvents() {\n      this.webex.internal.mercury.off(_constants.LOCUSEVENT.LOCUS_MERCURY);\n      this.webex.internal.mercury.off(_constants.ROAP.ROAP_MERCURY);\n      this.webex.internal.mercury.off(_constants.ONLINE);\n    }\n    /**\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'onReady',\n    value: function onReady() {\n      var _this4 = this;\n\n      this.webex.once(_constants.READY, function () {\n        _config3.default.set(_this4.config);\n\n        _loggerConfig2.default.set(_this4.config.logging);\n\n        _loggerProxy2.default.set(_this4.webex.logger);\n\n        _triggerProxy2.default.trigger(_this4, {\n          file: 'meetings',\n          function: 'onReady'\n        }, _constants.EVENT_TRIGGERS.MEETINGS_READY);\n      });\n    }\n    /**\n     * Explicitly sets up the meetings plugin by registering\n     * the device, connecting to mercury, and listening for locus events.\n     *\n     * @returns {Promise}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'register',\n    value: function register() {\n      var _this5 = this;\n\n      if (!this.webex.canAuthorize) {\n        _loggerProxy2.default.logger.error('meetings->register#ERROR, Unable to register, SDK cannot authorize');\n\n        return _promise2.default.reject(new Error('SDK cannot authorize'));\n      }\n\n      if (this.registered) {\n        _loggerProxy2.default.logger.info('meetings->register#INFO, Meetings plugin already registered');\n\n        return _promise2.default.resolve();\n      }\n\n      return this.webex.internal.device.register().then(function () {\n        return _this5.webex.internal.mercury.connect();\n      }).then(function () {\n        _this5.listenForEvents();\n\n        _triggerProxy2.default.trigger(_this5, {\n          file: 'meetings',\n          function: 'register'\n        }, _constants.EVENT_TRIGGERS.MEETINGS_REGISTERED);\n\n        _this5.registered = true;\n      }).catch(function (error) {\n        _loggerProxy2.default.logger.error('meetings->register#ERROR, Unable to register, ' + error.message);\n\n        return _promise2.default.reject(error);\n      });\n    }\n    /**\n     * Explicitly tears down the meetings plugin by deregistering\n     * the device, disconnecting from mercury, and stops listening to locus events\n     *\n     * @returns {Promise}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'unregister',\n    value: function unregister() {\n      var _this6 = this;\n\n      if (!this.registered) {\n        _loggerProxy2.default.logger.info('meetings->unregister#INFO, Meetings plugin already unregistered');\n\n        return _promise2.default.resolve();\n      }\n\n      this.stopListeningForEvents();\n      return this.webex.internal.mercury.disconnect().then(function () {\n        return _this6.webex.internal.device.unregister();\n      }).then(function () {\n        _triggerProxy2.default.trigger(_this6, {\n          file: 'meetings',\n          function: 'unregister'\n        }, _constants.EVENT_TRIGGERS.MEETINGS_UNREGISTERED);\n\n        _this6.registered = false;\n      });\n    }\n    /**\n     * initializes the reachability instance for Meetings\n     * @returns {undefined}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'setReachability',\n    value: function setReachability() {\n      this.reachability = new _reachability2.default({}, {\n        parent: this.webex\n      });\n    }\n    /**\n     * gets the reachability instance for Meetings\n     * @returns {Reachability}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'getReachability',\n    value: function getReachability() {\n      return this.reachability;\n    }\n    /**\n     * initializes and starts gathering reachability for Meetings\n     * @returns {undefined}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'startReachability',\n    value: function startReachability() {\n      if (!this.reachability) {\n        this.setReachability();\n      }\n\n      this.getReachability().gatherReachability();\n    }\n    /**\n     * gets the personal meeting room instance, for saved PMR values for this user\n     * @returns {PersonalMeetingRoom}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'getPersonalMeetingRoom',\n    value: function getPersonalMeetingRoom() {\n      return this.personalMeetingRoom;\n    }\n    /**\n     * @param {String} meetingId\n     * @param {Object} reason\n     * @param {String} type\n     * @returns {Undefined}\n     * @private\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy(meetingId, reason) {\n      this.meetingCollection.delete(meetingId);\n\n      _triggerProxy2.default.trigger(this, {\n        file: 'meetings',\n        function: 'destroy'\n      }, _constants.EVENT_TRIGGERS.MEETING_REMOVED, {\n        meetingId: meetingId,\n        reason: reason\n      });\n    }\n    /**\n     * Create a meeting.\n     * @param {string} destination - sipURL, spaceId, phonenumber, meeting link, or locus object}\n     * @param {string} [type] - the optional specified type, such as locusId\n     * @returns {Promise} A new Meeting.\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'create',\n    value: function create(destination) {\n      var _this7 = this;\n\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null; // TODO: type should be from a dictionary\n      // Check if there is already meeting\n\n      var meeting = this.meetingCollection.getByKey(_constants.SIP_URI, destination);\n\n      if (!meeting) {\n        return this.createMeeting(destination, type).then(function (meeting) {\n          if (meeting && meeting.on) {\n            meeting.on(_constants.EVENTS.DESTROY_MEETING, function (payload) {\n              _this7.destroy(payload.meetingId, payload.reason);\n            });\n          } else {\n            _loggerProxy2.default.logger.error('meetings->create#ERROR, meeting does not have on method, will not be destroyed, meeting cleanup impossible for meeting: ' + meeting);\n          }\n\n          return _promise2.default.resolve(meeting);\n        });\n      }\n\n      return _promise2.default.resolve(meeting);\n    }\n    /**\n     * @param {String} destination see create()\n     * @param {String} type see create()\n     * @returns {Promise} a new meeting instance complete with meeting info and destination\n     * @private\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'createMeeting',\n    value: function () {\n      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(destination) {\n        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var meeting, info, meetingAddedType;\n        return _regenerator2.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                meeting = new _meeting2.default({\n                  userId: this.webex.internal.device.userId,\n                  deviceUrl: this.webex.internal.device.url,\n                  roapSeq: 0,\n                  locus: type === _constants._LOCUS_ID_ ? destination : null // pass the locus object if present\n\n                }, {\n                  parent: this.webex\n                });\n                this.meetingCollection.set(meeting);\n                _context.prev = 2;\n                _context.next = 5;\n                return this.meetingInfo.fetchMeetingInfo(_util2.default.extractDestination(destination, type), type);\n\n              case 5:\n                info = _context.sent;\n                meeting.parseMeetingInfo(info);\n                meeting.meetingInfo = info ? info.body : null;\n                _context.next = 16;\n                break;\n\n              case 10:\n                _context.prev = 10;\n                _context.t0 = _context['catch'](2); // if there is no meeting info we assume its a 1:1 call or wireless share\n\n                _loggerProxy2.default.logger.info('Meetings->createMeeting#Info Unable to fetch meeting info for ' + destination + '.');\n\n                _loggerProxy2.default.logger.info('Meetings->createMeeting#Info assuming this destination is a 1:1 or wireless share');\n\n                _loggerProxy2.default.logger.debug('Meetings->createMeeting#Debug ' + _context.t0 + ' fetching /meetingInfo for creation.'); // We need to save this info for future reference\n\n\n                meeting.destination = destination;\n\n              case 16:\n                _context.prev = 16; // For type LOCUS_ID we need to parse the locus object to get the information\n                // about the caller and callee\n                // Meeting Added event will be created in `handleLocusEvent`\n\n                if (type !== _constants._LOCUS_ID_) {\n                  if (!meeting.sipUri) {\n                    meeting.setSipUri(destination);\n                  } // TODO: check if we have to move this to parser\n\n\n                  meetingAddedType = _util2.default.getMeetingAddedType(type); // We typically shouldn't need to trigger both and event and return a promise.\n                  // Is this a special case? We want to make the public API usage as simple as possible.\n\n                  _triggerProxy2.default.trigger(this, {\n                    file: 'meetings',\n                    function: 'createMeeting'\n                  }, _constants.EVENT_TRIGGERS.MEETING_ADDED, {\n                    meeting: meeting,\n                    type: meetingAddedType\n                  });\n                }\n\n                return _context.finish(16);\n\n              case 19:\n                return _context.abrupt('return', meeting);\n\n              case 20:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 10, 16, 19]]);\n      }));\n\n      function createMeeting(_x3) {\n        return _ref2.apply(this, arguments);\n      }\n\n      return createMeeting;\n    }()\n    /**\n     * get a specifc meeting given it's type matched to the value, i.e., locus url\n     * @param {String} type\n     * @param {Object} value\n     * @returns {Meeting}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'getMeetingByType',\n    value: function getMeetingByType(type, value) {\n      return this.meetingCollection.getByKey(type, value);\n    }\n    /**\n     * Get all meetings.\n     * @param {object} options\n     * @param {object} options.startDate - get meetings after this start date\n     * @param {object} options.endDate - get meetings before this end date\n     * @returns {Object} All active and scheduled meetings.\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'getAllMeetings',\n    value: function getAllMeetings() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // Options may include other parameters to filter this collection\n      // of meetings.\n\n      return this.meetingCollection.getAll(options);\n    }\n    /**\n     * syncs all the meeting from server\n     * @returns {undefined}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'syncMeetings',\n    value: function syncMeetings() {\n      var _this8 = this;\n\n      return this.request.getActiveMeetings().then(function (locusArray) {\n        var activeLocusUrl = [];\n\n        if (locusArray.loci && locusArray.loci.length > 0) {\n          locusArray.loci.forEach(function (locus) {\n            activeLocusUrl.push(locus.url);\n\n            _this8.handleLocusEvent({\n              locus: locus,\n              locusUrl: locus.url\n            });\n          });\n        }\n\n        if ((0, _keys2.default)(_this8.meetingCollection.getAll()).length > 0) {\n          // Some time the mercury event is missed after mercury reconnect\n          // if sync returns no locus then clear all the meetings\n          (0, _forEach3.default)(_this8.meetingCollection.getAll(), function (meeting) {\n            if (!activeLocusUrl.includes(meeting.locusUrl)) {\n              _this8.destroy(meeting.id, _constants.MEETING_REMOVED_REASON.NO_MEETINGS_TO_SYNC);\n            }\n          });\n        }\n      });\n    }\n    /**\n     * Get all scheduled meetings.\n     * @param {object} options\n     * @param {object} options.startDate - get meetings after this start date\n     * @param {object} options.endDate - get meetings before this end date\n     * @returns {Object} All scheduled meetings.\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'getScheduledMeetings',\n    value: function getScheduledMeetings() {\n      return this.meetingCollection.getAll({\n        scheduled: true\n      });\n    }\n    /**\n     * Get the logger instance for plugin-meetings\n     * @returns {Logger}\n     */\n\n  }, {\n    key: 'getLogger',\n    value: function getLogger() {\n      return _loggerProxy2.default.get();\n    }\n    /**\n     * Get the Stats Analyzer singleton\n     * @returns {StatsAnalyzer}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'getAnalyzer',\n    value: function getAnalyzer() {\n      return _analyzer2.default;\n    }\n    /**\n     * Get the Stats Calculator singleton\n     * @returns {StatsCalculator}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: 'getCalculator',\n    value: function getCalculator() {\n      return _calculator2.default;\n    }\n  }]);\n  return Meetings;\n}(_webexCore.WebexPlugin);\n\nexports.default = Meetings;","map":{"version":3,"sources":["index.js"],"names":["Meetings","WebexPlugin","namespace","MEETINGS","args","MeetingInfo","parent","Request","MeetingCollection","PersonalMeetingRoom","Metrics","data","meeting","LOCUS_URL","CORRELATION_ID","MeetingsUtil","SIP_URI","LOCUS","LoggerProxy","_LEFT_","_LOCUS_ID_","LOCUSEVENT","_ID_","event","eventType","trigger","Trigger","file","function","EVENT_TRIGGERS","type","_MEETING_","_JOIN_","_INCOMING_","envelope","ROAP","ONLINE","READY","StaticConfig","LoggerConfig","error","Reachability","meetingId","reason","destination","EVENTS","payload","Meeting","userId","deviceUrl","roapSeq","locus","webex","info","meetingAddedType","value","options","activeLocusUrl","locusArray","locusUrl","url","MEETING_REMOVED_REASON","scheduled","StatsAnalyzer","StatsCalculator"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA,OAAA,CAAA,gCAAA,CAAA;;AAEA,IAAA,UAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AACA,IAAA,aAAA,GAAA,OAAA,CAAA,8BAAA,CAAA;;;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;;;AACA,IAAA,YAAA,GAAA,OAAA,CAAA,6BAAA,CAAA;;;;AACA,IAAA,aAAA,GAAA,OAAA,CAAA,gCAAA,CAAA;;;;AACA,IAAA,UAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAoBA,IAAA,YAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;;;AACA,IAAA,oBAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;;;AACA,IAAA,aAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;;;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;;;AAEA,IAAA,WAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;;;AACA,IAAA,KAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;;;;;;;;AAGA;;;;;;;;AAQA;;;;;;;;AAQA;;;;;;;;;;;;AAYA;;;;;;;;;;;AAWA;;;;;AArFA;;;;;IAyFqBA,Q;;AAGjB;;;;;;;AAMA,WAAA,QAAA,GAAqB;AAAA,QAAA,IAAA;;AAAA,KAAA,GAAA,gBAAA,CAAA,OAAA,EAAA,IAAA,EAAA,QAAA;;AAAA,SAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAANI,IAAM,GAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AAANA,MAAAA,IAAM,CAAA,IAAA,CAANA,GAAM,SAAA,CAAA,IAAA,CAANA;AAAM;AAEnB;;;;;;;;;AAFmB,QAAA,KAAA,GAAA,CAAA,GAAA,2BAAA,CAAA,OAAA,EAAA,IAAA,EAAA,CAAA,IAAA,GAAA,QAAA,CAAA,SAAA,IAAA,CAAA,GAAA,gBAAA,CAAA,OAAA,EAAA,QAAA,CAAA,EAAA,IAAA,CAAA,KAAA,CAAA,IAAA,EAAA,CAAA,IAAA,EAAA,MAAA,CAAA,IAAA,CAAA,CAAA,CAAA;;AAAA,IAAA,KAAA,CARrBF,SAQqB,GARTC,UAAAA,CAAAA,QAQS;AASnB,IAAA,KAAA,CAAA,WAAA,GAAmB,IAAIE,aAAAA,CAAJ,OAAA,CAAA,EAAA,EAAoB;AAACC,MAAAA,MAAAA,EAAQ,KAAA,CAAhD;AAAuC,KAApB,CAAnB;AACA;;;;;;;;AAOA,IAAA,KAAA,CAAA,OAAA,GAAe,IAAIC,SAAAA,CAAJ,OAAA,CAAA,EAAA,EAAgB;AAACD,MAAAA,MAAAA,EAAQ,KAAA,CAAxC;AAA+B,KAAhB,CAAf;AACA,IAAA,KAAA,CAAA,iBAAA,GAAyB,IAAIE,YAAAA,CAA7B,OAAyB,EAAzB;AACA;;;;;;;;AAOA,IAAA,KAAA,CAAA,mBAAA,GAA2B,IAAIC,qBAAAA,CAAJ,OAAA,CAAA,EAAA,EAA4B;AAACH,MAAAA,MAAAA,EAAQ,KAAA,CAAhE;AAAuD,KAA5B,CAA3B;AACA;;;;;;;;;AAQA,IAAA,KAAA,CAAA,YAAA,GAAA,IAAA;AAEA;;;;;;;;AAOA,IAAA,KAAA,CAAA,UAAA,GAAA,KAAA;;AAEA,IAAA,KAAA,CAAA,OAAA;;AACAI,IAAAA,SAAAA,CAAAA,OAAAA,CAAAA,YAAAA,CAAqB,KAAA,CAArBA,iBAAAA,EAA6C,KAAA,CAAA,KAAA,CAA7CA,OAAAA;;AA/CmB,WAAA,KAAA;AAgDpB;AAED;;;;;;;;;;;;;;qCAUiBC,I,EAAM;AAAA,UAAA,MAAA,GAAA,IAAA;;AACrB,UAAIC,OAAAA,GAAJ,IAAA,CADqB,CAGrB;AACA;AACA;;AACAA,MAAAA,OAAAA,GAAU,KAAA,iBAAA,CAAA,QAAA,CAAgCC,UAAAA,CAAhC,SAAA,EAA2CF,IAAAA,CAA3C,QAAA,KACV,KAAA,iBAAA,CAAA,QAAA,CAAgCG,UAAAA,CAAhC,cAAA,EAAgDC,MAAAA,CAAAA,OAAAA,CAAAA,qBAAAA,CAAmC,KAAA,KAAA,CAAA,QAAA,CAAA,MAAA,CAAnCA,GAAAA,EAAmEJ,IAAAA,CADzG,KACsCI,CAAhD,CADU,IAEV,KAAA,iBAAA,CAAA,QAAA,CAAgCC,UAAAA,CAAhC,OAAA,EAAyCL,IAAAA,CAAAA,KAAAA,CAAAA,IAAAA,IAAmBA,IAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAnBA,YAAAA,IAAmDA,IAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,YAAAA,CAF5FC,eAEA,CAFAA;;AAIA,UAAI,CAAJ,OAAA,EAAc;AACZ;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA,YAAID,IAAAA,CAAAA,KAAAA,IAAcA,IAAAA,CAAAA,KAAAA,CAAdA,SAAAA,IAAsCA,IAAAA,CAAAA,KAAAA,CAAAA,SAAAA,CAAAA,KAAAA,KAA+BM,UAAAA,CAAAA,KAAAA,CAAAA,KAAAA,CAAzE,QAAA,EAA+F;AAC7F;AACAC,UAAAA,aAAAA,CAAAA,OAAAA,CAAAA,MAAAA,CAAAA,IAAAA,CAAAA,kFAAAA;;AAEA;AACD,SAzBW,CA4BZ;AACA;;;AAEA,YAAIP,IAAAA,CAAAA,KAAAA,IAAcA,IAAAA,CAAAA,KAAAA,CAAdA,IAAAA,IAAkCA,IAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,KAAAA,KAA0BQ,UAAAA,CAA1BR,MAAlCA,IAAsEA,IAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,OAAAA,KAA1E,IAAA,EAA6G;AAC3G;AACAO,UAAAA,aAAAA,CAAAA,OAAAA,CAAAA,MAAAA,CAAAA,IAAAA,CAAAA,kFAAAA;;AAEA;AACD;;AAED,aAAA,MAAA,CAAYP,IAAAA,CAAZ,KAAA,EAAwBS,UAAAA,CAAxB,UAAA,EAAA,IAAA,CAAyC,UAAA,UAAA,EAAgB;AACvDR,UAAAA,OAAAA,GAAAA,UAAAA;;AAEA,cAAID,IAAAA,CAAAA,SAAAA,KAAmBU,UAAAA,CAAAA,UAAAA,CAAvB,UAAA,EAA8C;AAC5C;AACAT,YAAAA,OAAAA,CAAAA,SAAAA,CAAAA,YAAAA,CAA+BD,IAAAA,CAA/BC,KAAAA,EAAAA,OAAAA;AAFF,WAAA,MAIK;AACH;AACAA,YAAAA,OAAAA,CAAAA,SAAAA,CAAAA,YAAAA,CAA+BD,IAAAA,CAA/BC,KAAAA;AACD;AAVH,SAAA,EAAA,OAAA,CAYW,YAAM;AACb;AACA;AAEA,cAAI,MAAA,CAAA,gBAAA,CAAsBU,UAAAA,CAAtB,IAAA,EAA4BV,OAAAA,CAAhC,EAAI,CAAJ,EAA6C;AAC7C;AACEF,YAAAA,SAAAA,CAAAA,OAAAA,CAAAA,SAAAA,CAAkB;AAACa,cAAAA,KAAAA,EAAOC,OAAAA,CAAAA,SAAAA,CAAR,qBAAA;AAAyCZ,cAAAA,OAAAA,EAAzC,OAAA;AAAkDD,cAAAA,IAAAA,EAAM;AAACc,gBAAAA,OAAAA,EAASA,OAAAA,CAAAA,OAAAA,CAApFf;AAA0E;AAAxD,aAAlBA;;AAEAA,YAAAA,SAAAA,CAAAA,OAAAA,CAAAA,SAAAA,CAAkB;AAACa,cAAAA,KAAAA,EAAOC,OAAAA,CAAAA,SAAAA,CAAR,cAAA;AAAkCZ,cAAAA,OAAAA,EAAlC,OAAA;AAA2CD,cAAAA,IAAAA,EAAM;AAACc,gBAAAA,OAAAA,EAASA,OAAAA,CAAAA,OAAAA,CAA7Ef;AAAmE;AAAjD,aAAlBA;;AACAgB,YAAAA,cAAAA,CAAAA,OAAAA,CAAAA,OAAAA,CAAAA,MAAAA,EAEE;AACEC,cAAAA,IAAAA,EADF,UAAA;AAEEC,cAAAA,QAAAA,EAAU;AAFZ,aAFFF,EAMEG,UAAAA,CAAAA,cAAAA,CANFH,aAAAA,EAOE;AACEd,cAAAA,OAAAA,EADF,OAAA;AAEEkB,cAAAA,IAAAA,EAAMlB,OAAAA,CAAAA,IAAAA,KAAiBmB,UAAAA,CAAjBnB,SAAAA,GAA6BoB,UAAAA,CAA7BpB,MAAAA,GAAsCqB,UAAAA,CAAAA;AAF9C,aAPFP;AALF,WAAA,MAkBK;AACH;AACAR,YAAAA,aAAAA,CAAAA,OAAAA,CAAAA,MAAAA,CAAAA,IAAAA,CAAAA,yFAAAA;AACD;AArCL,SAAA;AAtCF,OAAA,MA8EK;AACHR,QAAAA,SAAAA,CAAAA,OAAAA,CAAAA,SAAAA,CAAkB;AAACa,UAAAA,KAAAA,EAAOC,OAAAA,CAAAA,SAAAA,CAAR,qBAAA;AAAyCZ,UAAAA,OAAAA,EAAzC,OAAA;AAAkDD,UAAAA,IAAAA,EAAM;AAACc,YAAAA,OAAAA,EAASA,OAAAA,CAAAA,OAAAA,CAApFf;AAA0E;AAAxD,SAAlBA;;AACAE,QAAAA,OAAAA,CAAAA,SAAAA,CAAAA,KAAAA,CAAAA,OAAAA,EAAAA,IAAAA;AACD;AACF;AAED;;;;;;;;;;;;uCASmBsB,Q,EAAU;AAAA,UACpBvB,IADoB,GACZuB,QADY,CAAA,IAAA;AAAA,UAEpBV,SAFoB,GAEPb,IAFO,CAAA,SAAA;;AAI3B,UAAIa,SAAAA,IAAaA,SAAAA,KAAcH,UAAAA,CAAAA,UAAAA,CAA/B,YAAA,EAAwD;AACtD,aAAA,gBAAA,CAAA,IAAA;AACD;AACF;AAED;;;;;;;;;sCAMkB;AAAA,UAAA,MAAA,GAAA,IAAA;;AAChB,WAAA,KAAA,CAAA,QAAA,CAAA,OAAA,CAAA,EAAA,CAA+BA,UAAAA,CAAAA,UAAAA,CAA/B,aAAA,EAAyD,UAAA,QAAA,EAAc;AACrE,QAAA,MAAA,CAAA,kBAAA,CAAA,QAAA;AADF,OAAA;AAGA,WAAA,KAAA,CAAA,QAAA,CAAA,OAAA,CAAA,EAAA,CAA+Bc,UAAAA,CAAAA,IAAAA,CAA/B,YAAA,EAAkD,UAAA,QAAA,EAAc;AAC9DpB,QAAAA,MAAAA,CAAAA,OAAAA,CAAAA,iBAAAA,CAAAA,QAAAA,EAAyC,MAAA,CAAzCA,iBAAAA;AADF,OAAA;AAIA,WAAA,KAAA,CAAA,QAAA,CAAA,OAAA,CAAA,EAAA,CAA+BqB,UAAAA,CAA/B,MAAA,EAAuC,YAAM;AAC3C,QAAA,MAAA,CAAA,YAAA;AADF,OAAA;AAGD;AAED;;;;;;;;;6CAMyB;AACvB,WAAA,KAAA,CAAA,QAAA,CAAA,OAAA,CAAA,GAAA,CAAgCf,UAAAA,CAAAA,UAAAA,CAAhC,aAAA;AACA,WAAA,KAAA,CAAA,QAAA,CAAA,OAAA,CAAA,GAAA,CAAgCc,UAAAA,CAAAA,IAAAA,CAAhC,YAAA;AACA,WAAA,KAAA,CAAA,QAAA,CAAA,OAAA,CAAA,GAAA,CAAgCC,UAAAA,CAAhC,MAAA;AACD;AAED;;;;;;;;8BAKU;AAAA,UAAA,MAAA,GAAA,IAAA;;AACR,WAAA,KAAA,CAAA,IAAA,CAAgBC,UAAAA,CAAhB,KAAA,EAAuB,YAAM;AAC3BC,QAAAA,QAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAAiB,MAAA,CAAjBA,MAAAA;;AACAC,QAAAA,cAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAAiB,MAAA,CAAA,MAAA,CAAjBA,OAAAA;;AACArB,QAAAA,aAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAAgB,MAAA,CAAA,KAAA,CAAhBA,MAAAA;;AACAQ,QAAAA,cAAAA,CAAAA,OAAAA,CAAAA,OAAAA,CAAAA,MAAAA,EAEE;AACEC,UAAAA,IAAAA,EADF,UAAA;AAEEC,UAAAA,QAAAA,EAAU;AAFZ,SAFFF,EAMEG,UAAAA,CAAAA,cAAAA,CANFH,cAAAA;AAJF,OAAA;AAaD;AAED;;;;;;;;;;;+BAQW;AAAA,UAAA,MAAA,GAAA,IAAA;;AACT,UAAI,CAAC,KAAA,KAAA,CAAL,YAAA,EAA8B;AAC5BR,QAAAA,aAAAA,CAAAA,OAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAAA,oEAAAA;;AAEA,eAAO,SAAA,CAAA,OAAA,CAAA,MAAA,CAAe,IAAA,KAAA,CAAtB,sBAAsB,CAAf,CAAP;AACD;;AAED,UAAI,KAAJ,UAAA,EAAqB;AACnBA,QAAAA,aAAAA,CAAAA,OAAAA,CAAAA,MAAAA,CAAAA,IAAAA,CAAAA,6DAAAA;;AAEA,eAAO,SAAA,CAAA,OAAA,CAAP,OAAO,EAAP;AACD;;AAED,aAAO,KAAA,KAAA,CAAA,QAAA,CAAA,MAAA,CAAA,QAAA,GAAA,IAAA,CACC,YAAA;AAAA,eAAM,MAAA,CAAA,KAAA,CAAA,QAAA,CAAA,OAAA,CAAN,OAAM,EAAN;AADD,OAAA,EAAA,IAAA,CAEC,YAAM;AACV,QAAA,MAAA,CAAA,eAAA;;AACAQ,QAAAA,cAAAA,CAAAA,OAAAA,CAAAA,OAAAA,CAAAA,MAAAA,EAEE;AACEC,UAAAA,IAAAA,EADF,UAAA;AAEEC,UAAAA,QAAAA,EAAU;AAFZ,SAFFF,EAMEG,UAAAA,CAAAA,cAAAA,CANFH,mBAAAA;;AAQA,QAAA,MAAA,CAAA,UAAA,GAAA,IAAA;AAZG,OAAA,EAAA,KAAA,CAcE,UAAA,KAAA,EAAW;AAChBR,QAAAA,aAAAA,CAAAA,OAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAAA,mDAA0EsB,KAAAA,CAA1EtB,OAAAA;;AAEA,eAAO,SAAA,CAAA,OAAA,CAAA,MAAA,CAAP,KAAO,CAAP;AAjBJ,OAAO,CAAP;AAmBD;AAED;;;;;;;;;;;iCAQa;AAAA,UAAA,MAAA,GAAA,IAAA;;AACX,UAAI,CAAC,KAAL,UAAA,EAAsB;AACpBA,QAAAA,aAAAA,CAAAA,OAAAA,CAAAA,MAAAA,CAAAA,IAAAA,CAAAA,iEAAAA;;AAEA,eAAO,SAAA,CAAA,OAAA,CAAP,OAAO,EAAP;AACD;;AAED,WAAA,sBAAA;AAEA,aAAO,KAAA,KAAA,CAAA,QAAA,CAAA,OAAA,CAAA,UAAA,GAAA,IAAA,CACC,YAAA;AAAA,eAAM,MAAA,CAAA,KAAA,CAAA,QAAA,CAAA,MAAA,CAAN,UAAM,EAAN;AADD,OAAA,EAAA,IAAA,CAEC,YAAM;AACVQ,QAAAA,cAAAA,CAAAA,OAAAA,CAAAA,OAAAA,CAAAA,MAAAA,EAEE;AACEC,UAAAA,IAAAA,EADF,UAAA;AAEEC,UAAAA,QAAAA,EAAU;AAFZ,SAFFF,EAMEG,UAAAA,CAAAA,cAAAA,CANFH,qBAAAA;;AAQA,QAAA,MAAA,CAAA,UAAA,GAAA,KAAA;AAXJ,OAAO,CAAP;AAaD;AAED;;;;;;;;;sCAMkB;AAChB,WAAA,YAAA,GAAoB,IAAIe,cAAAA,CAAJ,OAAA,CAAA,EAAA,EAAqB;AAACnC,QAAAA,MAAAA,EAAQ,KAAlD;AAAyC,OAArB,CAApB;AACD;AAED;;;;;;;;;sCAMkB;AAChB,aAAO,KAAP,YAAA;AACD;AAED;;;;;;;;;wCAMoB;AAClB,UAAI,CAAC,KAAL,YAAA,EAAwB;AACtB,aAAA,eAAA;AACD;;AACD,WAAA,eAAA,GAAA,kBAAA;AACD;AAED;;;;;;;;;6CAMyB;AACvB,aAAO,KAAP,mBAAA;AACD;AAED;;;;;;;;;;;4BAQQoC,S,EAAWC,M,EAAQ;AACzB,WAAA,iBAAA,CAAA,MAAA,CAAA,SAAA;;AACAjB,MAAAA,cAAAA,CAAAA,OAAAA,CAAAA,OAAAA,CAAAA,IAAAA,EAEE;AACEC,QAAAA,IAAAA,EADF,UAAA;AAEEC,QAAAA,QAAAA,EAAU;AAFZ,OAFFF,EAMEG,UAAAA,CAAAA,cAAAA,CANFH,eAAAA,EAOE;AACEgB,QAAAA,SAAAA,EADF,SAAA;AAEEC,QAAAA,MAAAA,EAAAA;AAFF,OAPFjB;AAYD;AAED;;;;;;;;;;;2BAQOkB,W,EAA0B;AAAA,UAAA,MAAA,GAAA,IAAA;;AAAA,UAAbd,IAAa,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAN,IAAM,CAAA,CAC/B;AACA;;AACA,UAAMlB,OAAAA,GAAU,KAAA,iBAAA,CAAA,QAAA,CAAgCI,UAAAA,CAAhC,OAAA,EAAhB,WAAgB,CAAhB;;AAEA,UAAI,CAAJ,OAAA,EAAc;AACZ,eAAO,KAAA,aAAA,CAAA,WAAA,EAAA,IAAA,EAAA,IAAA,CACC,UAAA,OAAA,EAAa;AACjB,cAAIJ,OAAAA,IAAWA,OAAAA,CAAf,EAAA,EAA2B;AACzBA,YAAAA,OAAAA,CAAAA,EAAAA,CAAWiC,UAAAA,CAAAA,MAAAA,CAAXjC,eAAAA,EAAmC,UAAA,OAAA,EAAa;AAC9C,cAAA,MAAA,CAAA,OAAA,CAAakC,OAAAA,CAAb,SAAA,EAAgCA,OAAAA,CAAhC,MAAA;AADFlC,aAAAA;AADF,WAAA,MAKK;AACHM,YAAAA,aAAAA,CAAAA,OAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAAA,6HAAAA,OAAAA;AACD;;AAED,iBAAO,SAAA,CAAA,OAAA,CAAA,OAAA,CAAP,OAAO,CAAP;AAXJ,SAAO,CAAP;AAaD;;AAED,aAAO,SAAA,CAAA,OAAA,CAAA,OAAA,CAAP,OAAO,CAAP;AACD;AAED;;;;;;;;;;;4GAOoB0B,W;YAAad,I,uEAAO,I;;;;;;AAChClB,gBAAAA,O,GAAU,IAAImC,SAAAA,CAAJ,OAAA,CACd;AACEC,kBAAAA,MAAAA,EAAQ,KAAA,KAAA,CAAA,QAAA,CAAA,MAAA,CADV,MAAA;AAEEC,kBAAAA,SAAAA,EAAW,KAAA,KAAA,CAAA,QAAA,CAAA,MAAA,CAFb,GAAA;AAGEC,kBAAAA,OAAAA,EAHF,CAAA;AAIEC,kBAAAA,KAAAA,EAAOrB,IAAAA,KAASV,UAAAA,CAATU,UAAAA,GAAAA,WAAAA,GAJT,IAAA,CAIkD;;AAJlD,iBADc,EAOd;AACExB,kBAAAA,MAAAA,EAAQ,KAAK8C;AADf,iBAPc,CAAVxC;AAYN,qBAAA,iBAAA,CAAA,GAAA,CAAA,OAAA;;;uBAGqB,KAAA,WAAA,CAAA,gBAAA,CAAkCG,MAAAA,CAAAA,OAAAA,CAAAA,kBAAAA,CAAAA,WAAAA,EAAlC,IAAkCA,CAAlC,EAAA,IAAA,C;;;AAAbsC,gBAAAA,I,gBAAAA;AAENzC,gBAAAA,OAAAA,CAAAA,gBAAAA,CAAAA,IAAAA;AACAA,gBAAAA,OAAAA,CAAAA,WAAAA,GAAsByC,IAAAA,GAAOA,IAAAA,CAAPA,IAAAA,GAAtBzC,IAAAA;;;;;;oDAGA;;AACAM,gBAAAA,aAAAA,CAAAA,OAAAA,CAAAA,MAAAA,CAAAA,IAAAA,CAAAA,mEAAAA,WAAAA,GAAAA,GAAAA;;AACAA,gBAAAA,aAAAA,CAAAA,OAAAA,CAAAA,MAAAA,CAAAA,IAAAA,CAAAA,mFAAAA;;AACAA,gBAAAA,aAAAA,CAAAA,OAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAAA,mCAAAA,QAAAA,CAAAA,EAAAA,GAAAA,sCAAAA,E,CACA;;;AACAN,gBAAAA,OAAAA,CAAAA,WAAAA,GAAAA,WAAAA;;;oCAGA;AACA;AACA;;AACA,oBAAIkB,IAAAA,KAASV,UAAAA,CAAb,UAAA,EAAyB;AACvB,sBAAI,CAACR,OAAAA,CAAL,MAAA,EAAqB;AACnBA,oBAAAA,OAAAA,CAAAA,SAAAA,CAAAA,WAAAA;AACD,mBAHsB,CAKvB;;;AACM0C,kBAAAA,gBANiB,GAMEvC,MAAAA,CAAAA,OAAAA,CAAAA,mBAAAA,CANF,IAMEA,CAAnBuC,CANiB,CAQvB;AACA;;AACA5B,kBAAAA,cAAAA,CAAAA,OAAAA,CAAAA,OAAAA,CAAAA,IAAAA,EAEE;AACEC,oBAAAA,IAAAA,EADF,UAAA;AAEEC,oBAAAA,QAAAA,EAAU;AAFZ,mBAFFF,EAMEG,UAAAA,CAAAA,cAAAA,CANFH,aAAAA,EAOE;AACEd,oBAAAA,OAAAA,EADF,OAAA;AAEEkB,oBAAAA,IAAAA,EAAMwB;AAFR,mBAPF5B;AAYD;;;;;iDAGId,O;;;;;;;;;;;;;;;;AAqBT;;;;;;;;;;;qCAQiBkB,I,EAAMyB,K,EAAO;AAC5B,aAAO,KAAA,iBAAA,CAAA,QAAA,CAAA,IAAA,EAAP,KAAO,CAAP;AACD;AAED;;;;;;;;;;;;qCAS6B;AAAA,UAAdC,OAAc,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI,CAAA,CAC3B;AACA;;AACA,aAAO,KAAA,iBAAA,CAAA,MAAA,CAAP,OAAO,CAAP;AACD;AAED;;;;;;;;;mCAMe;AAAA,UAAA,MAAA,GAAA,IAAA;;AACb,aAAO,KAAA,OAAA,CAAA,iBAAA,GAAA,IAAA,CAAsC,UAAA,UAAA,EAAgB;AAC3D,YAAMC,cAAAA,GAAN,EAAA;;AAEA,YAAIC,UAAAA,CAAAA,IAAAA,IAAmBA,UAAAA,CAAAA,IAAAA,CAAAA,MAAAA,GAAvB,CAAA,EAAmD;AACjDA,UAAAA,UAAAA,CAAAA,IAAAA,CAAAA,OAAAA,CAAwB,UAAA,KAAA,EAAW;AACjCD,YAAAA,cAAAA,CAAAA,IAAAA,CAAoBN,KAAAA,CAApBM,GAAAA;;AACA,YAAA,MAAA,CAAA,gBAAA,CAAsB;AACpBN,cAAAA,KAAAA,EADoB,KAAA;AAEpBQ,cAAAA,QAAAA,EAAUR,KAAAA,CAAMS;AAFI,aAAtB;AAFFF,WAAAA;AAOD;;AACD,YAAI,CAAA,GAAA,MAAA,CAAA,OAAA,EAAY,MAAA,CAAA,iBAAA,CAAZ,MAAY,EAAZ,EAAA,MAAA,GAAJ,CAAA,EAA6D;AAC3D;AACA;AACA,WAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,MAAA,CAAA,iBAAA,CAAR,MAAQ,EAAR,EAAyC,UAAA,OAAA,EAAa;AACpD,gBAAI,CAACD,cAAAA,CAAAA,QAAAA,CAAwB7C,OAAAA,CAA7B,QAAK6C,CAAL,EAAgD;AAC9C,cAAA,MAAA,CAAA,OAAA,CAAa7C,OAAAA,CAAb,EAAA,EAAyBiD,UAAAA,CAAAA,sBAAAA,CAAzB,mBAAA;AACD;AAHH,WAAA;AAKD;AApBH,OAAO,CAAP;AAsBD;AAED;;;;;;;;;;;2CAQuB;AACrB,aAAO,KAAA,iBAAA,CAAA,MAAA,CAA8B;AAACC,QAAAA,SAAAA,EAAtC;AAAqC,OAA9B,CAAP;AACD;AAED;;;;;;;gCAIY;AACV,aAAO5C,aAAAA,CAAAA,OAAAA,CAAP,GAAOA,EAAP;AACD;AAED;;;;;;;;;kCAMc;AACZ,aAAO6C,UAAAA,CAAP,OAAA;AACD;AAED;;;;;;;;;oCAMgB;AACd,aAAOC,YAAAA,CAAP,OAAA;AACD;;;EA5kBiC/D,UAAAA,CAAAA,W;;kBAAjBD,Q","sourcesContent":["/*!\n  * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n*/\n\nimport '@webex/internal-plugin-mercury';\nimport {forEach} from 'lodash';\nimport {WebexPlugin} from '@webex/webex-core';\n\nimport Metrics from '../metrics';\nimport {trigger, eventType} from '../metrics/config';\nimport LoggerConfig from '../common/logs/logger-config';\nimport StaticConfig from '../common/config';\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport Trigger from '../common/events/trigger-proxy';\nimport {\n  MEETINGS,\n  EVENTS,\n  EVENT_TRIGGERS,\n  READY,\n  LOCUSEVENT,\n  LOCUS_URL,\n  ROAP,\n  ONLINE,\n  _MEETING_,\n  _JOIN_,\n  _LOCUS_ID_,\n  _INCOMING_,\n  LOCUS,\n  CORRELATION_ID,\n  SIP_URI,\n  _LEFT_,\n  _ID_,\n  MEETING_REMOVED_REASON\n} from '../constants';\nimport MeetingInfo from '../meeting-info';\nimport Meeting from '../meeting';\nimport PersonalMeetingRoom from '../personal-meeting-room';\nimport Reachability from '../reachability';\nimport Request from '../meetings/request';\nimport StatsAnalyzer from '../analyzer/analyzer';\nimport StatsCalculator from '../analyzer/calculator';\n\nimport MeetingCollection from './collection';\nimport MeetingsUtil from './util';\n\n\n/**\n   * Meetings Ready Event\n   * Emitted when the meetings instance on webex is ready\n   * @event meetings:ready\n   * @instance\n   * @memberof Meetings\n   */\n\n/**\n * Meetings Registered Event\n * Emitted when the meetings instance has been registered and listening\n * @event meetings:registered\n * @instance\n * @memberof Meetings\n */\n\n/**\n    * Meeting Removed Event\n    * Emitted when a meeting was removed from the cache of meetings\n    * @event meeting:removed\n    * @instance\n    * @type {Object}\n    * @property {String} meetingId the removed meeting\n    * @property {Object} response the server response\n    * @property {String} type what type of meeting it was\n    * @memberof Meetings\n    */\n\n/**\n    * Meeting Added Event\n    * Emitted when a meeting was added to the cache of meetings\n    * @event meeting:added\n    * @instance\n    * @type {Object}\n    * @property {String} meetingId the added meeting\n    * @property {String} type what type of meeting it was\n    * @memberof Meetings\n    */\n\n/**\n   * Maintain a cache of meetings and sync with services.\n   * @class\n   */\nexport default class Meetings extends WebexPlugin {\n    namespace = MEETINGS;\n\n    /**\n     * Initializes the Meetings Plugin\n     * @constructor\n     * @public\n     * @memberof Meetings\n     */\n    constructor(...args) {\n      super(...args);\n      /**\n       * The MeetingInfo object to interact with server\n       * @instance\n       * @type {Object}\n       * @private\n       * @memberof Meetings\n       */\n      this.meetingInfo = new MeetingInfo({}, {parent: this.webex});\n      /**\n       * The Meetings request to interact with server\n       * @instance\n       * @type {Object}\n       * @private\n       * @memberof Meetings\n       */\n      this.request = new Request({}, {parent: this.webex});\n      this.meetingCollection = new MeetingCollection();\n      /**\n       * The PersonalMeetingRoom object to interact with server\n       * @instance\n       * @type {Object}\n       * @public\n       * @memberof Meetings\n       */\n      this.personalMeetingRoom = new PersonalMeetingRoom({}, {parent: this.webex});\n      /**\n       * The Reachability object to interact with server, starts as null until {@link Meeting#setReachability} is called\n       * starts as null\n       * @instance\n       * @type {Object}\n       * @private\n       * @memberof Meetings\n       */\n      this.reachability = null;\n\n      /**\n       * If the meetings plugin has been registered and listening via {@link Meetings#register}\n       * @instance\n       * @type {Boolean}\n       * @public\n       * @memberof Meetings\n       */\n      this.registered = false;\n\n      this.onReady();\n      Metrics.initialSetup(this.meetingCollection, this.webex.version);\n    }\n\n    /**\n     * handle locus events and takes meeting actions with them as they come in\n     * @param {Object} data a locus event\n     * @param {String} data.locusUrl\n     * @param {Object} data.locus\n     * @param {String} data.eventType\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n    handleLocusEvent(data) {\n      let meeting = null;\n\n      // getting meeting by correlationId. This will happen for the new event\n      // Either the locus\n      // TODO : Add check for the callBack Address\n      meeting = this.meetingCollection.getByKey(LOCUS_URL, data.locusUrl) ||\n      this.meetingCollection.getByKey(CORRELATION_ID, MeetingsUtil.checkForCorrelationId(this.webex.internal.device.url, data.locus)) ||\n      this.meetingCollection.getByKey(SIP_URI, data.locus.self && data.locus.self.callbackInfo && data.locus.self.callbackInfo.callbackAddress);\n\n      if (!meeting) {\n        // TODO: create meeting when we get a meeting object\n        // const checkForEnded = (locus) => {\n        // TODO: you already ended the meeting but you got an event later\n        // Mainly for 1:1 Callsor meeting\n        // Happens mainly after refresh\n\n        // 1:1 Meeting\n        // 1)  You ended a call before but you got a mercury event\n        // Make sure end the call and cleanup the meeting only if the mercury\n        // event says so\n        // 2) Maintain lastSync time in the meetings object which helps to compare\n        // If the meeting came befor or after the sync . ANy meeting start time before the sync time is invalid\n\n        // For space Meeting\n        // Check the locus object and see who has joined\n\n        // };\n        // rather then locus object change to locus url\n\n        if (data.locus && data.locus.fullState && data.locus.fullState.state === LOCUS.STATE.INACTIVE) {\n          // just ignore the event as its already ended and not active\n          LoggerProxy.logger.warn('Meetings->handleLocusEvent#Locus event received for meeting, after it was ended.');\n\n          return;\n        }\n\n\n        // When its wireless share or guest and user leaves the meeting we dont have to keep the meeting object\n        // Any future events will be neglected\n\n        if (data.locus && data.locus.self && (data.locus.self.state === _LEFT_ && data.locus.self.removed === true)) {\n          // just ignore the event as its already ended and not active\n          LoggerProxy.logger.warn('Meetings->handleLocusEvent#Locus event received for meeting, after it was ended.');\n\n          return;\n        }\n\n        this.create(data.locus, _LOCUS_ID_).then((newMeeting) => {\n          meeting = newMeeting;\n\n          if (data.eventType === LOCUSEVENT.DIFFERENCE) {\n            // its a delta object and we have a new meeting\n            meeting.locusInfo.initialSetup(data.locus, meeting);\n          }\n          else {\n            // Its a new meeting and have a fresh locus object\n            meeting.locusInfo.initialSetup(data.locus);\n          }\n        })\n          .finally(() => {\n            // There will be cases where locus event comes in gets created and deleted because its a 1:1 and meeting gets deleted\n            // because the other user left so before sending 'added' event make sure it exists in the collection\n\n            if (this.getMeetingByType(_ID_, meeting.id)) {\n            // Had to put `meeting:added here as the parsing of the locus object is done here\n              Metrics.postEvent({event: eventType.NOTIFICATION_RECEIVED, meeting, data: {trigger: trigger.MERCURY_EVENT}});\n\n              Metrics.postEvent({event: eventType.REMOTE_STARTED, meeting, data: {trigger: trigger.MERCURY_EVENT}});\n              Trigger.trigger(\n                this,\n                {\n                  file: 'meetings',\n                  function: 'handleLocusEvent'\n                },\n                EVENT_TRIGGERS.MEETING_ADDED,\n                {\n                  meeting,\n                  type: meeting.type === _MEETING_ ? _JOIN_ : _INCOMING_\n                }\n              );\n            }\n            else {\n              // Meeting got added but was not found in the collection. It might have got destroyed\n              LoggerProxy.logger.warn('Meetings->handleLocusEvent#Created and destroyed meeting object before sending an event');\n            }\n          });\n      }\n      else {\n        Metrics.postEvent({event: eventType.NOTIFICATION_RECEIVED, meeting, data: {trigger: trigger.MERCURY_EVENT}});\n        meeting.locusInfo.parse(meeting, data);\n      }\n    }\n\n    /**\n     * handles locus events through mercury that are not roap\n     * @param {Object} envelope\n     * @param {Object} envelope.data\n     * @param {String} envelope.data.eventType\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n    handleLocusMercury(envelope) {\n      const {data} = envelope;\n      const {eventType} = data;\n\n      if (eventType && eventType !== LOCUSEVENT.MESSAGE_ROAP) {\n        this.handleLocusEvent(data);\n      }\n    }\n\n    /**\n     * registers for locus and roap mercury events\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n    listenForEvents() {\n      this.webex.internal.mercury.on(LOCUSEVENT.LOCUS_MERCURY, (envelope) => {\n        this.handleLocusMercury(envelope);\n      });\n      this.webex.internal.mercury.on(ROAP.ROAP_MERCURY, (envelope) => {\n        MeetingsUtil.handleRoapMercury(envelope, this.meetingCollection);\n      });\n\n      this.webex.internal.mercury.on(ONLINE, () => {\n        this.syncMeetings();\n      });\n    }\n\n    /**\n     * stops listening for locus and roap mercury events\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n    stopListeningForEvents() {\n      this.webex.internal.mercury.off(LOCUSEVENT.LOCUS_MERCURY);\n      this.webex.internal.mercury.off(ROAP.ROAP_MERCURY);\n      this.webex.internal.mercury.off(ONLINE);\n    }\n\n    /**\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n    onReady() {\n      this.webex.once(READY, () => {\n        StaticConfig.set(this.config);\n        LoggerConfig.set(this.config.logging);\n        LoggerProxy.set(this.webex.logger);\n        Trigger.trigger(\n          this,\n          {\n            file: 'meetings',\n            function: 'onReady'\n          },\n          EVENT_TRIGGERS.MEETINGS_READY\n        );\n      });\n    }\n\n    /**\n     * Explicitly sets up the meetings plugin by registering\n     * the device, connecting to mercury, and listening for locus events.\n     *\n     * @returns {Promise}\n     * @public\n     * @memberof Meetings\n     */\n    register() {\n      if (!this.webex.canAuthorize) {\n        LoggerProxy.logger.error('meetings->register#ERROR, Unable to register, SDK cannot authorize');\n\n        return Promise.reject(new Error('SDK cannot authorize'));\n      }\n\n      if (this.registered) {\n        LoggerProxy.logger.info('meetings->register#INFO, Meetings plugin already registered');\n\n        return Promise.resolve();\n      }\n\n      return this.webex.internal.device.register()\n        .then(() => this.webex.internal.mercury.connect())\n        .then(() => {\n          this.listenForEvents();\n          Trigger.trigger(\n            this,\n            {\n              file: 'meetings',\n              function: 'register'\n            },\n            EVENT_TRIGGERS.MEETINGS_REGISTERED\n          );\n          this.registered = true;\n        })\n        .catch((error) => {\n          LoggerProxy.logger.error(`meetings->register#ERROR, Unable to register, ${error.message}`);\n\n          return Promise.reject(error);\n        });\n    }\n\n    /**\n     * Explicitly tears down the meetings plugin by deregistering\n     * the device, disconnecting from mercury, and stops listening to locus events\n     *\n     * @returns {Promise}\n     * @public\n     * @memberof Meetings\n     */\n    unregister() {\n      if (!this.registered) {\n        LoggerProxy.logger.info('meetings->unregister#INFO, Meetings plugin already unregistered');\n\n        return Promise.resolve();\n      }\n\n      this.stopListeningForEvents();\n\n      return this.webex.internal.mercury.disconnect()\n        .then(() => this.webex.internal.device.unregister())\n        .then(() => {\n          Trigger.trigger(\n            this,\n            {\n              file: 'meetings',\n              function: 'unregister'\n            },\n            EVENT_TRIGGERS.MEETINGS_UNREGISTERED\n          );\n          this.registered = false;\n        });\n    }\n\n    /**\n     * initializes the reachability instance for Meetings\n     * @returns {undefined}\n     * @public\n     * @memberof Meetings\n     */\n    setReachability() {\n      this.reachability = new Reachability({}, {parent: this.webex});\n    }\n\n    /**\n     * gets the reachability instance for Meetings\n     * @returns {Reachability}\n     * @public\n     * @memberof Meetings\n     */\n    getReachability() {\n      return this.reachability;\n    }\n\n    /**\n     * initializes and starts gathering reachability for Meetings\n     * @returns {undefined}\n     * @public\n     * @memberof Meetings\n     */\n    startReachability() {\n      if (!this.reachability) {\n        this.setReachability();\n      }\n      this.getReachability().gatherReachability();\n    }\n\n    /**\n     * gets the personal meeting room instance, for saved PMR values for this user\n     * @returns {PersonalMeetingRoom}\n     * @public\n     * @memberof Meetings\n     */\n    getPersonalMeetingRoom() {\n      return this.personalMeetingRoom;\n    }\n\n    /**\n     * @param {String} meetingId\n     * @param {Object} reason\n     * @param {String} type\n     * @returns {Undefined}\n     * @private\n     * @memberof Meetings\n     */\n    destroy(meetingId, reason) {\n      this.meetingCollection.delete(meetingId);\n      Trigger.trigger(\n        this,\n        {\n          file: 'meetings',\n          function: 'destroy'\n        },\n        EVENT_TRIGGERS.MEETING_REMOVED,\n        {\n          meetingId,\n          reason\n        }\n      );\n    }\n\n    /**\n     * Create a meeting.\n     * @param {string} destination - sipURL, spaceId, phonenumber, meeting link, or locus object}\n     * @param {string} [type] - the optional specified type, such as locusId\n     * @returns {Promise} A new Meeting.\n     * @public\n     * @memberof Meetings\n     */\n    create(destination, type = null) {\n      // TODO: type should be from a dictionary\n      // Check if there is already meeting\n      const meeting = this.meetingCollection.getByKey(SIP_URI, destination);\n\n      if (!meeting) {\n        return this.createMeeting(destination, type)\n          .then((meeting) => {\n            if (meeting && meeting.on) {\n              meeting.on(EVENTS.DESTROY_MEETING, (payload) => {\n                this.destroy(payload.meetingId, payload.reason);\n              });\n            }\n            else {\n              LoggerProxy.logger.error(`meetings->create#ERROR, meeting does not have on method, will not be destroyed, meeting cleanup impossible for meeting: ${meeting}`);\n            }\n\n            return Promise.resolve(meeting);\n          });\n      }\n\n      return Promise.resolve(meeting);\n    }\n\n    /**\n     * @param {String} destination see create()\n     * @param {String} type see create()\n     * @returns {Promise} a new meeting instance complete with meeting info and destination\n     * @private\n     * @memberof Meetings\n     */\n    async createMeeting(destination, type = null) {\n      const meeting = new Meeting(\n        {\n          userId: this.webex.internal.device.userId,\n          deviceUrl: this.webex.internal.device.url,\n          roapSeq: 0,\n          locus: type === _LOCUS_ID_ ? destination : null // pass the locus object if present\n        },\n        {\n          parent: this.webex\n        }\n      );\n\n      this.meetingCollection.set(meeting);\n\n      try {\n        const info = await this.meetingInfo.fetchMeetingInfo(MeetingsUtil.extractDestination(destination, type), type);\n\n        meeting.parseMeetingInfo(info);\n        meeting.meetingInfo = info ? info.body : null;\n      }\n      catch (err) {\n        // if there is no meeting info we assume its a 1:1 call or wireless share\n        LoggerProxy.logger.info(`Meetings->createMeeting#Info Unable to fetch meeting info for ${destination}.`);\n        LoggerProxy.logger.info('Meetings->createMeeting#Info assuming this destination is a 1:1 or wireless share');\n        LoggerProxy.logger.debug(`Meetings->createMeeting#Debug ${err} fetching /meetingInfo for creation.`);\n        // We need to save this info for future reference\n        meeting.destination = destination;\n      }\n      finally {\n        // For type LOCUS_ID we need to parse the locus object to get the information\n        // about the caller and callee\n        // Meeting Added event will be created in `handleLocusEvent`\n        if (type !== _LOCUS_ID_) {\n          if (!meeting.sipUri) {\n            meeting.setSipUri(destination);\n          }\n\n          // TODO: check if we have to move this to parser\n          const meetingAddedType = MeetingsUtil.getMeetingAddedType(type);\n\n          // We typically shouldn't need to trigger both and event and return a promise.\n          // Is this a special case? We want to make the public API usage as simple as possible.\n          Trigger.trigger(\n            this,\n            {\n              file: 'meetings',\n              function: 'createMeeting'\n            },\n            EVENT_TRIGGERS.MEETING_ADDED,\n            {\n              meeting,\n              type: meetingAddedType\n            }\n          );\n        }\n      }\n\n      return meeting;\n\n      // Create the meeting calling the necessary service endpoints.\n\n      // Internally, there are many more destinations:\n      //\n      // - locusID\n      // - meetingURL\n      // - globalMeetingID, e.g, *00*meetingID\n      // - meetingID\n      // - meetingURL\n      // - PSTN\n      // - phone number\n      //\n      // Our job is to determine the appropriate one\n      // and its corresponding service so that developers\n      // need only sipURL or spaceID to get a meeting\n      // and its ID, but have the option to use createWithType()\n      // and specify those types to get meetingInfo\n    }\n\n    /**\n     * get a specifc meeting given it's type matched to the value, i.e., locus url\n     * @param {String} type\n     * @param {Object} value\n     * @returns {Meeting}\n     * @public\n     * @memberof Meetings\n     */\n    getMeetingByType(type, value) {\n      return this.meetingCollection.getByKey(type, value);\n    }\n\n    /**\n     * Get all meetings.\n     * @param {object} options\n     * @param {object} options.startDate - get meetings after this start date\n     * @param {object} options.endDate - get meetings before this end date\n     * @returns {Object} All active and scheduled meetings.\n     * @public\n     * @memberof Meetings\n     */\n    getAllMeetings(options = {}) {\n      // Options may include other parameters to filter this collection\n      // of meetings.\n      return this.meetingCollection.getAll(options);\n    }\n\n    /**\n     * syncs all the meeting from server\n     * @returns {undefined}\n     * @public\n     * @memberof Meetings\n     */\n    syncMeetings() {\n      return this.request.getActiveMeetings().then((locusArray) => {\n        const activeLocusUrl = [];\n\n        if (locusArray.loci && locusArray.loci.length > 0) {\n          locusArray.loci.forEach((locus) => {\n            activeLocusUrl.push(locus.url);\n            this.handleLocusEvent({\n              locus,\n              locusUrl: locus.url\n            });\n          });\n        }\n        if (Object.keys(this.meetingCollection.getAll()).length > 0) {\n          // Some time the mercury event is missed after mercury reconnect\n          // if sync returns no locus then clear all the meetings\n          forEach(this.meetingCollection.getAll(), (meeting) => {\n            if (!activeLocusUrl.includes(meeting.locusUrl)) {\n              this.destroy(meeting.id, MEETING_REMOVED_REASON.NO_MEETINGS_TO_SYNC);\n            }\n          });\n        }\n      });\n    }\n\n    /**\n     * Get all scheduled meetings.\n     * @param {object} options\n     * @param {object} options.startDate - get meetings after this start date\n     * @param {object} options.endDate - get meetings before this end date\n     * @returns {Object} All scheduled meetings.\n     * @memberof Meetings\n     */\n    getScheduledMeetings() {\n      return this.meetingCollection.getAll({scheduled: true});\n    }\n\n    /**\n     * Get the logger instance for plugin-meetings\n     * @returns {Logger}\n     */\n    getLogger() {\n      return LoggerProxy.get();\n    }\n\n    /**\n     * Get the Stats Analyzer singleton\n     * @returns {StatsAnalyzer}\n     * @public\n     * @memberof Meetings\n     */\n    getAnalyzer() {\n      return StatsAnalyzer;\n    }\n\n    /**\n     * Get the Stats Calculator singleton\n     * @returns {StatsCalculator}\n     * @public\n     * @memberof Meetings\n     */\n    getCalculator() {\n      return StatsCalculator;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}