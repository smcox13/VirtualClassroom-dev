{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _weakMap = require('babel-runtime/core-js/weak-map');\n\nvar _weakMap2 = _interopRequireDefault(_weakMap);\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _sha = require('crypto-js/sha256');\n\nvar _sha2 = _interopRequireDefault(_sha);\n\nvar _webexPlugin = require('../webex-plugin');\n\nvar _webexPlugin2 = _interopRequireDefault(_webexPlugin);\n\nvar _serviceCatalog = require('./service-catalog');\n\nvar _serviceCatalog2 = _interopRequireDefault(_serviceCatalog);\n\nvar _serviceRegistry = require('./service-registry');\n\nvar _serviceRegistry2 = _interopRequireDefault(_serviceRegistry);\n\nvar _serviceState = require('./service-state');\n\nvar _serviceState2 = _interopRequireDefault(_serviceState);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* eslint-disable no-underscore-dangle */\n\n/**\n * @class\n */\n\n\nvar Services = _webexPlugin2.default.extend({\n  namespace: 'Services',\n\n  /**\n   * The {@link WeakMap} of {@link ServiceRegistry} class instances that are\n   * keyed with WebexCore instances.\n   *\n   * @instance\n   * @type {WeakMap<WebexCore, ServiceRegistry>}\n   * @private\n   * @memberof Services\n   */\n  registries: new _weakMap2.default(),\n\n  /**\n   * The {@link WeakMap} of {@link ServiceState} class instances that are\n   * keyed with WebexCore instances.\n   *\n   * @instance\n   * @type {WeakMap<WebexCore, ServiceState>}\n   * @private\n   * @memberof Services\n   */\n  states: new _weakMap2.default(),\n  props: {\n    validateDomains: ['boolean', false, true]\n  },\n  _catalogs: new _weakMap2.default(),\n\n  /**\n   * Get the registry associated with this webex instance.\n   *\n   * @private\n   * @memberof Services\n   * @returns {ServiceRegistry} - The associated {@link ServiceRegistry}.\n   */\n  getRegistry: function getRegistry() {\n    return this.registries.get(this.webex);\n  },\n\n  /**\n   * Get the state associated with this webex instance.\n   *\n   * @private\n   * @memberof Services\n   * @returns {ServiceState} - The associated {@link ServiceState}.\n   */\n  getState: function getState() {\n    return this.states.get(this.webex);\n  },\n\n  /**\n   * @private\n   * Get the current catalog based on the assocaited\n   * webex instance.\n   * @returns {ServiceCatalog}\n   */\n  _getCatalog: function _getCatalog() {\n    return this._catalogs.get(this.webex);\n  },\n\n  /**\n   * Get a service url from the current services list by name\n   * from the associated instance catalog.\n   * @param {string} name\n   * @param {boolean} [priorityHost]\n   * @param {string} [serviceGroup]\n   * @returns {string|undefined}\n   */\n  get: function get(name, priorityHost, serviceGroup) {\n    var catalog = this._getCatalog();\n\n    return catalog.get(name, priorityHost, serviceGroup);\n  },\n\n  /**\n   * Determine if the catalog contains a specific service\n   *\n   * @param {string} serviceName - The service name to validate.\n   * @returns {boolean} - True if the service exists.\n   */\n  hasService: function hasService(serviceName) {\n    return !!this.get(serviceName);\n  },\n\n  /**\n   * Determine if a whilelist exists in the service catalog.\n   *\n   * @returns {boolean} - True if a allowed domains list exists.\n   */\n  hasAllowedDomains: function hasAllowedDomains() {\n    var catalog = this._getCatalog();\n\n    return catalog.getAllowedDomains().length > 0;\n  },\n\n  /**\n   * Generate a service catalog as an object from\n   * the associated instance catalog.\n   * @param {boolean} [priorityHost] - use highest priority host if set to `true`\n   * @param {string} [serviceGroup]\n   * @returns {Record<string, string>}\n   */\n  list: function list(priorityHost, serviceGroup) {\n    var catalog = this._getCatalog();\n\n    return catalog.list(priorityHost, serviceGroup);\n  },\n\n  /**\n   * Mark a priority host service url as failed.\n   * This will mark the host associated with the\n   * `ServiceUrl` to be removed from the its\n   * respective host array, and then return the next\n   * viable host from the `ServiceUrls` host array,\n   * or the `ServiceUrls` default url if no other priority\n   * hosts are available, or if `noPriorityHosts` is set to\n   * `true`.\n   * @param {string} url\n   * @param {boolean} noPriorityHosts\n   * @returns {string}\n   */\n  markFailedUrl: function markFailedUrl(url, noPriorityHosts) {\n    var catalog = this._getCatalog();\n\n    return catalog.markFailedUrl(url, noPriorityHosts);\n  },\n\n  /**\n   * Update a list of `serviceUrls` to the most current\n   * catalog via the defined `discoveryUrl` then returns the current\n   * list of services.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  updateServices: function updateServices() {\n    var _this = this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        from = _ref.from,\n        query = _ref.query,\n        token = _ref.token;\n\n    var catalog = this._getCatalog();\n\n    var formattedQuery = void 0,\n        serviceGroup = void 0; // map catalog name to service group name.\n\n    switch (from) {\n      case 'limited':\n        serviceGroup = 'preauth';\n        break;\n\n      case 'signin':\n        serviceGroup = 'signin';\n        break;\n\n      default:\n        serviceGroup = 'postauth';\n        break;\n    } // confirm catalog update for group is not in progress.\n\n\n    if (catalog.status[serviceGroup].collecting) {\n      return this.waitForCatalog(serviceGroup);\n    }\n\n    catalog.status[serviceGroup].collecting = true;\n\n    if (serviceGroup === 'preauth') {\n      var queryKey = query && (0, _keys2.default)(query)[0];\n\n      if (!['email', 'emailhash', 'userId', 'orgId', 'mode'].includes(queryKey)) {\n        return _promise2.default.reject(new Error('a query param of email, emailhash, userId, orgId, or mode is required'));\n      }\n    } // encode email when query key is email\n\n\n    if (serviceGroup === 'preauth' || serviceGroup === 'signin') {\n      var _queryKey = (0, _keys2.default)(query)[0];\n      formattedQuery = {};\n\n      if (_queryKey === 'email') {\n        formattedQuery.emailhash = (0, _sha2.default)(query.email.toLowerCase()).toString();\n      } else {\n        formattedQuery[_queryKey] = query[_queryKey];\n      }\n    }\n\n    return this._fetchNewServiceHostmap({\n      from: from,\n      token: token,\n      query: formattedQuery\n    }).then(function (serviceHostMap) {\n      catalog.updateServiceUrls(serviceGroup, serviceHostMap);\n\n      _this.updateCredentialsConfig();\n\n      catalog.status[serviceGroup].collecting = false;\n    }).catch(function (error) {\n      catalog.status[serviceGroup].collecting = false;\n      return _promise2.default.reject(error);\n    });\n  },\n\n  /**\n   * User validation parameter transfer object for {@link validateUser}.\n   * @param {object} ValidateUserPTO\n   * @property {string} ValidateUserPTO.email - The email of the user.\n   * @property {string} [ValidateUserPTO.reqId] - The activation requester.\n   */\n\n  /**\n   * User validation return transfer object for {@link validateUser}.\n   * @param {object} ValidateUserRTO\n   * @property {boolean} ValidateUserRTO.activated - If the user is activated.\n   * @property {boolean} ValidateUserRTO.exists - If the user exists.\n   * @property {string} ValidateUserRTO.details - A descriptive status message.\n   * @property {object} ValidateUserRTO.user - **Atlas** service user object.\n   */\n\n  /**\n   * Validate if a user is activated and update the service catalogs as needed\n   * based on the user's activation status.\n   *\n   * @param {ValidateUserPTO} - The parameter transfer object.\n   * @returns {ValidateUserRTO} - The return transfer object.\n   */\n  validateUser: function validateUser(_ref2) {\n    var _this2 = this;\n\n    var email = _ref2.email,\n        _ref2$reqId = _ref2.reqId,\n        reqId = _ref2$reqId === undefined ? 'WEBCLIENT' : _ref2$reqId;\n    this.logger.info('services: validating a user'); // Validate that an email parameter key was provided.\n\n    if (!email) {\n      return _promise2.default.reject(new Error('`email` is required'));\n    } // Destructure the credentials object.\n\n\n    var canAuthorize = this.webex.credentials.canAuthorize; // Validate that the user is already authorized.\n\n    if (canAuthorize) {\n      return this.updateServices().then(function () {\n        return _this2.webex.credentials.getUserToken();\n      }).then(function (token) {\n        return _this2.sendUserActivation({\n          email: email,\n          reqId: reqId,\n          token: token.toString()\n        });\n      }).then(function (userObj) {\n        return {\n          activated: true,\n          exists: true,\n          details: 'user is authorized via a user token',\n          user: userObj\n        };\n      });\n    } // Destructure the client authorization details.\n\n    /* eslint-disable camelcase */\n\n\n    var _webex$credentials$co = this.webex.credentials.config,\n        client_id = _webex$credentials$co.client_id,\n        client_secret = _webex$credentials$co.client_secret; // Validate that client authentication details exist.\n\n    if (!client_id || !client_secret) {\n      return _promise2.default.reject(new Error('client authentication details are not available'));\n    }\n    /* eslint-enable camelcase */\n    // Declare a class-memeber-scoped token for usage within the promise chain.\n\n\n    var token = void 0; // Begin client authentication user validation.\n\n    return this.collectPreauthCatalog({\n      email: email\n    }).then(function () {\n      // Retrieve the service url from the updated catalog. This is required\n      // since `WebexCore` is usually not fully initialized at the time this\n      // request completes.\n      var idbrokerService = _this2.get('idbroker', true); // Collect the client auth token.\n\n\n      return _this2.webex.credentials.getClientToken({\n        uri: idbrokerService + 'idb/oauth2/v1/access_token',\n        scope: 'webexsquare:admin webexsquare:get_conversation Identity:SCIM'\n      });\n    }).then(function (tokenObj) {\n      // Generate the token string.\n      token = tokenObj.toString(); // Collect the signin catalog using the client auth information.\n\n      return _this2.collectSigninCatalog({\n        email: email,\n        token: token\n      });\n    }) // Validate if collecting the signin catalog failed and populate the RTO\n    // with the appropriate content.\n    .catch(function (error) {\n      return {\n        exists: error.name !== 'NotFound',\n        activated: false,\n        details: error.name !== 'NotFound' ? 'user exists but is not activated' : 'user does not exist and is not activated'\n      };\n    }) // Validate if the previous promise resolved with an RTO and populate the\n    // new RTO accordingly.\n    .then(function (rto) {\n      return _promise2.default.all([rto || {\n        activated: true,\n        exists: true,\n        details: 'user exists and is activated'\n      }, _this2.sendUserActivation({\n        email: email,\n        reqId: reqId,\n        token: token\n      })]);\n    }).then(function (_ref3) {\n      var _ref4 = (0, _slicedToArray3.default)(_ref3, 2),\n          rto = _ref4[0],\n          user = _ref4[1];\n\n      return (0, _extends3.default)({}, rto, {\n        user: user\n      });\n    }).catch(function (error) {\n      var response = {\n        statusCode: error.statusCode,\n        responseText: error.body.message,\n        body: error.body\n      };\n      return _promise2.default.reject(response);\n    });\n  },\n\n  /**\n   * User activation parameter transfer object for {@link sendUserActivation}.\n   * @typedef {object} SendUserActivationPTO\n   * @property {string} SendUserActivationPTO.email - The email of the user.\n   * @property {string} SendUserActivationPTO.reqId - The activation requester.\n   * @property {string} SendUserActivationPTO.token - The client auth token.\n   */\n\n  /**\n   * Send a request to activate a user using a client token.\n   *\n   * @param {SendUserActivationPTO} - The Parameter transfer object.\n   * @returns {AtlasDTO} - The DTO returned from the **Atlas** service.\n   */\n  sendUserActivation: function sendUserActivation(_ref5) {\n    var email = _ref5.email,\n        reqId = _ref5.reqId,\n        token = _ref5.token;\n    this.logger.info('services: sending user activation request'); // Send the user activation request to the **Atlas** service.\n\n    return this.request({\n      service: 'atlas',\n      resource: 'users/activations',\n      method: 'POST',\n      headers: {\n        accept: 'application/json',\n        authorization: token,\n        'x-prelogin-userid': undefined\n      },\n      body: {\n        email: email,\n        reqId: reqId\n      },\n      shouldRefreshAccessToken: false\n    }) // On success, return the **Atlas** user object.\n    .then(function (_ref6) {\n      var body = _ref6.body;\n      return body;\n    }) // On failure, reject with error from **Atlas**.\n    .catch(function (error) {\n      return _promise2.default.reject(error);\n    });\n  },\n\n  /**\n   * simplified method to update the preauth catalog via email\n   *\n   * @param {object} query\n   * @param {string} query.email - A standard format email.\n   * @param {string} query.orgId - The user's OrgId.\n   * @returns {Promise<void>}\n   */\n  collectPreauthCatalog: function collectPreauthCatalog(query) {\n    if (!query) {\n      return this.updateServices({\n        from: 'limited',\n        query: {\n          mode: 'DEFAULT_BY_PROXIMITY'\n        }\n      });\n    }\n\n    return this.updateServices({\n      from: 'limited',\n      query: query\n    });\n  },\n\n  /**\n   * simplified method to update the signin catalog via email and token\n   * @param {object} param\n   * @param {string} param.email - must be a standard-format email\n   * @param {string} param.token - must be a client token\n   * @returns {Promise<void>}\n   */\n  collectSigninCatalog: function collectSigninCatalog() {\n    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        email = _ref7.email,\n        token = _ref7.token;\n\n    if (!email) {\n      return _promise2.default.reject(new Error('`email` is required'));\n    }\n\n    if (!token) {\n      return _promise2.default.reject(new Error('`token` is required'));\n    }\n\n    return this.updateServices({\n      from: 'signin',\n      query: {\n        email: email\n      },\n      token: token\n    });\n  },\n\n  /**\n   * Updates credentials config to utilize u2c catalog\n   * urls.\n   * @returns {void}\n   */\n  updateCredentialsConfig: function updateCredentialsConfig() {\n    var _list = this.list(true),\n        idbroker = _list.idbroker,\n        identity = _list.identity;\n\n    if (idbroker && identity) {\n      this.webex.setConfig({\n        credentials: {\n          idbroker: {\n            url: idbroker.slice(0, -1) // remove trailing slash\n\n          },\n          identity: {\n            url: identity.slice(0, -1) // remove trailing slash\n\n          }\n        }\n      });\n    }\n  },\n\n  /**\n   * Wait until the service catalog is available,\n   * or reject afte ra timeout of 60 seconds.\n   * @param {string} serviceGroup\n   * @param {number} [timeout] - in seconds\n   * @returns {Promise<void>}\n   */\n  waitForCatalog: function waitForCatalog(serviceGroup, timeout) {\n    var catalog = this._getCatalog();\n\n    var supertoken = this.webex.credentials.supertoken;\n\n    if (serviceGroup === 'postauth' && supertoken && supertoken.access_token && !catalog.status.postauth.collecting && !catalog.status.postauth.ready) {\n      if (!catalog.status.preauth.ready) {\n        return this.initServiceCatalogs();\n      }\n\n      return this.updateServices();\n    }\n\n    return catalog.waitForCatalog(serviceGroup, timeout);\n  },\n\n  /**\n   * Service waiting parameter transfer object for {@link waitForService}.\n   *\n   * @typedef {object} WaitForServicePTO\n   * @property {string} [WaitForServicePTO.name] - The service name.\n   * @property {string} [WaitForServicePTO.url] - The service url.\n   * @property {string} [WaitForServicePTO.timeout] - wait duration in seconds.\n   */\n\n  /**\n   * Wait until the service has been ammended to any service catalog. This\n   * method prioritizes the service name over the service url when searching.\n   *\n   * @param {WaitForServicePTO} - The parameter transfer object.\n   * @returns {Promise<string>} - Resolves to the priority host of a service.\n   */\n  waitForService: function waitForService(_ref8) {\n    var _this3 = this;\n\n    var name = _ref8.name,\n        _ref8$timeout = _ref8.timeout,\n        timeout = _ref8$timeout === undefined ? 5 : _ref8$timeout,\n        url = _ref8.url;\n    var priorityUrl = this.get(name, true);\n    var priorityUrlObj = this.getServiceFromUrl(url);\n\n    if (priorityUrl || priorityUrlObj) {\n      return _promise2.default.resolve(priorityUrl || priorityUrlObj.priorityUrl);\n    } // Save memory by grabbing the catalog after there isn't a priortyURL\n\n\n    var catalog = this._getCatalog();\n\n    if (catalog.isReady) {\n      return url ? _promise2.default.resolve(url) : _promise2.default.reject(new Error('services: service \\'' + name + '\\' was not found in any of the catalogs'));\n    }\n\n    return new _promise2.default(function (resolve, reject) {\n      var groupsToCheck = ['limited', 'signin', 'postauth'];\n\n      var checkCatalog = function checkCatalog(catalogGroup) {\n        return catalog.waitForCatalog(catalogGroup, timeout).then(function () {\n          var scopedPriorityUrl = _this3.get(name, true);\n\n          var scopedPrioriryUrlObj = _this3.getServiceFromUrl(url);\n\n          if (scopedPriorityUrl || scopedPrioriryUrlObj) {\n            resolve(scopedPriorityUrl || scopedPrioriryUrlObj.priorityUrl);\n          }\n        }).catch(function () {\n          return undefined;\n        });\n      };\n\n      _promise2.default.all(groupsToCheck.map(function (group) {\n        return checkCatalog(group);\n      })).then(function () {\n        reject(new Error('services: service \\'' + name + '\\' was not found after waiting'));\n      });\n    });\n  },\n\n  /**\n   * @private\n   * Organize a received hostmap from a service\n   * catalog endpoint.\n   * @param {object} serviceHostmap\n   * @returns {object}\n   */\n  _formatReceivedHostmap: function _formatReceivedHostmap(serviceHostmap) {\n    // map the host catalog items to a formatted hostmap\n    var formattedHostmap = (0, _keys2.default)(serviceHostmap.hostCatalog).reduce(function (accumulator, key) {\n      var _serviceItem$hosts;\n\n      if (serviceHostmap.hostCatalog[key].length === 0) {\n        return accumulator;\n      }\n\n      var serviceName = serviceHostmap.hostCatalog[key][0].id.split(':')[3];\n      var defaultUrl = serviceHostmap.serviceLinks[serviceName];\n      var serviceItem = accumulator.find(function (item) {\n        return item.name === serviceName;\n      });\n\n      if (!serviceItem) {\n        serviceItem = {\n          name: serviceName,\n          defaultUrl: defaultUrl,\n          defaultHost: _url2.default.parse(defaultUrl).hostname,\n          hosts: []\n        };\n        accumulator.push(serviceItem);\n      }\n\n      (_serviceItem$hosts = serviceItem.hosts).push.apply(_serviceItem$hosts, [// map the default key as a low priority default for cluster matching\n      {\n        host: key,\n        ttl: -1,\n        priority: 10,\n        id: serviceHostmap.hostCatalog[key][0].id,\n        homeCluster: serviceItem.defaultHost === key\n      }].concat((0, _toConsumableArray3.default)(serviceHostmap.hostCatalog[key].map(function (host) {\n        return (0, _extends3.default)({}, host, {\n          homeCluster: serviceItem.defaultHost === key\n        });\n      }))));\n\n      return accumulator;\n    }, []); // append service links that do not exist in the host catalog\n\n    (0, _keys2.default)(serviceHostmap.serviceLinks).forEach(function (key) {\n      var service = formattedHostmap.find(function (item) {\n        return item.name === key;\n      });\n\n      if (!service) {\n        formattedHostmap.push({\n          name: key,\n          defaultUrl: serviceHostmap.serviceLinks[key],\n          defaultHost: _url2.default.parse(serviceHostmap.serviceLinks[key]).hostname,\n          hosts: []\n        });\n      }\n    });\n    return formattedHostmap;\n  },\n\n  /**\n   * Get the clusterId associated with a URL string.\n   * @param {string} url\n   * @returns {string} - Cluster ID of url provided\n   */\n  getClusterId: function getClusterId(url) {\n    var catalog = this._getCatalog();\n\n    return catalog.findClusterId(url);\n  },\n\n  /**\n   * Get a service value from a provided clusterId. This method will\n   * return an object containing both the name and url of a found service.\n   * @param {object} params\n   * @param {string} params.clusterId - clusterId of found service\n   * @param {boolean} [params.priorityHost] - returns priority host url if true\n   * @param {string} [params.serviceGroup] - specify service group\n   * @returns {object} service\n   * @returns {string} service.name\n   * @returns {string} service.url\n   */\n  getServiceFromClusterId: function getServiceFromClusterId(params) {\n    var catalog = this._getCatalog();\n\n    return catalog.findServiceFromClusterId(params);\n  },\n\n  /**\n   * Get a service object from a service url if the service url exists in the\n   * catalog.\n   *\n   * @param {string} url - The url to be validated.\n   * @returns {object} - Service object.\n   * @returns {object.name} - The name of the service found.\n   * @returns {object.priorityUrl} - The priority url of the found service.\n   * @returns {object.defaultUrl} - The default url of the found service.\n   */\n  getServiceFromUrl: function getServiceFromUrl() {\n    var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n    var service = this._getCatalog().findServiceUrlFromUrl(url);\n\n    if (!service) {\n      return undefined;\n    }\n\n    return {\n      name: service.name,\n      priorityUrl: service.get(true),\n      defaultUrl: service.get()\n    };\n  },\n\n  /**\n   * Verify that a provided url exists in the service\n   * catalog.\n   * @param {string} url\n   * @returns {boolean} - true if exists, false otherwise\n   */\n  isServiceUrl: function isServiceUrl(url) {\n    var catalog = this._getCatalog();\n\n    return !!catalog.findServiceUrlFromUrl(url);\n  },\n\n  /**\n   * Determine if a provided url is in the catalog's allowed domains.\n   *\n   * @param {string} url - The url to match allowed domains against.\n   * @returns {boolean} - True if the url provided is allowed.\n   */\n  isAllowedDomainUrl: function isAllowedDomainUrl(url) {\n    var catalog = this._getCatalog();\n\n    return !!catalog.findAllowedDomain(url);\n  },\n\n  /**\n   * Converts the host portion of the url from default host\n   * to a priority host\n   *\n   * @param {string} url a service url that contains a default host\n   * @returns {string} a service url that contains the top priority host.\n   * @throws if url isn't a service url\n   */\n  convertUrlToPriorityHostUrl: function convertUrlToPriorityHostUrl() {\n    var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var data = this.getServiceFromUrl(url);\n\n    if (!data) {\n      throw Error('No service associated with url: [' + url + ']');\n    }\n\n    return url.replace(data.defaultUrl, data.priorityUrl);\n  },\n\n  /**\n   * @private\n   * Simplified method wrapper for sending a request to get\n   * an updated service hostmap.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  _fetchNewServiceHostmap: function _fetchNewServiceHostmap() {\n    var _this4 = this;\n\n    var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        from = _ref9.from,\n        query = _ref9.query,\n        token = _ref9.token;\n\n    var service = 'u2c';\n    var resource = from ? '/' + from + '/catalog' : '/catalog';\n    var qs = (0, _extends3.default)({}, query, {\n      format: 'hostmap'\n    });\n    var requestObject = {\n      method: 'GET',\n      service: service,\n      resource: resource,\n      qs: qs\n    };\n\n    if (token) {\n      requestObject.headers = {\n        authorization: token\n      };\n    }\n\n    return this.request(requestObject).then(function (_ref10) {\n      var body = _ref10.body;\n      return _this4._formatReceivedHostmap(body);\n    });\n  },\n\n  /**\n   * Initialize the discovery services and the whitelisted services.\n   *\n   * @returns {void}\n   */\n  initConfig: function initConfig() {\n    // Get the catalog and destructure the services config.\n    var catalog = this._getCatalog();\n\n    var services = this.webex.config.services; // Validate that the services configuration exists.\n\n    if (services) {\n      // Check for discovery services.\n      if (services.discovery) {\n        // Format the discovery configuration into an injectable array.\n        var formattedDiscoveryServices = (0, _keys2.default)(services.discovery).map(function (key) {\n          return {\n            name: key,\n            defaultUrl: services.discovery[key]\n          };\n        }); // Inject formatted services into services catalog.\n\n        catalog.updateServiceUrls('discovery', formattedDiscoveryServices);\n      } // Check for allowed host domains.\n\n\n      if (services.allowedDomains) {\n        // Store the allowed domains as a property of the catalog.\n        catalog.setAllowedDomains(services.allowedDomains);\n      } // Set `validateDomains` property to match configuration\n\n\n      this.validateDomains = services.validateDomains;\n    }\n  },\n\n  /**\n   * Make the initial requests to collect the root catalogs.\n   *\n   * @returns {Promise<void, Error>} - Errors if the token is unavailable.\n   */\n  initServiceCatalogs: function initServiceCatalogs() {\n    var _this5 = this;\n\n    this.logger.info('services: initializing initial service catalogs'); // Destructure the credentials plugin.\n\n    var credentials = this.webex.credentials; // Init a promise chain. Must be done as a Promise.resolve() to allow\n    // credentials#getOrgId() to properly throw.\n\n    return _promise2.default.resolve() // Get the user's OrgId.\n    .then(function () {\n      return credentials.getOrgId();\n    }) // Begin collecting the preauth/limited catalog.\n    .then(function (orgId) {\n      return _this5.collectPreauthCatalog({\n        orgId: orgId\n      });\n    }).then(function () {\n      // Validate if the token is authorized.\n      if (credentials.canAuthorize) {\n        // Attempt to collect the postauth catalog.\n        return _this5.updateServices().catch(function () {\n          return _this5.logger.warn('services: cannot retrieve postauth catalog');\n        });\n      } // Return a resolved promise for consistent return value.\n\n\n      return _promise2.default.resolve();\n    });\n  },\n\n  /**\n   * Initializer\n   *\n   * @instance\n   * @memberof Services\n   * @returns {Services}\n   */\n  initialize: function initialize() {\n    var _this6 = this;\n\n    var catalog = new _serviceCatalog2.default();\n    var registry = new _serviceRegistry2.default();\n    var state = new _serviceState2.default();\n\n    this._catalogs.set(this.webex, catalog);\n\n    this.registries.set(this.webex, registry);\n    this.states.set(this.webex, state); // Listen for configuration changes once.\n\n    this.listenToOnce(this.webex, 'change:config', function () {\n      _this6.initConfig();\n    }); // wait for webex instance to be ready before attempting\n    // to update the service catalogs\n\n    this.listenToOnce(this.webex, 'ready', function () {\n      var supertoken = _this6.webex.credentials.supertoken; // Validate if the supertoken exists.\n\n      if (supertoken && supertoken.access_token) {\n        _this6.initServiceCatalogs().then(function () {\n          catalog.isReady = true;\n        }).catch(function (error) {\n          return _this6.logger.error('services: failed to init initial services, ' + error.message);\n        });\n      } else {\n        var email = _this6.webex.config.email;\n\n        _this6.collectPreauthCatalog(email ? {\n          email: email\n        } : undefined);\n      }\n    });\n  },\n  version: '1.80.172'\n});\n/* eslint-enable no-underscore-dangle */\n\n\nexports.default = Services;","map":{"version":3,"sources":["services.js"],"names":["Services","namespace","registries","states","props","validateDomains","_catalogs","getRegistry","getState","_getCatalog","get","catalog","hasService","hasAllowedDomains","list","markFailedUrl","updateServices","from","query","token","formattedQuery","serviceGroup","queryKey","validateUser","email","reqId","canAuthorize","activated","exists","details","user","userObj","client_id","client_secret","idbrokerService","uri","scope","tokenObj","error","rto","response","statusCode","responseText","body","sendUserActivation","service","resource","method","headers","accept","authorization","undefined","shouldRefreshAccessToken","collectPreauthCatalog","mode","collectSigninCatalog","updateCredentialsConfig","idbroker","identity","credentials","url","waitForCatalog","supertoken","waitForService","name","timeout","priorityUrl","priorityUrlObj","groupsToCheck","checkCatalog","scopedPriorityUrl","scopedPrioriryUrlObj","resolve","reject","_formatReceivedHostmap","formattedHostmap","serviceHostmap","serviceName","defaultUrl","serviceItem","item","defaultHost","Url","hosts","accumulator","host","ttl","priority","id","homeCluster","key","getClusterId","getServiceFromClusterId","getServiceFromUrl","isServiceUrl","isAllowedDomainUrl","convertUrlToPriorityHostUrl","data","Error","_fetchNewServiceHostmap","qs","format","requestObject","initConfig","services","formattedDiscoveryServices","initServiceCatalogs","orgId","initialize","ServiceCatalog","registry","ServiceRegistry","state","ServiceState"],"mappings":"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","sourcesContent":["import Url from 'url';\n\nimport sha256 from 'crypto-js/sha256';\n\nimport WebexPlugin from '../webex-plugin';\n\nimport ServiceCatalog from './service-catalog';\nimport ServiceRegistry from './service-registry';\nimport ServiceState from './service-state';\n\n/* eslint-disable no-underscore-dangle */\n/**\n * @class\n */\nconst Services = WebexPlugin.extend({\n  namespace: 'Services',\n\n  /**\n   * The {@link WeakMap} of {@link ServiceRegistry} class instances that are\n   * keyed with WebexCore instances.\n   *\n   * @instance\n   * @type {WeakMap<WebexCore, ServiceRegistry>}\n   * @private\n   * @memberof Services\n   */\n  registries: new WeakMap(),\n\n  /**\n   * The {@link WeakMap} of {@link ServiceState} class instances that are\n   * keyed with WebexCore instances.\n   *\n   * @instance\n   * @type {WeakMap<WebexCore, ServiceState>}\n   * @private\n   * @memberof Services\n   */\n  states: new WeakMap(),\n\n  props: {\n    validateDomains: ['boolean', false, true]\n  },\n\n  _catalogs: new WeakMap(),\n\n  /**\n   * Get the registry associated with this webex instance.\n   *\n   * @private\n   * @memberof Services\n   * @returns {ServiceRegistry} - The associated {@link ServiceRegistry}.\n   */\n  getRegistry() {\n    return this.registries.get(this.webex);\n  },\n\n  /**\n   * Get the state associated with this webex instance.\n   *\n   * @private\n   * @memberof Services\n   * @returns {ServiceState} - The associated {@link ServiceState}.\n   */\n  getState() {\n    return this.states.get(this.webex);\n  },\n\n  /**\n   * @private\n   * Get the current catalog based on the assocaited\n   * webex instance.\n   * @returns {ServiceCatalog}\n   */\n  _getCatalog() {\n    return this._catalogs.get(this.webex);\n  },\n\n  /**\n   * Get a service url from the current services list by name\n   * from the associated instance catalog.\n   * @param {string} name\n   * @param {boolean} [priorityHost]\n   * @param {string} [serviceGroup]\n   * @returns {string|undefined}\n   */\n  get(name, priorityHost, serviceGroup) {\n    const catalog = this._getCatalog();\n\n    return catalog.get(name, priorityHost, serviceGroup);\n  },\n\n  /**\n   * Determine if the catalog contains a specific service\n   *\n   * @param {string} serviceName - The service name to validate.\n   * @returns {boolean} - True if the service exists.\n   */\n  hasService(serviceName) {\n    return !!(this.get(serviceName));\n  },\n\n  /**\n   * Determine if a whilelist exists in the service catalog.\n   *\n   * @returns {boolean} - True if a allowed domains list exists.\n   */\n  hasAllowedDomains() {\n    const catalog = this._getCatalog();\n\n    return (catalog.getAllowedDomains().length > 0);\n  },\n\n  /**\n   * Generate a service catalog as an object from\n   * the associated instance catalog.\n   * @param {boolean} [priorityHost] - use highest priority host if set to `true`\n   * @param {string} [serviceGroup]\n   * @returns {Record<string, string>}\n   */\n  list(priorityHost, serviceGroup) {\n    const catalog = this._getCatalog();\n\n    return catalog.list(priorityHost, serviceGroup);\n  },\n\n  /**\n   * Mark a priority host service url as failed.\n   * This will mark the host associated with the\n   * `ServiceUrl` to be removed from the its\n   * respective host array, and then return the next\n   * viable host from the `ServiceUrls` host array,\n   * or the `ServiceUrls` default url if no other priority\n   * hosts are available, or if `noPriorityHosts` is set to\n   * `true`.\n   * @param {string} url\n   * @param {boolean} noPriorityHosts\n   * @returns {string}\n   */\n  markFailedUrl(url, noPriorityHosts) {\n    const catalog = this._getCatalog();\n\n    return catalog.markFailedUrl(url, noPriorityHosts);\n  },\n\n  /**\n   * Update a list of `serviceUrls` to the most current\n   * catalog via the defined `discoveryUrl` then returns the current\n   * list of services.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  updateServices({from, query, token} = {}) {\n    const catalog = this._getCatalog();\n    let formattedQuery, serviceGroup;\n\n    // map catalog name to service group name.\n    switch (from) {\n      case 'limited': serviceGroup = 'preauth'; break;\n      case 'signin': serviceGroup = 'signin'; break;\n      default: serviceGroup = 'postauth'; break;\n    }\n\n    // confirm catalog update for group is not in progress.\n    if (catalog.status[serviceGroup].collecting) {\n      return this.waitForCatalog(serviceGroup);\n    }\n\n    catalog.status[serviceGroup].collecting = true;\n\n    if (serviceGroup === 'preauth') {\n      const queryKey = query && Object.keys(query)[0];\n\n      if (!['email', 'emailhash', 'userId', 'orgId', 'mode'].includes(queryKey)) {\n        return Promise.reject(new Error('a query param of email, emailhash, userId, orgId, or mode is required'));\n      }\n    }\n    // encode email when query key is email\n    if (serviceGroup === 'preauth' || serviceGroup === 'signin') {\n      const queryKey = Object.keys(query)[0];\n\n      formattedQuery = {};\n\n      if (queryKey === 'email') {\n        formattedQuery.emailhash = sha256(query.email.toLowerCase()).toString();\n      }\n      else {\n        formattedQuery[queryKey] = query[queryKey];\n      }\n    }\n\n    return this._fetchNewServiceHostmap({\n      from,\n      token,\n      query: formattedQuery\n    })\n      .then((serviceHostMap) => {\n        catalog.updateServiceUrls(serviceGroup, serviceHostMap);\n        this.updateCredentialsConfig();\n        catalog.status[serviceGroup].collecting = false;\n      })\n      .catch((error) => {\n        catalog.status[serviceGroup].collecting = false;\n\n        return Promise.reject(error);\n      });\n  },\n\n  /**\n   * User validation parameter transfer object for {@link validateUser}.\n   * @param {object} ValidateUserPTO\n   * @property {string} ValidateUserPTO.email - The email of the user.\n   * @property {string} [ValidateUserPTO.reqId] - The activation requester.\n   */\n\n  /**\n   * User validation return transfer object for {@link validateUser}.\n   * @param {object} ValidateUserRTO\n   * @property {boolean} ValidateUserRTO.activated - If the user is activated.\n   * @property {boolean} ValidateUserRTO.exists - If the user exists.\n   * @property {string} ValidateUserRTO.details - A descriptive status message.\n   * @property {object} ValidateUserRTO.user - **Atlas** service user object.\n   */\n\n  /**\n   * Validate if a user is activated and update the service catalogs as needed\n   * based on the user's activation status.\n   *\n   * @param {ValidateUserPTO} - The parameter transfer object.\n   * @returns {ValidateUserRTO} - The return transfer object.\n   */\n  validateUser({email, reqId = 'WEBCLIENT'}) {\n    this.logger.info('services: validating a user');\n\n    // Validate that an email parameter key was provided.\n    if (!email) {\n      return Promise.reject(new Error('`email` is required'));\n    }\n\n    // Destructure the credentials object.\n    const {canAuthorize} = this.webex.credentials;\n\n    // Validate that the user is already authorized.\n    if (canAuthorize) {\n      return this.updateServices()\n        .then(() => this.webex.credentials.getUserToken())\n        .then((token) => this.sendUserActivation({\n          email,\n          reqId,\n          token: token.toString()\n        }))\n        .then((userObj) => ({\n          activated: true,\n          exists: true,\n          details: 'user is authorized via a user token',\n          user: userObj\n        }));\n    }\n\n    // Destructure the client authorization details.\n    /* eslint-disable camelcase */\n    const {client_id, client_secret} = this.webex.credentials.config;\n\n    // Validate that client authentication details exist.\n    if (!client_id || !client_secret) {\n      return Promise.reject(new Error(\n        'client authentication details are not available'\n      ));\n    }\n    /* eslint-enable camelcase */\n\n    // Declare a class-memeber-scoped token for usage within the promise chain.\n    let token;\n\n    // Begin client authentication user validation.\n    return this.collectPreauthCatalog({email})\n      .then(() => {\n        // Retrieve the service url from the updated catalog. This is required\n        // since `WebexCore` is usually not fully initialized at the time this\n        // request completes.\n        const idbrokerService = this.get('idbroker', true);\n\n        // Collect the client auth token.\n        return this.webex.credentials.getClientToken({\n          uri: `${idbrokerService}idb/oauth2/v1/access_token`,\n          scope: 'webexsquare:admin webexsquare:get_conversation Identity:SCIM'\n        });\n      })\n      .then((tokenObj) => {\n        // Generate the token string.\n        token = tokenObj.toString();\n\n        // Collect the signin catalog using the client auth information.\n        return this.collectSigninCatalog({email, token});\n      })\n      // Validate if collecting the signin catalog failed and populate the RTO\n      // with the appropriate content.\n      .catch((error) => ({\n        exists: (error.name !== 'NotFound'),\n        activated: false,\n        details: (error.name !== 'NotFound') ?\n          'user exists but is not activated' :\n          'user does not exist and is not activated'\n      }))\n      // Validate if the previous promise resolved with an RTO and populate the\n      // new RTO accordingly.\n      .then((rto) => Promise.all([\n        rto || {\n          activated: true,\n          exists: true,\n          details: 'user exists and is activated'\n        },\n        this.sendUserActivation({email, reqId, token})\n      ]))\n      .then(([rto, user]) => ({...rto, user}))\n      .catch((error) => {\n        const response = {\n          statusCode: error.statusCode,\n          responseText: error.body.message,\n          body: error.body\n        };\n\n        return Promise.reject(response);\n      });\n  },\n\n  /**\n   * User activation parameter transfer object for {@link sendUserActivation}.\n   * @typedef {object} SendUserActivationPTO\n   * @property {string} SendUserActivationPTO.email - The email of the user.\n   * @property {string} SendUserActivationPTO.reqId - The activation requester.\n   * @property {string} SendUserActivationPTO.token - The client auth token.\n   */\n\n  /**\n   * Send a request to activate a user using a client token.\n   *\n   * @param {SendUserActivationPTO} - The Parameter transfer object.\n   * @returns {AtlasDTO} - The DTO returned from the **Atlas** service.\n   */\n  sendUserActivation({email, reqId, token}) {\n    this.logger.info('services: sending user activation request');\n\n    // Send the user activation request to the **Atlas** service.\n    return this.request({\n      service: 'atlas',\n      resource: 'users/activations',\n      method: 'POST',\n      headers: {\n        accept: 'application/json',\n        authorization: token,\n        'x-prelogin-userid': undefined\n      },\n      body: {email, reqId},\n      shouldRefreshAccessToken: false\n    })\n      // On success, return the **Atlas** user object.\n      .then(({body}) => body)\n      // On failure, reject with error from **Atlas**.\n      .catch((error) => Promise.reject(error));\n  },\n\n  /**\n   * simplified method to update the preauth catalog via email\n   *\n   * @param {object} query\n   * @param {string} query.email - A standard format email.\n   * @param {string} query.orgId - The user's OrgId.\n   * @returns {Promise<void>}\n   */\n  collectPreauthCatalog(query) {\n    if (!query) {\n      return this.updateServices({from: 'limited', query: {mode: 'DEFAULT_BY_PROXIMITY'}});\n    }\n\n    return this.updateServices({from: 'limited', query});\n  },\n\n  /**\n   * simplified method to update the signin catalog via email and token\n   * @param {object} param\n   * @param {string} param.email - must be a standard-format email\n   * @param {string} param.token - must be a client token\n   * @returns {Promise<void>}\n   */\n  collectSigninCatalog({email, token} = {}) {\n    if (!email) {\n      return Promise.reject(new Error('`email` is required'));\n    }\n    if (!token) {\n      return Promise.reject(new Error('`token` is required'));\n    }\n\n    return this.updateServices({from: 'signin', query: {email}, token});\n  },\n\n  /**\n   * Updates credentials config to utilize u2c catalog\n   * urls.\n   * @returns {void}\n   */\n  updateCredentialsConfig() {\n    const {idbroker, identity} = this.list(true);\n\n    if (idbroker && identity) {\n      this.webex.setConfig({\n        credentials: {\n          idbroker: {\n            url: idbroker.slice(0, -1) // remove trailing slash\n          },\n          identity: {\n            url: identity.slice(0, -1) // remove trailing slash\n          }\n        }\n      });\n    }\n  },\n\n  /**\n   * Wait until the service catalog is available,\n   * or reject afte ra timeout of 60 seconds.\n   * @param {string} serviceGroup\n   * @param {number} [timeout] - in seconds\n   * @returns {Promise<void>}\n   */\n  waitForCatalog(serviceGroup, timeout) {\n    const catalog = this._getCatalog();\n    const {supertoken} = this.webex.credentials;\n\n    if (\n      serviceGroup === 'postauth' &&\n      supertoken &&\n      supertoken.access_token &&\n      !catalog.status.postauth.collecting &&\n      !catalog.status.postauth.ready\n    ) {\n      if (!catalog.status.preauth.ready) {\n        return this.initServiceCatalogs();\n      }\n\n      return this.updateServices();\n    }\n\n    return catalog.waitForCatalog(serviceGroup, timeout);\n  },\n\n  /**\n   * Service waiting parameter transfer object for {@link waitForService}.\n   *\n   * @typedef {object} WaitForServicePTO\n   * @property {string} [WaitForServicePTO.name] - The service name.\n   * @property {string} [WaitForServicePTO.url] - The service url.\n   * @property {string} [WaitForServicePTO.timeout] - wait duration in seconds.\n   */\n\n  /**\n   * Wait until the service has been ammended to any service catalog. This\n   * method prioritizes the service name over the service url when searching.\n   *\n   * @param {WaitForServicePTO} - The parameter transfer object.\n   * @returns {Promise<string>} - Resolves to the priority host of a service.\n   */\n  waitForService({name, timeout = 5, url}) {\n    const priorityUrl = this.get(name, true);\n    const priorityUrlObj = this.getServiceFromUrl(url);\n\n    if (priorityUrl || priorityUrlObj) {\n      return Promise.resolve(priorityUrl || priorityUrlObj.priorityUrl);\n    }\n\n    // Save memory by grabbing the catalog after there isn't a priortyURL\n    const catalog = this._getCatalog();\n\n    if (catalog.isReady) {\n      return url ?\n        Promise.resolve(url) :\n        Promise.reject(new Error(\n          `services: service '${name}' was not found in any of the catalogs`\n        ));\n    }\n\n    return new Promise((resolve, reject) => {\n      const groupsToCheck = ['limited', 'signin', 'postauth'];\n      const checkCatalog = (catalogGroup) =>\n        catalog.waitForCatalog(catalogGroup, timeout)\n          .then(() => {\n            const scopedPriorityUrl = this.get(name, true);\n            const scopedPrioriryUrlObj = this.getServiceFromUrl(url);\n\n            if (scopedPriorityUrl || scopedPrioriryUrlObj) {\n              resolve(scopedPriorityUrl || scopedPrioriryUrlObj.priorityUrl);\n            }\n          })\n          .catch(() => undefined);\n\n      Promise.all(groupsToCheck.map((group) => checkCatalog(group)))\n        .then(() => {\n          reject(new Error(\n            `services: service '${name}' was not found after waiting`\n          ));\n        });\n    });\n  },\n\n  /**\n   * @private\n   * Organize a received hostmap from a service\n   * catalog endpoint.\n   * @param {object} serviceHostmap\n   * @returns {object}\n   */\n  _formatReceivedHostmap(serviceHostmap) {\n    // map the host catalog items to a formatted hostmap\n    const formattedHostmap = Object.keys(serviceHostmap.hostCatalog).reduce(\n      (accumulator, key) => {\n        if (serviceHostmap.hostCatalog[key].length === 0) {\n          return accumulator;\n        }\n\n        const serviceName = serviceHostmap.hostCatalog[key][0].id.split(':')[3];\n        const defaultUrl = serviceHostmap.serviceLinks[serviceName];\n\n        let serviceItem = accumulator.find(\n          (item) => item.name === serviceName\n        );\n\n        if (!serviceItem) {\n          serviceItem = {\n            name: serviceName,\n            defaultUrl,\n            defaultHost: Url.parse(defaultUrl).hostname,\n            hosts: []\n          };\n\n          accumulator.push(serviceItem);\n        }\n\n        serviceItem.hosts.push(\n          // map the default key as a low priority default for cluster matching\n          {\n            host: key,\n            ttl: -1,\n            priority: 10,\n            id: serviceHostmap.hostCatalog[key][0].id,\n            homeCluster: serviceItem.defaultHost === key\n          },\n          // map the rest of the hosts in their proper locations\n          ...serviceHostmap.hostCatalog[key].map(\n            (host) => ({\n              ...host,\n              homeCluster: serviceItem.defaultHost === key\n            })\n          )\n        );\n\n        return accumulator;\n      }, []\n    );\n\n    // append service links that do not exist in the host catalog\n    Object.keys(serviceHostmap.serviceLinks).forEach((key) => {\n      const service = formattedHostmap.find((item) => item.name === key);\n\n      if (!service) {\n        formattedHostmap.push({\n          name: key,\n          defaultUrl: serviceHostmap.serviceLinks[key],\n          defaultHost: Url.parse(serviceHostmap.serviceLinks[key]).hostname,\n          hosts: []\n        });\n      }\n    });\n\n    return formattedHostmap;\n  },\n\n  /**\n   * Get the clusterId associated with a URL string.\n   * @param {string} url\n   * @returns {string} - Cluster ID of url provided\n   */\n  getClusterId(url) {\n    const catalog = this._getCatalog();\n\n    return catalog.findClusterId(url);\n  },\n\n  /**\n   * Get a service value from a provided clusterId. This method will\n   * return an object containing both the name and url of a found service.\n   * @param {object} params\n   * @param {string} params.clusterId - clusterId of found service\n   * @param {boolean} [params.priorityHost] - returns priority host url if true\n   * @param {string} [params.serviceGroup] - specify service group\n   * @returns {object} service\n   * @returns {string} service.name\n   * @returns {string} service.url\n   */\n  getServiceFromClusterId(params) {\n    const catalog = this._getCatalog();\n\n    return catalog.findServiceFromClusterId(params);\n  },\n\n  /**\n   * Get a service object from a service url if the service url exists in the\n   * catalog.\n   *\n   * @param {string} url - The url to be validated.\n   * @returns {object} - Service object.\n   * @returns {object.name} - The name of the service found.\n   * @returns {object.priorityUrl} - The priority url of the found service.\n   * @returns {object.defaultUrl} - The default url of the found service.\n   */\n  getServiceFromUrl(url = '') {\n    const service = this._getCatalog().findServiceUrlFromUrl(url);\n\n    if (!service) {\n      return undefined;\n    }\n\n    return {\n      name: service.name,\n      priorityUrl: service.get(true),\n      defaultUrl: service.get()\n    };\n  },\n\n  /**\n   * Verify that a provided url exists in the service\n   * catalog.\n   * @param {string} url\n   * @returns {boolean} - true if exists, false otherwise\n   */\n  isServiceUrl(url) {\n    const catalog = this._getCatalog();\n\n    return !!(catalog.findServiceUrlFromUrl(url));\n  },\n\n  /**\n   * Determine if a provided url is in the catalog's allowed domains.\n   *\n   * @param {string} url - The url to match allowed domains against.\n   * @returns {boolean} - True if the url provided is allowed.\n   */\n  isAllowedDomainUrl(url) {\n    const catalog = this._getCatalog();\n\n    return !!(catalog.findAllowedDomain(url));\n  },\n\n  /**\n   * Converts the host portion of the url from default host\n   * to a priority host\n   *\n   * @param {string} url a service url that contains a default host\n   * @returns {string} a service url that contains the top priority host.\n   * @throws if url isn't a service url\n   */\n  convertUrlToPriorityHostUrl(url = '') {\n    const data = this.getServiceFromUrl(url);\n\n    if (!data) {\n      throw Error(`No service associated with url: [${url}]`);\n    }\n\n    return url.replace(data.defaultUrl, data.priorityUrl);\n  },\n\n  /**\n   * @private\n   * Simplified method wrapper for sending a request to get\n   * an updated service hostmap.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  _fetchNewServiceHostmap({from, query, token} = {}) {\n    const service = 'u2c';\n    const resource = from ? `/${from}/catalog` : '/catalog';\n    const qs = {...query, format: 'hostmap'};\n\n    const requestObject = {\n      method: 'GET', service, resource, qs\n    };\n\n    if (token) {\n      requestObject.headers = {authorization: token};\n    }\n\n    return this.request(requestObject)\n      .then(({body}) => this._formatReceivedHostmap(body));\n  },\n\n  /**\n   * Initialize the discovery services and the whitelisted services.\n   *\n   * @returns {void}\n   */\n  initConfig() {\n    // Get the catalog and destructure the services config.\n    const catalog = this._getCatalog();\n    const {services} = this.webex.config;\n\n    // Validate that the services configuration exists.\n    if (services) {\n      // Check for discovery services.\n      if (services.discovery) {\n        // Format the discovery configuration into an injectable array.\n        const formattedDiscoveryServices = Object.keys(services.discovery)\n          .map((key) => ({\n            name: key,\n            defaultUrl: services.discovery[key]\n          }));\n\n        // Inject formatted services into services catalog.\n        catalog.updateServiceUrls('discovery', formattedDiscoveryServices);\n      }\n\n      // Check for allowed host domains.\n      if (services.allowedDomains) {\n        // Store the allowed domains as a property of the catalog.\n        catalog.setAllowedDomains(services.allowedDomains);\n      }\n\n      // Set `validateDomains` property to match configuration\n      this.validateDomains = services.validateDomains;\n    }\n  },\n\n  /**\n   * Make the initial requests to collect the root catalogs.\n   *\n   * @returns {Promise<void, Error>} - Errors if the token is unavailable.\n   */\n  initServiceCatalogs() {\n    this.logger.info('services: initializing initial service catalogs');\n\n    // Destructure the credentials plugin.\n    const {credentials} = this.webex;\n\n    // Init a promise chain. Must be done as a Promise.resolve() to allow\n    // credentials#getOrgId() to properly throw.\n    return Promise.resolve()\n      // Get the user's OrgId.\n      .then(() => credentials.getOrgId())\n      // Begin collecting the preauth/limited catalog.\n      .then((orgId) => this.collectPreauthCatalog({orgId}))\n      .then(() => {\n        // Validate if the token is authorized.\n        if (credentials.canAuthorize) {\n          // Attempt to collect the postauth catalog.\n          return this.updateServices()\n            .catch(() => this.logger.warn(\n              'services: cannot retrieve postauth catalog'\n            ));\n        }\n\n        // Return a resolved promise for consistent return value.\n        return Promise.resolve();\n      });\n  },\n\n  /**\n   * Initializer\n   *\n   * @instance\n   * @memberof Services\n   * @returns {Services}\n   */\n  initialize() {\n    const catalog = new ServiceCatalog();\n    const registry = new ServiceRegistry();\n    const state = new ServiceState();\n\n    this._catalogs.set(this.webex, catalog);\n    this.registries.set(this.webex, registry);\n    this.states.set(this.webex, state);\n\n    // Listen for configuration changes once.\n    this.listenToOnce(this.webex, 'change:config', () => {\n      this.initConfig();\n    });\n\n    // wait for webex instance to be ready before attempting\n    // to update the service catalogs\n    this.listenToOnce(this.webex, 'ready', () => {\n      const {supertoken} = this.webex.credentials;\n\n      // Validate if the supertoken exists.\n      if (supertoken && supertoken.access_token) {\n        this.initServiceCatalogs()\n          .then(() => {\n            catalog.isReady = true;\n          })\n          .catch((error) => this.logger.error(\n            `services: failed to init initial services, ${error.message}`\n          ));\n      }\n      else {\n        const {email} = this.webex.config;\n\n        this.collectPreauthCatalog(email ? {email} : undefined);\n      }\n    });\n  }\n});\n/* eslint-enable no-underscore-dangle */\n\nexport default Services;\n"]},"metadata":{},"sourceType":"script"}