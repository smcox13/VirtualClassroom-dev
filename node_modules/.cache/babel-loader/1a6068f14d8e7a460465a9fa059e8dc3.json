{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { decorate, internalDeprecation } from './private/utils';\n\nfunction toObject(cache, value) {\n  if (value === Object(value)) {\n    return value;\n  }\n\n  return cache[value] || (cache[value] = {});\n}\n\nfunction applyAndCache(context, fn, args, cache, signature) {\n  var ret = fn.apply(context, args);\n  cache[signature] = ret;\n  return ret;\n}\n\nfunction metaForDescriptor(descriptor) {\n  var fn = void 0,\n      wrapKey = void 0; // This is ugly code, but way faster than other\n  // ways I tried that *looked* pretty\n\n  if (descriptor.value) {\n    fn = descriptor.value;\n    wrapKey = 'value';\n  } else if (descriptor.get) {\n    fn = descriptor.get;\n    wrapKey = 'get';\n  } else if (descriptor.set) {\n    fn = descriptor.set;\n    wrapKey = 'set';\n  }\n\n  return {\n    fn: fn,\n    wrapKey: wrapKey\n  };\n}\n\nfunction handleDescriptor(target, key, descriptor) {\n  var _metaForDescriptor = metaForDescriptor(descriptor),\n      fn = _metaForDescriptor.fn,\n      wrapKey = _metaForDescriptor.wrapKey;\n\n  var argumentCache = new WeakMap();\n  var signatureCache = Object.create(null);\n  var primativeRefCache = Object.create(null);\n  var argumentIdCounter = 0;\n  return _extends({}, descriptor, _defineProperty({}, wrapKey, function memoizeWrapper() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var signature = '0';\n\n    for (var i = 0, l = args.length; i < l; i++) {\n      var arg = args[i];\n      var argRef = toObject(primativeRefCache, arg);\n      var argKey = argumentCache.get(argRef);\n\n      if (argKey === undefined) {\n        argKey = ++argumentIdCounter;\n        argumentCache.set(argRef, argKey);\n      }\n\n      signature += argKey;\n    }\n\n    return signatureCache[signature] || applyAndCache(this, fn, arguments, signatureCache, signature);\n  }));\n}\n\nexport default function memoize() {\n  internalDeprecation('@memoize is deprecated and will be removed shortly. Use @memoize from lodash-decorators.\\n\\n  https://www.npmjs.com/package/lodash-decorators');\n\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return decorate(handleDescriptor, args);\n}","map":{"version":3,"sources":["/Users/pratison/Work/Cisco/Education/React/education-webex/node_modules/core-decorators/es/memoize.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_defineProperty","obj","value","defineProperty","enumerable","configurable","writable","decorate","internalDeprecation","toObject","cache","applyAndCache","context","fn","args","signature","ret","apply","metaForDescriptor","descriptor","wrapKey","get","set","handleDescriptor","_metaForDescriptor","argumentCache","WeakMap","signatureCache","create","primativeRefCache","argumentIdCounter","memoizeWrapper","_len","Array","_key","l","arg","argRef","argKey","undefined","memoize","_len2","_key2"],"mappings":"AAAA,IAAIA,QAAQ,GAAGC,MAAM,CAACC,MAAP,IAAiB,UAAUC,MAAV,EAAkB;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAtB;;AAA2B,SAAK,IAAII,GAAT,IAAgBD,MAAhB,EAAwB;AAAE,UAAIN,MAAM,CAACQ,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCJ,MAArC,EAA6CC,GAA7C,CAAJ,EAAuD;AAAEL,QAAAA,MAAM,CAACK,GAAD,CAAN,GAAcD,MAAM,CAACC,GAAD,CAApB;AAA4B;AAAE;AAAE;;AAAC,SAAOL,MAAP;AAAgB,CAAhQ;;AAEA,SAASS,eAAT,CAAyBC,GAAzB,EAA8BL,GAA9B,EAAmCM,KAAnC,EAA0C;AAAE,MAAIN,GAAG,IAAIK,GAAX,EAAgB;AAAEZ,IAAAA,MAAM,CAACc,cAAP,CAAsBF,GAAtB,EAA2BL,GAA3B,EAAgC;AAAEM,MAAAA,KAAK,EAAEA,KAAT;AAAgBE,MAAAA,UAAU,EAAE,IAA5B;AAAkCC,MAAAA,YAAY,EAAE,IAAhD;AAAsDC,MAAAA,QAAQ,EAAE;AAAhE,KAAhC;AAA0G,GAA5H,MAAkI;AAAEL,IAAAA,GAAG,CAACL,GAAD,CAAH,GAAWM,KAAX;AAAmB;;AAAC,SAAOD,GAAP;AAAa;;AAEjN,SAASM,QAAT,EAAmBC,mBAAnB,QAA8C,iBAA9C;;AAEA,SAASC,QAAT,CAAkBC,KAAlB,EAAyBR,KAAzB,EAAgC;AAC9B,MAAIA,KAAK,KAAKb,MAAM,CAACa,KAAD,CAApB,EAA6B;AAC3B,WAAOA,KAAP;AACD;;AACD,SAAOQ,KAAK,CAACR,KAAD,CAAL,KAAiBQ,KAAK,CAACR,KAAD,CAAL,GAAe,EAAhC,CAAP;AACD;;AAED,SAASS,aAAT,CAAuBC,OAAvB,EAAgCC,EAAhC,EAAoCC,IAApC,EAA0CJ,KAA1C,EAAiDK,SAAjD,EAA4D;AAC1D,MAAIC,GAAG,GAAGH,EAAE,CAACI,KAAH,CAASL,OAAT,EAAkBE,IAAlB,CAAV;AACAJ,EAAAA,KAAK,CAACK,SAAD,CAAL,GAAmBC,GAAnB;AACA,SAAOA,GAAP;AACD;;AAED,SAASE,iBAAT,CAA2BC,UAA3B,EAAuC;AACrC,MAAIN,EAAE,GAAG,KAAK,CAAd;AAAA,MACIO,OAAO,GAAG,KAAK,CADnB,CADqC,CAIrC;AACA;;AAEA,MAAID,UAAU,CAACjB,KAAf,EAAsB;AACpBW,IAAAA,EAAE,GAAGM,UAAU,CAACjB,KAAhB;AACAkB,IAAAA,OAAO,GAAG,OAAV;AACD,GAHD,MAGO,IAAID,UAAU,CAACE,GAAf,EAAoB;AACzBR,IAAAA,EAAE,GAAGM,UAAU,CAACE,GAAhB;AACAD,IAAAA,OAAO,GAAG,KAAV;AACD,GAHM,MAGA,IAAID,UAAU,CAACG,GAAf,EAAoB;AACzBT,IAAAA,EAAE,GAAGM,UAAU,CAACG,GAAhB;AACAF,IAAAA,OAAO,GAAG,KAAV;AACD;;AAED,SAAO;AAAEP,IAAAA,EAAE,EAAEA,EAAN;AAAUO,IAAAA,OAAO,EAAEA;AAAnB,GAAP;AACD;;AAED,SAASG,gBAAT,CAA0BhC,MAA1B,EAAkCK,GAAlC,EAAuCuB,UAAvC,EAAmD;AACjD,MAAIK,kBAAkB,GAAGN,iBAAiB,CAACC,UAAD,CAA1C;AAAA,MACIN,EAAE,GAAGW,kBAAkB,CAACX,EAD5B;AAAA,MAEIO,OAAO,GAAGI,kBAAkB,CAACJ,OAFjC;;AAIA,MAAIK,aAAa,GAAG,IAAIC,OAAJ,EAApB;AACA,MAAIC,cAAc,GAAGtC,MAAM,CAACuC,MAAP,CAAc,IAAd,CAArB;AACA,MAAIC,iBAAiB,GAAGxC,MAAM,CAACuC,MAAP,CAAc,IAAd,CAAxB;AACA,MAAIE,iBAAiB,GAAG,CAAxB;AAEA,SAAO1C,QAAQ,CAAC,EAAD,EAAK+B,UAAL,EAAiBnB,eAAe,CAAC,EAAD,EAAKoB,OAAL,EAAc,SAASW,cAAT,GAA0B;AACrF,SAAK,IAAIC,IAAI,GAAGvC,SAAS,CAACC,MAArB,EAA6BoB,IAAI,GAAGmB,KAAK,CAACD,IAAD,CAAzC,EAAiDE,IAAI,GAAG,CAA7D,EAAgEA,IAAI,GAAGF,IAAvE,EAA6EE,IAAI,EAAjF,EAAqF;AACnFpB,MAAAA,IAAI,CAACoB,IAAD,CAAJ,GAAazC,SAAS,CAACyC,IAAD,CAAtB;AACD;;AAED,QAAInB,SAAS,GAAG,GAAhB;;AAEA,SAAK,IAAIvB,CAAC,GAAG,CAAR,EAAW2C,CAAC,GAAGrB,IAAI,CAACpB,MAAzB,EAAiCF,CAAC,GAAG2C,CAArC,EAAwC3C,CAAC,EAAzC,EAA6C;AAC3C,UAAI4C,GAAG,GAAGtB,IAAI,CAACtB,CAAD,CAAd;AACA,UAAI6C,MAAM,GAAG5B,QAAQ,CAACoB,iBAAD,EAAoBO,GAApB,CAArB;AACA,UAAIE,MAAM,GAAGb,aAAa,CAACJ,GAAd,CAAkBgB,MAAlB,CAAb;;AAEA,UAAIC,MAAM,KAAKC,SAAf,EAA0B;AACxBD,QAAAA,MAAM,GAAG,EAAER,iBAAX;AACAL,QAAAA,aAAa,CAACH,GAAd,CAAkBe,MAAlB,EAA0BC,MAA1B;AACD;;AAEDvB,MAAAA,SAAS,IAAIuB,MAAb;AACD;;AAED,WAAOX,cAAc,CAACZ,SAAD,CAAd,IAA6BJ,aAAa,CAAC,IAAD,EAAOE,EAAP,EAAWpB,SAAX,EAAsBkC,cAAtB,EAAsCZ,SAAtC,CAAjD;AACD,GArB8C,CAAhC,CAAf;AAsBD;;AAED,eAAe,SAASyB,OAAT,GAAmB;AAChChC,EAAAA,mBAAmB,CAAC,+IAAD,CAAnB;;AAEA,OAAK,IAAIiC,KAAK,GAAGhD,SAAS,CAACC,MAAtB,EAA8BoB,IAAI,GAAGmB,KAAK,CAACQ,KAAD,CAA1C,EAAmDC,KAAK,GAAG,CAAhE,EAAmEA,KAAK,GAAGD,KAA3E,EAAkFC,KAAK,EAAvF,EAA2F;AACzF5B,IAAAA,IAAI,CAAC4B,KAAD,CAAJ,GAAcjD,SAAS,CAACiD,KAAD,CAAvB;AACD;;AAED,SAAOnC,QAAQ,CAACgB,gBAAD,EAAmBT,IAAnB,CAAf;AACD","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { decorate, internalDeprecation } from './private/utils';\n\nfunction toObject(cache, value) {\n  if (value === Object(value)) {\n    return value;\n  }\n  return cache[value] || (cache[value] = {});\n}\n\nfunction applyAndCache(context, fn, args, cache, signature) {\n  var ret = fn.apply(context, args);\n  cache[signature] = ret;\n  return ret;\n}\n\nfunction metaForDescriptor(descriptor) {\n  var fn = void 0,\n      wrapKey = void 0;\n\n  // This is ugly code, but way faster than other\n  // ways I tried that *looked* pretty\n\n  if (descriptor.value) {\n    fn = descriptor.value;\n    wrapKey = 'value';\n  } else if (descriptor.get) {\n    fn = descriptor.get;\n    wrapKey = 'get';\n  } else if (descriptor.set) {\n    fn = descriptor.set;\n    wrapKey = 'set';\n  }\n\n  return { fn: fn, wrapKey: wrapKey };\n}\n\nfunction handleDescriptor(target, key, descriptor) {\n  var _metaForDescriptor = metaForDescriptor(descriptor),\n      fn = _metaForDescriptor.fn,\n      wrapKey = _metaForDescriptor.wrapKey;\n\n  var argumentCache = new WeakMap();\n  var signatureCache = Object.create(null);\n  var primativeRefCache = Object.create(null);\n  var argumentIdCounter = 0;\n\n  return _extends({}, descriptor, _defineProperty({}, wrapKey, function memoizeWrapper() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var signature = '0';\n\n    for (var i = 0, l = args.length; i < l; i++) {\n      var arg = args[i];\n      var argRef = toObject(primativeRefCache, arg);\n      var argKey = argumentCache.get(argRef);\n\n      if (argKey === undefined) {\n        argKey = ++argumentIdCounter;\n        argumentCache.set(argRef, argKey);\n      }\n\n      signature += argKey;\n    }\n\n    return signatureCache[signature] || applyAndCache(this, fn, arguments, signatureCache, signature);\n  }));\n}\n\nexport default function memoize() {\n  internalDeprecation('@memoize is deprecated and will be removed shortly. Use @memoize from lodash-decorators.\\n\\n  https://www.npmjs.com/package/lodash-decorators');\n\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return decorate(handleDescriptor, args);\n}"]},"metadata":{},"sourceType":"module"}