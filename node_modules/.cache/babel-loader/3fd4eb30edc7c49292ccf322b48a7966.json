{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _set2 = require('lodash/set');\n\nvar _set3 = _interopRequireDefault(_set2);\n\nvar _httpCore = require('@webex/http-core');\n\nvar _constants = require('../constants');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n  * Adds 'cisco-device-url' header, as appropriate, to requests\n  */\n\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar DeviceUrlInterceptor = function (_Interceptor) {\n  (0, _inherits3.default)(DeviceUrlInterceptor, _Interceptor);\n\n  function DeviceUrlInterceptor() {\n    (0, _classCallCheck3.default)(this, DeviceUrlInterceptor);\n    return (0, _possibleConstructorReturn3.default)(this, (DeviceUrlInterceptor.__proto__ || (0, _getPrototypeOf2.default)(DeviceUrlInterceptor)).apply(this, arguments));\n  }\n\n  (0, _createClass3.default)(DeviceUrlInterceptor, [{\n    key: 'onRequest',\n\n    /**\n     * @see Interceptor#onRequest\n     * @param {Object} options\n     * @returns {Object}\n     */\n    value: function onRequest(options) {\n      var headers = options.headers,\n          service = options.service,\n          uri = options.uri;\n      var _webex$internal = this.webex.internal,\n          device = _webex$internal.device,\n          services = _webex$internal.services; // Check if header is already set before moving forward\n\n      if (!device.url || headers && _constants.CISCO_DEVICE_URL in headers && !headers[_constants.CISCO_DEVICE_URL]) {\n        return _promise2.default.resolve(options);\n      } // Wait for catalog and service to be defined.\n\n\n      return services.waitForService({\n        service: service,\n        url: uri\n      }).then(function (url) {\n        // Grab the service name with the url returned from waitForService\n        var _ref = services.getServiceFromUrl(url) || {},\n            serviceName = _ref.name;\n\n        var invalidServices = ['idbroker', 'oauth', 'saml']; // Check if service is not one of the invalid services\n        // Assign the url to the device header\n\n        if (serviceName && !invalidServices.includes(serviceName)) {\n          (0, _set3.default)(options, 'headers[\\'' + _constants.CISCO_DEVICE_URL + '\\']', device.url);\n        }\n\n        return options;\n      }).catch(function (error) {\n        // Validate that the error came from getServiceFromUrl\n        if (error.message.match(/was not found after waiting/)) {\n          return options;\n        }\n\n        return _promise2.default.reject(error);\n      });\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * @returns {DeviceUrlInterceptor}\n     */\n    value: function create() {\n      /* eslint no-invalid-this: [0] */\n      return new DeviceUrlInterceptor({\n        webex: this\n      });\n    }\n  }]);\n  return DeviceUrlInterceptor;\n}(_httpCore.Interceptor);\n\nexports.default = DeviceUrlInterceptor;","map":{"version":3,"sources":["device-url.js"],"names":["DeviceUrlInterceptor","Interceptor","webex","options","headers","service","uri","device","services","CISCO_DEVICE_URL","url","serviceName","invalidServices","error"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA,IAAA,SAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AAGA,IAAA,UAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;;;;;;AAEA;;;;AATA;;;;;IAYqBA,oB;;;;;;;;;;;AASnB;;;;;8BAKUG,O,EAAS;AAAA,UACVC,OADU,GACeD,OADf,CAAA,OAAA;AAAA,UACDE,OADC,GACeF,OADf,CAAA,OAAA;AAAA,UACQG,GADR,GACeH,OADf,CAAA,GAAA;AAAA,UAAA,eAAA,GAEU,KAAA,KAAA,CAFV,QAAA;AAAA,UAEVI,MAFU,GAAA,eAAA,CAAA,MAAA;AAAA,UAEFC,QAFE,GAAA,eAAA,CAAA,QAAA,CAAA,CAIjB;;AACA,UACE,CAACD,MAAAA,CAAD,GAAA,IACCH,OAAAA,IAAWK,UAAAA,CAAAA,gBAAAA,IAAXL,OAAAA,IAA0C,CAACA,OAAAA,CAAQK,UAAAA,CAFtD,gBAE8CL,CAF9C,EAGE;AACA,eAAO,SAAA,CAAA,OAAA,CAAA,OAAA,CAAP,OAAO,CAAP;AACD,OAVgB,CAYjB;;;AACA,aAAO,QAAA,CAAA,cAAA,CAAwB;AAACC,QAAAA,OAAAA,EAAD,OAAA;AAAUK,QAAAA,GAAAA,EAAlC;AAAwB,OAAxB,EAAA,IAAA,CACC,UAAA,GAAA,EAAS;AACb;AADa,YAAA,IAAA,GAEeF,QAAAA,CAAAA,iBAAAA,CAAAA,GAAAA,KAFf,EAAA;AAAA,YAEAG,WAFA,GAAA,IAAA,CAAA,IAAA;;AAGb,YAAMC,eAAAA,GAAkB,CAAA,UAAA,EAAA,OAAA,EAAxB,MAAwB,CAAxB,CAHa,CAKb;AACA;;AACA,YAAID,WAAAA,IAAe,CAACC,eAAAA,CAAAA,QAAAA,CAApB,WAAoBA,CAApB,EAA2D;AACzD,WAAA,GAAA,KAAA,CAAA,OAAA,EAAA,OAAA,EAAA,eAAyBH,UAAAA,CAAzB,gBAAA,GAAA,KAAA,EAA+CF,MAAAA,CAA/C,GAAA;AACD;;AAED,eAAA,OAAA;AAZG,OAAA,EAAA,KAAA,CAcE,UAAA,KAAA,EAAW;AAChB;AACA,YAAIM,KAAAA,CAAAA,OAAAA,CAAAA,KAAAA,CAAJ,6BAAIA,CAAJ,EAAwD;AACtD,iBAAA,OAAA;AACD;;AAED,eAAO,SAAA,CAAA,OAAA,CAAA,MAAA,CAAP,KAAO,CAAP;AApBJ,OAAO,CAAP;AAsBD;;;;AAhDD;;;6BAGgB;AACd;AACA,aAAO,IAAA,oBAAA,CAAyB;AAACX,QAAAA,KAAAA,EAAjC;AAAgC,OAAzB,CAAP;AACD;;;EAP+CD,SAAAA,CAAAA,W;;kBAA7BD,oB","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {Interceptor} from '@webex/http-core';\nimport {set} from 'lodash';\n\nimport {CISCO_DEVICE_URL} from '../constants';\n\n/**\n  * Adds 'cisco-device-url' header, as appropriate, to requests\n  */\nexport default class DeviceUrlInterceptor extends Interceptor {\n  /**\n   * @returns {DeviceUrlInterceptor}\n   */\n  static create() {\n    /* eslint no-invalid-this: [0] */\n    return new DeviceUrlInterceptor({webex: this});\n  }\n\n  /**\n   * @see Interceptor#onRequest\n   * @param {Object} options\n   * @returns {Object}\n   */\n  onRequest(options) {\n    const {headers, service, uri} = options;\n    const {device, services} = this.webex.internal;\n\n    // Check if header is already set before moving forward\n    if (\n      !device.url ||\n      (headers && CISCO_DEVICE_URL in headers && !headers[CISCO_DEVICE_URL])\n    ) {\n      return Promise.resolve(options);\n    }\n\n    // Wait for catalog and service to be defined.\n    return services.waitForService({service, url: uri})\n      .then((url) => {\n        // Grab the service name with the url returned from waitForService\n        const {name: serviceName} = services.getServiceFromUrl(url) || {};\n        const invalidServices = ['idbroker', 'oauth', 'saml'];\n\n        // Check if service is not one of the invalid services\n        // Assign the url to the device header\n        if (serviceName && !invalidServices.includes(serviceName)) {\n          set(options, `headers['${CISCO_DEVICE_URL}']`, device.url);\n        }\n\n        return options;\n      })\n      .catch((error) => {\n        // Validate that the error came from getServiceFromUrl\n        if (error.message.match(/was not found after waiting/)) {\n          return options;\n        }\n\n        return Promise.reject(error);\n      });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}