{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _ampersandState = require('ampersand-state');\n\nvar _ampersandState2 = _interopRequireDefault(_ampersandState);\n\nvar _serviceUrl = require('./service-url');\n\nvar _serviceUrl2 = _interopRequireDefault(_serviceUrl);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* eslint-disable no-underscore-dangle */\n\n/**\n * @class\n */\n\n\nvar ServiceCatalog = _ampersandState2.default.extend({\n  namespace: 'ServiceCatalog',\n  props: {\n    serviceGroups: ['object', true, function () {\n      return {\n        discovery: [],\n        preauth: [],\n        signin: [],\n        postauth: []\n      };\n    }],\n    status: ['object', true, function () {\n      return {\n        discovery: {\n          ready: false,\n          collecting: false\n        },\n        preauth: {\n          ready: false,\n          collecting: false\n        },\n        postauth: {\n          ready: false,\n          collecting: false\n        },\n        signin: {\n          ready: false,\n          collecting: false\n        }\n      };\n    }],\n    isReady: ['boolean', false, false],\n    allowedDomains: ['array', false, function () {\n      return [];\n    }]\n  },\n\n  /**\n   * @private\n   * Search the service url array to locate a `ServiceUrl`\n   * class object based on its name.\n   * @param {string} name\n   * @param {string} [serviceGroup]\n   * @returns {ServiceUrl}\n   */\n  _getUrl: function _getUrl(name, serviceGroup) {\n    var serviceUrls = typeof serviceGroup === 'string' ? this.serviceGroups[serviceGroup] || [] : [].concat((0, _toConsumableArray3.default)(this.serviceGroups.postauth), (0, _toConsumableArray3.default)(this.serviceGroups.signin), (0, _toConsumableArray3.default)(this.serviceGroups.preauth), (0, _toConsumableArray3.default)(this.serviceGroups.discovery));\n    return serviceUrls.find(function (serviceUrl) {\n      return serviceUrl.name === name;\n    });\n  },\n\n  /**\n   * @private\n   * Generate an array of `ServiceUrl`s that is organized from highest auth\n   * level to lowest auth level.\n   * @returns {Array<ServiceUrl>} - array of `ServiceUrl`s\n   */\n  _listServiceUrls: function _listServiceUrls() {\n    return [].concat((0, _toConsumableArray3.default)(this.serviceGroups.postauth), (0, _toConsumableArray3.default)(this.serviceGroups.signin), (0, _toConsumableArray3.default)(this.serviceGroups.preauth), (0, _toConsumableArray3.default)(this.serviceGroups.discovery));\n  },\n\n  /**\n   * @private\n   * Safely load one or more `ServiceUrl`s into this `Services` instance.\n   * @param {string} serviceGroup\n   * @param  {Array<ServiceUrl>} services\n   * @returns {Services}\n   */\n  _loadServiceUrls: function _loadServiceUrls(serviceGroup, services) {\n    var _this = this; // declare namespaces outside of loop\n\n\n    var existingService = void 0;\n    services.forEach(function (service) {\n      existingService = _this._getUrl(service.name, serviceGroup);\n\n      if (!existingService) {\n        _this.serviceGroups[serviceGroup].push(service);\n      }\n    });\n    return this;\n  },\n\n  /**\n   * @private\n   * Safely unload one or more `ServiceUrl`s into this `Services` instance\n   * @param {string} serviceGroup\n   * @param  {Array<ServiceUrl>} services\n   * @returns {Services}\n   */\n  _unloadServiceUrls: function _unloadServiceUrls(serviceGroup, services) {\n    var _this2 = this; // declare namespaces outside of loop\n\n\n    var existingService = void 0;\n    services.forEach(function (service) {\n      existingService = _this2._getUrl(service.name, serviceGroup);\n\n      if (existingService) {\n        _this2.serviceGroups[serviceGroup].splice(_this2.serviceGroups[serviceGroup].indexOf(existingService), 1);\n      }\n    });\n    return this;\n  },\n\n  /**\n   * Clear all collected catalog data and reset catalog status.\n   *\n   * @returns {void}\n   */\n  clean: function clean() {\n    this.serviceGroups.preauth.length = 0;\n    this.serviceGroups.signin.length = 0;\n    this.serviceGroups.postauth.length = 0;\n    this.status.preauth = {\n      ready: false\n    };\n    this.status.signin = {\n      ready: false\n    };\n    this.status.postauth = {\n      ready: false\n    };\n  },\n\n  /**\n   * Search over all service groups to find a cluster id based\n   * on a given url.\n   * @param {string} url - Must be parsable by `Url`\n   * @returns {string} - ClusterId of a given url\n   */\n  findClusterId: function findClusterId(url) {\n    var incomingUrlObj = _url2.default.parse(url);\n\n    var serviceUrlObj = void 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(this.serviceGroups)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var key = _step.value;\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = (0, _getIterator3.default)(this.serviceGroups[key]), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var service = _step2.value;\n            serviceUrlObj = _url2.default.parse(service.defaultUrl);\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n              for (var _iterator3 = (0, _getIterator3.default)(service.hosts), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                var host = _step3.value;\n\n                if (incomingUrlObj.hostname === host.host && host.id) {\n                  return host.id;\n                }\n              }\n            } catch (err) {\n              _didIteratorError3 = true;\n              _iteratorError3 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                  _iterator3.return();\n                }\n              } finally {\n                if (_didIteratorError3) {\n                  throw _iteratorError3;\n                }\n              }\n            }\n\n            if (serviceUrlObj.hostname === incomingUrlObj.hostname && service.hosts.length > 0) {\n              // no exact match, so try to grab the first home cluster\n              var _iteratorNormalCompletion4 = true;\n              var _didIteratorError4 = false;\n              var _iteratorError4 = undefined;\n\n              try {\n                for (var _iterator4 = (0, _getIterator3.default)(service.hosts), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                  var _host = _step4.value;\n\n                  if (_host.homeCluster) {\n                    return _host.id;\n                  }\n                } // no match found still, so return the first entry\n\n              } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                    _iterator4.return();\n                  }\n                } finally {\n                  if (_didIteratorError4) {\n                    throw _iteratorError4;\n                  }\n                }\n              }\n\n              return service.hosts[0].id;\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return undefined;\n  },\n\n  /**\n   * Search over all service groups and return a service value from a provided\n   * clusterId. Currently, this method will return either a service name, or a\n   * service url depending on the `value` parameter. If the `value` parameter\n   * is set to `name`, it will return a service name to be utilized within the\n   * Services plugin methods.\n   * @param {object} params\n   * @param {string} params.clusterId - clusterId of found service\n   * @param {boolean} [params.priorityHost = true] - returns priority host url if true\n   * @param {string} [params.serviceGroup] - specify service group\n   * @returns {object} service\n   * @returns {string} service.name\n   * @returns {string} service.url\n   */\n  findServiceFromClusterId: function findServiceFromClusterId() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        clusterId = _ref.clusterId,\n        _ref$priorityHost = _ref.priorityHost,\n        priorityHost = _ref$priorityHost === undefined ? true : _ref$priorityHost,\n        serviceGroup = _ref.serviceGroup;\n\n    var serviceUrls = typeof serviceGroup === 'string' ? this.serviceGroups[serviceGroup] || [] : [].concat((0, _toConsumableArray3.default)(this.serviceGroups.postauth), (0, _toConsumableArray3.default)(this.serviceGroups.signin), (0, _toConsumableArray3.default)(this.serviceGroups.preauth), (0, _toConsumableArray3.default)(this.serviceGroups.discovery));\n    var identifiedServiceUrl = serviceUrls.find(function (serviceUrl) {\n      return serviceUrl.hosts.find(function (host) {\n        return host.id === clusterId;\n      });\n    });\n\n    if (identifiedServiceUrl) {\n      return {\n        name: identifiedServiceUrl.name,\n        url: identifiedServiceUrl.get(priorityHost, clusterId)\n      };\n    }\n\n    return undefined;\n  },\n\n  /**\n   * Find a service based on the provided url.\n   * @param {string} url - Must be parsable by `Url`\n   * @returns {serviceUrl} - ServiceUrl assocated with provided url\n   */\n  findServiceUrlFromUrl: function findServiceUrlFromUrl(url) {\n    var incomingUrlObj = _url2.default.parse(url);\n\n    var serviceUrls = [].concat((0, _toConsumableArray3.default)(this.serviceGroups.discovery), (0, _toConsumableArray3.default)(this.serviceGroups.preauth), (0, _toConsumableArray3.default)(this.serviceGroups.signin), (0, _toConsumableArray3.default)(this.serviceGroups.postauth));\n    return serviceUrls.find(function (serviceUrl) {\n      if (incomingUrlObj.hostname === _url2.default.parse(serviceUrl.defaultUrl).hostname) {\n        return true;\n      }\n\n      if (serviceUrl.hosts.find(function (host) {\n        return host.host === incomingUrlObj.hostname;\n      })) {\n        return true;\n      }\n\n      return false;\n    });\n  },\n\n  /**\n   * Finds an allowed domain that matches a specific url.\n   *\n   * @param {string} url - The url to match the allowed domains against.\n   * @returns {string} - The matching allowed domain.\n   */\n  findAllowedDomain: function findAllowedDomain(url) {\n    var urlObj = _url2.default.parse(url);\n\n    if (!urlObj.host) {\n      return undefined;\n    }\n\n    return this.allowedDomains.find(function (allowedDomain) {\n      return urlObj.host.includes(allowedDomain);\n    });\n  },\n\n  /**\n   * Get a service url from the current services list by name.\n   * @param {string} name\n   * @param {boolean} priorityHost\n   * @param {string} serviceGroup\n   * @returns {string}\n   */\n  get: function get(name, priorityHost, serviceGroup) {\n    var serviceUrl = this._getUrl(name, serviceGroup);\n\n    return serviceUrl ? serviceUrl.get(priorityHost) : undefined;\n  },\n\n  /**\n   * Get the current allowed domains list.\n   *\n   * @returns {Array<string>} - the current allowed domains list.\n   */\n  getAllowedDomains: function getAllowedDomains() {\n    return [].concat((0, _toConsumableArray3.default)(this.allowedDomains));\n  },\n\n  /**\n   * Creates an object where the keys are the service names\n   * and the values are the service urls.\n   * @param {boolean} priorityHost - use the highest priority if set to `true`\n   * @param {string} [serviceGroup]\n   * @returns {Record<string, string>}\n   */\n  list: function list(priorityHost, serviceGroup) {\n    var output = {};\n    var serviceUrls = typeof serviceGroup === 'string' ? this.serviceGroups[serviceGroup] || [] : [].concat((0, _toConsumableArray3.default)(this.serviceGroups.discovery), (0, _toConsumableArray3.default)(this.serviceGroups.preauth), (0, _toConsumableArray3.default)(this.serviceGroups.signin), (0, _toConsumableArray3.default)(this.serviceGroups.postauth));\n\n    if (serviceUrls) {\n      serviceUrls.forEach(function (serviceUrl) {\n        output[serviceUrl.name] = serviceUrl.get(priorityHost);\n      });\n    }\n\n    return output;\n  },\n\n  /**\n   * Mark a priority host service url as failed.\n   * This will mark the host associated with the\n   * `ServiceUrl` to be removed from the its\n   * respective host array, and then return the next\n   * viable host from the `ServiceUrls` host array,\n   * or the `ServiceUrls` default url if no other priority\n   * hosts are available, or if `noPriorityHosts` is set to\n   * `true`.\n   * @param {string} url\n   * @param {boolean} noPriorityHosts\n   * @returns {string}\n   */\n  markFailedUrl: function markFailedUrl(url, noPriorityHosts) {\n    var _this3 = this;\n\n    var serviceUrl = this._getUrl((0, _keys2.default)(this.list()).find(function (key) {\n      return _this3._getUrl(key).failHost(url);\n    }));\n\n    if (!serviceUrl) {\n      return undefined;\n    }\n\n    return noPriorityHosts ? serviceUrl.get(false) : serviceUrl.get(true);\n  },\n\n  /**\n   * Set the allowed domains for the catalog.\n   *\n   * @param {Array<string>} allowedDomains - allowed domains to be assigned.\n   * @returns {void}\n   */\n  setAllowedDomains: function setAllowedDomains(allowedDomains) {\n    this.allowedDomains = [].concat((0, _toConsumableArray3.default)(allowedDomains));\n  },\n\n  /**\n   * Update the current list of `ServiceUrl`s against a provided\n   * service hostmap.\n   * @emits ServiceCatalog#preauthorized\n   * @emits ServiceCatalog#postauthorized\n   * @param {string} serviceGroup\n   * @param {object} serviceHostmap\n   * @returns {Services}\n   */\n  updateServiceUrls: function updateServiceUrls(serviceGroup, serviceHostmap) {\n    var _this4 = this;\n\n    var currentServiceUrls = this.serviceGroups[serviceGroup];\n    var unusedUrls = currentServiceUrls.filter(function (serviceUrl) {\n      return serviceHostmap.every(function (item) {\n        return item.name !== serviceUrl.name;\n      });\n    });\n\n    this._unloadServiceUrls(serviceGroup, unusedUrls);\n\n    serviceHostmap.forEach(function (serviceObj) {\n      var service = _this4._getUrl(serviceObj.name, serviceGroup);\n\n      if (service) {\n        service.defaultUrl = serviceObj.defaultUrl;\n        service.hosts = serviceObj.hosts || [];\n      } else {\n        _this4._loadServiceUrls(serviceGroup, [new _serviceUrl2.default((0, _extends3.default)({}, serviceObj))]);\n      }\n    });\n    this.status[serviceGroup].ready = true;\n    this.trigger(serviceGroup);\n    return this;\n  },\n\n  /**\n   * Wait until the service catalog is available,\n   * or reject after a timeout of 60 seconds.\n   * @param {string} serviceGroup\n   * @param {number} [timeout] - in seconds\n   * @returns {Promise<void>}\n   */\n  waitForCatalog: function waitForCatalog(serviceGroup, timeout) {\n    var _this5 = this;\n\n    return new _promise2.default(function (resolve, reject) {\n      if (_this5.status[serviceGroup].ready) {\n        resolve();\n      }\n\n      var timeoutTimer = setTimeout(function () {\n        return reject(new Error('services: timeout occured while waiting for \\'' + serviceGroup + '\\' catalog to populate'));\n      }, timeout ? timeout * 1000 : 60000);\n\n      _this5.once(serviceGroup, function () {\n        clearTimeout(timeoutTimer);\n        resolve();\n      });\n    });\n  }\n});\n/* eslint-enable no-underscore-dangle */\n\n\nexports.default = ServiceCatalog;","map":{"version":3,"sources":["service-catalog.js"],"names":["ServiceCatalog","namespace","props","serviceGroups","discovery","preauth","signin","postauth","status","ready","collecting","isReady","allowedDomains","_getUrl","serviceUrls","serviceUrl","_listServiceUrls","_loadServiceUrls","existingService","services","service","_unloadServiceUrls","clean","findClusterId","incomingUrlObj","Url","serviceUrlObj","key","host","findServiceFromClusterId","clusterId","priorityHost","serviceGroup","identifiedServiceUrl","name","url","findServiceUrlFromUrl","findAllowedDomain","urlObj","get","getAllowedDomains","list","output","markFailedUrl","noPriorityHosts","setAllowedDomains","updateServiceUrls","currentServiceUrls","unusedUrls","item","serviceHostmap","serviceObj","ServiceUrl","waitForCatalog","resolve","timeoutTimer","reject","timeout","clearTimeout"],"mappings":"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","sourcesContent":["import Url from 'url';\n\nimport AmpState from 'ampersand-state';\n\nimport ServiceUrl from './service-url';\n\n/* eslint-disable no-underscore-dangle */\n/**\n * @class\n */\nconst ServiceCatalog = AmpState.extend({\n  namespace: 'ServiceCatalog',\n\n  props: {\n    serviceGroups: ['object', true, (() => ({\n      discovery: [],\n      preauth: [],\n      signin: [],\n      postauth: []\n    }))],\n    status: ['object', true, (() => ({\n      discovery: {\n        ready: false,\n        collecting: false\n      },\n      preauth: {\n        ready: false,\n        collecting: false\n      },\n      postauth: {\n        ready: false,\n        collecting: false\n      },\n      signin: {\n        ready: false,\n        collecting: false\n      }\n    }))],\n    isReady: ['boolean', false, false],\n    allowedDomains: ['array', false, (() => [])]\n  },\n\n  /**\n   * @private\n   * Search the service url array to locate a `ServiceUrl`\n   * class object based on its name.\n   * @param {string} name\n   * @param {string} [serviceGroup]\n   * @returns {ServiceUrl}\n   */\n  _getUrl(name, serviceGroup) {\n    const serviceUrls = (typeof serviceGroup === 'string') ?\n      this.serviceGroups[serviceGroup] || [] :\n      [\n        ...this.serviceGroups.postauth,\n        ...this.serviceGroups.signin,\n        ...this.serviceGroups.preauth,\n        ...this.serviceGroups.discovery\n      ];\n\n    return serviceUrls.find((serviceUrl) => serviceUrl.name === name);\n  },\n\n  /**\n   * @private\n   * Generate an array of `ServiceUrl`s that is organized from highest auth\n   * level to lowest auth level.\n   * @returns {Array<ServiceUrl>} - array of `ServiceUrl`s\n   */\n  _listServiceUrls() {\n    return [\n      ...this.serviceGroups.postauth,\n      ...this.serviceGroups.signin,\n      ...this.serviceGroups.preauth,\n      ...this.serviceGroups.discovery\n    ];\n  },\n\n  /**\n   * @private\n   * Safely load one or more `ServiceUrl`s into this `Services` instance.\n   * @param {string} serviceGroup\n   * @param  {Array<ServiceUrl>} services\n   * @returns {Services}\n   */\n  _loadServiceUrls(serviceGroup, services) {\n    // declare namespaces outside of loop\n    let existingService;\n\n    services.forEach((service) => {\n      existingService = this._getUrl(service.name, serviceGroup);\n\n      if (!existingService) {\n        this.serviceGroups[serviceGroup].push(service);\n      }\n    });\n\n    return this;\n  },\n\n  /**\n   * @private\n   * Safely unload one or more `ServiceUrl`s into this `Services` instance\n   * @param {string} serviceGroup\n   * @param  {Array<ServiceUrl>} services\n   * @returns {Services}\n   */\n  _unloadServiceUrls(serviceGroup, services) {\n    // declare namespaces outside of loop\n    let existingService;\n\n    services.forEach((service) => {\n      existingService = this._getUrl(service.name, serviceGroup);\n\n      if (existingService) {\n        this.serviceGroups[serviceGroup].splice(\n          this.serviceGroups[serviceGroup].indexOf(existingService), 1\n        );\n      }\n    });\n\n    return this;\n  },\n\n  /**\n   * Clear all collected catalog data and reset catalog status.\n   *\n   * @returns {void}\n   */\n  clean() {\n    this.serviceGroups.preauth.length = 0;\n    this.serviceGroups.signin.length = 0;\n    this.serviceGroups.postauth.length = 0;\n    this.status.preauth = {ready: false};\n    this.status.signin = {ready: false};\n    this.status.postauth = {ready: false};\n  },\n\n  /**\n   * Search over all service groups to find a cluster id based\n   * on a given url.\n   * @param {string} url - Must be parsable by `Url`\n   * @returns {string} - ClusterId of a given url\n   */\n  findClusterId(url) {\n    const incomingUrlObj = Url.parse(url);\n    let serviceUrlObj;\n\n    for (const key of Object.keys(this.serviceGroups)) {\n      for (const service of this.serviceGroups[key]) {\n        serviceUrlObj = Url.parse(service.defaultUrl);\n\n        for (const host of service.hosts) {\n          if (incomingUrlObj.hostname === host.host && host.id) {\n            return host.id;\n          }\n        }\n\n        if (serviceUrlObj.hostname === incomingUrlObj.hostname &&\n          service.hosts.length > 0) {\n          // no exact match, so try to grab the first home cluster\n          for (const host of service.hosts) {\n            if (host.homeCluster) {\n              return host.id;\n            }\n          }\n\n          // no match found still, so return the first entry\n          return service.hosts[0].id;\n        }\n      }\n    }\n\n    return undefined;\n  },\n\n  /**\n   * Search over all service groups and return a service value from a provided\n   * clusterId. Currently, this method will return either a service name, or a\n   * service url depending on the `value` parameter. If the `value` parameter\n   * is set to `name`, it will return a service name to be utilized within the\n   * Services plugin methods.\n   * @param {object} params\n   * @param {string} params.clusterId - clusterId of found service\n   * @param {boolean} [params.priorityHost = true] - returns priority host url if true\n   * @param {string} [params.serviceGroup] - specify service group\n   * @returns {object} service\n   * @returns {string} service.name\n   * @returns {string} service.url\n   */\n  findServiceFromClusterId({clusterId, priorityHost = true, serviceGroup} = {}) {\n    const serviceUrls = (typeof serviceGroup === 'string') ?\n      this.serviceGroups[serviceGroup] || [] : [\n        ...this.serviceGroups.postauth,\n        ...this.serviceGroups.signin,\n        ...this.serviceGroups.preauth,\n        ...this.serviceGroups.discovery\n      ];\n\n    const identifiedServiceUrl = serviceUrls.find(\n      (serviceUrl) => serviceUrl.hosts.find(\n        (host) => host.id === clusterId\n      )\n    );\n\n    if (identifiedServiceUrl) {\n      return {\n        name: identifiedServiceUrl.name,\n        url: identifiedServiceUrl.get(priorityHost, clusterId)\n      };\n    }\n\n    return undefined;\n  },\n\n  /**\n   * Find a service based on the provided url.\n   * @param {string} url - Must be parsable by `Url`\n   * @returns {serviceUrl} - ServiceUrl assocated with provided url\n   */\n  findServiceUrlFromUrl(url) {\n    const incomingUrlObj = Url.parse(url);\n    const serviceUrls = [\n      ...this.serviceGroups.discovery,\n      ...this.serviceGroups.preauth,\n      ...this.serviceGroups.signin,\n      ...this.serviceGroups.postauth\n    ];\n\n    return serviceUrls.find(\n      (serviceUrl) => {\n        if (incomingUrlObj.hostname ===\n          Url.parse(serviceUrl.defaultUrl).hostname) {\n          return true;\n        }\n\n        if (serviceUrl.hosts.find((host) => host.host === incomingUrlObj.hostname)) {\n          return true;\n        }\n\n        return false;\n      }\n    );\n  },\n\n  /**\n   * Finds an allowed domain that matches a specific url.\n   *\n   * @param {string} url - The url to match the allowed domains against.\n   * @returns {string} - The matching allowed domain.\n   */\n  findAllowedDomain(url) {\n    const urlObj = Url.parse(url);\n\n    if (!urlObj.host) {\n      return undefined;\n    }\n\n    return this.allowedDomains.find(\n      (allowedDomain) => urlObj.host.includes(allowedDomain)\n    );\n  },\n\n  /**\n   * Get a service url from the current services list by name.\n   * @param {string} name\n   * @param {boolean} priorityHost\n   * @param {string} serviceGroup\n   * @returns {string}\n   */\n  get(name, priorityHost, serviceGroup) {\n    const serviceUrl = this._getUrl(name, serviceGroup);\n\n    return (serviceUrl) ? serviceUrl.get(priorityHost) : undefined;\n  },\n\n  /**\n   * Get the current allowed domains list.\n   *\n   * @returns {Array<string>} - the current allowed domains list.\n   */\n  getAllowedDomains() {\n    return [...this.allowedDomains];\n  },\n\n  /**\n   * Creates an object where the keys are the service names\n   * and the values are the service urls.\n   * @param {boolean} priorityHost - use the highest priority if set to `true`\n   * @param {string} [serviceGroup]\n   * @returns {Record<string, string>}\n   */\n  list(priorityHost, serviceGroup) {\n    const output = {};\n\n    const serviceUrls = (typeof serviceGroup === 'string') ?\n      this.serviceGroups[serviceGroup] || [] :\n      [\n        ...this.serviceGroups.discovery,\n        ...this.serviceGroups.preauth,\n        ...this.serviceGroups.signin,\n        ...this.serviceGroups.postauth\n      ];\n\n    if (serviceUrls) {\n      serviceUrls.forEach((serviceUrl) => {\n        output[serviceUrl.name] = serviceUrl.get(priorityHost);\n      });\n    }\n\n    return output;\n  },\n\n  /**\n   * Mark a priority host service url as failed.\n   * This will mark the host associated with the\n   * `ServiceUrl` to be removed from the its\n   * respective host array, and then return the next\n   * viable host from the `ServiceUrls` host array,\n   * or the `ServiceUrls` default url if no other priority\n   * hosts are available, or if `noPriorityHosts` is set to\n   * `true`.\n   * @param {string} url\n   * @param {boolean} noPriorityHosts\n   * @returns {string}\n   */\n  markFailedUrl(url, noPriorityHosts) {\n    const serviceUrl = this._getUrl(Object.keys(this.list()).find(\n      (key) => this._getUrl(key).failHost(url)\n    ));\n\n    if (!serviceUrl) {\n      return undefined;\n    }\n\n    return (noPriorityHosts) ? serviceUrl.get(false) : serviceUrl.get(true);\n  },\n\n  /**\n   * Set the allowed domains for the catalog.\n   *\n   * @param {Array<string>} allowedDomains - allowed domains to be assigned.\n   * @returns {void}\n   */\n  setAllowedDomains(allowedDomains) {\n    this.allowedDomains = [...allowedDomains];\n  },\n\n  /**\n   * Update the current list of `ServiceUrl`s against a provided\n   * service hostmap.\n   * @emits ServiceCatalog#preauthorized\n   * @emits ServiceCatalog#postauthorized\n   * @param {string} serviceGroup\n   * @param {object} serviceHostmap\n   * @returns {Services}\n   */\n  updateServiceUrls(serviceGroup, serviceHostmap) {\n    const currentServiceUrls = this.serviceGroups[serviceGroup];\n\n    const unusedUrls = currentServiceUrls.filter(\n      (serviceUrl) => serviceHostmap.every(\n        (item) => item.name !== serviceUrl.name\n      )\n    );\n\n    this._unloadServiceUrls(serviceGroup, unusedUrls);\n\n    serviceHostmap.forEach((serviceObj) => {\n      const service = this._getUrl(serviceObj.name, serviceGroup);\n\n      if (service) {\n        service.defaultUrl = serviceObj.defaultUrl;\n        service.hosts = serviceObj.hosts || [];\n      }\n      else {\n        this._loadServiceUrls(serviceGroup, [new ServiceUrl({\n          ...serviceObj\n        })]);\n      }\n    });\n\n    this.status[serviceGroup].ready = true;\n    this.trigger(serviceGroup);\n\n    return this;\n  },\n\n  /**\n   * Wait until the service catalog is available,\n   * or reject after a timeout of 60 seconds.\n   * @param {string} serviceGroup\n   * @param {number} [timeout] - in seconds\n   * @returns {Promise<void>}\n   */\n  waitForCatalog(serviceGroup, timeout) {\n    return new Promise((resolve, reject) => {\n      if (this.status[serviceGroup].ready) {\n        resolve();\n      }\n\n      const timeoutTimer = setTimeout(() => reject(\n        new Error(`services: timeout occured while waiting for '${serviceGroup}' catalog to populate`)\n      ), (timeout) ? timeout * 1000 : 60000);\n\n      this.once(serviceGroup, () => {\n        clearTimeout(timeoutTimer);\n        resolve();\n      });\n    });\n  }\n});\n/* eslint-enable no-underscore-dangle */\n\nexport default ServiceCatalog;\n"]},"metadata":{},"sourceType":"script"}