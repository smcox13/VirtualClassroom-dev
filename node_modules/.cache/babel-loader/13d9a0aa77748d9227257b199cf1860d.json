{"ast":null,"code":"class JsonError extends Error {\n  constructor(message, innerError) {\n    super(innerError ? `${message}. See the inner exception for more details.` : message);\n    this.message = message;\n    this.innerError = innerError;\n  }\n\n}\n\nclass TransformError extends JsonError {\n  constructor(schema, message, innerError) {\n    super(message, innerError);\n    this.schema = schema;\n  }\n\n}\n\nclass ParserError extends TransformError {\n  constructor(schema, message, innerError) {\n    super(schema, `JSON doesn't match to '${schema.target.name}' schema. ${message}`, innerError);\n  }\n\n}\n\nclass ValidationError extends JsonError {}\n\nclass SerializerError extends JsonError {\n  constructor(schemaName, message, innerError) {\n    super(`Cannot serialize by '${schemaName}' schema. ${message}`, innerError);\n    this.schemaName = schemaName;\n  }\n\n}\n\nclass KeyError extends ParserError {\n  constructor(schema, keys, errors = {}) {\n    super(schema, \"Some keys doesn't match to schema\");\n    this.keys = keys;\n    this.errors = errors;\n  }\n\n}\n\nvar JsonPropTypes;\n\n(function (JsonPropTypes) {\n  JsonPropTypes[JsonPropTypes[\"Any\"] = 0] = \"Any\";\n  JsonPropTypes[JsonPropTypes[\"Boolean\"] = 1] = \"Boolean\";\n  JsonPropTypes[JsonPropTypes[\"Number\"] = 2] = \"Number\";\n  JsonPropTypes[JsonPropTypes[\"String\"] = 3] = \"String\";\n})(JsonPropTypes || (JsonPropTypes = {}));\n\nfunction checkType(value, type) {\n  switch (type) {\n    case JsonPropTypes.Boolean:\n      return typeof value === \"boolean\";\n\n    case JsonPropTypes.Number:\n      return typeof value === \"number\";\n\n    case JsonPropTypes.String:\n      return typeof value === \"string\";\n  }\n\n  return true;\n}\n\nfunction throwIfTypeIsWrong(value, type) {\n  if (!checkType(value, type)) {\n    throw new TypeError(`Value must be ${JsonPropTypes[type]}`);\n  }\n}\n\nfunction isConvertible(target) {\n  if (target && target.prototype) {\n    if (target.prototype.toJSON && target.prototype.fromJSON) {\n      return true;\n    } else {\n      return isConvertible(target.prototype);\n    }\n  } else {\n    return !!(target && target.toJSON && target.fromJSON);\n  }\n}\n\nclass JsonSchemaStorage {\n  constructor() {\n    this.items = new Map();\n  }\n\n  has(target) {\n    return this.items.has(target) || !!this.findParentSchema(target);\n  }\n\n  get(target) {\n    const schema = this.items.get(target) || this.findParentSchema(target);\n\n    if (!schema) {\n      throw new Error(\"Cannot get schema for current target\");\n    }\n\n    return schema;\n  }\n\n  create(target) {\n    const schema = {\n      names: {}\n    };\n    const parentSchema = this.findParentSchema(target);\n\n    if (parentSchema) {\n      Object.assign(schema, parentSchema);\n      schema.names = {};\n\n      for (const name in parentSchema.names) {\n        schema.names[name] = Object.assign({}, parentSchema.names[name]);\n      }\n    }\n\n    schema.target = target;\n    return schema;\n  }\n\n  set(target, schema) {\n    this.items.set(target, schema);\n    return this;\n  }\n\n  findParentSchema(target) {\n    const parent = target.__proto__;\n\n    if (parent) {\n      const schema = this.items.get(parent);\n      return schema || this.findParentSchema(parent);\n    }\n\n    return null;\n  }\n\n}\n\nconst DEFAULT_SCHEMA = \"default\";\nconst schemaStorage = new JsonSchemaStorage();\n\nclass PatternValidation {\n  constructor(pattern) {\n    this.pattern = new RegExp(pattern);\n  }\n\n  validate(value) {\n    const pattern = new RegExp(this.pattern.source, this.pattern.flags);\n\n    if (typeof value !== \"string\") {\n      throw new ValidationError(\"Incoming value must be string\");\n    }\n\n    if (!pattern.exec(value)) {\n      throw new ValidationError(`Value doesn't match to pattern '${pattern.toString()}'`);\n    }\n  }\n\n}\n\nclass InclusiveValidation {\n  constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {\n    this.min = min;\n    this.max = max;\n  }\n\n  validate(value) {\n    throwIfTypeIsWrong(value, JsonPropTypes.Number);\n\n    if (!(this.min <= value && value <= this.max)) {\n      const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\n      const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\n      throw new ValidationError(`Value doesn't match to diapason [${min},${max}]`);\n    }\n  }\n\n}\n\nclass ExclusiveValidation {\n  constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {\n    this.min = min;\n    this.max = max;\n  }\n\n  validate(value) {\n    throwIfTypeIsWrong(value, JsonPropTypes.Number);\n\n    if (!(this.min < value && value < this.max)) {\n      const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\n      const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\n      throw new ValidationError(`Value doesn't match to diapason (${min},${max})`);\n    }\n  }\n\n}\n\nclass LengthValidation {\n  constructor(length, minLength, maxLength) {\n    this.length = length;\n    this.minLength = minLength;\n    this.maxLength = maxLength;\n  }\n\n  validate(value) {\n    if (this.length !== undefined) {\n      if (value.length !== this.length) {\n        throw new ValidationError(`Value length must be exactly ${this.length}.`);\n      }\n\n      return;\n    }\n\n    if (this.minLength !== undefined) {\n      if (value.length < this.minLength) {\n        throw new ValidationError(`Value length must be more than ${this.minLength}.`);\n      }\n    }\n\n    if (this.maxLength !== undefined) {\n      if (value.length > this.maxLength) {\n        throw new ValidationError(`Value length must be less than ${this.maxLength}.`);\n      }\n    }\n  }\n\n}\n\nclass EnumerationValidation {\n  constructor(enumeration) {\n    this.enumeration = enumeration;\n  }\n\n  validate(value) {\n    throwIfTypeIsWrong(value, JsonPropTypes.String);\n\n    if (!this.enumeration.includes(value)) {\n      throw new ValidationError(`Value must be one of ${this.enumeration.map(v => `'${v}'`).join(\", \")}`);\n    }\n  }\n\n}\n\nclass JsonTransform {\n  static checkValues(data, schemaItem) {\n    const values = Array.isArray(data) ? data : [data];\n\n    for (const value of values) {\n      for (const validation of schemaItem.validations) {\n        if (validation instanceof LengthValidation && schemaItem.repeated) {\n          validation.validate(data);\n        } else {\n          validation.validate(value);\n        }\n      }\n    }\n  }\n\n  static checkTypes(value, schemaItem) {\n    if (schemaItem.repeated && !Array.isArray(value)) {\n      throw new TypeError(\"Value must be Array\");\n    }\n\n    if (typeof schemaItem.type === \"number\") {\n      const values = Array.isArray(value) ? value : [value];\n\n      for (const v of values) {\n        throwIfTypeIsWrong(v, schemaItem.type);\n      }\n    }\n  }\n\n  static getSchemaByName(schema, name = DEFAULT_SCHEMA) {\n    return { ...schema.names[DEFAULT_SCHEMA],\n      ...schema.names[name]\n    };\n  }\n\n}\n\nclass JsonSerializer extends JsonTransform {\n  static serialize(obj, options, replacer, space) {\n    const json = this.toJSON(obj, options);\n    return JSON.stringify(json, replacer, space);\n  }\n\n  static toJSON(obj, options = {}) {\n    let res;\n    let targetSchema = options.targetSchema;\n    const schemaName = options.schemaName || DEFAULT_SCHEMA;\n\n    if (isConvertible(obj)) {\n      return obj.toJSON();\n    }\n\n    if (Array.isArray(obj)) {\n      res = [];\n\n      for (const item of obj) {\n        res.push(this.toJSON(item, options));\n      }\n    } else if (typeof obj === \"object\") {\n      if (targetSchema && !schemaStorage.has(targetSchema)) {\n        throw new JsonError(\"Cannot get schema for `targetSchema` param\");\n      }\n\n      targetSchema = targetSchema || obj.constructor;\n\n      if (schemaStorage.has(targetSchema)) {\n        const schema = schemaStorage.get(targetSchema);\n        res = {};\n        const namedSchema = this.getSchemaByName(schema, schemaName);\n\n        for (const key in namedSchema) {\n          try {\n            const item = namedSchema[key];\n            const objItem = obj[key];\n            let value;\n\n            if (item.optional && objItem === undefined || item.defaultValue !== undefined && objItem === item.defaultValue) {\n              continue;\n            }\n\n            if (!item.optional && objItem === undefined) {\n              throw new SerializerError(targetSchema.name, `Property '${key}' is required.`);\n            }\n\n            if (typeof item.type === \"number\") {\n              if (item.converter) {\n                if (item.repeated) {\n                  value = objItem.map(el => item.converter.toJSON(el, obj));\n                } else {\n                  value = item.converter.toJSON(objItem, obj);\n                }\n              } else {\n                value = objItem;\n              }\n            } else {\n              if (item.repeated) {\n                value = objItem.map(el => this.toJSON(el, {\n                  schemaName\n                }));\n              } else {\n                value = this.toJSON(objItem, {\n                  schemaName\n                });\n              }\n            }\n\n            this.checkTypes(value, item);\n            this.checkValues(value, item);\n            res[item.name || key] = value;\n          } catch (e) {\n            if (e instanceof SerializerError) {\n              throw e;\n            } else {\n              throw new SerializerError(schema.target.name, `Property '${key}' is wrong. ${e.message}`, e);\n            }\n          }\n        }\n      } else {\n        res = {};\n\n        for (const key in obj) {\n          res[key] = this.toJSON(obj[key], {\n            schemaName\n          });\n        }\n      }\n    } else {\n      res = obj;\n    }\n\n    return res;\n  }\n\n}\n\nclass JsonParser extends JsonTransform {\n  static parse(data, options) {\n    const obj = JSON.parse(data);\n    return this.fromJSON(obj, options);\n  }\n\n  static fromJSON(target, options) {\n    const targetSchema = options.targetSchema;\n    const schemaName = options.schemaName || DEFAULT_SCHEMA;\n    const obj = new targetSchema();\n\n    if (isConvertible(obj)) {\n      return obj.fromJSON(target);\n    }\n\n    const schema = schemaStorage.get(targetSchema);\n    const namedSchema = this.getSchemaByName(schema, schemaName);\n    const keyErrors = {};\n\n    if (options.strictProperty && !Array.isArray(target)) {\n      JsonParser.checkStrictProperty(target, namedSchema, schema);\n    }\n\n    for (const key in namedSchema) {\n      try {\n        const item = namedSchema[key];\n        const name = item.name || key;\n        const value = target[name];\n\n        if (value === undefined && (item.optional || item.defaultValue !== undefined)) {\n          continue;\n        }\n\n        if (!item.optional && value === undefined) {\n          throw new ParserError(schema, `Property '${name}' is required.`);\n        }\n\n        this.checkTypes(value, item);\n        this.checkValues(value, item);\n\n        if (typeof item.type === \"number\") {\n          if (item.converter) {\n            if (item.repeated) {\n              obj[key] = value.map(el => item.converter.fromJSON(el, obj));\n            } else {\n              obj[key] = item.converter.fromJSON(value, obj);\n            }\n          } else {\n            obj[key] = value;\n          }\n        } else {\n          const newOptions = { ...options,\n            targetSchema: item.type,\n            schemaName\n          };\n\n          if (item.repeated) {\n            obj[key] = value.map(el => this.fromJSON(el, newOptions));\n          } else {\n            obj[key] = this.fromJSON(value, newOptions);\n          }\n        }\n      } catch (e) {\n        if (!(e instanceof ParserError)) {\n          e = new ParserError(schema, `Property '${key}' is wrong. ${e.message}`, e);\n        }\n\n        if (options.strictAllKeys) {\n          keyErrors[key] = e;\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    const keys = Object.keys(keyErrors);\n\n    if (keys.length) {\n      throw new KeyError(schema, keys, keyErrors);\n    }\n\n    return obj;\n  }\n\n  static checkStrictProperty(target, namedSchema, schema) {\n    const jsonProps = Object.keys(target);\n    const schemaProps = Object.keys(namedSchema);\n    const keys = [];\n\n    for (const key of jsonProps) {\n      if (schemaProps.indexOf(key) === -1) {\n        keys.push(key);\n      }\n    }\n\n    if (keys.length) {\n      throw new KeyError(schema, keys);\n    }\n  }\n\n}\n\nfunction getValidations(item) {\n  const validations = [];\n\n  if (item.pattern) {\n    validations.push(new PatternValidation(item.pattern));\n  }\n\n  if (item.type === JsonPropTypes.Number || item.type === JsonPropTypes.Any) {\n    if (item.minInclusive !== undefined || item.maxInclusive !== undefined) {\n      validations.push(new InclusiveValidation(item.minInclusive, item.maxInclusive));\n    }\n\n    if (item.minExclusive !== undefined || item.maxExclusive !== undefined) {\n      validations.push(new ExclusiveValidation(item.minExclusive, item.maxExclusive));\n    }\n\n    if (item.enumeration !== undefined) {\n      validations.push(new EnumerationValidation(item.enumeration));\n    }\n  }\n\n  if (item.type === JsonPropTypes.String || item.repeated || item.type === JsonPropTypes.Any) {\n    if (item.length !== undefined || item.minLength !== undefined || item.maxLength !== undefined) {\n      validations.push(new LengthValidation(item.length, item.minLength, item.maxLength));\n    }\n  }\n\n  return validations;\n}\n\nconst JsonProp = (options = {}) => (target, propertyKey) => {\n  const errorMessage = `Cannot set type for ${propertyKey} property of ${target.constructor.name} schema`;\n  let schema;\n\n  if (!schemaStorage.has(target.constructor)) {\n    schema = schemaStorage.create(target.constructor);\n    schemaStorage.set(target.constructor, schema);\n  } else {\n    schema = schemaStorage.get(target.constructor);\n\n    if (schema.target !== target.constructor) {\n      schema = schemaStorage.create(target.constructor);\n      schemaStorage.set(target.constructor, schema);\n    }\n  }\n\n  const defaultSchema = {\n    type: JsonPropTypes.Any,\n    validations: []\n  };\n  const copyOptions = Object.assign(defaultSchema, options);\n  copyOptions.validations = getValidations(copyOptions);\n\n  if (typeof copyOptions.type !== \"number\") {\n    if (!schemaStorage.has(copyOptions.type) && !isConvertible(copyOptions.type)) {\n      throw new Error(`${errorMessage}. Assigning type doesn't have schema.`);\n    }\n  }\n\n  let schemaNames;\n\n  if (Array.isArray(options.schema)) {\n    schemaNames = options.schema;\n  } else {\n    schemaNames = [options.schema || DEFAULT_SCHEMA];\n  }\n\n  for (const schemaName of schemaNames) {\n    if (!schema.names[schemaName]) {\n      schema.names[schemaName] = {};\n    }\n\n    const namedSchema = schema.names[schemaName];\n    namedSchema[propertyKey] = copyOptions;\n  }\n};\n\nexport { JsonError, JsonParser, JsonProp, JsonPropTypes, JsonSerializer, KeyError, ParserError, SerializerError, TransformError, ValidationError };","map":{"version":3,"sources":["/Users/pratison/Work/Cisco/Education/React/education-webex/node_modules/@peculiar/json-schema/build/index.es.js"],"names":["JsonError","Error","constructor","message","innerError","TransformError","schema","ParserError","target","name","ValidationError","SerializerError","schemaName","KeyError","keys","errors","JsonPropTypes","checkType","value","type","Boolean","Number","String","throwIfTypeIsWrong","TypeError","isConvertible","prototype","toJSON","fromJSON","JsonSchemaStorage","items","Map","has","findParentSchema","get","create","names","parentSchema","Object","assign","set","parent","__proto__","DEFAULT_SCHEMA","schemaStorage","PatternValidation","pattern","RegExp","validate","source","flags","exec","toString","InclusiveValidation","min","MIN_VALUE","max","MAX_VALUE","ExclusiveValidation","LengthValidation","length","minLength","maxLength","undefined","EnumerationValidation","enumeration","includes","map","v","join","JsonTransform","checkValues","data","schemaItem","values","Array","isArray","validation","validations","repeated","checkTypes","getSchemaByName","JsonSerializer","serialize","obj","options","replacer","space","json","JSON","stringify","res","targetSchema","item","push","namedSchema","key","objItem","optional","defaultValue","converter","el","e","JsonParser","parse","keyErrors","strictProperty","checkStrictProperty","newOptions","strictAllKeys","jsonProps","schemaProps","indexOf","getValidations","Any","minInclusive","maxInclusive","minExclusive","maxExclusive","JsonProp","propertyKey","errorMessage","defaultSchema","copyOptions","schemaNames"],"mappings":"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","sourcesContent":["class JsonError extends Error {\r\n    constructor(message, innerError) {\r\n        super(innerError\r\n            ? `${message}. See the inner exception for more details.`\r\n            : message);\r\n        this.message = message;\r\n        this.innerError = innerError;\r\n    }\r\n}\n\nclass TransformError extends JsonError {\r\n    constructor(schema, message, innerError) {\r\n        super(message, innerError);\r\n        this.schema = schema;\r\n    }\r\n}\n\nclass ParserError extends TransformError {\r\n    constructor(schema, message, innerError) {\r\n        super(schema, `JSON doesn't match to '${schema.target.name}' schema. ${message}`, innerError);\r\n    }\r\n}\n\nclass ValidationError extends JsonError {\r\n}\n\nclass SerializerError extends JsonError {\r\n    constructor(schemaName, message, innerError) {\r\n        super(`Cannot serialize by '${schemaName}' schema. ${message}`, innerError);\r\n        this.schemaName = schemaName;\r\n    }\r\n}\n\nclass KeyError extends ParserError {\r\n    constructor(schema, keys, errors = {}) {\r\n        super(schema, \"Some keys doesn't match to schema\");\r\n        this.keys = keys;\r\n        this.errors = errors;\r\n    }\r\n}\n\nvar JsonPropTypes;\r\n(function (JsonPropTypes) {\r\n    JsonPropTypes[JsonPropTypes[\"Any\"] = 0] = \"Any\";\r\n    JsonPropTypes[JsonPropTypes[\"Boolean\"] = 1] = \"Boolean\";\r\n    JsonPropTypes[JsonPropTypes[\"Number\"] = 2] = \"Number\";\r\n    JsonPropTypes[JsonPropTypes[\"String\"] = 3] = \"String\";\r\n})(JsonPropTypes || (JsonPropTypes = {}));\n\nfunction checkType(value, type) {\r\n    switch (type) {\r\n        case JsonPropTypes.Boolean:\r\n            return typeof value === \"boolean\";\r\n        case JsonPropTypes.Number:\r\n            return typeof value === \"number\";\r\n        case JsonPropTypes.String:\r\n            return typeof value === \"string\";\r\n    }\r\n    return true;\r\n}\r\nfunction throwIfTypeIsWrong(value, type) {\r\n    if (!checkType(value, type)) {\r\n        throw new TypeError(`Value must be ${JsonPropTypes[type]}`);\r\n    }\r\n}\r\nfunction isConvertible(target) {\r\n    if (target && target.prototype) {\r\n        if (target.prototype.toJSON && target.prototype.fromJSON) {\r\n            return true;\r\n        }\r\n        else {\r\n            return isConvertible(target.prototype);\r\n        }\r\n    }\r\n    else {\r\n        return !!(target && target.toJSON && target.fromJSON);\r\n    }\r\n}\n\nclass JsonSchemaStorage {\r\n    constructor() {\r\n        this.items = new Map();\r\n    }\r\n    has(target) {\r\n        return this.items.has(target) || !!this.findParentSchema(target);\r\n    }\r\n    get(target) {\r\n        const schema = this.items.get(target) || this.findParentSchema(target);\r\n        if (!schema) {\r\n            throw new Error(\"Cannot get schema for current target\");\r\n        }\r\n        return schema;\r\n    }\r\n    create(target) {\r\n        const schema = { names: {} };\r\n        const parentSchema = this.findParentSchema(target);\r\n        if (parentSchema) {\r\n            Object.assign(schema, parentSchema);\r\n            schema.names = {};\r\n            for (const name in parentSchema.names) {\r\n                schema.names[name] = Object.assign({}, parentSchema.names[name]);\r\n            }\r\n        }\r\n        schema.target = target;\r\n        return schema;\r\n    }\r\n    set(target, schema) {\r\n        this.items.set(target, schema);\r\n        return this;\r\n    }\r\n    findParentSchema(target) {\r\n        const parent = target.__proto__;\r\n        if (parent) {\r\n            const schema = this.items.get(parent);\r\n            return schema || this.findParentSchema(parent);\r\n        }\r\n        return null;\r\n    }\r\n}\n\nconst DEFAULT_SCHEMA = \"default\";\r\nconst schemaStorage = new JsonSchemaStorage();\n\nclass PatternValidation {\r\n    constructor(pattern) {\r\n        this.pattern = new RegExp(pattern);\r\n    }\r\n    validate(value) {\r\n        const pattern = new RegExp(this.pattern.source, this.pattern.flags);\r\n        if (typeof value !== \"string\") {\r\n            throw new ValidationError(\"Incoming value must be string\");\r\n        }\r\n        if (!pattern.exec(value)) {\r\n            throw new ValidationError(`Value doesn't match to pattern '${pattern.toString()}'`);\r\n        }\r\n    }\r\n}\n\nclass InclusiveValidation {\r\n    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    validate(value) {\r\n        throwIfTypeIsWrong(value, JsonPropTypes.Number);\r\n        if (!(this.min <= value && value <= this.max)) {\r\n            const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\r\n            const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\r\n            throw new ValidationError(`Value doesn't match to diapason [${min},${max}]`);\r\n        }\r\n    }\r\n}\n\nclass ExclusiveValidation {\r\n    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    validate(value) {\r\n        throwIfTypeIsWrong(value, JsonPropTypes.Number);\r\n        if (!(this.min < value && value < this.max)) {\r\n            const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\r\n            const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\r\n            throw new ValidationError(`Value doesn't match to diapason (${min},${max})`);\r\n        }\r\n    }\r\n}\n\nclass LengthValidation {\r\n    constructor(length, minLength, maxLength) {\r\n        this.length = length;\r\n        this.minLength = minLength;\r\n        this.maxLength = maxLength;\r\n    }\r\n    validate(value) {\r\n        if (this.length !== undefined) {\r\n            if (value.length !== this.length) {\r\n                throw new ValidationError(`Value length must be exactly ${this.length}.`);\r\n            }\r\n            return;\r\n        }\r\n        if (this.minLength !== undefined) {\r\n            if (value.length < this.minLength) {\r\n                throw new ValidationError(`Value length must be more than ${this.minLength}.`);\r\n            }\r\n        }\r\n        if (this.maxLength !== undefined) {\r\n            if (value.length > this.maxLength) {\r\n                throw new ValidationError(`Value length must be less than ${this.maxLength}.`);\r\n            }\r\n        }\r\n    }\r\n}\n\nclass EnumerationValidation {\r\n    constructor(enumeration) {\r\n        this.enumeration = enumeration;\r\n    }\r\n    validate(value) {\r\n        throwIfTypeIsWrong(value, JsonPropTypes.String);\r\n        if (!this.enumeration.includes(value)) {\r\n            throw new ValidationError(`Value must be one of ${this.enumeration.map((v) => `'${v}'`).join(\", \")}`);\r\n        }\r\n    }\r\n}\n\nclass JsonTransform {\r\n    static checkValues(data, schemaItem) {\r\n        const values = Array.isArray(data) ? data : [data];\r\n        for (const value of values) {\r\n            for (const validation of schemaItem.validations) {\r\n                if (validation instanceof LengthValidation && schemaItem.repeated) {\r\n                    validation.validate(data);\r\n                }\r\n                else {\r\n                    validation.validate(value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static checkTypes(value, schemaItem) {\r\n        if (schemaItem.repeated && !Array.isArray(value)) {\r\n            throw new TypeError(\"Value must be Array\");\r\n        }\r\n        if (typeof schemaItem.type === \"number\") {\r\n            const values = Array.isArray(value) ? value : [value];\r\n            for (const v of values) {\r\n                throwIfTypeIsWrong(v, schemaItem.type);\r\n            }\r\n        }\r\n    }\r\n    static getSchemaByName(schema, name = DEFAULT_SCHEMA) {\r\n        return { ...schema.names[DEFAULT_SCHEMA], ...schema.names[name] };\r\n    }\r\n}\n\nclass JsonSerializer extends JsonTransform {\r\n    static serialize(obj, options, replacer, space) {\r\n        const json = this.toJSON(obj, options);\r\n        return JSON.stringify(json, replacer, space);\r\n    }\r\n    static toJSON(obj, options = {}) {\r\n        let res;\r\n        let targetSchema = options.targetSchema;\r\n        const schemaName = options.schemaName || DEFAULT_SCHEMA;\r\n        if (isConvertible(obj)) {\r\n            return obj.toJSON();\r\n        }\r\n        if (Array.isArray(obj)) {\r\n            res = [];\r\n            for (const item of obj) {\r\n                res.push(this.toJSON(item, options));\r\n            }\r\n        }\r\n        else if (typeof obj === \"object\") {\r\n            if (targetSchema && !schemaStorage.has(targetSchema)) {\r\n                throw new JsonError(\"Cannot get schema for `targetSchema` param\");\r\n            }\r\n            targetSchema = (targetSchema || obj.constructor);\r\n            if (schemaStorage.has(targetSchema)) {\r\n                const schema = schemaStorage.get(targetSchema);\r\n                res = {};\r\n                const namedSchema = this.getSchemaByName(schema, schemaName);\r\n                for (const key in namedSchema) {\r\n                    try {\r\n                        const item = namedSchema[key];\r\n                        const objItem = obj[key];\r\n                        let value;\r\n                        if ((item.optional && objItem === undefined)\r\n                            || (item.defaultValue !== undefined && objItem === item.defaultValue)) {\r\n                            continue;\r\n                        }\r\n                        if (!item.optional && objItem === undefined) {\r\n                            throw new SerializerError(targetSchema.name, `Property '${key}' is required.`);\r\n                        }\r\n                        if (typeof item.type === \"number\") {\r\n                            if (item.converter) {\r\n                                if (item.repeated) {\r\n                                    value = objItem.map((el) => item.converter.toJSON(el, obj));\r\n                                }\r\n                                else {\r\n                                    value = item.converter.toJSON(objItem, obj);\r\n                                }\r\n                            }\r\n                            else {\r\n                                value = objItem;\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (item.repeated) {\r\n                                value = objItem.map((el) => this.toJSON(el, { schemaName }));\r\n                            }\r\n                            else {\r\n                                value = this.toJSON(objItem, { schemaName });\r\n                            }\r\n                        }\r\n                        this.checkTypes(value, item);\r\n                        this.checkValues(value, item);\r\n                        res[item.name || key] = value;\r\n                    }\r\n                    catch (e) {\r\n                        if (e instanceof SerializerError) {\r\n                            throw e;\r\n                        }\r\n                        else {\r\n                            throw new SerializerError(schema.target.name, `Property '${key}' is wrong. ${e.message}`, e);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                res = {};\r\n                for (const key in obj) {\r\n                    res[key] = this.toJSON(obj[key], { schemaName });\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            res = obj;\r\n        }\r\n        return res;\r\n    }\r\n}\n\nclass JsonParser extends JsonTransform {\r\n    static parse(data, options) {\r\n        const obj = JSON.parse(data);\r\n        return this.fromJSON(obj, options);\r\n    }\r\n    static fromJSON(target, options) {\r\n        const targetSchema = options.targetSchema;\r\n        const schemaName = options.schemaName || DEFAULT_SCHEMA;\r\n        const obj = new targetSchema();\r\n        if (isConvertible(obj)) {\r\n            return obj.fromJSON(target);\r\n        }\r\n        const schema = schemaStorage.get(targetSchema);\r\n        const namedSchema = this.getSchemaByName(schema, schemaName);\r\n        const keyErrors = {};\r\n        if (options.strictProperty && !Array.isArray(target)) {\r\n            JsonParser.checkStrictProperty(target, namedSchema, schema);\r\n        }\r\n        for (const key in namedSchema) {\r\n            try {\r\n                const item = namedSchema[key];\r\n                const name = item.name || key;\r\n                const value = target[name];\r\n                if (value === undefined && (item.optional || item.defaultValue !== undefined)) {\r\n                    continue;\r\n                }\r\n                if (!item.optional && value === undefined) {\r\n                    throw new ParserError(schema, `Property '${name}' is required.`);\r\n                }\r\n                this.checkTypes(value, item);\r\n                this.checkValues(value, item);\r\n                if (typeof (item.type) === \"number\") {\r\n                    if (item.converter) {\r\n                        if (item.repeated) {\r\n                            obj[key] = value.map((el) => item.converter.fromJSON(el, obj));\r\n                        }\r\n                        else {\r\n                            obj[key] = item.converter.fromJSON(value, obj);\r\n                        }\r\n                    }\r\n                    else {\r\n                        obj[key] = value;\r\n                    }\r\n                }\r\n                else {\r\n                    const newOptions = {\r\n                        ...options,\r\n                        targetSchema: item.type,\r\n                        schemaName,\r\n                    };\r\n                    if (item.repeated) {\r\n                        obj[key] = value.map((el) => this.fromJSON(el, newOptions));\r\n                    }\r\n                    else {\r\n                        obj[key] = this.fromJSON(value, newOptions);\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n                if (!(e instanceof ParserError)) {\r\n                    e = new ParserError(schema, `Property '${key}' is wrong. ${e.message}`, e);\r\n                }\r\n                if (options.strictAllKeys) {\r\n                    keyErrors[key] = e;\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        const keys = Object.keys(keyErrors);\r\n        if (keys.length) {\r\n            throw new KeyError(schema, keys, keyErrors);\r\n        }\r\n        return obj;\r\n    }\r\n    static checkStrictProperty(target, namedSchema, schema) {\r\n        const jsonProps = Object.keys(target);\r\n        const schemaProps = Object.keys(namedSchema);\r\n        const keys = [];\r\n        for (const key of jsonProps) {\r\n            if (schemaProps.indexOf(key) === -1) {\r\n                keys.push(key);\r\n            }\r\n        }\r\n        if (keys.length) {\r\n            throw new KeyError(schema, keys);\r\n        }\r\n    }\r\n}\n\nfunction getValidations(item) {\r\n    const validations = [];\r\n    if (item.pattern) {\r\n        validations.push(new PatternValidation(item.pattern));\r\n    }\r\n    if (item.type === JsonPropTypes.Number || item.type === JsonPropTypes.Any) {\r\n        if (item.minInclusive !== undefined || item.maxInclusive !== undefined) {\r\n            validations.push(new InclusiveValidation(item.minInclusive, item.maxInclusive));\r\n        }\r\n        if (item.minExclusive !== undefined || item.maxExclusive !== undefined) {\r\n            validations.push(new ExclusiveValidation(item.minExclusive, item.maxExclusive));\r\n        }\r\n        if (item.enumeration !== undefined) {\r\n            validations.push(new EnumerationValidation(item.enumeration));\r\n        }\r\n    }\r\n    if (item.type === JsonPropTypes.String || item.repeated || item.type === JsonPropTypes.Any) {\r\n        if (item.length !== undefined || item.minLength !== undefined || item.maxLength !== undefined) {\r\n            validations.push(new LengthValidation(item.length, item.minLength, item.maxLength));\r\n        }\r\n    }\r\n    return validations;\r\n}\r\nconst JsonProp = (options = {}) => (target, propertyKey) => {\r\n    const errorMessage = `Cannot set type for ${propertyKey} property of ${target.constructor.name} schema`;\r\n    let schema;\r\n    if (!schemaStorage.has(target.constructor)) {\r\n        schema = schemaStorage.create(target.constructor);\r\n        schemaStorage.set(target.constructor, schema);\r\n    }\r\n    else {\r\n        schema = schemaStorage.get(target.constructor);\r\n        if (schema.target !== target.constructor) {\r\n            schema = schemaStorage.create(target.constructor);\r\n            schemaStorage.set(target.constructor, schema);\r\n        }\r\n    }\r\n    const defaultSchema = {\r\n        type: JsonPropTypes.Any,\r\n        validations: [],\r\n    };\r\n    const copyOptions = Object.assign(defaultSchema, options);\r\n    copyOptions.validations = getValidations(copyOptions);\r\n    if (typeof copyOptions.type !== \"number\") {\r\n        if (!schemaStorage.has(copyOptions.type) && !isConvertible(copyOptions.type)) {\r\n            throw new Error(`${errorMessage}. Assigning type doesn't have schema.`);\r\n        }\r\n    }\r\n    let schemaNames;\r\n    if (Array.isArray(options.schema)) {\r\n        schemaNames = options.schema;\r\n    }\r\n    else {\r\n        schemaNames = [options.schema || DEFAULT_SCHEMA];\r\n    }\r\n    for (const schemaName of schemaNames) {\r\n        if (!schema.names[schemaName]) {\r\n            schema.names[schemaName] = {};\r\n        }\r\n        const namedSchema = schema.names[schemaName];\r\n        namedSchema[propertyKey] = copyOptions;\r\n    }\r\n};\n\nexport { JsonError, JsonParser, JsonProp, JsonPropTypes, JsonSerializer, KeyError, ParserError, SerializerError, TransformError, ValidationError };\n"]},"metadata":{},"sourceType":"module"}