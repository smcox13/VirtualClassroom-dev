{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _defineProperty = require('babel-runtime/core-js/object/define-property');\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _weakMap = require('babel-runtime/core-js/weak-map');\n\nvar _weakMap2 = _interopRequireDefault(_weakMap);\n\nvar _desc, _value, _class, _descriptor;\n\nvar _coreDecorators = require('core-decorators');\n\nvar _ampersandEvents = require('ampersand-events');\n\nvar _ampersandEvents2 = _interopRequireDefault(_ampersandEvents);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _initDefineProp(target, property, descriptor, context) {\n  if (!descriptor) return;\n  (0, _defineProperty2.default)(target, property, {\n    enumerable: descriptor.enumerable,\n    configurable: descriptor.configurable,\n    writable: descriptor.writable,\n    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n  });\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n\nfunction _initializerWarningHelper(descriptor, context) {\n  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');\n} // hold onto weak references to parent' Webexs to help avoid retain cycles\n\n\nvar webexs = new _weakMap2.default();\n/**\n * Base plugin class. Doesn't depend on Ampersand State\n */\n\nvar StatelessWebexPlugin = (_class = function () {\n  (0, _createClass3.default)(StatelessWebexPlugin, [{\n    key: 'config',\n\n    /**\n     * The config for this plugin's namespace. If no namespace has been set\n     * returns all of webex's config.\n     * @type {Object}\n     */\n    get: function get() {\n      var namespace = this.getNamespace ? this.getNamespace() : this.namespace;\n\n      if (namespace) {\n        namespace = namespace.toLowerCase();\n        return this.webex.config[namespace];\n      }\n\n      return this.webex.config;\n    }\n    /**\n     * A reference to the webex logger.\n     * @type {Logger}\n     */\n\n  }, {\n    key: 'logger',\n    get: function get() {\n      return this.webex.logger;\n    }\n    /**\n     * A reference to the main sdk instance\n     * @type {WebexCore}\n     */\n\n  }, {\n    key: 'webex',\n    get: function get() {\n      return webexs.get(this);\n    }\n    /**\n     * Mostly here for compatibility with legacy WebexPlugins.\n     * StatelessWebexPlugins will never have a state other than ready, however, if\n     * we implement stateful WebexPlugins as es6 classes, they may have the option\n     * to have ready be false\n     * @private\n     * @type {boolean}\n     */\n\n  }]);\n  /**\n   * Constructor. One of attrs.webex or options.parent is required\n   * @param {Object} attrs\n   * @param {WebexCore} [attrs.webex]\n   * @param {Object} options\n   * @param {WebexCore} [options.parent]\n   */\n\n  function StatelessWebexPlugin() {\n    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck3.default)(this, StatelessWebexPlugin);\n\n    _initDefineProp(this, 'ready', _descriptor, this);\n\n    var webex = attrs.webex || options.parent;\n\n    if (!webex) {\n      throw new Error('One of `attrs.webex` or `options.parent` must be supplied when initializing a StatelessWebexPlugin');\n    }\n\n    while (webex.parent || webex.collection) {\n      webex = webex.parent || webex.collection;\n    }\n\n    webexs.set(this, webex);\n  }\n  /**\n   * Proxies to {@link WebexPlugin#webex}'s `request()` method.\n   * @see WebexCore#request\n   * @param {Array<mixed>} args\n   * @returns {Promise}\n   */\n\n\n  (0, _createClass3.default)(StatelessWebexPlugin, [{\n    key: 'request',\n    value: function request() {\n      var _webex;\n\n      return (_webex = this.webex).request.apply(_webex, arguments);\n    }\n    /**\n     * Proxies to {@link WebexPlugin#webex}'s `upload()` method.\n     * @see WebexCore#upload\n     * @param {Array<mixed>} args\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'upload',\n    value: function upload() {\n      var _webex2;\n\n      return (_webex2 = this.webex).upload.apply(_webex2, arguments);\n    }\n  }]);\n  return StatelessWebexPlugin;\n}(), _descriptor = _applyDecoratedDescriptor(_class.prototype, 'ready', [_coreDecorators.readonly], {\n  enumerable: true,\n  initializer: function initializer() {\n    return true;\n  }\n}), _class);\nexports.default = StatelessWebexPlugin;\n(0, _assign2.default)(StatelessWebexPlugin.prototype, _ampersandEvents2.default);","map":{"version":3,"sources":["stateless-webex-plugin.js"],"names":["webexs","StatelessWebexPlugin","namespace","readonly","attrs","options","webex","AmpEvents"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,IAAA,gBAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAEA;;;AACA,IAAMA,MAAAA,GAAS,IAAA,SAAA,CAAf,OAAe,EAAf;AAEA;;;;IAGqBC,oB;;;;AACnB;;;;;wBAKa;AACX,UAAIC,SAAAA,GAAY,KAAA,YAAA,GAAoB,KAApB,YAAoB,EAApB,GAA0C,KAA1D,SAAA;;AAEA,UAAA,SAAA,EAAe;AACbA,QAAAA,SAAAA,GAAYA,SAAAA,CAAZA,WAAYA,EAAZA;AAEA,eAAO,KAAA,KAAA,CAAA,MAAA,CAAP,SAAO,CAAP;AACD;;AAED,aAAO,KAAA,KAAA,CAAP,MAAA;AACD;AAED;;;;;;;wBAIa;AACX,aAAO,KAAA,KAAA,CAAP,MAAA;AACD;AAED;;;;;;;wBAIY;AACV,aAAOF,MAAAA,CAAAA,GAAAA,CAAP,IAAOA,CAAP;AACD;AAGD;;;;;;;;;;AAUA;;;;;;;;AAOA,WAAA,oBAAA,GAAsC;AAAA,QAA1BI,KAA0B,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAlB,EAAkB;AAAA,QAAdC,OAAc,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI;AAAA,KAAA,GAAA,gBAAA,CAAA,OAAA,EAAA,IAAA,EAAA,oBAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,OAAA,EAAA,WAAA,EAAA,IAAA,CAAA;;AACpC,QAAIC,KAAAA,GAAQF,KAAAA,CAAAA,KAAAA,IAAeC,OAAAA,CAA3B,MAAA;;AAEA,QAAI,CAAJ,KAAA,EAAY;AACV,YAAM,IAAA,KAAA,CAAN,oGAAM,CAAN;AACD;;AAED,WAAOC,KAAAA,CAAAA,MAAAA,IAAgBA,KAAAA,CAAvB,UAAA,EAAyC;AACvCA,MAAAA,KAAAA,GAAQA,KAAAA,CAAAA,MAAAA,IAAgBA,KAAAA,CAAxBA,UAAAA;AACD;;AACDN,IAAAA,MAAAA,CAAAA,GAAAA,CAAAA,IAAAA,EAAAA,KAAAA;AACD;AAED;;;;;;;;;;8BAMiB;AAAA,UAAA,MAAA;;AACf,aAAO,CAAA,MAAA,GAAA,KAAA,KAAA,EAAA,OAAA,CAAA,KAAA,CAAA,MAAA,EAAP,SAAO,CAAP;AACD;AAED;;;;;;;;;6BAMgB;AAAA,UAAA,OAAA;;AACd,aAAO,CAAA,OAAA,GAAA,KAAA,KAAA,EAAA,MAAA,CAAA,KAAA,CAAA,OAAA,EAAP,SAAO,CAAP;AACD;;;yEAjDAG,eAAAA,CAAAA,Q;;;WASO,I;;;kBA3CWF,oB;AAsFrB,CAAA,GAAA,QAAA,CAAA,OAAA,EAAcA,oBAAAA,CAAd,SAAA,EAA8CM,iBAAAA,CAA9C,OAAA","sourcesContent":["import {readonly} from 'core-decorators';\nimport AmpEvents from 'ampersand-events';\n\n// hold onto weak references to parent' Webexs to help avoid retain cycles\nconst webexs = new WeakMap();\n\n/**\n * Base plugin class. Doesn't depend on Ampersand State\n */\nexport default class StatelessWebexPlugin {\n  /**\n   * The config for this plugin's namespace. If no namespace has been set\n   * returns all of webex's config.\n   * @type {Object}\n   */\n  get config() {\n    let namespace = this.getNamespace ? this.getNamespace() : this.namespace;\n\n    if (namespace) {\n      namespace = namespace.toLowerCase();\n\n      return this.webex.config[namespace];\n    }\n\n    return this.webex.config;\n  }\n\n  /**\n   * A reference to the webex logger.\n   * @type {Logger}\n   */\n  get logger() {\n    return this.webex.logger;\n  }\n\n  /**\n   * A reference to the main sdk instance\n   * @type {WebexCore}\n   */\n  get webex() {\n    return webexs.get(this);\n  }\n\n  @readonly\n  /**\n   * Mostly here for compatibility with legacy WebexPlugins.\n   * StatelessWebexPlugins will never have a state other than ready, however, if\n   * we implement stateful WebexPlugins as es6 classes, they may have the option\n   * to have ready be false\n   * @private\n   * @type {boolean}\n   */\n  ready = true;\n\n  /**\n   * Constructor. One of attrs.webex or options.parent is required\n   * @param {Object} attrs\n   * @param {WebexCore} [attrs.webex]\n   * @param {Object} options\n   * @param {WebexCore} [options.parent]\n   */\n  constructor(attrs = {}, options = {}) {\n    let webex = attrs.webex || options.parent;\n\n    if (!webex) {\n      throw new Error('One of `attrs.webex` or `options.parent` must be supplied when initializing a StatelessWebexPlugin');\n    }\n\n    while (webex.parent || webex.collection) {\n      webex = webex.parent || webex.collection;\n    }\n    webexs.set(this, webex);\n  }\n\n  /**\n   * Proxies to {@link WebexPlugin#webex}'s `request()` method.\n   * @see WebexCore#request\n   * @param {Array<mixed>} args\n   * @returns {Promise}\n   */\n  request(...args) {\n    return this.webex.request(...args);\n  }\n\n  /**\n   * Proxies to {@link WebexPlugin#webex}'s `upload()` method.\n   * @see WebexCore#upload\n   * @param {Array<mixed>} args\n   * @returns {Promise}\n   */\n  upload(...args) {\n    return this.webex.upload(...args);\n  }\n}\n\nObject.assign(StatelessWebexPlugin.prototype, AmpEvents);\n"]},"metadata":{},"sourceType":"script"}