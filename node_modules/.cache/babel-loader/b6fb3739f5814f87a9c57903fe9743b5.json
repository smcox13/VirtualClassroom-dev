{"ast":null,"code":"/*!\n * algorithms/ecdsa.js - Elliptic Curve Digitial Signature Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nvar ecUtil = require(\"./ec-util.js\"),\n    helpers = require(\"./helpers.js\"),\n    sha = require(\"./sha.js\");\n\nfunction idealCurve(hash) {\n  switch (hash) {\n    case \"SHA-256\":\n      return \"P-256\";\n\n    case \"SHA-384\":\n      return \"P-384\";\n\n    case \"SHA-512\":\n      return \"P-521\";\n\n    default:\n      throw new Error(\"unsupported hash: \" + hash);\n  }\n}\n\nfunction ecdsaSignFN(hash) {\n  var curve = idealCurve(hash); // ### Fallback implementation -- uses forge\n\n  var fallback = function (key, pdata\n  /*, props */\n  ) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n\n    var pk = ecUtil.convertToForge(key, false);\n    var promise; // generate hash\n\n    promise = sha[hash].digest(pdata); // sign hash\n\n    promise = promise.then(function (result) {\n      result = pk.sign(result);\n      result = Buffer.concat([result.r, result.s]);\n      return {\n        data: pdata,\n        mac: result\n      };\n    });\n    return promise;\n  }; // ### WebCrypto API implementation\n\n\n  var webcrypto = function (key, pdata\n  /*, props */\n  ) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n\n    var pk = ecUtil.convertToJWK(key, false);\n    var promise;\n    var alg = {\n      name: \"ECDSA\",\n      namedCurve: pk.crv,\n      hash: {\n        name: hash\n      }\n    };\n    promise = helpers.subtleCrypto.importKey(\"jwk\", pk, alg, true, [\"sign\"]);\n    promise = promise.then(function (key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function (result) {\n      result = new Buffer(result);\n      return {\n        data: pdata,\n        mac: result\n      };\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(null, webcrypto, fallback);\n}\n\nfunction ecdsaVerifyFN(hash) {\n  var curve = idealCurve(hash); // ### Fallback implementation -- uses forge\n\n  var fallback = function (key, pdata, mac\n  /*, props */\n  ) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n\n    var pk = ecUtil.convertToForge(key, true);\n    var promise; // generate hash\n\n    promise = sha[hash].digest(pdata); // verify hash\n\n    promise = promise.then(function (result) {\n      var len = mac.length / 2;\n      var rs = {\n        r: mac.slice(0, len),\n        s: mac.slice(len)\n      };\n\n      if (!pk.verify(result, rs)) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  }; // ### WebCrypto API implementation\n\n\n  var webcrypto = function (key, pdata, mac\n  /* , props */\n  ) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n\n    var pk = ecUtil.convertToJWK(key, true);\n    var promise;\n    var alg = {\n      name: \"ECDSA\",\n      namedCurve: pk.crv,\n      hash: {\n        name: hash\n      }\n    };\n    promise = helpers.subtleCrypto.importKey(\"jwk\", pk, alg, true, [\"verify\"]);\n    promise = promise.then(function (key) {\n      return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n    });\n    promise = promise.then(function (result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(null, webcrypto, fallback);\n} // ### Public API\n\n\nvar ecdsa = {}; // * [name].sign\n// * [name].verify\n\n[\"ES256\", \"ES384\", \"ES512\"].forEach(function (name) {\n  var hash = name.replace(/ES(\\d+)/g, function (m, size) {\n    return \"SHA-\" + size;\n  });\n  ecdsa[name] = {\n    sign: ecdsaSignFN(hash),\n    verify: ecdsaVerifyFN(hash)\n  };\n});\nmodule.exports = ecdsa;","map":{"version":3,"sources":["/Users/pratison/Work/Cisco/Education/React/education-webex/node_modules/node-jose/lib/algorithms/ecdsa.js"],"names":["ecUtil","require","helpers","sha","idealCurve","hash","Error","ecdsaSignFN","curve","fallback","key","pdata","crv","Promise","reject","pk","convertToForge","promise","digest","then","result","sign","Buffer","concat","r","s","data","mac","webcrypto","convertToJWK","alg","name","namedCurve","subtleCrypto","importKey","setupFallback","ecdsaVerifyFN","len","length","rs","slice","verify","valid","ecdsa","forEach","replace","m","size","module","exports"],"mappings":"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","sourcesContent":["/*!\n * algorithms/ecdsa.js - Elliptic Curve Digitial Signature Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nvar ecUtil = require(\"./ec-util.js\"),\n    helpers = require(\"./helpers.js\"),\n    sha = require(\"./sha.js\");\n\nfunction idealCurve(hash) {\n  switch (hash) {\n    case \"SHA-256\":\n      return \"P-256\";\n    case \"SHA-384\":\n      return \"P-384\";\n    case \"SHA-512\":\n      return \"P-521\";\n    default:\n      throw new Error(\"unsupported hash: \" + hash);\n  }\n}\n\nfunction ecdsaSignFN(hash) {\n  var curve = idealCurve(hash);\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function(key, pdata /*, props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToForge(key, false);\n\n    var promise;\n    // generate hash\n    promise = sha[hash].digest(pdata);\n    // sign hash\n    promise = promise.then(function(result) {\n      result = pk.sign(result);\n      result = Buffer.concat([result.r, result.s]);\n      return {\n        data: pdata,\n        mac: result\n      };\n    });\n    return promise;\n  };\n\n  // ### WebCrypto API implementation\n  var webcrypto = function(key, pdata /*, props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToJWK(key, false);\n\n    var promise;\n    var alg = {\n      name: \"ECDSA\",\n      namedCurve: pk.crv,\n      hash: {\n        name: hash\n      }\n    };\n    promise = helpers.subtleCrypto.importKey(\"jwk\",\n                                             pk,\n                                             alg,\n                                             true,\n                                             [ \"sign\" ]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function(result) {\n      result = new Buffer(result);\n      return {\n        data: pdata,\n        mac: result\n      };\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(null, webcrypto, fallback);\n}\n\nfunction ecdsaVerifyFN(hash) {\n  var curve = idealCurve(hash);\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function(key, pdata, mac /*, props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToForge(key, true);\n\n    var promise;\n    // generate hash\n    promise = sha[hash].digest(pdata);\n    // verify hash\n    promise = promise.then(function(result) {\n      var len = mac.length / 2;\n      var rs = {\n        r: mac.slice(0, len),\n        s: mac.slice(len)\n      };\n      if (!pk.verify(result, rs)) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  };\n\n  // ### WebCrypto API implementation\n  var webcrypto = function(key, pdata, mac /* , props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToJWK(key, true);\n\n    var promise;\n    var alg = {\n      name: \"ECDSA\",\n      namedCurve: pk.crv,\n      hash: {\n        name: hash\n      }\n    };\n    promise = helpers.subtleCrypto.importKey(\"jwk\",\n                                             pk,\n                                             alg,\n                                             true,\n                                             [\"verify\"]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n    });\n    promise = promise.then(function(result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(null, webcrypto, fallback);\n}\n\n// ### Public API\nvar ecdsa = {};\n\n// * [name].sign\n// * [name].verify\n[\n  \"ES256\",\n  \"ES384\",\n  \"ES512\"\n].forEach(function(name) {\n  var hash = name.replace(/ES(\\d+)/g, function(m, size) {\n    return \"SHA-\" + size;\n  });\n  ecdsa[name] = {\n    sign: ecdsaSignFN(hash),\n    verify: ecdsaVerifyFN(hash)\n  };\n});\n\nmodule.exports = ecdsa;\n"]},"metadata":{},"sourceType":"script"}