{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.constructHydraId = constructHydraId;\nexports.deconstructHydraId = deconstructHydraId;\nexports.buildHydraMessageId = buildHydraMessageId;\nexports.buildHydraPersonId = buildHydraPersonId;\nexports.buildHydraRoomId = buildHydraRoomId;\nexports.buildHydraOrgId = buildHydraOrgId;\nexports.buildHydraMembershipId = buildHydraMembershipId;\nexports.getHydraRoomType = getHydraRoomType;\nexports.getHydraFiles = getHydraFiles;\n\nvar _base = require('./base64');\n\nvar _constants = require('./constants');\n\nvar hydraBaseUrl = 'https://api.ciscospark.com/v1';\n\nvar isRequired = function isRequired() {\n  throw Error('parameter is required');\n};\n/**\n * Constructs a Hydra ID for a given UUID and type.\n *\n * @export\n * @param {string} type one of PEOPLE, TEAM, ROOM\n * @param {any} id identifying the \"TYPE\" object\n * @param {string} cluster containing the \"TYPE\" object\n * @returns {string}\n */\n\n\nfunction constructHydraId() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : isRequired();\n  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : isRequired();\n  var cluster = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'us';\n\n  if (!type.toUpperCase) {\n    throw Error('\"type\" must be a string');\n  }\n\n  return (0, _base.encode)('ciscospark://' + cluster + '/' + type.toUpperCase() + '/' + id);\n}\n/**\n * @typedef {Object} DeconstructedHydraId\n * @property {UUID} id identifying the object\n * @property {String} type of the object\n * @property {String} cluster containing the object\n */\n\n/**\n * Deconstructs a Hydra ID.\n *\n * @export\n * @param {String} id Hydra style id\n * @returns {DeconstructedHydraId} deconstructed id\n */\n\n\nfunction deconstructHydraId(id) {\n  var payload = (0, _base.decode)(id).split('/');\n  return {\n    id: payload.pop(),\n    type: payload.pop(),\n    cluster: payload.pop()\n  };\n}\n/**\n * Constructs a Hydra ID for a message based on internal UUID\n *\n * @export\n * @param {any} uuid\n * @param {string} cluster containing the message\n * @returns {string}\n */\n\n\nfunction buildHydraMessageId(uuid, cluster) {\n  return constructHydraId(_constants.hydraTypes.MESSAGE, uuid, cluster);\n}\n/**\n * Constructs a Hydra ID for a person based on internal UUID\n *\n * @export\n * @param {any} uuid\n * @param {string} cluster containing the person\n * @returns {string}\n */\n\n\nfunction buildHydraPersonId(uuid, cluster) {\n  return constructHydraId(_constants.hydraTypes.PEOPLE, uuid, cluster);\n}\n/**\n * Constructs a Hydra ID for a room based on internal UUID\n *\n * @export\n * @param {any} uuid\n * @param {string} cluster containing the room\n * @returns {string}\n */\n\n\nfunction buildHydraRoomId(uuid, cluster) {\n  return constructHydraId(_constants.hydraTypes.ROOM, uuid, cluster);\n}\n/**\n * Constructs a Hydra ID for an organization based on internal UUID\n *\n * @export\n * @param {any} uuid\n * @param {string} cluster containing the organization\n * @returns {string}\n */\n\n\nfunction buildHydraOrgId(uuid, cluster) {\n  return constructHydraId(_constants.hydraTypes.ORGANIZATION, uuid, cluster);\n}\n/**\n * Constructs a Hydra ID for an membership based on an\n * internal UUID for the person, and the space\n *\n * @export\n * @param {any} personUUID\n * @param {any} spaceUUID\n * @param {string} cluster containing the membership\n * @returns {string}\n */\n\n\nfunction buildHydraMembershipId(personUUID, spaceUUID, cluster) {\n  return constructHydraId(_constants.hydraTypes.MEMBERSHIP, personUUID + ':' + spaceUUID, cluster);\n}\n/**\n * Returns a Hydra roomType based on conversation tags\n *\n * @export\n * @param {arra} tags\n * @param {any} spaceUUID\n * @returns {string}\n */\n\n\nfunction getHydraRoomType(tags) {\n  if (tags.includes(_constants.SDK_EVENT.INTERNAL.ACTIVITY_TAG.ONE_ON_ONE)) {\n    return _constants.SDK_EVENT.EXTERNAL.SPACE_TYPE.DIRECT;\n  }\n\n  return _constants.SDK_EVENT.EXTERNAL.SPACE_TYPE.GROUP;\n}\n/**\n * Returns file URLs for the activity, adhering to Hydra details,\n * e.g., https://api.ciscospark.com/v1/contents/Y2lzY29zcGF...\n * @see https://developer.webex.com/docs/api/v1/messages/get-message-details\n * @param {Object} activity from mercury\n * @param {string} cluster containing the files\n * @returns {Array} file URLs\n */\n\n\nfunction getHydraFiles(activity, cluster) {\n  var hydraFiles = [];\n  var files = activity.object.files;\n\n  if (files) {\n    var items = files.items; // Note: Generated ID is dependent on file order.\n\n    for (var i = 0; i < items.length; i += 1) {\n      var contentId = constructHydraId(_constants.hydraTypes.CONTENT, activity.id + '/' + i, cluster);\n      hydraFiles.push(hydraBaseUrl + '/contents/' + contentId);\n    }\n  }\n\n  return hydraFiles;\n}","map":{"version":3,"sources":["uuid-utils.js"],"names":["hydraBaseUrl","isRequired","Error","constructHydraId","type","id","cluster","deconstructHydraId","payload","buildHydraMessageId","hydraTypes","buildHydraPersonId","buildHydraRoomId","buildHydraOrgId","buildHydraMembershipId","personUUID","getHydraRoomType","tags","SDK_EVENT","getHydraFiles","hydraFiles","files","activity","items","i","contentId"],"mappings":"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","sourcesContent":["import {encode, decode} from './base64';\nimport {SDK_EVENT, hydraTypes} from './constants';\n\nconst hydraBaseUrl = 'https://api.ciscospark.com/v1';\n\nconst isRequired = () => {\n  throw Error('parameter is required');\n};\n\n/**\n * Constructs a Hydra ID for a given UUID and type.\n *\n * @export\n * @param {string} type one of PEOPLE, TEAM, ROOM\n * @param {any} id identifying the \"TYPE\" object\n * @param {string} cluster containing the \"TYPE\" object\n * @returns {string}\n */\nexport function constructHydraId(\n  type = isRequired(),\n  id = isRequired(),\n  cluster = 'us'\n) {\n  if (!type.toUpperCase) {\n    throw Error('\"type\" must be a string');\n  }\n\n  return encode(`ciscospark://${cluster}/${type.toUpperCase()}/${id}`);\n}\n\n/**\n * @typedef {Object} DeconstructedHydraId\n * @property {UUID} id identifying the object\n * @property {String} type of the object\n * @property {String} cluster containing the object\n */\n\n/**\n * Deconstructs a Hydra ID.\n *\n * @export\n * @param {String} id Hydra style id\n * @returns {DeconstructedHydraId} deconstructed id\n */\nexport function deconstructHydraId(id) {\n  const payload = decode(id).split('/');\n\n  return {\n    id: payload.pop(),\n    type: payload.pop(),\n    cluster: payload.pop()\n  };\n}\n\n/**\n * Constructs a Hydra ID for a message based on internal UUID\n *\n * @export\n * @param {any} uuid\n * @param {string} cluster containing the message\n * @returns {string}\n */\nexport function buildHydraMessageId(uuid, cluster) {\n  return constructHydraId(hydraTypes.MESSAGE, uuid, cluster);\n}\n\n/**\n * Constructs a Hydra ID for a person based on internal UUID\n *\n * @export\n * @param {any} uuid\n * @param {string} cluster containing the person\n * @returns {string}\n */\nexport function buildHydraPersonId(uuid, cluster) {\n  return constructHydraId(hydraTypes.PEOPLE, uuid, cluster);\n}\n\n/**\n * Constructs a Hydra ID for a room based on internal UUID\n *\n * @export\n * @param {any} uuid\n * @param {string} cluster containing the room\n * @returns {string}\n */\nexport function buildHydraRoomId(uuid, cluster) {\n  return constructHydraId(hydraTypes.ROOM, uuid, cluster);\n}\n\n/**\n * Constructs a Hydra ID for an organization based on internal UUID\n *\n * @export\n * @param {any} uuid\n * @param {string} cluster containing the organization\n * @returns {string}\n */\nexport function buildHydraOrgId(uuid, cluster) {\n  return constructHydraId(hydraTypes.ORGANIZATION, uuid, cluster);\n}\n\n/**\n * Constructs a Hydra ID for an membership based on an\n * internal UUID for the person, and the space\n *\n * @export\n * @param {any} personUUID\n * @param {any} spaceUUID\n * @param {string} cluster containing the membership\n * @returns {string}\n */\nexport function buildHydraMembershipId(personUUID, spaceUUID, cluster) {\n  return constructHydraId(hydraTypes.MEMBERSHIP,\n    `${personUUID}:${spaceUUID}`, cluster);\n}\n\n/**\n * Returns a Hydra roomType based on conversation tags\n *\n * @export\n * @param {arra} tags\n * @param {any} spaceUUID\n * @returns {string}\n */\nexport function getHydraRoomType(tags) {\n  if (tags.includes(SDK_EVENT.INTERNAL.ACTIVITY_TAG.ONE_ON_ONE)) {\n    return SDK_EVENT.EXTERNAL.SPACE_TYPE.DIRECT;\n  }\n\n  return SDK_EVENT.EXTERNAL.SPACE_TYPE.GROUP;\n}\n\n/**\n * Returns file URLs for the activity, adhering to Hydra details,\n * e.g., https://api.ciscospark.com/v1/contents/Y2lzY29zcGF...\n * @see https://developer.webex.com/docs/api/v1/messages/get-message-details\n * @param {Object} activity from mercury\n * @param {string} cluster containing the files\n * @returns {Array} file URLs\n */\nexport function getHydraFiles(activity, cluster) {\n  const hydraFiles = [];\n  const {files} = activity.object;\n\n  if (files) {\n    const {items} = files;\n\n    // Note: Generated ID is dependent on file order.\n    for (let i = 0; i < items.length; i += 1) {\n      const contentId =\n        constructHydraId(hydraTypes.CONTENT, `${activity.id}/${i}`, cluster);\n\n      hydraFiles.push(`${hydraBaseUrl}/contents/${contentId}`);\n    }\n  }\n\n  return hydraFiles;\n}\n"]},"metadata":{},"sourceType":"script"}