{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport { decorate } from './private/utils';\nvar GENERIC_FUNCTION_ERROR = '{child} does not properly override {parent}';\nvar FUNCTION_REGEXP = /^function ([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?(\\([^\\)]*\\))[\\s\\S]+$/;\n\nvar SyntaxErrorReporter = function () {\n  _createClass(SyntaxErrorReporter, [{\n    key: '_getTopic',\n    value: function _getTopic(descriptor) {\n      if (descriptor === undefined) {\n        return null;\n      }\n\n      if ('value' in descriptor) {\n        return descriptor.value;\n      }\n\n      if ('get' in descriptor) {\n        return descriptor.get;\n      }\n\n      if ('set' in descriptor) {\n        return descriptor.set;\n      }\n    }\n  }, {\n    key: '_extractTopicSignature',\n    value: function _extractTopicSignature(topic) {\n      switch (typeof topic === 'undefined' ? 'undefined' : _typeof(topic)) {\n        case 'function':\n          return this._extractFunctionSignature(topic);\n\n        default:\n          return this.key;\n      }\n    }\n  }, {\n    key: '_extractFunctionSignature',\n    value: function _extractFunctionSignature(fn) {\n      var _this = this;\n\n      return fn.toString().replace(FUNCTION_REGEXP, function (match) {\n        var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.key;\n        var params = arguments[2];\n        return name + params;\n      });\n    }\n  }, {\n    key: 'key',\n    get: function get() {\n      return this.childDescriptor.key;\n    }\n  }, {\n    key: 'parentNotation',\n    get: function get() {\n      return this.parentKlass.constructor.name + '#' + this.parentPropertySignature;\n    }\n  }, {\n    key: 'childNotation',\n    get: function get() {\n      return this.childKlass.constructor.name + '#' + this.childPropertySignature;\n    }\n  }, {\n    key: 'parentTopic',\n    get: function get() {\n      return this._getTopic(this.parentDescriptor);\n    }\n  }, {\n    key: 'childTopic',\n    get: function get() {\n      return this._getTopic(this.childDescriptor);\n    }\n  }, {\n    key: 'parentPropertySignature',\n    get: function get() {\n      return this._extractTopicSignature(this.parentTopic);\n    }\n  }, {\n    key: 'childPropertySignature',\n    get: function get() {\n      return this._extractTopicSignature(this.childTopic);\n    }\n  }]);\n\n  function SyntaxErrorReporter(parentKlass, childKlass, parentDescriptor, childDescriptor) {\n    _classCallCheck(this, SyntaxErrorReporter);\n\n    this.parentKlass = parentKlass;\n    this.childKlass = childKlass;\n    this.parentDescriptor = parentDescriptor;\n    this.childDescriptor = childDescriptor;\n  }\n\n  _createClass(SyntaxErrorReporter, [{\n    key: 'assert',\n    value: function assert(condition) {\n      var msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n      if (condition !== true) {\n        this.error(GENERIC_FUNCTION_ERROR + msg);\n      }\n    }\n  }, {\n    key: 'error',\n    value: function error(msg) {\n      var _this2 = this;\n\n      msg = msg // Replace lazily, because they actually might not\n      // be available in all cases\n      .replace('{parent}', function (m) {\n        return _this2.parentNotation;\n      }).replace('{child}', function (m) {\n        return _this2.childNotation;\n      });\n      throw new SyntaxError(msg);\n    }\n  }]);\n\n  return SyntaxErrorReporter;\n}();\n\nfunction getDescriptorType(descriptor) {\n  if (descriptor.hasOwnProperty('value')) {\n    return 'data';\n  }\n\n  if (descriptor.hasOwnProperty('get') || descriptor.hasOwnProperty('set')) {\n    return 'accessor';\n  } // If none of them exist, browsers treat it as\n  // a data descriptor with a value of `undefined`\n\n\n  return 'data';\n}\n\nfunction checkFunctionSignatures(parent, child, reporter) {\n  reporter.assert(parent.length === child.length);\n}\n\nfunction checkDataDescriptors(parent, child, reporter) {\n  var parentValueType = _typeof(parent.value);\n\n  var childValueType = _typeof(child.value);\n\n  if (parentValueType === 'undefined' && childValueType === 'undefined') {\n    // class properties can be any expression, which isn't ran until the\n    // the instance is created, so we can't reliably get type information\n    // for them yet (per spec). Perhaps when Babel includes flow-type info\n    // in runtime? Tried regex solutions, but super hacky and only feasible\n    // on primitives, which is confusing for usage...\n    reporter.error('descriptor values are both undefined. (class properties are are not currently supported)\\'');\n  }\n\n  if (parentValueType !== childValueType) {\n    var isFunctionOverUndefined = childValueType === 'function' && parentValueType === undefined; // Even though we don't support class properties, this\n    // will still handle more than just functions, just in case.\n    // Shadowing an undefined value is an error if the inherited\n    // value was undefined (usually a class property, not a method)\n\n    if (isFunctionOverUndefined || parentValueType !== undefined) {\n      reporter.error('value types do not match. {parent} is \"' + parentValueType + '\", {child} is \"' + childValueType + '\"');\n    }\n  } // Switch, in preparation for supporting more types\n\n\n  switch (childValueType) {\n    case 'function':\n      checkFunctionSignatures(parent.value, child.value, reporter);\n      break;\n\n    default:\n      reporter.error('Unexpected error. Please file a bug with: {parent} is \"' + parentValueType + '\", {child} is \"' + childValueType + '\"');\n      break;\n  }\n}\n\nfunction checkAccessorDescriptors(parent, child, reporter) {\n  var parentHasGetter = typeof parent.get === 'function';\n  var childHasGetter = typeof child.get === 'function';\n  var parentHasSetter = typeof parent.set === 'function';\n  var childHasSetter = typeof child.set === 'function';\n\n  if (parentHasGetter || childHasGetter) {\n    if (!parentHasGetter && parentHasSetter) {\n      reporter.error('{parent} is setter but {child} is getter');\n    }\n\n    if (!childHasGetter && childHasSetter) {\n      reporter.error('{parent} is getter but {child} is setter');\n    }\n\n    checkFunctionSignatures(parent.get, child.get, reporter);\n  }\n\n  if (parentHasSetter || childHasSetter) {\n    if (!parentHasSetter && parentHasGetter) {\n      reporter.error('{parent} is getter but {child} is setter');\n    }\n\n    if (!childHasSetter && childHasGetter) {\n      reporter.error('{parent} is setter but {child} is getter');\n    }\n\n    checkFunctionSignatures(parent.set, child.set, reporter);\n  }\n}\n\nfunction checkDescriptors(parent, child, reporter) {\n  var parentType = getDescriptorType(parent);\n  var childType = getDescriptorType(child);\n\n  if (parentType !== childType) {\n    reporter.error('descriptor types do not match. {parent} is \"' + parentType + '\", {child} is \"' + childType + '\"');\n  }\n\n  switch (childType) {\n    case 'data':\n      checkDataDescriptors(parent, child, reporter);\n      break;\n\n    case 'accessor':\n      checkAccessorDescriptors(parent, child, reporter);\n      break;\n  }\n}\n\nvar suggestionTransforms = [function (key) {\n  return key.toLowerCase();\n}, function (key) {\n  return key.toUpperCase();\n}, function (key) {\n  return key + 's';\n}, function (key) {\n  return key.slice(0, -1);\n}, function (key) {\n  return key.slice(1, key.length);\n}];\n\nfunction findPossibleAlternatives(superKlass, key) {\n  for (var i = 0, l = suggestionTransforms.length; i < l; i++) {\n    var fn = suggestionTransforms[i];\n    var suggestion = fn(key);\n\n    if (suggestion in superKlass) {\n      return suggestion;\n    }\n  }\n\n  return null;\n}\n\nfunction handleDescriptor(target, key, descriptor) {\n  descriptor.key = key;\n  var superKlass = Object.getPrototypeOf(target);\n  var superDescriptor = Object.getOwnPropertyDescriptor(superKlass, key);\n  var reporter = new SyntaxErrorReporter(superKlass, target, superDescriptor, descriptor);\n\n  if (superDescriptor === undefined) {\n    var suggestedKey = findPossibleAlternatives(superKlass, key);\n    var suggestion = suggestedKey ? '\\n\\n  Did you mean \"' + suggestedKey + '\"?' : '';\n    reporter.error('No descriptor matching {child} was found on the prototype chain.' + suggestion);\n  }\n\n  checkDescriptors(superDescriptor, descriptor, reporter);\n  return descriptor;\n}\n\nexport default function override() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(handleDescriptor, args);\n}","map":{"version":3,"sources":["/Users/pratison/Work/Cisco/Education/React/education-webex/node_modules/core-decorators/es/override.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","_classCallCheck","instance","TypeError","decorate","GENERIC_FUNCTION_ERROR","FUNCTION_REGEXP","SyntaxErrorReporter","value","_getTopic","undefined","get","set","_extractTopicSignature","topic","_extractFunctionSignature","fn","_this","toString","replace","match","name","arguments","params","childDescriptor","parentKlass","parentPropertySignature","childKlass","childPropertySignature","parentDescriptor","parentTopic","childTopic","assert","condition","msg","error","_this2","m","parentNotation","childNotation","SyntaxError","getDescriptorType","hasOwnProperty","checkFunctionSignatures","parent","child","reporter","checkDataDescriptors","parentValueType","childValueType","isFunctionOverUndefined","checkAccessorDescriptors","parentHasGetter","childHasGetter","parentHasSetter","childHasSetter","checkDescriptors","parentType","childType","suggestionTransforms","toLowerCase","toUpperCase","slice","findPossibleAlternatives","superKlass","l","suggestion","handleDescriptor","getPrototypeOf","superDescriptor","getOwnPropertyDescriptor","suggestedKey","override","_len","args","Array","_key"],"mappings":"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","sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nimport { decorate } from './private/utils';\n\nvar GENERIC_FUNCTION_ERROR = '{child} does not properly override {parent}';\nvar FUNCTION_REGEXP = /^function ([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?(\\([^\\)]*\\))[\\s\\S]+$/;\n\nvar SyntaxErrorReporter = function () {\n  _createClass(SyntaxErrorReporter, [{\n    key: '_getTopic',\n    value: function _getTopic(descriptor) {\n      if (descriptor === undefined) {\n        return null;\n      }\n\n      if ('value' in descriptor) {\n        return descriptor.value;\n      }\n\n      if ('get' in descriptor) {\n        return descriptor.get;\n      }\n\n      if ('set' in descriptor) {\n        return descriptor.set;\n      }\n    }\n  }, {\n    key: '_extractTopicSignature',\n    value: function _extractTopicSignature(topic) {\n      switch (typeof topic === 'undefined' ? 'undefined' : _typeof(topic)) {\n        case 'function':\n          return this._extractFunctionSignature(topic);\n        default:\n          return this.key;\n      }\n    }\n  }, {\n    key: '_extractFunctionSignature',\n    value: function _extractFunctionSignature(fn) {\n      var _this = this;\n\n      return fn.toString().replace(FUNCTION_REGEXP, function (match) {\n        var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.key;\n        var params = arguments[2];\n        return name + params;\n      });\n    }\n  }, {\n    key: 'key',\n    get: function get() {\n      return this.childDescriptor.key;\n    }\n  }, {\n    key: 'parentNotation',\n    get: function get() {\n      return this.parentKlass.constructor.name + '#' + this.parentPropertySignature;\n    }\n  }, {\n    key: 'childNotation',\n    get: function get() {\n      return this.childKlass.constructor.name + '#' + this.childPropertySignature;\n    }\n  }, {\n    key: 'parentTopic',\n    get: function get() {\n      return this._getTopic(this.parentDescriptor);\n    }\n  }, {\n    key: 'childTopic',\n    get: function get() {\n      return this._getTopic(this.childDescriptor);\n    }\n  }, {\n    key: 'parentPropertySignature',\n    get: function get() {\n      return this._extractTopicSignature(this.parentTopic);\n    }\n  }, {\n    key: 'childPropertySignature',\n    get: function get() {\n      return this._extractTopicSignature(this.childTopic);\n    }\n  }]);\n\n  function SyntaxErrorReporter(parentKlass, childKlass, parentDescriptor, childDescriptor) {\n    _classCallCheck(this, SyntaxErrorReporter);\n\n    this.parentKlass = parentKlass;\n    this.childKlass = childKlass;\n    this.parentDescriptor = parentDescriptor;\n    this.childDescriptor = childDescriptor;\n  }\n\n  _createClass(SyntaxErrorReporter, [{\n    key: 'assert',\n    value: function assert(condition) {\n      var msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n      if (condition !== true) {\n        this.error(GENERIC_FUNCTION_ERROR + msg);\n      }\n    }\n  }, {\n    key: 'error',\n    value: function error(msg) {\n      var _this2 = this;\n\n      msg = msg\n      // Replace lazily, because they actually might not\n      // be available in all cases\n      .replace('{parent}', function (m) {\n        return _this2.parentNotation;\n      }).replace('{child}', function (m) {\n        return _this2.childNotation;\n      });\n      throw new SyntaxError(msg);\n    }\n  }]);\n\n  return SyntaxErrorReporter;\n}();\n\nfunction getDescriptorType(descriptor) {\n  if (descriptor.hasOwnProperty('value')) {\n    return 'data';\n  }\n\n  if (descriptor.hasOwnProperty('get') || descriptor.hasOwnProperty('set')) {\n    return 'accessor';\n  }\n\n  // If none of them exist, browsers treat it as\n  // a data descriptor with a value of `undefined`\n  return 'data';\n}\n\nfunction checkFunctionSignatures(parent, child, reporter) {\n  reporter.assert(parent.length === child.length);\n}\n\nfunction checkDataDescriptors(parent, child, reporter) {\n  var parentValueType = _typeof(parent.value);\n  var childValueType = _typeof(child.value);\n\n  if (parentValueType === 'undefined' && childValueType === 'undefined') {\n    // class properties can be any expression, which isn't ran until the\n    // the instance is created, so we can't reliably get type information\n    // for them yet (per spec). Perhaps when Babel includes flow-type info\n    // in runtime? Tried regex solutions, but super hacky and only feasible\n    // on primitives, which is confusing for usage...\n    reporter.error('descriptor values are both undefined. (class properties are are not currently supported)\\'');\n  }\n\n  if (parentValueType !== childValueType) {\n    var isFunctionOverUndefined = childValueType === 'function' && parentValueType === undefined;\n    // Even though we don't support class properties, this\n    // will still handle more than just functions, just in case.\n    // Shadowing an undefined value is an error if the inherited\n    // value was undefined (usually a class property, not a method)\n    if (isFunctionOverUndefined || parentValueType !== undefined) {\n      reporter.error('value types do not match. {parent} is \"' + parentValueType + '\", {child} is \"' + childValueType + '\"');\n    }\n  }\n\n  // Switch, in preparation for supporting more types\n  switch (childValueType) {\n    case 'function':\n      checkFunctionSignatures(parent.value, child.value, reporter);\n      break;\n\n    default:\n      reporter.error('Unexpected error. Please file a bug with: {parent} is \"' + parentValueType + '\", {child} is \"' + childValueType + '\"');\n      break;\n  }\n}\n\nfunction checkAccessorDescriptors(parent, child, reporter) {\n  var parentHasGetter = typeof parent.get === 'function';\n  var childHasGetter = typeof child.get === 'function';\n  var parentHasSetter = typeof parent.set === 'function';\n  var childHasSetter = typeof child.set === 'function';\n\n  if (parentHasGetter || childHasGetter) {\n    if (!parentHasGetter && parentHasSetter) {\n      reporter.error('{parent} is setter but {child} is getter');\n    }\n\n    if (!childHasGetter && childHasSetter) {\n      reporter.error('{parent} is getter but {child} is setter');\n    }\n\n    checkFunctionSignatures(parent.get, child.get, reporter);\n  }\n\n  if (parentHasSetter || childHasSetter) {\n    if (!parentHasSetter && parentHasGetter) {\n      reporter.error('{parent} is getter but {child} is setter');\n    }\n\n    if (!childHasSetter && childHasGetter) {\n      reporter.error('{parent} is setter but {child} is getter');\n    }\n\n    checkFunctionSignatures(parent.set, child.set, reporter);\n  }\n}\n\nfunction checkDescriptors(parent, child, reporter) {\n  var parentType = getDescriptorType(parent);\n  var childType = getDescriptorType(child);\n\n  if (parentType !== childType) {\n    reporter.error('descriptor types do not match. {parent} is \"' + parentType + '\", {child} is \"' + childType + '\"');\n  }\n\n  switch (childType) {\n    case 'data':\n      checkDataDescriptors(parent, child, reporter);\n      break;\n\n    case 'accessor':\n      checkAccessorDescriptors(parent, child, reporter);\n      break;\n  }\n}\n\nvar suggestionTransforms = [function (key) {\n  return key.toLowerCase();\n}, function (key) {\n  return key.toUpperCase();\n}, function (key) {\n  return key + 's';\n}, function (key) {\n  return key.slice(0, -1);\n}, function (key) {\n  return key.slice(1, key.length);\n}];\n\nfunction findPossibleAlternatives(superKlass, key) {\n  for (var i = 0, l = suggestionTransforms.length; i < l; i++) {\n    var fn = suggestionTransforms[i];\n    var suggestion = fn(key);\n\n    if (suggestion in superKlass) {\n      return suggestion;\n    }\n  }\n\n  return null;\n}\n\nfunction handleDescriptor(target, key, descriptor) {\n  descriptor.key = key;\n  var superKlass = Object.getPrototypeOf(target);\n  var superDescriptor = Object.getOwnPropertyDescriptor(superKlass, key);\n  var reporter = new SyntaxErrorReporter(superKlass, target, superDescriptor, descriptor);\n\n  if (superDescriptor === undefined) {\n    var suggestedKey = findPossibleAlternatives(superKlass, key);\n    var suggestion = suggestedKey ? '\\n\\n  Did you mean \"' + suggestedKey + '\"?' : '';\n    reporter.error('No descriptor matching {child} was found on the prototype chain.' + suggestion);\n  }\n\n  checkDescriptors(superDescriptor, descriptor, reporter);\n\n  return descriptor;\n}\n\nexport default function override() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(handleDescriptor, args);\n}"]},"metadata":{},"sourceType":"module"}