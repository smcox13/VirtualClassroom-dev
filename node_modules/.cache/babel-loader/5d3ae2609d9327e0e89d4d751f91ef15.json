{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _map = require('babel-runtime/core-js/map');\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _weakMap = require('babel-runtime/core-js/weak-map');\n\nvar _weakMap2 = _interopRequireDefault(_weakMap);\n\nvar _httpCore = require('@webex/http-core');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // contains the system time in milliseconds at which the retry after associated with a 429 expires\n// mapped by the API name, e.g.: idbroker.webex.com/doStuff would be mapped as 'doStuff'\n\n\nvar rateLimitExpiryTime = new _weakMap2.default(); // extracts the common identity API being called\n\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nvar idBrokerRegex = /.*(idbroker|identity)(bts)?.ciscospark.com\\/([^/]+)/;\n/**\n * @class\n */\n\nvar RateLimitInterceptor = function (_Interceptor) {\n  (0, _inherits3.default)(RateLimitInterceptor, _Interceptor);\n  (0, _createClass3.default)(RateLimitInterceptor, null, [{\n    key: 'create',\n\n    /**\n     * @returns {RateLimitInterceptor}\n     */\n    value: function create() {\n      return new RateLimitInterceptor({\n        webex: this\n      });\n    }\n    /**\n    * constructor\n    * @param {mixed} args\n    * @returns {Exception}\n    */\n\n  }]);\n\n  function RateLimitInterceptor() {\n    var _ref;\n\n    (0, _classCallCheck3.default)(this, RateLimitInterceptor);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = RateLimitInterceptor.__proto__ || (0, _getPrototypeOf2.default)(RateLimitInterceptor)).call.apply(_ref, [this].concat(args)));\n\n    rateLimitExpiryTime.set(_this, new _map2.default());\n    return _this;\n  }\n  /**\n   * @see {@link Interceptor#onRequest}\n   * @param {Object} options\n   * @returns {Object}\n   */\n\n\n  (0, _createClass3.default)(RateLimitInterceptor, [{\n    key: 'onRequest',\n    value: function onRequest(options) {\n      if (this.isRateLimited(options.uri)) {\n        return _promise2.default.reject(new Error('API rate limited ' + options.uri));\n      }\n\n      return _promise2.default.resolve(options);\n    }\n    /**\n     * @see {@link Interceptor#onResponseError}\n     * @param {Object} options\n     * @param {Error} reason\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'onResponseError',\n    value: function onResponseError(options, reason) {\n      if (reason.statusCode === 429 && (options.uri.includes('idbroker') || options.uri.includes('identity'))) {\n        // set the retry after in the map, setting to milliseconds\n        this.setRateLimitExpiry(options.uri, this.extractRetryAfterTime(options));\n      }\n\n      return _promise2.default.reject(reason);\n    }\n    /**\n     * @param {object} options associated with the request\n     * @returns {number} retry after time in milliseconds\n     */\n\n  }, {\n    key: 'extractRetryAfterTime',\n    value: function extractRetryAfterTime(options) {\n      // 1S * 1K === 1MS\n      var milliMultiplier = 1000;\n      var retryAfter = options.headers['retry-after'] || null; // set 60 retry if no usable time defined\n\n      if (retryAfter === null || retryAfter <= 0) {\n        return 60 * milliMultiplier;\n      } // set max to 3600 S (1 hour) if greater than 1 hour\n\n\n      if (retryAfter > 3600) {\n        return 3600 * milliMultiplier;\n      }\n\n      return retryAfter * milliMultiplier;\n    }\n    /**\n     * Set the system time at which the rate limiting\n     * will expire in the rateLimitExpiryTime map.\n     * Assumes retryAfter is in milliseconds\n     * @param {string} uri API issuing the rate limiting\n     * @param {number} retryAfter milliseconds until rate limiting expires\n     * @returns {bool} true is value was successfully set\n     */\n\n  }, {\n    key: 'setRateLimitExpiry',\n    value: function setRateLimitExpiry(uri, retryAfter) {\n      var apiName = this.getApiName(uri);\n\n      if (!apiName) {\n        return false;\n      }\n\n      var currTimeMilli = new Date().getTime();\n      var expiry = currTimeMilli + retryAfter;\n      var dict = rateLimitExpiryTime.get(this);\n      return dict.set(apiName, expiry);\n    }\n    /**\n     * returns true if the API is currently rate limited\n     * @param {string} uri\n     * @returns {Boolean} indicates whether or not the API is rate currently rate limited\n     */\n\n  }, {\n    key: 'getRateLimitStatus',\n    value: function getRateLimitStatus(uri) {\n      var apiName = this.getApiName(uri);\n\n      if (!apiName) {\n        return false;\n      }\n\n      var currTimeMilli = new Date().getTime();\n      var dict = rateLimitExpiryTime.get(this);\n      var expiryTime = dict.get(apiName); // if no rate limit expiry has been registered in the map, return false.\n\n      if (expiryTime === undefined) {\n        return false;\n      } // return true, indicating rate limiting, if the system time is less than the expiry time\n\n\n      return currTimeMilli < dict.get(apiName);\n    }\n    /**\n     * split the URI and returns the API name of idBroker\n     * @param {string} uri\n     * @returns {string}\n     */\n\n  }, {\n    key: 'getApiName',\n    value: function getApiName(uri) {\n      if (!uri) {\n        return null;\n      }\n\n      var results = uri.match(idBrokerRegex);\n\n      if (!results) {\n        return null;\n      } // group 0 = full match of URL, group 1 = identity or idbroker base\n      // group 2 = api name\n\n\n      return results[2];\n    }\n    /**\n     * check URI against list of currently rate limited\n     * URIs, and determines if retry-after\n     * @param {String} uri pattern to check\n     * @returns {bool}\n     */\n\n  }, {\n    key: 'isRateLimited',\n    value: function isRateLimited(uri) {\n      // determine if the URI is associated with a common identity API\n      if (uri && (uri.includes('idbroker') || uri.includes('identity'))) {\n        return this.getRateLimitStatus(uri);\n      }\n\n      return false;\n    }\n  }]);\n  return RateLimitInterceptor;\n}(_httpCore.Interceptor);\n\nexports.default = RateLimitInterceptor;","map":{"version":3,"sources":["rate-limit.js"],"names":["rateLimitExpiryTime","idBrokerRegex","RateLimitInterceptor","Interceptor","webex","args","options","reason","milliMultiplier","retryAfter","uri","apiName","currTimeMilli","expiry","dict","expiryTime","results"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {Interceptor} from '@webex/http-core';\n\n// contains the system time in milliseconds at which the retry after associated with a 429 expires\n// mapped by the API name, e.g.: idbroker.webex.com/doStuff would be mapped as 'doStuff'\nconst rateLimitExpiryTime = new WeakMap();\n\n// extracts the common identity API being called\nconst idBrokerRegex = /.*(idbroker|identity)(bts)?.ciscospark.com\\/([^/]+)/;\n\n/**\n * @class\n */\nexport default class RateLimitInterceptor extends Interceptor {\n  /**\n   * @returns {RateLimitInterceptor}\n   */\n  static create() {\n    return new RateLimitInterceptor({webex: this});\n  }\n\n  /**\n  * constructor\n  * @param {mixed} args\n  * @returns {Exception}\n  */\n  constructor(...args) {\n    super(...args);\n    rateLimitExpiryTime.set(this, new Map());\n  }\n\n  /**\n   * @see {@link Interceptor#onRequest}\n   * @param {Object} options\n   * @returns {Object}\n   */\n  onRequest(options) {\n    if (this.isRateLimited(options.uri)) {\n      return Promise.reject(new Error(`API rate limited ${options.uri}`));\n    }\n\n    return Promise.resolve(options);\n  }\n\n  /**\n   * @see {@link Interceptor#onResponseError}\n   * @param {Object} options\n   * @param {Error} reason\n   * @returns {Object}\n   */\n  onResponseError(options, reason) {\n    if (reason.statusCode === 429 && (options.uri.includes('idbroker') || options.uri.includes('identity'))) {\n      // set the retry after in the map, setting to milliseconds\n      this.setRateLimitExpiry(options.uri, this.extractRetryAfterTime(options));\n    }\n\n    return Promise.reject(reason);\n  }\n\n  /**\n   * @param {object} options associated with the request\n   * @returns {number} retry after time in milliseconds\n   */\n  extractRetryAfterTime(options) {\n    // 1S * 1K === 1MS\n    const milliMultiplier = 1000;\n    const retryAfter = options.headers['retry-after'] || null;\n\n    // set 60 retry if no usable time defined\n    if (retryAfter === null || retryAfter <= 0) {\n      return 60 * milliMultiplier;\n    }\n    // set max to 3600 S (1 hour) if greater than 1 hour\n    if (retryAfter > 3600) {\n      return 3600 * milliMultiplier;\n    }\n\n    return retryAfter * milliMultiplier;\n  }\n\n  /**\n   * Set the system time at which the rate limiting\n   * will expire in the rateLimitExpiryTime map.\n   * Assumes retryAfter is in milliseconds\n   * @param {string} uri API issuing the rate limiting\n   * @param {number} retryAfter milliseconds until rate limiting expires\n   * @returns {bool} true is value was successfully set\n   */\n  setRateLimitExpiry(uri, retryAfter) {\n    const apiName = this.getApiName(uri);\n\n    if (!apiName) {\n      return false;\n    }\n\n    const currTimeMilli = new Date().getTime();\n    const expiry = currTimeMilli + retryAfter;\n    const dict = rateLimitExpiryTime.get(this);\n\n    return dict.set(apiName, expiry);\n  }\n\n  /**\n   * returns true if the API is currently rate limited\n   * @param {string} uri\n   * @returns {Boolean} indicates whether or not the API is rate currently rate limited\n   */\n  getRateLimitStatus(uri) {\n    const apiName = this.getApiName(uri);\n\n    if (!apiName) {\n      return false;\n    }\n\n    const currTimeMilli = new Date().getTime();\n    const dict = rateLimitExpiryTime.get(this);\n    const expiryTime = dict.get(apiName);\n\n    // if no rate limit expiry has been registered in the map, return false.\n    if (expiryTime === undefined) {\n      return false;\n    }\n\n    // return true, indicating rate limiting, if the system time is less than the expiry time\n    return currTimeMilli < dict.get(apiName);\n  }\n\n  /**\n   * split the URI and returns the API name of idBroker\n   * @param {string} uri\n   * @returns {string}\n   */\n  getApiName(uri) {\n    if (!uri) {\n      return null;\n    }\n\n    const results = uri.match(idBrokerRegex);\n\n    if (!results) {\n      return null;\n    }\n\n    // group 0 = full match of URL, group 1 = identity or idbroker base\n    // group 2 = api name\n    return results[2];\n  }\n\n  /**\n   * check URI against list of currently rate limited\n   * URIs, and determines if retry-after\n   * @param {String} uri pattern to check\n   * @returns {bool}\n   */\n  isRateLimited(uri) {\n    // determine if the URI is associated with a common identity API\n    if (uri && (uri.includes('idbroker') || uri.includes('identity'))) {\n      return this.getRateLimitStatus(uri);\n    }\n\n    return false;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}