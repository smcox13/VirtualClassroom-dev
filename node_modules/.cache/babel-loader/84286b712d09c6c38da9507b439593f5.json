{"ast":null,"code":"var AmpersandEvents = require('ampersand-events');\n\nvar classExtend = require('ampersand-class-extend');\n\nvar isArray = require('lodash/isArray');\n\nvar bind = require('lodash/bind');\n\nvar assign = require('lodash/assign');\n\nvar slice = [].slice;\n\nfunction Collection(models, options) {\n  options || (options = {});\n  if (options.model) this.model = options.model;\n  if (options.comparator) this.comparator = options.comparator;\n  if (options.parent) this.parent = options.parent;\n\n  if (!this.mainIndex) {\n    var idAttribute = this.model && this.model.prototype && this.model.prototype.idAttribute;\n    this.mainIndex = idAttribute || 'id';\n  }\n\n  this._reset();\n\n  this.initialize.apply(this, arguments);\n  if (models) this.reset(models, assign({\n    silent: true\n  }, options));\n}\n\nassign(Collection.prototype, AmpersandEvents, {\n  initialize: function () {},\n  isModel: function (model) {\n    return this.model && model instanceof this.model;\n  },\n  add: function (models, options) {\n    return this.set(models, assign({\n      merge: false,\n      add: true,\n      remove: false\n    }, options));\n  },\n  // overridable parse method\n  parse: function (res, options) {\n    return res;\n  },\n  // overridable serialize method\n  serialize: function () {\n    return this.map(function (model) {\n      if (model.serialize) {\n        return model.serialize();\n      } else {\n        var out = {};\n        assign(out, model);\n        delete out.collection;\n        return out;\n      }\n    });\n  },\n  toJSON: function () {\n    return this.serialize();\n  },\n  set: function (models, options) {\n    options = assign({\n      add: true,\n      remove: true,\n      merge: true\n    }, options);\n    if (options.parse) models = this.parse(models, options);\n    var singular = !isArray(models);\n    models = singular ? models ? [models] : [] : models.slice();\n    var id, model, attrs, existing, sort, i, length;\n    var at = options.at;\n    var sortable = this.comparator && at == null && options.sort !== false;\n    var sortAttr = 'string' === typeof this.comparator ? this.comparator : null;\n    var toAdd = [],\n        toRemove = [],\n        modelMap = {};\n    var add = options.add,\n        merge = options.merge,\n        remove = options.remove;\n    var order = !sortable && add && remove ? [] : false;\n    var targetProto = this.model && this.model.prototype || Object.prototype; // Turn bare objects into model references, and prevent invalid models\n    // from being added.\n\n    for (i = 0, length = models.length; i < length; i++) {\n      attrs = models[i] || {};\n\n      if (this.isModel(attrs)) {\n        id = model = attrs;\n      } else if (targetProto.generateId) {\n        id = targetProto.generateId(attrs);\n      } else {\n        id = attrs[this.mainIndex];\n\n        if (id === undefined && this._isDerivedIndex(targetProto)) {\n          id = targetProto._derived[this.mainIndex].fn.call(attrs);\n        }\n      } // If a duplicate is found, prevent it from being added and\n      // optionally merge it into the existing model.\n\n\n      if (existing = this.get(id)) {\n        if (remove) modelMap[existing.cid || existing[this.mainIndex]] = true;\n\n        if (merge) {\n          attrs = attrs === model ? model.attributes : attrs;\n          if (options.parse) attrs = existing.parse(attrs, options); // if this is model\n\n          if (existing.set) {\n            existing.set(attrs, options);\n            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;\n          } else {\n            // if not just update the properties\n            assign(existing, attrs);\n          }\n        }\n\n        models[i] = existing; // If this is a new, valid model, push it to the `toAdd` list.\n      } else if (add) {\n        model = models[i] = this._prepareModel(attrs, options);\n        if (!model) continue;\n        toAdd.push(model);\n\n        this._addReference(model, options);\n      } // Do not add multiple models with the same `id`.\n\n\n      model = existing || model;\n      if (!model) continue;\n      if (order && (model.isNew && model.isNew() || !model[this.mainIndex] || !modelMap[model.cid || model[this.mainIndex]])) order.push(model);\n      modelMap[model[this.mainIndex]] = true;\n    } // Remove nonexistent models if appropriate.\n\n\n    if (remove) {\n      for (i = 0, length = this.length; i < length; i++) {\n        model = this.models[i];\n        if (!modelMap[model.cid || model[this.mainIndex]]) toRemove.push(model);\n      }\n\n      if (toRemove.length) this.remove(toRemove, options); // Add indexes again to make sure they were not removed above.\n\n      for (i = 0, length = toAdd.length; i < length; i++) {\n        this._index(toAdd[i]);\n      }\n    } // See if sorting is needed, update `length` and splice in new models.\n\n\n    if (toAdd.length || order && order.length) {\n      if (sortable) sort = true;\n\n      if (at != null) {\n        for (i = 0, length = toAdd.length; i < length; i++) {\n          this.models.splice(at + i, 0, toAdd[i]);\n        }\n      } else {\n        var orderedModels = order || toAdd;\n\n        for (i = 0, length = orderedModels.length; i < length; i++) {\n          this.models.push(orderedModels[i]);\n        }\n      }\n    } // Silently sort the collection if appropriate.\n\n\n    if (sort) this.sort({\n      silent: true\n    }); // Unless silenced, it's time to fire all appropriate add/sort events.\n\n    if (!options.silent) {\n      for (i = 0, length = toAdd.length; i < length; i++) {\n        model = toAdd[i];\n\n        if (model.trigger) {\n          model.trigger('add', model, this, options);\n        } else {\n          this.trigger('add', model, this, options);\n        }\n      }\n\n      if (sort || order && order.length) this.trigger('sort', this, options);\n    } // Return the added (or merged) model (or models).\n\n\n    return singular ? models[0] : models;\n  },\n  get: function (query, indexName) {\n    if (query == null) return;\n    var collectionMainIndex = this.mainIndex;\n    var index = this._indexes[indexName || collectionMainIndex];\n    return index && (index[query] || query[collectionMainIndex] !== undefined && index[query[collectionMainIndex]]) || this._indexes.cid[query] || this._indexes.cid[query.cid];\n  },\n  // Get the model at the given index.\n  at: function (index) {\n    return this.models[index];\n  },\n  remove: function (models, options) {\n    var singular = !isArray(models);\n    var i, length, model, index;\n    models = singular ? [models] : slice.call(models);\n    options || (options = {});\n\n    for (i = 0, length = models.length; i < length; i++) {\n      model = models[i] = this.get(models[i]);\n      if (!model) continue;\n\n      this._deIndex(model);\n\n      index = this.models.indexOf(model);\n      this.models.splice(index, 1);\n\n      if (!options.silent) {\n        options.index = index;\n\n        if (model.trigger) {\n          model.trigger('remove', model, this, options);\n        } else {\n          this.trigger('remove', model, this, options);\n        }\n      }\n\n      this._removeReference(model, options);\n    }\n\n    return singular ? models[0] : models;\n  },\n  // When you have more items than you want to add or remove individually,\n  // you can reset the entire set with a new list of models, without firing\n  // any granular `add` or `remove` events. Fires `reset` when finished.\n  // Useful for bulk operations and optimizations.\n  reset: function (models, options) {\n    options || (options = {});\n\n    for (var i = 0, length = this.models.length; i < length; i++) {\n      this._removeReference(this.models[i], options);\n    }\n\n    options.previousModels = this.models;\n\n    this._reset();\n\n    models = this.add(models, assign({\n      silent: true\n    }, options));\n    if (!options.silent) this.trigger('reset', this, options);\n    return models;\n  },\n  sort: function (options) {\n    var self = this;\n    if (!this.comparator) throw new Error('Cannot sort a set without a comparator');\n    options || (options = {});\n\n    if (typeof this.comparator === 'string') {\n      this.models.sort(function (left, right) {\n        if (left.get) {\n          left = left.get(self.comparator);\n          right = right.get(self.comparator);\n        } else {\n          left = left[self.comparator];\n          right = right[self.comparator];\n        }\n\n        if (left > right || left === void 0) return 1;\n        if (left < right || right === void 0) return -1;\n        return 0;\n      });\n    } else if (this.comparator.length === 1) {\n      this.models.sort(function (left, right) {\n        left = self.comparator(left);\n        right = self.comparator(right);\n        if (left > right || left === void 0) return 1;\n        if (left < right || right === void 0) return -1;\n        return 0;\n      });\n    } else {\n      this.models.sort(bind(this.comparator, this));\n    }\n\n    if (!options.silent) this.trigger('sort', this, options);\n    return this;\n  },\n  // Private method to reset all internal state. Called when the collection\n  // is first initialized or reset.\n  _reset: function () {\n    var list = slice.call(this.indexes || []);\n    var i = 0;\n    list.push(this.mainIndex);\n    list.push('cid');\n    var l = list.length;\n    this.models = [];\n    this._indexes = {};\n\n    for (; i < l; i++) {\n      this._indexes[list[i]] = {};\n    }\n  },\n  _prepareModel: function (attrs, options) {\n    // if we haven't defined a constructor, skip this\n    if (!this.model) return attrs;\n\n    if (this.isModel(attrs)) {\n      if (!attrs.collection) attrs.collection = this;\n      return attrs;\n    } else {\n      options = options ? assign({}, options) : {};\n      options.collection = this;\n      var model = new this.model(attrs, options);\n      if (!model.validationError) return model;\n      this.trigger('invalid', this, model.validationError, options);\n      return false;\n    }\n  },\n  _deIndex: function (model, attribute, value) {\n    var indexVal;\n\n    if (attribute !== undefined) {\n      if (undefined === this._indexes[attribute]) throw new Error('Given attribute is not an index');\n      delete this._indexes[attribute][value];\n      return;\n    } // Not a specific attribute\n\n\n    for (var indexAttr in this._indexes) {\n      indexVal = model.hasOwnProperty(indexAttr) ? model[indexAttr] : model.get && model.get(indexAttr);\n      delete this._indexes[indexAttr][indexVal];\n    }\n  },\n  _index: function (model, attribute) {\n    var indexVal;\n\n    if (attribute !== undefined) {\n      if (undefined === this._indexes[attribute]) throw new Error('Given attribute is not an index');\n      indexVal = model[attribute] || model.get && model.get(attribute);\n      if (indexVal) this._indexes[attribute][indexVal] = model;\n      return;\n    } // Not a specific attribute\n\n\n    for (var indexAttr in this._indexes) {\n      indexVal = model.hasOwnProperty(indexAttr) ? model[indexAttr] : model.get && model.get(indexAttr);\n      if (indexVal != null) this._indexes[indexAttr][indexVal] = model;\n    }\n  },\n  _isDerivedIndex: function (proto) {\n    if (!proto || typeof proto._derived !== 'object') {\n      return false;\n    }\n\n    return Object.keys(proto._derived).indexOf(this.mainIndex) >= 0;\n  },\n  // Internal method to create a model's ties to a collection.\n  _addReference: function (model, options) {\n    this._index(model);\n\n    if (!model.collection) model.collection = this;\n    if (model.on) model.on('all', this._onModelEvent, this);\n  },\n  // Internal method to sever a model's ties to a collection.\n  _removeReference: function (model, options) {\n    if (this === model.collection) delete model.collection;\n\n    this._deIndex(model);\n\n    if (model.off) model.off('all', this._onModelEvent, this);\n  },\n  _onModelEvent: function (event, model, collection, options) {\n    var eventName = event.split(':')[0];\n    var attribute = event.split(':')[1];\n    if ((eventName === 'add' || eventName === 'remove') && collection !== this) return;\n    if (eventName === 'destroy') this.remove(model, options);\n\n    if (model && eventName === 'change' && attribute && this._indexes[attribute]) {\n      this._deIndex(model, attribute, model.previousAttributes()[attribute]);\n\n      this._index(model, attribute);\n    }\n\n    this.trigger.apply(this, arguments);\n  }\n});\nObject.defineProperties(Collection.prototype, {\n  length: {\n    get: function () {\n      return this.models.length;\n    }\n  },\n  isCollection: {\n    get: function () {\n      return true;\n    }\n  }\n});\nvar arrayMethods = ['indexOf', 'lastIndexOf', 'every', 'some', 'forEach', 'map', 'filter', 'reduce', 'reduceRight'];\narrayMethods.forEach(function (method) {\n  Collection.prototype[method] = function () {\n    return this.models[method].apply(this.models, arguments);\n  };\n}); // alias each/forEach for maximum compatibility\n\nCollection.prototype.each = Collection.prototype.forEach;\nCollection.extend = classExtend;\nmodule.exports = Collection;","map":{"version":3,"sources":["/Users/pratison/Work/Cisco/Education/React/education-webex/node_modules/ampersand-collection/ampersand-collection.js"],"names":["AmpersandEvents","require","classExtend","isArray","bind","assign","slice","Collection","models","options","model","comparator","parent","mainIndex","idAttribute","prototype","_reset","initialize","apply","arguments","reset","silent","isModel","add","set","merge","remove","parse","res","serialize","map","out","collection","toJSON","singular","id","attrs","existing","sort","i","length","at","sortable","sortAttr","toAdd","toRemove","modelMap","order","targetProto","Object","generateId","undefined","_isDerivedIndex","_derived","fn","call","get","cid","attributes","hasChanged","_prepareModel","push","_addReference","isNew","_index","splice","orderedModels","trigger","query","indexName","collectionMainIndex","index","_indexes","_deIndex","indexOf","_removeReference","previousModels","self","Error","left","right","list","indexes","l","validationError","attribute","value","indexVal","indexAttr","hasOwnProperty","proto","keys","on","_onModelEvent","off","event","eventName","split","previousAttributes","defineProperties","isCollection","arrayMethods","forEach","method","each","extend","module","exports"],"mappings":"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","sourcesContent":["var AmpersandEvents = require('ampersand-events');\nvar classExtend = require('ampersand-class-extend');\nvar isArray = require('lodash/isArray');\nvar bind = require('lodash/bind');\nvar assign = require('lodash/assign');\nvar slice = [].slice;\n\nfunction Collection(models, options) {\n    options || (options = {});\n    if (options.model) this.model = options.model;\n    if (options.comparator) this.comparator = options.comparator;\n    if (options.parent) this.parent = options.parent;\n    if (!this.mainIndex) {\n        var idAttribute = this.model && this.model.prototype && this.model.prototype.idAttribute;\n        this.mainIndex = idAttribute || 'id';\n    }\n    this._reset();\n    this.initialize.apply(this, arguments);\n    if (models) this.reset(models, assign({silent: true}, options));\n}\n\nassign(Collection.prototype, AmpersandEvents, {\n    initialize: function () {},\n\n    isModel: function (model) {\n        return this.model && model instanceof this.model;\n    },\n\n    add: function (models, options) {\n        return this.set(models, assign({merge: false, add: true, remove: false}, options));\n    },\n\n    // overridable parse method\n    parse: function (res, options) {\n        return res;\n    },\n\n    // overridable serialize method\n    serialize: function () {\n        return this.map(function (model) {\n            if (model.serialize) {\n                return model.serialize();\n            } else {\n                var out = {};\n                assign(out, model);\n                delete out.collection;\n                return out;\n            }\n        });\n    },\n\n    toJSON: function () {\n        return this.serialize();\n    },\n\n    set: function (models, options) {\n        options = assign({add: true, remove: true, merge: true}, options);\n        if (options.parse) models = this.parse(models, options);\n        var singular = !isArray(models);\n        models = singular ? (models ? [models] : []) : models.slice();\n        var id, model, attrs, existing, sort, i, length;\n        var at = options.at;\n        var sortable = this.comparator && (at == null) && options.sort !== false;\n        var sortAttr = ('string' === typeof this.comparator) ? this.comparator : null;\n        var toAdd = [], toRemove = [], modelMap = {};\n        var add = options.add, merge = options.merge, remove = options.remove;\n        var order = !sortable && add && remove ? [] : false;\n        var targetProto = this.model && this.model.prototype || Object.prototype;\n\n        // Turn bare objects into model references, and prevent invalid models\n        // from being added.\n        for (i = 0, length = models.length; i < length; i++) {\n            attrs = models[i] || {};\n            if (this.isModel(attrs)) {\n                id = model = attrs;\n            } else if (targetProto.generateId) {\n                id = targetProto.generateId(attrs);\n            } else {\n                id = attrs[this.mainIndex];\n                if (id === undefined && this._isDerivedIndex(targetProto)) {\n                    id = targetProto._derived[this.mainIndex].fn.call(attrs);\n                }\n            }\n\n            // If a duplicate is found, prevent it from being added and\n            // optionally merge it into the existing model.\n            if (existing = this.get(id)) {\n                if (remove) modelMap[existing.cid || existing[this.mainIndex]] = true;\n                if (merge) {\n                    attrs = attrs === model ? model.attributes : attrs;\n                    if (options.parse) attrs = existing.parse(attrs, options);\n                    // if this is model\n                    if (existing.set) {\n                        existing.set(attrs, options);\n                        if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;\n                    } else {\n                        // if not just update the properties\n                        assign(existing, attrs);\n                    }\n                }\n                models[i] = existing;\n\n            // If this is a new, valid model, push it to the `toAdd` list.\n            } else if (add) {\n                model = models[i] = this._prepareModel(attrs, options);\n                if (!model) continue;\n                toAdd.push(model);\n                this._addReference(model, options);\n            }\n\n            // Do not add multiple models with the same `id`.\n            model = existing || model;\n            if (!model) continue;\n            if (order && ((model.isNew && model.isNew() || !model[this.mainIndex]) || !modelMap[model.cid || model[this.mainIndex]])) order.push(model);\n            modelMap[model[this.mainIndex]] = true;\n        }\n\n        // Remove nonexistent models if appropriate.\n        if (remove) {\n            for (i = 0, length = this.length; i < length; i++) {\n                model = this.models[i];\n                if (!modelMap[model.cid || model[this.mainIndex]]) toRemove.push(model);\n            }\n            if (toRemove.length) this.remove(toRemove, options);\n\n            // Add indexes again to make sure they were not removed above.\n            for (i = 0, length = toAdd.length; i < length; i++) {\n                this._index(toAdd[i]);\n            }\n        }\n\n        // See if sorting is needed, update `length` and splice in new models.\n        if (toAdd.length || (order && order.length)) {\n            if (sortable) sort = true;\n            if (at != null) {\n                for (i = 0, length = toAdd.length; i < length; i++) {\n                    this.models.splice(at + i, 0, toAdd[i]);\n                }\n            } else {\n                var orderedModels = order || toAdd;\n                for (i = 0, length = orderedModels.length; i < length; i++) {\n                    this.models.push(orderedModels[i]);\n                }\n            }\n        }\n\n        // Silently sort the collection if appropriate.\n        if (sort) this.sort({silent: true});\n\n        // Unless silenced, it's time to fire all appropriate add/sort events.\n        if (!options.silent) {\n            for (i = 0, length = toAdd.length; i < length; i++) {\n                model = toAdd[i];\n                if (model.trigger) {\n                    model.trigger('add', model, this, options);\n                } else {\n                    this.trigger('add', model, this, options);\n                }\n            }\n            if (sort || (order && order.length)) this.trigger('sort', this, options);\n        }\n\n        // Return the added (or merged) model (or models).\n        return singular ? models[0] : models;\n    },\n\n    get: function (query, indexName) {\n        if (query == null) return;\n\n        var collectionMainIndex = this.mainIndex;\n        var index = this._indexes[indexName || collectionMainIndex];\n\n        return (\n            (\n                index && (\n                    index[query] || (\n                        query[collectionMainIndex] !== undefined &&\n                        index[query[collectionMainIndex]]\n                    )\n                )\n            ) ||\n            this._indexes.cid[query] ||\n            this._indexes.cid[query.cid]\n        );\n    },\n\n    // Get the model at the given index.\n    at: function (index) {\n        return this.models[index];\n    },\n\n    remove: function (models, options) {\n        var singular = !isArray(models);\n        var i, length, model, index;\n\n        models = singular ? [models] : slice.call(models);\n        options || (options = {});\n        for (i = 0, length = models.length; i < length; i++) {\n            model = models[i] = this.get(models[i]);\n            if (!model) continue;\n            this._deIndex(model);\n            index = this.models.indexOf(model);\n            this.models.splice(index, 1);\n            if (!options.silent) {\n                options.index = index;\n                if (model.trigger) {\n                    model.trigger('remove', model, this, options);\n                } else {\n                    this.trigger('remove', model, this, options);\n                }\n            }\n            this._removeReference(model, options);\n        }\n        return singular ? models[0] : models;\n    },\n\n    // When you have more items than you want to add or remove individually,\n    // you can reset the entire set with a new list of models, without firing\n    // any granular `add` or `remove` events. Fires `reset` when finished.\n    // Useful for bulk operations and optimizations.\n    reset: function (models, options) {\n        options || (options = {});\n        for (var i = 0, length = this.models.length; i < length; i++) {\n            this._removeReference(this.models[i], options);\n        }\n        options.previousModels = this.models;\n        this._reset();\n        models = this.add(models, assign({silent: true}, options));\n        if (!options.silent) this.trigger('reset', this, options);\n        return models;\n    },\n\n    sort: function (options) {\n        var self = this;\n        if (!this.comparator) throw new Error('Cannot sort a set without a comparator');\n        options || (options = {});\n\n        if (typeof this.comparator === 'string') {\n            this.models.sort(function (left, right) {\n                if (left.get) {\n                    left = left.get(self.comparator);\n                    right = right.get(self.comparator);\n                } else {\n                    left = left[self.comparator];\n                    right = right[self.comparator];\n                }\n                if (left > right || left === void 0) return 1;\n                if (left < right || right === void 0) return -1;\n                return 0;\n            });\n        } else if (this.comparator.length === 1) {\n            this.models.sort(function (left, right) {\n                left = self.comparator(left);\n                right = self.comparator(right);\n                if (left > right || left === void 0) return 1;\n                if (left < right || right === void 0) return -1;\n                return 0;\n            });\n        } else {\n            this.models.sort(bind(this.comparator,this));\n        }\n\n        if (!options.silent) this.trigger('sort', this, options);\n        return this;\n    },\n\n    // Private method to reset all internal state. Called when the collection\n    // is first initialized or reset.\n    _reset: function () {\n        var list = slice.call(this.indexes || []);\n        var i = 0;\n        list.push(this.mainIndex);\n        list.push('cid');\n        var l = list.length;\n        this.models = [];\n        this._indexes = {};\n        for (; i < l; i++) {\n            this._indexes[list[i]] = {};\n        }\n    },\n\n    _prepareModel: function (attrs, options) {\n        // if we haven't defined a constructor, skip this\n        if (!this.model) return attrs;\n\n        if (this.isModel(attrs)) {\n            if (!attrs.collection) attrs.collection = this;\n            return attrs;\n        } else {\n            options = options ? assign({}, options) : {};\n            options.collection = this;\n            var model = new this.model(attrs, options);\n            if (!model.validationError) return model;\n            this.trigger('invalid', this, model.validationError, options);\n            return false;\n        }\n    },\n\n    _deIndex: function (model, attribute, value) {\n        var indexVal;\n        if (attribute !== undefined) {\n            if (undefined === this._indexes[attribute]) throw new Error('Given attribute is not an index');\n            delete this._indexes[attribute][value];\n            return;\n        }\n        // Not a specific attribute\n        for (var indexAttr in this._indexes) {\n            indexVal = model.hasOwnProperty(indexAttr) ? model[indexAttr] : (model.get && model.get(indexAttr));\n            delete this._indexes[indexAttr][indexVal];\n        }\n    },\n\n    _index: function (model, attribute) {\n        var indexVal;\n        if (attribute !== undefined) {\n            if (undefined === this._indexes[attribute]) throw new Error('Given attribute is not an index');\n            indexVal = model[attribute] || (model.get && model.get(attribute));\n            if (indexVal) this._indexes[attribute][indexVal] = model;\n            return;\n        }\n        // Not a specific attribute\n        for (var indexAttr in this._indexes) {\n            indexVal = model.hasOwnProperty(indexAttr) ? model[indexAttr] : (model.get && model.get(indexAttr));\n            if (indexVal != null) this._indexes[indexAttr][indexVal] = model;\n        }\n    },\n\n    _isDerivedIndex: function(proto) {\n        if (!proto || typeof proto._derived !== 'object') {\n            return false;\n        }\n        return Object.keys(proto._derived).indexOf(this.mainIndex) >= 0;\n    },\n\n    // Internal method to create a model's ties to a collection.\n    _addReference: function (model, options) {\n        this._index(model);\n        if (!model.collection) model.collection = this;\n        if (model.on) model.on('all', this._onModelEvent, this);\n    },\n\n        // Internal method to sever a model's ties to a collection.\n    _removeReference: function (model, options) {\n        if (this === model.collection) delete model.collection;\n        this._deIndex(model);\n        if (model.off) model.off('all', this._onModelEvent, this);\n    },\n\n    _onModelEvent: function (event, model, collection, options) {\n        var eventName = event.split(':')[0];\n        var attribute = event.split(':')[1];\n\n        if ((eventName === 'add' || eventName === 'remove') && collection !== this) return;\n        if (eventName === 'destroy') this.remove(model, options);\n        if (model && eventName === 'change' && attribute && this._indexes[attribute]) {\n            this._deIndex(model, attribute, model.previousAttributes()[attribute]);\n            this._index(model, attribute);\n        }\n        this.trigger.apply(this, arguments);\n    }\n});\n\nObject.defineProperties(Collection.prototype, {\n    length: {\n        get: function () {\n            return this.models.length;\n        }\n    },\n    isCollection: {\n        get: function () {\n            return true;\n        }\n    }\n});\n\nvar arrayMethods = [\n    'indexOf',\n    'lastIndexOf',\n    'every',\n    'some',\n    'forEach',\n    'map',\n    'filter',\n    'reduce',\n    'reduceRight'\n];\n\narrayMethods.forEach(function (method) {\n    Collection.prototype[method] = function () {\n        return this.models[method].apply(this.models, arguments);\n    };\n});\n\n// alias each/forEach for maximum compatibility\nCollection.prototype.each = Collection.prototype.forEach;\n\nCollection.extend = classExtend;\n\nmodule.exports = Collection;\n"]},"metadata":{},"sourceType":"script"}