{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DryError = exports.KmsError = exports.KMS = exports.default = undefined;\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _isString2 = require('lodash/isString');\n\nvar _isString3 = _interopRequireDefault(_isString2);\n\nvar _isObject2 = require('lodash/isObject');\n\nvar _isObject3 = _interopRequireDefault(_isObject2);\n\nvar _has2 = require('lodash/has');\n\nvar _has3 = _interopRequireDefault(_has2);\n\nvar _encryption = require('./encryption');\n\nObject.defineProperty(exports, 'default', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_encryption).default;\n  }\n});\n\nvar _kms = require('./kms');\n\nObject.defineProperty(exports, 'KMS', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_kms).default;\n  }\n});\n\nvar _kmsErrors = require('./kms-errors');\n\nObject.defineProperty(exports, 'KmsError', {\n  enumerable: true,\n  get: function get() {\n    return _kmsErrors.KmsError;\n  }\n});\nObject.defineProperty(exports, 'DryError', {\n  enumerable: true,\n  get: function get() {\n    return _kmsErrors.DryError;\n  }\n});\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _encryption2 = _interopRequireDefault(_encryption);\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nrequire('@webex/internal-plugin-device');\n\nrequire('@webex/internal-plugin-mercury');\n\nvar _kmsDryErrorInterceptor = require('./kms-dry-error-interceptor');\n\nvar _kmsDryErrorInterceptor2 = _interopRequireDefault(_kmsDryErrorInterceptor);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar interceptors = void 0;\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n// Note: There's a bug where if bind gets replayed because of a timeout in which\n// the original request eventually completed, there'll be an error indicating\n// the key can't be bound (because it already has been). This could be mitigated\n// by using Promise.race to resolve replays (as more requests get enqueue for a\n// specific action, accept whichever one completes first).\n\nif (process.env.NODE_ENV === 'test') {\n  interceptors = {\n    KmsDryErrorInterceptor: _kmsDryErrorInterceptor2.default.create\n  };\n}\n\n(0, _webexCore.registerInternalPlugin)('encryption', _encryption2.default, {\n  payloadTransformer: {\n    predicates: [{\n      name: 'encryptKmsMessage',\n      direction: 'outbound',\n      // I don't see any practical way to reduce complexity here.\n      // eslint-disable-next-line complexity\n      test: function test(ctx, options) {\n        if (!(0, _has3.default)(options, 'body.kmsMessage')) {\n          return _promise2.default.resolve(false);\n        }\n\n        if (!(0, _isObject3.default)(options.body.kmsMessage)) {\n          return _promise2.default.resolve(false);\n        } // If this is a template for a kms message, assume another transform\n        // will fill it in later. This is a bit of a leaky abstraction, but the\n        // alternative is building a complex rules engine for controlling\n        // ordering of transforms\n\n\n        if (options.body.kmsMessage.keyUris && options.body.kmsMessage.keyUris.length === 0) {\n          return _promise2.default.resolve(false);\n        }\n\n        if (options.body.kmsMessage.resourceUri && (options.body.kmsMessage.resourceUri.includes('<KRO>') || options.body.kmsMessage.resourceUri.includes('<KEYURL>'))) {\n          return _promise2.default.resolve(false);\n        }\n\n        if (options.body.kmsMessage.uri && (options.body.kmsMessage.uri.includes('<KRO>') || options.body.kmsMessage.uri.includes('<KEYURL>'))) {\n          return _promise2.default.resolve(false);\n        }\n\n        return _promise2.default.resolve(true);\n      },\n      extract: function extract(options) {\n        return _promise2.default.resolve(options.body);\n      }\n    }, {\n      name: 'decryptKmsMessage',\n      direction: 'inbound',\n      test: function test(ctx, response) {\n        return _promise2.default.resolve((0, _has3.default)(response, 'body.kmsMessage') && (0, _isString3.default)(response.body.kmsMessage));\n      },\n      extract: function extract(response) {\n        return _promise2.default.resolve(response.body);\n      }\n    }, {\n      name: 'decryptErrorResponse',\n      direction: 'inbound',\n      test: function test(ctx, reason) {\n        return _promise2.default.resolve(Boolean(reason.body && reason.body.errorCode === 1900000));\n      },\n      extract: function extract(reason) {\n        return _promise2.default.resolve(reason);\n      }\n    }],\n    transforms: [{\n      name: 'encryptKmsMessage',\n      fn: function fn(ctx, object) {\n        if (!object) {\n          return _promise2.default.resolve();\n        }\n\n        if (!object.kmsMessage) {\n          return _promise2.default.resolve();\n        }\n\n        if ((0, _isString3.default)(object.kmsMessage)) {\n          return _promise2.default.resolve();\n        }\n\n        return ctx.webex.internal.encryption.kms.prepareRequest(object.kmsMessage).then(function (req) {\n          object.kmsMessage = req.wrapped;\n        });\n      }\n    }, {\n      name: 'decryptKmsMessage',\n      fn: function fn(ctx, object) {\n        return ctx.webex.internal.encryption.kms.decryptKmsMessage(object.kmsMessage).then(function (kmsMessage) {\n          object.kmsMessage = kmsMessage;\n        });\n      }\n    }, {\n      name: 'decryptErrorResponse',\n      fn: function fn(ctx, reason) {\n        var promises = reason.body.errors.map(function (error) {\n          return ctx.webex.internal.encryption.kms.decryptKmsMessage(error.description).then(function (desc) {\n            error.description = desc;\n          });\n        });\n        promises.push(ctx.webex.internal.encryption.kms.decryptKmsMessage(reason.body.message).then(function (kmsMessage) {\n          reason.body.message = kmsMessage;\n        }));\n        return _promise2.default.all(promises).then(function () {\n          return _promise2.default.reject(new _kmsErrors.DryError(reason));\n        });\n      }\n    }]\n  },\n  interceptors: interceptors,\n  config: _config2.default\n});","map":{"version":3,"sources":["index.js"],"names":["interceptors","process","KmsDryErrorInterceptor","create","Encryption","payloadTransformer","predicates","name","direction","test","options","extract","response","Boolean","reason","transforms","fn","object","req","promises","error","DryError","config","default","KmsError"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n// Note: There's a bug where if bind gets replayed because of a timeout in which\n// the original request eventually completed, there'll be an error indicating\n// the key can't be bound (because it already has been). This could be mitigated\n// by using Promise.race to resolve replays (as more requests get enqueue for a\n// specific action, accept whichever one completes first).\n\nimport {registerInternalPlugin} from '@webex/webex-core';\nimport {has, isObject, isString} from 'lodash';\n\nimport Encryption from './encryption';\nimport config from './config';\nimport {DryError} from './kms-errors';\nimport '@webex/internal-plugin-device';\nimport '@webex/internal-plugin-mercury';\nimport KmsDryErrorInterceptor from './kms-dry-error-interceptor';\n\nlet interceptors;\n\nif (process.env.NODE_ENV === 'test') {\n  interceptors = {\n    KmsDryErrorInterceptor: KmsDryErrorInterceptor.create\n  };\n}\n\nregisterInternalPlugin('encryption', Encryption, {\n  payloadTransformer: {\n    predicates: [{\n      name: 'encryptKmsMessage',\n      direction: 'outbound',\n      // I don't see any practical way to reduce complexity here.\n      // eslint-disable-next-line complexity\n      test(ctx, options) {\n        if (!has(options, 'body.kmsMessage')) {\n          return Promise.resolve(false);\n        }\n\n        if (!isObject(options.body.kmsMessage)) {\n          return Promise.resolve(false);\n        }\n\n        // If this is a template for a kms message, assume another transform\n        // will fill it in later. This is a bit of a leaky abstraction, but the\n        // alternative is building a complex rules engine for controlling\n        // ordering of transforms\n        if (options.body.kmsMessage.keyUris && options.body.kmsMessage.keyUris.length === 0) {\n          return Promise.resolve(false);\n        }\n        if (options.body.kmsMessage.resourceUri && (options.body.kmsMessage.resourceUri.includes('<KRO>') || options.body.kmsMessage.resourceUri.includes('<KEYURL>'))) {\n          return Promise.resolve(false);\n        }\n        if (options.body.kmsMessage.uri && (options.body.kmsMessage.uri.includes('<KRO>') || options.body.kmsMessage.uri.includes('<KEYURL>'))) {\n          return Promise.resolve(false);\n        }\n\n        return Promise.resolve(true);\n      },\n      extract(options) {\n        return Promise.resolve(options.body);\n      }\n    }, {\n      name: 'decryptKmsMessage',\n      direction: 'inbound',\n      test(ctx, response) {\n        return Promise.resolve(has(response, 'body.kmsMessage') && isString(response.body.kmsMessage));\n      },\n      extract(response) {\n        return Promise.resolve(response.body);\n      }\n    }, {\n      name: 'decryptErrorResponse',\n      direction: 'inbound',\n      test(ctx, reason) {\n        return Promise.resolve(Boolean(reason.body && reason.body.errorCode === 1900000));\n      },\n      extract(reason) {\n        return Promise.resolve(reason);\n      }\n    }],\n    transforms: [{\n      name: 'encryptKmsMessage',\n      fn(ctx, object) {\n        if (!object) {\n          return Promise.resolve();\n        }\n\n        if (!object.kmsMessage) {\n          return Promise.resolve();\n        }\n\n        if (isString(object.kmsMessage)) {\n          return Promise.resolve();\n        }\n\n        return ctx.webex.internal.encryption.kms.prepareRequest(object.kmsMessage)\n          .then((req) => {\n            object.kmsMessage = req.wrapped;\n          });\n      }\n    }, {\n      name: 'decryptKmsMessage',\n      fn(ctx, object) {\n        return ctx.webex.internal.encryption.kms.decryptKmsMessage(object.kmsMessage)\n          .then((kmsMessage) => {\n            object.kmsMessage = kmsMessage;\n          });\n      }\n    }, {\n      name: 'decryptErrorResponse',\n      fn(ctx, reason) {\n        const promises = reason.body.errors.map((error) => ctx.webex.internal.encryption.kms.decryptKmsMessage(error.description)\n          .then((desc) => {\n            error.description = desc;\n          }));\n\n        promises.push(ctx.webex.internal.encryption.kms.decryptKmsMessage(reason.body.message)\n          .then((kmsMessage) => {\n            reason.body.message = kmsMessage;\n          }));\n\n        return Promise.all(promises)\n          .then(() => Promise.reject(new DryError(reason)));\n      }\n    }]\n  },\n  interceptors,\n  config\n});\n\nexport {default} from './encryption';\nexport {default as KMS} from './kms';\nexport {KmsError, DryError} from './kms-errors';\n"]},"metadata":{},"sourceType":"script"}