{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _defineProperty = require('babel-runtime/core-js/reflect/define-property');\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _get2 = require('lodash/get');\n\nvar _get3 = _interopRequireDefault(_get2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * @class\n */\n\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar Interceptor = function () {\n  /**\n   * @constructor\n   * @param {Object} attrs\n   * @returns {UrlInterceptor}\n   */\n  function Interceptor(attrs) {\n    var _this = this;\n\n    (0, _classCallCheck3.default)(this, Interceptor);\n\n    if (attrs) {\n      (0, _keys2.default)(attrs).forEach(function (key) {\n        var value = attrs[key];\n        (0, _defineProperty2.default)(_this, key, {\n          enumerable: true,\n          value: value\n        });\n      });\n    }\n  }\n  /**\n   * Logs the options of a request. This should be utilized\n   * during the intercepting process, but can be used at any\n   * time otherwise.\n   * @param {object} options\n   * @returns {void}\n   */\n\n\n  (0, _createClass3.default)(Interceptor, [{\n    key: 'logOptions',\n    value: function logOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var logger = (0, _get3.default)(this, 'webex.logger', console);\n\n      if (!process.env.ENABLE_VERBOSE_NETWORK_LOGGING || !logger) {\n        return;\n      } // prepend a header for the interceptor\n\n\n      logger.info('/***** Interceptor ****************************************************\\\\');\n      logger.info(this.constructor.name + ' - ' + (0, _stringify2.default)(options, null, 2));\n    }\n    /**\n     * @abstract\n     * @returns {Interceptor}\n     */\n\n  }, {\n    key: 'onRequest',\n\n    /**\n     * Transform request options before sending them\n     * @param {Object} options\n     * @returns {Promise<Object>}\n     */\n    value: function onRequest(options) {\n      return _promise2.default.resolve(options);\n    }\n    /**\n     * Handle request failures\n     * @param {Object} options\n     * @param {Error} reason\n     * @returns {RejectedPromise<Error>}\n     */\n\n  }, {\n    key: 'onRequestError',\n    value: function onRequestError(options, reason) {\n      return _promise2.default.reject(reason);\n    }\n    /**\n     * Transform response before returning it\n     * @param {Object} options\n     * @param {HttpResponse} response\n     * @returns {Promise<HttpResponse>}\n     */\n\n  }, {\n    key: 'onResponse',\n    value: function onResponse(options, response) {\n      return _promise2.default.resolve(response);\n    }\n    /**\n     * Handle response errors\n     * @param {Object} options\n     * @param {WebexHttpError} reason\n     * @returns {Promise<WebexHttpError>}\n     */\n\n  }, {\n    key: 'onResponseError',\n    value: function onResponseError(options, reason) {\n      return _promise2.default.reject(reason);\n    }\n  }], [{\n    key: 'create',\n    value: function create() {\n      throw new Error('`Interceptor.create()` must be defined');\n    }\n  }]);\n  return Interceptor;\n}();\n\nexports.default = Interceptor;","map":{"version":3,"sources":["interceptor.js"],"names":["Interceptor","value","attrs","enumerable","options","logger","process","reason","response"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;;;AANA;;;;;IASqBA,W;AACnB;;;;;AAKA,WAAA,WAAA,CAAA,KAAA,EAAmB;AAAA,QAAA,KAAA,GAAA,IAAA;;AAAA,KAAA,GAAA,gBAAA,CAAA,OAAA,EAAA,IAAA,EAAA,WAAA;;AACjB,QAAA,KAAA,EAAW;AACT,OAAA,GAAA,MAAA,CAAA,OAAA,EAAA,KAAA,EAAA,OAAA,CAA2B,UAAA,GAAA,EAAS;AAClC,YAAMC,KAAAA,GAAQC,KAAAA,CAAd,GAAcA,CAAd;AAEA,SAAA,GAAA,gBAAA,CAAA,OAAA,EAAA,KAAA,EAAA,GAAA,EAAkC;AAChCC,UAAAA,UAAAA,EADgC,IAAA;AAEhCF,UAAAA,KAAAA,EAAAA;AAFgC,SAAlC;AAHF,OAAA;AAQD;AACF;AAED;;;;;;;;;;;iCAOyB;AAAA,UAAdG,OAAc,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI;AACvB,UAAMC,MAAAA,GAAS,CAAA,GAAA,KAAA,CAAA,OAAA,EAAA,IAAA,EAAA,cAAA,EAAf,OAAe,CAAf;;AAEA,UAAI,CAACC,OAAAA,CAAAA,GAAAA,CAAD,8BAAA,IAA+C,CAAnD,MAAA,EAA4D;AAC1D;AACD,OALsB,CAOvB;;;AACAD,MAAAA,MAAAA,CAAAA,IAAAA,CAAAA,2EAAAA;AAEAA,MAAAA,MAAAA,CAAAA,IAAAA,CACK,KAAA,WAAA,CADLA,IACK,GADLA,KACK,GAA2B,CAAA,GAAA,WAAA,CAAA,OAAA,EAAA,OAAA,EAAA,IAAA,EADhCA,CACgC,CADhCA;AAGD;AAED;;;;;;;;AAQA;;;;;8BAKUD,O,EAAS;AACjB,aAAO,SAAA,CAAA,OAAA,CAAA,OAAA,CAAP,OAAO,CAAP;AACD;AAED;;;;;;;;;mCAMeA,O,EAASG,M,EAAQ;AAC9B,aAAO,SAAA,CAAA,OAAA,CAAA,MAAA,CAAP,MAAO,CAAP;AACD;AAED;;;;;;;;;+BAMWH,O,EAASI,Q,EAAU;AAC5B,aAAO,SAAA,CAAA,OAAA,CAAA,OAAA,CAAP,QAAO,CAAP;AACD;AAED;;;;;;;;;oCAMgBJ,O,EAASG,M,EAAQ;AAC/B,aAAO,SAAA,CAAA,OAAA,CAAA,MAAA,CAAP,MAAO,CAAP;AACD;;;6BAzCe;AACd,YAAM,IAAA,KAAA,CAAN,wCAAM,CAAN;AACD;;;;;kBA/CkBP,W","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {get} from 'lodash';\n\n/**\n * @class\n */\nexport default class Interceptor {\n  /**\n   * @constructor\n   * @param {Object} attrs\n   * @returns {UrlInterceptor}\n   */\n  constructor(attrs) {\n    if (attrs) {\n      Object.keys(attrs).forEach((key) => {\n        const value = attrs[key];\n\n        Reflect.defineProperty(this, key, {\n          enumerable: true,\n          value\n        });\n      });\n    }\n  }\n\n  /**\n   * Logs the options of a request. This should be utilized\n   * during the intercepting process, but can be used at any\n   * time otherwise.\n   * @param {object} options\n   * @returns {void}\n   */\n  logOptions(options = {}) {\n    const logger = get(this, 'webex.logger', console);\n\n    if (!process.env.ENABLE_VERBOSE_NETWORK_LOGGING || !logger) {\n      return;\n    }\n\n    // prepend a header for the interceptor\n    logger.info('/***** Interceptor ****************************************************\\\\');\n\n    logger.info(\n      `${this.constructor.name} - ${JSON.stringify(options, null, 2)}`\n    );\n  }\n\n  /**\n   * @abstract\n   * @returns {Interceptor}\n   */\n  static create() {\n    throw new Error('`Interceptor.create()` must be defined');\n  }\n\n  /**\n   * Transform request options before sending them\n   * @param {Object} options\n   * @returns {Promise<Object>}\n   */\n  onRequest(options) {\n    return Promise.resolve(options);\n  }\n\n  /**\n   * Handle request failures\n   * @param {Object} options\n   * @param {Error} reason\n   * @returns {RejectedPromise<Error>}\n   */\n  onRequestError(options, reason) {\n    return Promise.reject(reason);\n  }\n\n  /**\n   * Transform response before returning it\n   * @param {Object} options\n   * @param {HttpResponse} response\n   * @returns {Promise<HttpResponse>}\n   */\n  onResponse(options, response) {\n    return Promise.resolve(response);\n  }\n\n  /**\n   * Handle response errors\n   * @param {Object} options\n   * @param {WebexHttpError} reason\n   * @returns {Promise<WebexHttpError>}\n   */\n  onResponseError(options, reason) {\n    return Promise.reject(reason);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}