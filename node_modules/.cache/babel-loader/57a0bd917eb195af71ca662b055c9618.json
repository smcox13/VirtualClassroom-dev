{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _javascriptStateMachine = require('javascript-state-machine');\n\nvar _javascriptStateMachine2 = _interopRequireDefault(_javascriptStateMachine);\n\nvar _history = require('javascript-state-machine/lib/history');\n\nvar _history2 = _interopRequireDefault(_history);\n\nvar _loggerProxy = require('../common/logs/logger-proxy');\n\nvar _loggerProxy2 = _interopRequireDefault(_loggerProxy);\n\nvar _media = require('../media');\n\nvar _media2 = _interopRequireDefault(_media);\n\nvar _util = require('../meeting/util');\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _constants = require('../constants');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar handleTransition = function handleTransition(video) {\n  if (video.mute && video.self) {\n    return _constants.MEETING_VIDEO_STATE_MACHINE.STATES.MUTE_SELF;\n  }\n\n  if (!video.mute && video.self) {\n    return _constants.MEETING_VIDEO_STATE_MACHINE.STATES.UNMUTE_SELF;\n  }\n\n  return null;\n};\n\nvar doToggle = function doToggle(transition, video, meeting) {\n  _media2.default.setLocalTrack(video.mute, meeting.mediaProperties.videoTrack);\n\n  var meetingAudio = meeting.audio;\n  var audioMuted = meetingAudio ? meetingAudio.muted : true;\n  return _util2.default.remoteUpdateAudioVideo(audioMuted, video.mute, meeting).then(function () {\n    _loggerProxy2.default.logger.log('VideoStateMachine->onAfterToggle#' + transition.event + ' fired! State changed from \\'' + transition.from + '\\' to \\'' + transition.to + '\\' with transition \\'' + transition.transition + '\\'\\'.');\n  }).catch(function (remoteUpdateError) {\n    _loggerProxy2.default.logger.log('VideoStateMachine->onBeforeToggle#' + transition.event + ' fired! State failed to change with transition \\'' + transition.transition + '\\'\\'. After local Video toggle failed, resetting remote also failed, meeting video in bad state with error: ' + remoteUpdateError + '.');\n\n    return _promise2.default.reject(remoteUpdateError);\n  });\n};\n\nvar VideoStateMachine = {\n  /**\n   *\n   * @param {Object} mediaDirection object containing media direction\n   * @param {Boolean} mediaDirection.sendVideo Whether or not to send video in the meeting\n   * @param {Meeting} meeting an instance of a Meeting\n   * @returns {Statemachine} returns a state machine instance\n   */\n  create: function create(mediaDirection, meeting) {\n    if (!mediaDirection.sendVideo) {\n      return undefined;\n    }\n\n    return new _javascriptStateMachine2.default({\n      transitions: [{\n        name: _constants.MEETING_VIDEO_STATE_MACHINE.TRANSITIONS.TOGGLE,\n        from: '*',\n\n        /**\n         *\n         * @param {Object} video current video data for the transition {mute, self}\n         * @returns {String} a new state value for the transition\n         */\n        to: function to(video) {\n          return handleTransition(video) || this.state;\n        }\n      }],\n      data: {\n        muted: false,\n        self: true\n      },\n      methods: {\n        /**\n         * Convenience function to tell whether we are muted or not\n         * @returns {Boolen} boolean that indicates whether the video is currently muted\n         */\n        isMuted: function isMuted() {\n          return this.muted;\n        },\n\n        /**\n         * Convenience function to tell who last muted/unmuted the video\n         * @returns {Boolen} boolean that indicates whether the video was muted by the end user or server\n         */\n        isSelf: function isSelf() {\n          return this.self;\n        },\n\n        /**\n         *\n         * @param {Object} video current video options to set on the state machine\n         * @param {Boolean} video.mute indicates if video is muted or not for a meeting\n         * @param {Boolean} video.self indicates whether the end user or server muted the video\n         * @returns {null}\n         */\n        setData: function setData(video) {\n          this.muted = video.mute;\n          this.self = video.self;\n        },\n\n        /**\n         * Method that gets fired before the toggle state change.\n         * If this fails, return false will cancel the transition and the state will remain unchanged\n          * @param {Object} transition the StateMachine transition object\n         * @param {Object} video video options\n         * @returns {Object} this.data which contains {muted, self}\n         */\n        onBeforeToggle: function onBeforeToggle(transition, video) {\n          var _this = this;\n\n          if (transition.from !== transition.to) {\n            return doToggle(transition, video, meeting).then(function () {\n              return _promise2.default.resolve(_this.data);\n            });\n          }\n\n          return _promise2.default.resolve(this.data);\n        },\n\n        /**\n         *\n         * @param {Object} transition StateMachine transition\n         * @param {Object} video video options\n         * @returns {Object} this.data which contains {muted, self}\n         */\n        onAfterToggle: function onAfterToggle(transition, video) {\n          this.setData(video);\n          return _promise2.default.resolve(this.data);\n        },\n        plugins: [new _history2.default({\n          max: 5\n        })]\n      }\n    });\n  }\n};\nexports.default = VideoStateMachine;","map":{"version":3,"sources":["video.js"],"names":["handleTransition","video","MEETING_VIDEO_STATE_MACHINE","doToggle","Media","meeting","meetingAudio","audioMuted","LoggerProxy","transition","VideoStateMachine","create","mediaDirection","StateMachine","transitions","name","from","to","data","muted","self","methods","isMuted","isSelf","setData","onBeforeToggle","onAfterToggle","plugins","StateMachineHistory","max"],"mappings":"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","sourcesContent":["import StateMachine from 'javascript-state-machine';\nimport StateMachineHistory from 'javascript-state-machine/lib/history';\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport Media from '../media';\nimport MeetingUtil from '../meeting/util';\nimport {MEETING_VIDEO_STATE_MACHINE} from '../constants';\n\nconst handleTransition = (video) => {\n  if (video.mute && video.self) {\n    return MEETING_VIDEO_STATE_MACHINE.STATES.MUTE_SELF;\n  }\n  if (!video.mute && video.self) {\n    return MEETING_VIDEO_STATE_MACHINE.STATES.UNMUTE_SELF;\n  }\n\n  return null;\n};\n\nconst doToggle = (transition, video, meeting) => {\n  Media.setLocalTrack(video.mute, meeting.mediaProperties.videoTrack);\n  const meetingAudio = meeting.audio;\n  const audioMuted = meetingAudio ? meetingAudio.muted : true;\n\n  return MeetingUtil.remoteUpdateAudioVideo(audioMuted, video.mute, meeting)\n    .then(() => {\n      LoggerProxy.logger.log(\n        `VideoStateMachine->onAfterToggle#${transition.event} fired! State changed from '${transition.from}' to '${\n          transition.to\n        }' with transition '${transition.transition}''.`\n      );\n    })\n    .catch((remoteUpdateError) => {\n      LoggerProxy.logger.log(\n        `VideoStateMachine->onBeforeToggle#${transition.event} fired! State failed to change with transition '${\n          transition.transition\n        }''. After local Video toggle failed, resetting remote also failed, meeting video in bad state with error: ${remoteUpdateError}.`\n      );\n\n      return Promise.reject(remoteUpdateError);\n    });\n};\n\nconst VideoStateMachine = {\n  /**\n   *\n   * @param {Object} mediaDirection object containing media direction\n   * @param {Boolean} mediaDirection.sendVideo Whether or not to send video in the meeting\n   * @param {Meeting} meeting an instance of a Meeting\n   * @returns {Statemachine} returns a state machine instance\n   */\n  create(mediaDirection, meeting) {\n    if (!mediaDirection.sendVideo) {\n      return undefined;\n    }\n\n    return new StateMachine({\n      transitions: [\n        {\n          name: MEETING_VIDEO_STATE_MACHINE.TRANSITIONS.TOGGLE,\n          from: '*',\n          /**\n           *\n           * @param {Object} video current video data for the transition {mute, self}\n           * @returns {String} a new state value for the transition\n           */\n          to(video) {\n            return handleTransition(video) || this.state;\n          }\n        }\n      ],\n      data: {\n        muted: false,\n        self: true\n      },\n      methods: {\n        /**\n         * Convenience function to tell whether we are muted or not\n         * @returns {Boolen} boolean that indicates whether the video is currently muted\n         */\n        isMuted() {\n          return this.muted;\n        },\n        /**\n         * Convenience function to tell who last muted/unmuted the video\n         * @returns {Boolen} boolean that indicates whether the video was muted by the end user or server\n         */\n        isSelf() {\n          return this.self;\n        },\n\n        /**\n         *\n         * @param {Object} video current video options to set on the state machine\n         * @param {Boolean} video.mute indicates if video is muted or not for a meeting\n         * @param {Boolean} video.self indicates whether the end user or server muted the video\n         * @returns {null}\n         */\n        setData(video) {\n          this.muted = video.mute;\n          this.self = video.self;\n        },\n\n        /**\n         * Method that gets fired before the toggle state change.\n         * If this fails, return false will cancel the transition and the state will remain unchanged\n\n         * @param {Object} transition the StateMachine transition object\n         * @param {Object} video video options\n         * @returns {Object} this.data which contains {muted, self}\n         */\n        onBeforeToggle(transition, video) {\n          if (transition.from !== transition.to) {\n            return doToggle(transition, video, meeting)\n              .then(() => Promise.resolve(this.data));\n          }\n\n          return Promise.resolve(this.data);\n        },\n\n        /**\n         *\n         * @param {Object} transition StateMachine transition\n         * @param {Object} video video options\n         * @returns {Object} this.data which contains {muted, self}\n         */\n        onAfterToggle(transition, video) {\n          this.setData(video);\n\n          return Promise.resolve(this.data);\n        },\n        plugins: [new StateMachineHistory({max: 5})]\n      }\n    });\n  }\n};\n\nexport default VideoStateMachine;\n"]},"metadata":{},"sourceType":"script"}