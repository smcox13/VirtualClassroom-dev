{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _isArray2 = require('lodash/isArray');\n\nvar _isArray3 = _interopRequireDefault(_isArray2);\n\nvar _dec, _dec2, _dec3, _dec4, _desc, _value, _obj;\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar _common = require('@webex/common');\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _userUuidBatcher = require('./user-uuid-batcher');\n\nvar _userUuidBatcher2 = _interopRequireDefault(_userUuidBatcher);\n\nvar _userUuidStore = require('./user-uuid-store');\n\nvar _userUuidStore2 = _interopRequireDefault(_userUuidStore);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n/**\n * @class\n */\n\n\nvar User = _webexCore.WebexPlugin.extend((_dec = (0, _webexCore.waitForValue)('@'), _dec2 = (0, _common.oneFlight)({\n  keyFactory: function keyFactory(email, options) {\n    return email + String(options && options.create);\n  }\n}), _dec3 = (0, _webexCore.persist)('@'), _dec4 = (0, _common.deprecated)('Use User#verify()'), (_obj = {\n  namespace: 'User',\n  children: {\n    batcher: _userUuidBatcher2.default\n  },\n  props: {\n    /**\n     * Indicates if the current user is known to have a password.\n     * @instance\n     * @memberof User\n     * @type {boolean}\n     */\n    hasPassword: {\n      default: false,\n      type: 'boolean'\n    }\n  },\n  session: {\n    store: {\n      default: function _default() {\n        return new _userUuidStore2.default();\n      },\n      type: 'any'\n    }\n  },\n\n  /**\n   * Activates a Webex user account and exchanges for user token.\n   * @instance\n   * @memberof User\n   * @param {Object} options\n   * @param {Object} options.confirmationCode (required -- optional if verification token is provided)\n   * @param {Object} options.id (required -- optional if verification token is provided)\n   * @param {Object} options.verificationToken (required -- optional if uuid and verification token provided)\n   * @param {Object} options.email (required with verificationToken for Federation/global user)\n   * @returns {Promise} Resolves with a userSession\n   */\n  activate: function activate() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!(options.verificationToken || options.confirmationCode && options.id)) {\n      return _promise2.default.reject(new Error('either options.verificationToken is required or both options.confirmationCode and options.id are required'));\n    }\n\n    options.scope = this.webex.config.credentials.scope; // if we have options.email and options.verificationToken\n    // and Federation flag is enabled, flag that we need to\n    // lookup user's CI.\n\n    var activateOptions = (0, _assign2.default)({}, options);\n    delete activateOptions.email;\n    return this.request({\n      uri: this.webex.config.credentials.activationUrl,\n      method: 'POST',\n      body: activateOptions,\n      auth: {\n        user: this.webex.config.credentials.client_id,\n        pass: this.webex.config.credentials.client_secret,\n        sendImmediately: true\n      }\n    }).then(function (res) {\n      _this.webex.credentials.set({\n        supertoken: res.body.tokenData\n      });\n\n      return res.body;\n    });\n  },\n\n  /**\n   * Converts a user-identifying object to a uuid, perhaps by doing a network\n   * lookup\n   * @param {string|Object} user\n   * @param {Object} options\n   * @param {boolean} options.create if true, ensures the return UUID refers to\n   * an existing user (rather than creating one deterministically based on email\n   * address), even if that user must be created\n   * @returns {Promise<string>}\n   */\n  asUUID: function asUUID(user, options) {\n    var _this2 = this;\n\n    if (!user) {\n      return _promise2.default.reject(new Error('`user` is required'));\n    }\n\n    if ((0, _isArray3.default)(user)) {\n      return _promise2.default.all(user.map(function (u) {\n        return _this2.asUUID(u, options);\n      }));\n    }\n\n    var id = this._extractUUID(user);\n\n    if (!(options && options.force) && _common.patterns.uuid.test(id)) {\n      return _promise2.default.resolve(id);\n    }\n\n    var email = this._extractEmailAddress(user);\n\n    if (!_common.patterns.email.test(email)) {\n      return _promise2.default.reject(new Error('Provided user object does not appear to identify a user'));\n    }\n\n    return this.getUUID(email, options);\n  },\n\n  /**\n   * Requests a uuid from the api\n   * @param {string} email\n   * @param {Object} options\n   * @param {boolean} options.create\n   * @returns {Promise<string>}\n   */\n  fetchUUID: function fetchUUID(email, options) {\n    var _this3 = this;\n\n    return this.batcher.request({\n      email: email,\n      create: options && options.create\n    }).then(function (user) {\n      return _this3.recordUUID((0, _assign2.default)({\n        emailAddress: email\n      }, user)).then(function () {\n        return user.id;\n      });\n    });\n  },\n\n  /**\n   * Fetches details about the current user\n   * @returns {Promise<Object>}\n   */\n  get: function get() {\n    var _this4 = this;\n\n    return this.request({\n      service: 'conversation',\n      resource: 'users'\n    }).then(function (res) {\n      return res.body;\n    }).then((0, _common.tap)(function (user) {\n      return _this4.recordUUID({\n        id: user.id,\n        // CI endpoints don't use the same user format as actors, so, email may\n        // be in one of a few fields\n        emailAddress: user.email || user.emailAddress\n      });\n    }));\n  },\n  getUUID: function getUUID(email, options) {\n    var _this5 = this;\n\n    return this.store.getByEmail(email).then(function (user) {\n      if (options && options.create && !user.userExists) {\n        return _promise2.default.reject(new Error('User for specified email cannot be confirmed to exist'));\n      }\n\n      if (!user.id) {\n        return _promise2.default.reject(new Error('No id recorded for specified user'));\n      }\n\n      return user.id;\n    }).catch(function () {\n      return _this5.fetchUUID(email, options);\n    });\n  },\n  initialize: function initialize() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return (0, _apply2.default)(_webexCore.WebexPlugin.prototype.initialize, this, args);\n  },\n\n  /**\n   * Caches the uuid for the specified email address\n   * @param {Object} user\n   * @param {string} user.id\n   * @param {string} user.emailAddress\n   * @returns {Promise}\n   */\n  recordUUID: function recordUUID(user) {\n    if (!user) {\n      return _promise2.default.reject(new Error('`user` is required'));\n    }\n\n    if (!user.id) {\n      return _promise2.default.reject(new Error('`user.id` is required'));\n    }\n\n    if (!_common.patterns.uuid.test(user.id)) {\n      return _promise2.default.reject(new Error('`user.id` must be a uuid'));\n    }\n\n    if (!user.emailAddress) {\n      return _promise2.default.reject(new Error('`user.emailAddress` is required'));\n    }\n\n    if (!_common.patterns.email.test(user.emailAddress)) {\n      return _promise2.default.reject(new Error('`user.emailAddress` must be an email address'));\n    }\n\n    return this.store.add(user);\n  },\n  register: function register() {\n    return this.verify.apply(this, arguments);\n  },\n\n  /**\n   * Updates a user's password with webex.\n   * @instance\n   * @memberof User\n   * @param {Object} options\n   * @param {string} options.password (required)\n   * @param {string} options.email (required when federation enabled)\n   * @returns {Promise} Resolves with complete user object containing new password\n   */\n  setPassword: function setPassword(options) {\n    var _this6 = this;\n\n    options = options || {};\n\n    if (!options.password) {\n      return _promise2.default.reject(new Error('`options.password` is required'));\n    }\n\n    return this.webex.credentials.getUserToken().then(function (token) {\n      return _this6.request({\n        uri: _this6.webex.config.credentials.setPasswordUrl + '/' + _this6.webex.internal.device.userId,\n        method: 'PATCH',\n        headers: {\n          authorization: token.toString()\n        },\n        body: {\n          schemas: ['urn:scim:schemas:core:1.0', 'urn:scim:schemas:extension:cisco:commonidentity:1.0'],\n          password: options.password\n        }\n      });\n    }).then(function (res) {\n      _this6.hasPassword = true;\n      return res.body;\n    });\n  },\n\n  /**\n   * Updates the current user's display name\n   * @param {Object} options\n   * @param {string} options.displayName\n   * @returns {Promise<Object>}\n   */\n  update: function update(options) {\n    options = options || {};\n\n    if (!options.displayName) {\n      return _promise2.default.reject(new Error('`options.displayName` is required'));\n    }\n\n    return this.request({\n      method: 'PATCH',\n      service: 'conversation',\n      resource: 'users/user',\n      body: options\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n\n  /**\n   * Determines if the specified user needs to signup or can signin.\n   * Triggers activation email if client credentials are used\n   * @param {Object} options\n   * @param {string} options.email (required)\n   * @param {string} options.reqId required if need to check email status\n   * @param {string} options.preloginId\n   * @returns {Promise<Object>}\n   */\n  verify: function verify(options) {\n    var _this7 = this;\n\n    options = (0, _assign2.default)({}, this.config.verifyDefaults, options);\n    var _options = options,\n        email = _options.email;\n\n    if (!email) {\n      return _promise2.default.reject(new Error('`options.email` is required'));\n    }\n\n    return this.webex.internal.services.collectPreauthCatalog({\n      email: email\n    }).then(function () {\n      return _this7.webex.credentials.getUserToken();\n    }).catch(function () {\n      return _this7.webex.credentials.getClientToken();\n    }).then(function (token) {\n      return _this7.request({\n        service: 'atlas',\n        resource: 'users/activations',\n        method: 'POST',\n        headers: {\n          authorization: token.toString(),\n          'x-prelogin-userid': options.preloginId\n        },\n        body: options,\n        shouldRefreshAccessToken: false\n      });\n    }).then(function (res) {\n      if (res.body.hasPassword || res.body.sso) {\n        _this7.hasPassword = true;\n      }\n\n      return res.body;\n    });\n  },\n\n  /**\n   * If the passed-in lookupCI is true, retrieve the user's\n   * CI from Atlas and return the URL's via a Promise.\n   * Otherwise, return current CI in config via a Promise.\n   * Useful in a Promise chain to retrieve the CI based on\n   * conditions like Federation enabled, and suppresses sending\n   * an additional email to the user, since this is just a\n   * look-up.\n   * @param {string} email (required)\n   * @param {boolean} lookupCI (required)\n   * @returns {Promise<Object>}\n   */\n  getUserCI: function getUserCI(email, lookupCI) {\n    if (lookupCI) {\n      // call verify first to get the user's CI, but suppress sending another email\n      var verifyOptions = {\n        email: email,\n        suppressEmail: true\n      };\n      return this.verify(verifyOptions).then(function (res) {\n        return _promise2.default.resolve(res.userEntities);\n      });\n    }\n\n    return _promise2.default.resolve({\n      idBrokerUrl: this.webex.config.credentials.idbroker.url,\n      identityUrl: this.webex.config.credentials.identity.url\n    });\n  },\n\n  /**\n   * Extracts the uuid from a user identifying object\n   * @param {string|Object} user\n   * @private\n   * @returns {string}\n   */\n  _extractUUID: function _extractUUID(user) {\n    return user.entryUUID || user.id || user;\n  },\n\n  /**\n   * Extracts the email address from a user identifying object\n   * @param {string|Object} user\n   * @private\n   * @returns {string}\n   */\n  _extractEmailAddress: function _extractEmailAddress(user) {\n    return user.email || user.emailAddress || user.entryEmail || user;\n  },\n  version: '1.80.172'\n}, (_applyDecoratedDescriptor(_obj, 'activate', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'activate'), _obj), _applyDecoratedDescriptor(_obj, 'getUUID', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'getUUID'), _obj), _applyDecoratedDescriptor(_obj, 'initialize', [_dec3], (0, _getOwnPropertyDescriptor2.default)(_obj, 'initialize'), _obj), _applyDecoratedDescriptor(_obj, 'register', [_dec4], (0, _getOwnPropertyDescriptor2.default)(_obj, 'register'), _obj)), _obj)));\n\nexports.default = User;","map":{"version":3,"sources":["user.js"],"names":["User","namespace","children","batcher","UserUUIDBatcher","props","hasPassword","default","type","session","store","UserUUIDStore","activate","options","activateOptions","uri","method","body","auth","user","pass","sendImmediately","supertoken","res","asUUID","id","patterns","email","fetchUUID","create","emailAddress","get","service","resource","keyFactory","String","getUUID","initialize","args","WebexPlugin","recordUUID","register","setPassword","headers","authorization","token","schemas","password","update","verify","preloginId","shouldRefreshAccessToken","getUserCI","verifyOptions","suppressEmail","idBrokerUrl","identityUrl","url","_extractUUID","_extractEmailAddress"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {isArray} from 'lodash';\nimport {deprecated, oneFlight, patterns, tap} from '@webex/common';\nimport {persist, WebexPlugin, waitForValue} from '@webex/webex-core';\n\nimport UserUUIDBatcher from './user-uuid-batcher';\nimport UserUUIDStore from './user-uuid-store';\n\n/**\n * @class\n */\nconst User = WebexPlugin.extend({\n  namespace: 'User',\n\n  children: {\n    batcher: UserUUIDBatcher\n  },\n\n  props: {\n    /**\n     * Indicates if the current user is known to have a password.\n     * @instance\n     * @memberof User\n     * @type {boolean}\n     */\n    hasPassword: {\n      default: false,\n      type: 'boolean'\n    }\n  },\n\n  session: {\n    store: {\n      default() {\n        return new UserUUIDStore();\n      },\n      type: 'any'\n    }\n  },\n\n  @waitForValue('@')\n  /**\n   * Activates a Webex user account and exchanges for user token.\n   * @instance\n   * @memberof User\n   * @param {Object} options\n   * @param {Object} options.confirmationCode (required -- optional if verification token is provided)\n   * @param {Object} options.id (required -- optional if verification token is provided)\n   * @param {Object} options.verificationToken (required -- optional if uuid and verification token provided)\n   * @param {Object} options.email (required with verificationToken for Federation/global user)\n   * @returns {Promise} Resolves with a userSession\n   */\n  activate(options = {}) {\n    if (!(options.verificationToken || (options.confirmationCode && options.id))) {\n      return Promise.reject(new Error('either options.verificationToken is required or both options.confirmationCode and options.id are required'));\n    }\n\n    options.scope = this.webex.config.credentials.scope;\n\n    // if we have options.email and options.verificationToken\n    // and Federation flag is enabled, flag that we need to\n    // lookup user's CI.\n    const activateOptions = Object.assign({}, options);\n\n    delete activateOptions.email;\n\n    return this.request({\n      uri: this.webex.config.credentials.activationUrl,\n      method: 'POST',\n      body: activateOptions,\n      auth: {\n        user: this.webex.config.credentials.client_id,\n        pass: this.webex.config.credentials.client_secret,\n        sendImmediately: true\n      }\n    })\n      .then((res) => {\n        this.webex.credentials.set({supertoken: res.body.tokenData});\n\n        return res.body;\n      });\n  },\n\n  /**\n   * Converts a user-identifying object to a uuid, perhaps by doing a network\n   * lookup\n   * @param {string|Object} user\n   * @param {Object} options\n   * @param {boolean} options.create if true, ensures the return UUID refers to\n   * an existing user (rather than creating one deterministically based on email\n   * address), even if that user must be created\n   * @returns {Promise<string>}\n   */\n  asUUID(user, options) {\n    if (!user) {\n      return Promise.reject(new Error('`user` is required'));\n    }\n\n    if (isArray(user)) {\n      return Promise.all(user.map((u) => this.asUUID(u, options)));\n    }\n\n    const id = this._extractUUID(user);\n\n    if (!(options && options.force) && patterns.uuid.test(id)) {\n      return Promise.resolve(id);\n    }\n\n    const email = this._extractEmailAddress(user);\n\n    if (!patterns.email.test(email)) {\n      return Promise.reject(new Error('Provided user object does not appear to identify a user'));\n    }\n\n    return this.getUUID(email, options);\n  },\n\n  /**\n   * Requests a uuid from the api\n   * @param {string} email\n   * @param {Object} options\n   * @param {boolean} options.create\n   * @returns {Promise<string>}\n   */\n  fetchUUID(email, options) {\n    return this.batcher.request({\n      email,\n      create: options && options.create\n    })\n      .then((user) => this.recordUUID(Object.assign({emailAddress: email}, user))\n        .then(() => user.id));\n  },\n\n  /**\n   * Fetches details about the current user\n   * @returns {Promise<Object>}\n   */\n  get() {\n    return this.request({\n      service: 'conversation',\n      resource: 'users'\n    })\n      .then((res) => res.body)\n      .then(tap((user) => this.recordUUID({\n        id: user.id,\n        // CI endpoints don't use the same user format as actors, so, email may\n        // be in one of a few fields\n        emailAddress: user.email || user.emailAddress\n      })));\n  },\n\n  /**\n   * Converts an email address to a uuid, perhaps by doing a network lookup\n   * @param {string} email\n   * @param {Object} options\n   * @param {boolean} options.create\n   * @returns {Promise<string>}\n   */\n  @oneFlight({keyFactory: (email, options) => email + String(options && options.create)})\n  getUUID(email, options) {\n    return this.store.getByEmail(email)\n      .then((user) => {\n        if (options && options.create && !user.userExists) {\n          return Promise.reject(new Error('User for specified email cannot be confirmed to exist'));\n        }\n\n        if (!user.id) {\n          return Promise.reject(new Error('No id recorded for specified user'));\n        }\n\n        return user.id;\n      })\n      .catch(() => this.fetchUUID(email, options));\n  },\n\n  @persist('@')\n  initialize(...args) {\n    return Reflect.apply(WebexPlugin.prototype.initialize, this, args);\n  },\n\n  /**\n   * Caches the uuid for the specified email address\n   * @param {Object} user\n   * @param {string} user.id\n   * @param {string} user.emailAddress\n   * @returns {Promise}\n   */\n  recordUUID(user) {\n    if (!user) {\n      return Promise.reject(new Error('`user` is required'));\n    }\n\n    if (!user.id) {\n      return Promise.reject(new Error('`user.id` is required'));\n    }\n\n    if (!patterns.uuid.test(user.id)) {\n      return Promise.reject(new Error('`user.id` must be a uuid'));\n    }\n\n    if (!user.emailAddress) {\n      return Promise.reject(new Error('`user.emailAddress` is required'));\n    }\n\n    if (!patterns.email.test(user.emailAddress)) {\n      return Promise.reject(new Error('`user.emailAddress` must be an email address'));\n    }\n\n    return this.store.add(user);\n  },\n\n  @deprecated('Use User#verify()')\n  register(...args) {\n    return this.verify(...args);\n  },\n\n  /**\n   * Updates a user's password with webex.\n   * @instance\n   * @memberof User\n   * @param {Object} options\n   * @param {string} options.password (required)\n   * @param {string} options.email (required when federation enabled)\n   * @returns {Promise} Resolves with complete user object containing new password\n   */\n  setPassword(options) {\n    options = options || {};\n    if (!options.password) {\n      return Promise.reject(new Error('`options.password` is required'));\n    }\n\n    return this.webex.credentials.getUserToken()\n      .then((token) => this.request({\n        uri: `${this.webex.config.credentials.setPasswordUrl}/${this.webex.internal.device.userId}`,\n        method: 'PATCH',\n        headers: {\n          authorization: token.toString()\n        },\n        body: {\n          schemas: ['urn:scim:schemas:core:1.0', 'urn:scim:schemas:extension:cisco:commonidentity:1.0'],\n          password: options.password\n        }\n      }))\n      .then((res) => {\n        this.hasPassword = true;\n\n        return res.body;\n      });\n  },\n\n  /**\n   * Updates the current user's display name\n   * @param {Object} options\n   * @param {string} options.displayName\n   * @returns {Promise<Object>}\n   */\n  update(options) {\n    options = options || {};\n    if (!options.displayName) {\n      return Promise.reject(new Error('`options.displayName` is required'));\n    }\n\n    return this.request({\n      method: 'PATCH',\n      service: 'conversation',\n      resource: 'users/user',\n      body: options\n    })\n      .then((res) => res.body);\n  },\n\n  /**\n   * Determines if the specified user needs to signup or can signin.\n   * Triggers activation email if client credentials are used\n   * @param {Object} options\n   * @param {string} options.email (required)\n   * @param {string} options.reqId required if need to check email status\n   * @param {string} options.preloginId\n   * @returns {Promise<Object>}\n   */\n  verify(options) {\n    options = Object.assign({}, this.config.verifyDefaults, options);\n    const {email} = options;\n\n    if (!email) {\n      return Promise.reject(new Error('`options.email` is required'));\n    }\n\n    return this.webex.internal.services.collectPreauthCatalog({email})\n      .then(() => this.webex.credentials.getUserToken())\n      .catch(() => this.webex.credentials.getClientToken())\n      .then((token) => this.request({\n        service: 'atlas',\n        resource: 'users/activations',\n        method: 'POST',\n        headers: {\n          authorization: token.toString(),\n          'x-prelogin-userid': options.preloginId\n        },\n        body: options,\n        shouldRefreshAccessToken: false\n      }))\n      .then((res) => {\n        if (res.body.hasPassword || res.body.sso) {\n          this.hasPassword = true;\n        }\n\n        return res.body;\n      });\n  },\n\n\n  /**\n   * If the passed-in lookupCI is true, retrieve the user's\n   * CI from Atlas and return the URL's via a Promise.\n   * Otherwise, return current CI in config via a Promise.\n   * Useful in a Promise chain to retrieve the CI based on\n   * conditions like Federation enabled, and suppresses sending\n   * an additional email to the user, since this is just a\n   * look-up.\n   * @param {string} email (required)\n   * @param {boolean} lookupCI (required)\n   * @returns {Promise<Object>}\n   */\n  getUserCI(email, lookupCI) {\n    if (lookupCI) {\n      // call verify first to get the user's CI, but suppress sending another email\n      const verifyOptions = {\n        email,\n        suppressEmail: true\n      };\n\n      return this.verify(verifyOptions).then((res) => Promise.resolve(res.userEntities));\n    }\n\n    return Promise.resolve(\n      {\n        idBrokerUrl: this.webex.config.credentials.idbroker.url,\n        identityUrl: this.webex.config.credentials.identity.url\n      }\n    );\n  },\n\n  /**\n   * Extracts the uuid from a user identifying object\n   * @param {string|Object} user\n   * @private\n   * @returns {string}\n   */\n  _extractUUID(user) {\n    return user.entryUUID || user.id || user;\n  },\n\n  /**\n   * Extracts the email address from a user identifying object\n   * @param {string|Object} user\n   * @private\n   * @returns {string}\n   */\n  _extractEmailAddress(user) {\n    return user.email || user.emailAddress || user.entryEmail || user;\n  }\n\n});\n\nexport default User;\n"]},"metadata":{},"sourceType":"script"}