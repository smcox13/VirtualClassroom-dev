{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromBER = fromBER;\nexports.compareSchema = compareSchema;\nexports.verifySchema = verifySchema;\nexports.fromJSON = fromJSON;\nexports.RawData = exports.Repeated = exports.Any = exports.Choice = exports.TIME = exports.Duration = exports.DateTime = exports.TimeOfDay = exports.DATE = exports.GeneralizedTime = exports.UTCTime = exports.CharacterString = exports.GeneralString = exports.VisibleString = exports.GraphicString = exports.IA5String = exports.VideotexString = exports.TeletexString = exports.PrintableString = exports.NumericString = exports.UniversalString = exports.BmpString = exports.RelativeObjectIdentifier = exports.Utf8String = exports.ObjectIdentifier = exports.Enumerated = exports.Integer = exports.BitString = exports.OctetString = exports.Null = exports.Set = exports.Sequence = exports.Boolean = exports.EndOfContent = exports.Constructed = exports.Primitive = exports.BaseBlock = exports.ValueBlock = exports.HexBlock = void 0;\n\nvar _pvutils = require(\"pvutils\");\n/* eslint-disable indent */\n\n/*\r\n * Copyright (c) 2016-2018, Peculiar Ventures\r\n * All rights reserved.\r\n *\r\n * Author 2016-2018, Yury Strozhevsky <www.strozhevsky.com>.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n * 3. Neither the name of the copyright holder nor the names of its contributors\r\n *    may be used to endorse or promote products derived from this software without\r\n *    specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\r\n * OF SUCH DAMAGE.\r\n *\r\n */\n//**************************************************************************************\n//**************************************************************************************\n//region Declaration of global variables\n//**************************************************************************************\n\n\nconst powers2 = [new Uint8Array([1])];\nconst digitsString = \"0123456789\"; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration for \"LocalBaseBlock\" class\n//**************************************************************************************\n\n/**\r\n * Class used as a base block for all remaining ASN.1 classes\r\n * @typedef LocalBaseBlock\r\n * @interface\r\n * @property {number} blockLength\r\n * @property {string} error\r\n * @property {Array.<string>} warnings\r\n * @property {ArrayBuffer} valueBeforeDecode\r\n */\n\nclass LocalBaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalBaseBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueBeforeDecode]\r\n   */\n  constructor(parameters = {}) {\n    /**\r\n     * @type {number} blockLength\r\n     */\n    this.blockLength = (0, _pvutils.getParametersValue)(parameters, \"blockLength\", 0);\n    /**\r\n     * @type {string} error\r\n     */\n\n    this.error = (0, _pvutils.getParametersValue)(parameters, \"error\", \"\");\n    /**\r\n     * @type {Array.<string>} warnings\r\n     */\n\n    this.warnings = (0, _pvutils.getParametersValue)(parameters, \"warnings\", []); //noinspection JSCheckFunctionSignatures\n\n    /**\r\n     * @type {ArrayBuffer} valueBeforeDecode\r\n     */\n\n    if (\"valueBeforeDecode\" in parameters) this.valueBeforeDecode = parameters.valueBeforeDecode.slice(0);else this.valueBeforeDecode = new ArrayBuffer(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"baseBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    return {\n      blockName: this.constructor.blockName(),\n      blockLength: this.blockLength,\n      error: this.error,\n      warnings: this.warnings,\n      valueBeforeDecode: (0, _pvutils.bufferToHexCodes)(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength)\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Description for \"HexBlock\" class\n//**************************************************************************************\n\n/**\r\n * Class used as a base block for all remaining ASN.1 classes\r\n * @extends LocalBaseBlock\r\n * @typedef HexBlock\r\n * @property {number} blockLength\r\n * @property {string} error\r\n * @property {Array.<string>} warnings\r\n * @property {ArrayBuffer} valueBeforeDecode\r\n * @property {boolean} isHexOnly\r\n * @property {ArrayBuffer} valueHex\r\n */\n//noinspection JSUnusedLocalSymbols\n\n\nconst HexBlock = BaseClass => class LocalHexBlockMixin extends BaseClass {\n  //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Constructor for \"HexBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    /**\r\n     * @type {boolean}\r\n     */\n\n    this.isHexOnly = (0, _pvutils.getParametersValue)(parameters, \"isHexOnly\", false);\n    /**\r\n     * @type {ArrayBuffer}\r\n     */\n\n    if (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else this.valueHex = new ArrayBuffer(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"hexBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.warnings.push(\"Zero buffer length\");\n      return inputOffset;\n    } //endregion\n    //region Copy input buffer to internal buffer\n\n\n    this.valueHex = inputBuffer.slice(inputOffset, inputOffset + inputLength); //endregion\n\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    if (this.isHexOnly !== true) {\n      this.error = \"Flag \\\"isHexOnly\\\" is not set, abort\";\n      return new ArrayBuffer(0);\n    }\n\n    if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength); //noinspection JSCheckFunctionSignatures\n\n    return this.valueHex.slice(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.blockName = this.constructor.blockName();\n    object.isHexOnly = this.isHexOnly;\n    object.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n    return object;\n  } //**********************************************************************************\n\n\n}; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of identification block class\n//**************************************************************************************\n\n\nexports.HexBlock = HexBlock;\n\nclass LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalBaseBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {Object} [idBlock]\r\n   */\n  constructor(parameters = {}) {\n    super();\n\n    if (\"idBlock\" in parameters) {\n      //region Properties from hexBlock class\n      this.isHexOnly = (0, _pvutils.getParametersValue)(parameters.idBlock, \"isHexOnly\", false);\n      this.valueHex = (0, _pvutils.getParametersValue)(parameters.idBlock, \"valueHex\", new ArrayBuffer(0)); //endregion\n\n      this.tagClass = (0, _pvutils.getParametersValue)(parameters.idBlock, \"tagClass\", -1);\n      this.tagNumber = (0, _pvutils.getParametersValue)(parameters.idBlock, \"tagNumber\", -1);\n      this.isConstructed = (0, _pvutils.getParametersValue)(parameters.idBlock, \"isConstructed\", false);\n    } else {\n      this.tagClass = -1;\n      this.tagNumber = -1;\n      this.isConstructed = false;\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"identificationBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //region Initial variables\n    let firstOctet = 0;\n    let retBuf;\n    let retView; //endregion\n\n    switch (this.tagClass) {\n      case 1:\n        firstOctet |= 0x00; // UNIVERSAL\n\n        break;\n\n      case 2:\n        firstOctet |= 0x40; // APPLICATION\n\n        break;\n\n      case 3:\n        firstOctet |= 0x80; // CONTEXT-SPECIFIC\n\n        break;\n\n      case 4:\n        firstOctet |= 0xC0; // PRIVATE\n\n        break;\n\n      default:\n        this.error = \"Unknown tag class\";\n        return new ArrayBuffer(0);\n    }\n\n    if (this.isConstructed) firstOctet |= 0x20;\n\n    if (this.tagNumber < 31 && !this.isHexOnly) {\n      retBuf = new ArrayBuffer(1);\n      retView = new Uint8Array(retBuf);\n\n      if (!sizeOnly) {\n        let number = this.tagNumber;\n        number &= 0x1F;\n        firstOctet |= number;\n        retView[0] = firstOctet;\n      }\n\n      return retBuf;\n    }\n\n    if (this.isHexOnly === false) {\n      const encodedBuf = (0, _pvutils.utilToBase)(this.tagNumber, 7);\n      const encodedView = new Uint8Array(encodedBuf);\n      const size = encodedBuf.byteLength;\n      retBuf = new ArrayBuffer(size + 1);\n      retView = new Uint8Array(retBuf);\n      retView[0] = firstOctet | 0x1F;\n\n      if (!sizeOnly) {\n        for (let i = 0; i < size - 1; i++) retView[i + 1] = encodedView[i] | 0x80;\n\n        retView[size] = encodedView[size - 1];\n      }\n\n      return retBuf;\n    }\n\n    retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n    retView = new Uint8Array(retBuf);\n    retView[0] = firstOctet | 0x1F;\n\n    if (sizeOnly === false) {\n      const curView = new Uint8Array(this.valueHex);\n\n      for (let i = 0; i < curView.length - 1; i++) retView[i + 1] = curView[i] | 0x80;\n\n      retView[this.valueHex.byteLength] = curView[curView.length - 1];\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.error = \"Zero buffer length\";\n      return -1;\n    } //endregion\n    //region Find tag class\n\n\n    const tagClassMask = intBuffer[0] & 0xC0;\n\n    switch (tagClassMask) {\n      case 0x00:\n        this.tagClass = 1; // UNIVERSAL\n\n        break;\n\n      case 0x40:\n        this.tagClass = 2; // APPLICATION\n\n        break;\n\n      case 0x80:\n        this.tagClass = 3; // CONTEXT-SPECIFIC\n\n        break;\n\n      case 0xC0:\n        this.tagClass = 4; // PRIVATE\n\n        break;\n\n      default:\n        this.error = \"Unknown tag class\";\n        return -1;\n    } //endregion\n    //region Find it's constructed or not\n\n\n    this.isConstructed = (intBuffer[0] & 0x20) === 0x20; //endregion\n    //region Find tag number\n\n    this.isHexOnly = false;\n    const tagNumberMask = intBuffer[0] & 0x1F; //region Simple case (tag number < 31)\n\n    if (tagNumberMask !== 0x1F) {\n      this.tagNumber = tagNumberMask;\n      this.blockLength = 1;\n    } //endregion\n    //region Tag number bigger or equal to 31\n    else {\n        let count = 1;\n        this.valueHex = new ArrayBuffer(255);\n        let tagNumberBufferMaxLength = 255;\n        let intTagNumberBuffer = new Uint8Array(this.valueHex); //noinspection JSBitwiseOperatorUsage\n\n        while (intBuffer[count] & 0x80) {\n          intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\n          count++;\n\n          if (count >= intBuffer.length) {\n            this.error = \"End of input reached before message was fully decoded\";\n            return -1;\n          } //region In case if tag number length is greater than 255 bytes (rare but possible case)\n\n\n          if (count === tagNumberBufferMaxLength) {\n            tagNumberBufferMaxLength += 255;\n            const tempBuffer = new ArrayBuffer(tagNumberBufferMaxLength);\n            const tempBufferView = new Uint8Array(tempBuffer);\n\n            for (let i = 0; i < intTagNumberBuffer.length; i++) tempBufferView[i] = intTagNumberBuffer[i];\n\n            this.valueHex = new ArrayBuffer(tagNumberBufferMaxLength);\n            intTagNumberBuffer = new Uint8Array(this.valueHex);\n          } //endregion\n\n        }\n\n        this.blockLength = count + 1;\n        intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F; // Write last byte to buffer\n        //region Cut buffer\n\n        const tempBuffer = new ArrayBuffer(count);\n        const tempBufferView = new Uint8Array(tempBuffer);\n\n        for (let i = 0; i < count; i++) tempBufferView[i] = intTagNumberBuffer[i];\n\n        this.valueHex = new ArrayBuffer(count);\n        intTagNumberBuffer = new Uint8Array(this.valueHex);\n        intTagNumberBuffer.set(tempBufferView); //endregion\n        //region Try to convert long tag number to short form\n\n        if (this.blockLength <= 9) this.tagNumber = (0, _pvutils.utilFromBase)(intTagNumberBuffer, 7);else {\n          this.isHexOnly = true;\n          this.warnings.push(\"Tag too long, represented as hex-coded\");\n        } //endregion\n      } //endregion\n    //endregion\n    //region Check if constructed encoding was using for primitive type\n\n\n    if (this.tagClass === 1 && this.isConstructed) {\n      switch (this.tagNumber) {\n        case 1: // Boolean\n\n        case 2: // REAL\n\n        case 5: // Null\n\n        case 6: // OBJECT IDENTIFIER\n\n        case 9: // REAL\n\n        case 13: // RELATIVE OBJECT IDENTIFIER\n\n        case 14: // Time\n\n        case 23:\n        case 24:\n        case 31:\n        case 32:\n        case 33:\n        case 34:\n          this.error = \"Constructed encoding used for primitive type\";\n          return -1;\n\n        default:\n      }\n    } //endregion\n\n\n    return inputOffset + this.blockLength; // Return current offset in input buffer\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName: string,\r\n   *  tagClass: number,\r\n   *  tagNumber: number,\r\n   *  isConstructed: boolean,\r\n   *  isHexOnly: boolean,\r\n   *  valueHex: ArrayBuffer,\r\n   *  blockLength: number,\r\n   *  error: string, warnings: Array.<string>,\r\n   *  valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.blockName = this.constructor.blockName();\n    object.tagClass = this.tagClass;\n    object.tagNumber = this.tagNumber;\n    object.isConstructed = this.isConstructed;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of length block class\n//**************************************************************************************\n\n\nclass LocalLengthBlock extends LocalBaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalLengthBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {Object} [lenBlock]\r\n   */\n  constructor(parameters = {}) {\n    super();\n\n    if (\"lenBlock\" in parameters) {\n      this.isIndefiniteForm = (0, _pvutils.getParametersValue)(parameters.lenBlock, \"isIndefiniteForm\", false);\n      this.longFormUsed = (0, _pvutils.getParametersValue)(parameters.lenBlock, \"longFormUsed\", false);\n      this.length = (0, _pvutils.getParametersValue)(parameters.lenBlock, \"length\", 0);\n    } else {\n      this.isIndefiniteForm = false;\n      this.longFormUsed = false;\n      this.length = 0;\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"lengthBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.error = \"Zero buffer length\";\n      return -1;\n    }\n\n    if (intBuffer[0] === 0xFF) {\n      this.error = \"Length block 0xFF is reserved by standard\";\n      return -1;\n    } //endregion\n    //region Check for length form type\n\n\n    this.isIndefiniteForm = intBuffer[0] === 0x80; //endregion\n    //region Stop working in case of indefinite length form\n\n    if (this.isIndefiniteForm === true) {\n      this.blockLength = 1;\n      return inputOffset + this.blockLength;\n    } //endregion\n    //region Check is long form of length encoding using\n\n\n    this.longFormUsed = !!(intBuffer[0] & 0x80); //endregion\n    //region Stop working in case of short form of length value\n\n    if (this.longFormUsed === false) {\n      this.length = intBuffer[0];\n      this.blockLength = 1;\n      return inputOffset + this.blockLength;\n    } //endregion\n    //region Calculate length value in case of long form\n\n\n    const count = intBuffer[0] & 0x7F;\n\n    if (count > 8) // Too big length value\n      {\n        this.error = \"Too big integer\";\n        return -1;\n      }\n\n    if (count + 1 > intBuffer.length) {\n      this.error = \"End of input reached before message was fully decoded\";\n      return -1;\n    }\n\n    const lengthBufferView = new Uint8Array(count);\n\n    for (let i = 0; i < count; i++) lengthBufferView[i] = intBuffer[i + 1];\n\n    if (lengthBufferView[count - 1] === 0x00) this.warnings.push(\"Needlessly long encoded length\");\n    this.length = (0, _pvutils.utilFromBase)(lengthBufferView, 8);\n    if (this.longFormUsed && this.length <= 127) this.warnings.push(\"Unneccesary usage of long length form\");\n    this.blockLength = count + 1; //endregion\n\n    return inputOffset + this.blockLength; // Return current offset in input buffer\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //region Initial variables\n    let retBuf;\n    let retView; //endregion\n\n    if (this.length > 127) this.longFormUsed = true;\n\n    if (this.isIndefiniteForm) {\n      retBuf = new ArrayBuffer(1);\n\n      if (sizeOnly === false) {\n        retView = new Uint8Array(retBuf);\n        retView[0] = 0x80;\n      }\n\n      return retBuf;\n    }\n\n    if (this.longFormUsed === true) {\n      const encodedBuf = (0, _pvutils.utilToBase)(this.length, 8);\n\n      if (encodedBuf.byteLength > 127) {\n        this.error = \"Too big length\";\n        return new ArrayBuffer(0);\n      }\n\n      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\n      if (sizeOnly === true) return retBuf;\n      const encodedView = new Uint8Array(encodedBuf);\n      retView = new Uint8Array(retBuf);\n      retView[0] = encodedBuf.byteLength | 0x80;\n\n      for (let i = 0; i < encodedBuf.byteLength; i++) retView[i + 1] = encodedView[i];\n\n      return retBuf;\n    }\n\n    retBuf = new ArrayBuffer(1);\n\n    if (sizeOnly === false) {\n      retView = new Uint8Array(retBuf);\n      retView[0] = this.length;\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.blockName = this.constructor.blockName();\n    object.isIndefiniteForm = this.isIndefiniteForm;\n    object.longFormUsed = this.longFormUsed;\n    object.length = this.length;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of value block class\n//**************************************************************************************\n\n\nclass ValueBlock extends LocalBaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"ValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"valueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Throw an exception for a function which needs to be specified in extended classes\n    throw TypeError(\"User need to make a specific function in a class which extends \\\"ValueBlock\\\"\"); //endregion\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //region Throw an exception for a function which needs to be specified in extended classes\n    throw TypeError(\"User need to make a specific function in a class which extends \\\"ValueBlock\\\"\"); //endregion\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic ASN.1 block class\n//**************************************************************************************\n\n\nexports.ValueBlock = ValueBlock;\n\nclass BaseBlock extends LocalBaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"BaseBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {Object} [primitiveSchema]\r\n   * @property {string} [name]\r\n   * @property {boolean} [optional]\r\n   * @param valueBlockType Type of value block\r\n   */\n  constructor(parameters = {}, valueBlockType = ValueBlock) {\n    super(parameters);\n    if (\"name\" in parameters) this.name = parameters.name;\n    if (\"optional\" in parameters) this.optional = parameters.optional;\n    if (\"primitiveSchema\" in parameters) this.primitiveSchema = parameters.primitiveSchema;\n    this.idBlock = new LocalIdentificationBlock(parameters);\n    this.lenBlock = new LocalLengthBlock(parameters);\n    this.valueBlock = new valueBlockType(parameters);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BaseBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    let retBuf;\n    const idBlockBuf = this.idBlock.toBER(sizeOnly);\n    const valueBlockSizeBuf = this.valueBlock.toBER(true);\n    this.lenBlock.length = valueBlockSizeBuf.byteLength;\n    const lenBlockBuf = this.lenBlock.toBER(sizeOnly);\n    retBuf = (0, _pvutils.utilConcatBuf)(idBlockBuf, lenBlockBuf);\n    let valueBlockBuf;\n    if (sizeOnly === false) valueBlockBuf = this.valueBlock.toBER(sizeOnly);else valueBlockBuf = new ArrayBuffer(this.lenBlock.length);\n    retBuf = (0, _pvutils.utilConcatBuf)(retBuf, valueBlockBuf);\n\n    if (this.lenBlock.isIndefiniteForm === true) {\n      const indefBuf = new ArrayBuffer(2);\n\n      if (sizeOnly === false) {\n        const indefView = new Uint8Array(indefBuf);\n        indefView[0] = 0x00;\n        indefView[1] = 0x00;\n      }\n\n      retBuf = (0, _pvutils.utilConcatBuf)(retBuf, indefBuf);\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.idBlock = this.idBlock.toJSON();\n    object.lenBlock = this.lenBlock.toJSON();\n    object.valueBlock = this.valueBlock.toJSON();\n    if (\"name\" in this) object.name = this.name;\n    if (\"optional\" in this) object.optional = this.optional;\n    if (\"primitiveSchema\" in this) object.primitiveSchema = this.primitiveSchema.toJSON();\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic block for all PRIMITIVE types\n//**************************************************************************************\n\n\nexports.BaseBlock = BaseBlock;\n\nclass LocalPrimitiveValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalPrimitiveValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueBeforeDecode]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters); //region Variables from \"hexBlock\" class\n\n    if (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else this.valueHex = new ArrayBuffer(0);\n    this.isHexOnly = (0, _pvutils.getParametersValue)(parameters, \"isHexOnly\", true); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.warnings.push(\"Zero buffer length\");\n      return inputOffset;\n    } //endregion\n    //region Copy input buffer into internal buffer\n\n\n    this.valueHex = new ArrayBuffer(intBuffer.length);\n    const valueHexView = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < intBuffer.length; i++) valueHexView[i] = intBuffer[i]; //endregion\n\n\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    return this.valueHex.slice(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"PrimitiveValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n    object.isHexOnly = this.isHexOnly;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass Primitive extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Primitive\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalPrimitiveValueBlock);\n    this.idBlock.isConstructed = false;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"PRIMITIVE\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic block for all CONSTRUCTED types\n//**************************************************************************************\n\n\nexports.Primitive = Primitive;\n\nclass LocalConstructedValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalConstructedValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", []);\n    this.isIndefiniteForm = (0, _pvutils.getParametersValue)(parameters, \"isIndefiniteForm\", false);\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Store initial offset and length\n    const initialOffset = inputOffset;\n    const initialLength = inputLength; //endregion\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.warnings.push(\"Zero buffer length\");\n      return inputOffset;\n    } //endregion\n    //region Aux function\n\n\n    function checkLen(indefiniteLength, length) {\n      if (indefiniteLength === true) return 1;\n      return length;\n    } //endregion\n\n\n    let currentOffset = inputOffset;\n\n    while (checkLen(this.isIndefiniteForm, inputLength) > 0) {\n      const returnObject = LocalFromBER(inputBuffer, currentOffset, inputLength);\n\n      if (returnObject.offset === -1) {\n        this.error = returnObject.result.error;\n        this.warnings.concat(returnObject.result.warnings);\n        return -1;\n      }\n\n      currentOffset = returnObject.offset;\n      this.blockLength += returnObject.result.blockLength;\n      inputLength -= returnObject.result.blockLength;\n      this.value.push(returnObject.result);\n      if (this.isIndefiniteForm === true && returnObject.result.constructor.blockName() === EndOfContent.blockName()) break;\n    }\n\n    if (this.isIndefiniteForm === true) {\n      if (this.value[this.value.length - 1].constructor.blockName() === EndOfContent.blockName()) this.value.pop();else this.warnings.push(\"No EndOfContent block encoded\");\n    } //region Copy \"inputBuffer\" to \"valueBeforeDecode\"\n\n\n    this.valueBeforeDecode = inputBuffer.slice(initialOffset, initialOffset + initialLength); //endregion\n\n    return currentOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    let retBuf = new ArrayBuffer(0);\n\n    for (let i = 0; i < this.value.length; i++) {\n      const valueBuf = this.value[i].toBER(sizeOnly);\n      retBuf = (0, _pvutils.utilConcatBuf)(retBuf, valueBuf);\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"ConstructedValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.isIndefiniteForm = this.isIndefiniteForm;\n    object.value = [];\n\n    for (let i = 0; i < this.value.length; i++) object.value.push(this.value[i].toJSON());\n\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass Constructed extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Constructed\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalConstructedValueBlock);\n    this.idBlock.isConstructed = true;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"CONSTRUCTED\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 EndOfContent type class\n//**************************************************************************************\n\n\nexports.Constructed = Constructed;\n\nclass LocalEndOfContentValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalEndOfContentValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region There is no \"value block\" for EndOfContent type and we need to return the same offset\n    return inputOffset; //endregion\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    return new ArrayBuffer(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"EndOfContentValueBlock\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass EndOfContent extends BaseBlock {\n  //**********************************************************************************\n  constructor(paramaters = {}) {\n    super(paramaters, LocalEndOfContentValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 0; // EndOfContent\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"EndOfContent\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Boolean type class\n//**************************************************************************************\n\n\nexports.EndOfContent = EndOfContent;\n\nclass LocalBooleanValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalBooleanValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", false);\n    this.isHexOnly = (0, _pvutils.getParametersValue)(parameters, \"isHexOnly\", false);\n    if (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else {\n      this.valueHex = new ArrayBuffer(1);\n\n      if (this.value === true) {\n        const view = new Uint8Array(this.valueHex);\n        view[0] = 0xFF;\n      }\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n\n    if (inputLength > 1) this.warnings.push(\"Boolean value encoded in more then 1 octet\");\n    this.isHexOnly = true; //region Copy input buffer to internal array\n\n    this.valueHex = new ArrayBuffer(intBuffer.length);\n    const view = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < intBuffer.length; i++) view[i] = intBuffer[i]; //endregion\n\n\n    if (_pvutils.utilDecodeTC.call(this) !== 0) this.value = true;else this.value = false;\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    return this.valueHex;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BooleanValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    object.isHexOnly = this.isHexOnly;\n    object.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass Boolean extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Boolean\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalBooleanValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 1; // Boolean\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Boolean\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Sequence and Set type classes\n//**************************************************************************************\n\n\nexports.Boolean = Boolean;\n\nclass Sequence extends Constructed {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Sequence\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 16; // Sequence\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Sequence\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.Sequence = Sequence;\n\nclass Set extends Constructed {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Set\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 17; // Set\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Set\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Null type class\n//**************************************************************************************\n\n\nexports.Set = Set;\n\nclass Null extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Null\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalBaseBlock); // We will not have a call to \"Null value block\" because of specified \"fromBER\" and \"toBER\" functions\n\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 5; // Null\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Null\";\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (this.lenBlock.length > 0) this.warnings.push(\"Non-zero length of value block for Null type\");\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    this.blockLength += inputLength;\n\n    if (inputOffset + inputLength > inputBuffer.byteLength) {\n      this.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n      return -1;\n    }\n\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    const retBuf = new ArrayBuffer(2);\n    if (sizeOnly === true) return retBuf;\n    const retView = new Uint8Array(retBuf);\n    retView[0] = 0x05;\n    retView[1] = 0x00;\n    return retBuf;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 OctetString type class\n//**************************************************************************************\n\n\nexports.Null = Null;\n\nclass LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalOctetStringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.isConstructed = (0, _pvutils.getParametersValue)(parameters, \"isConstructed\", false);\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = 0;\n\n    if (this.isConstructed === true) {\n      this.isHexOnly = false;\n      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n      if (resultOffset === -1) return resultOffset;\n\n      for (let i = 0; i < this.value.length; i++) {\n        const currentBlockName = this.value[i].constructor.blockName();\n\n        if (currentBlockName === EndOfContent.blockName()) {\n          if (this.isIndefiniteForm === true) break;else {\n            this.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\n            return -1;\n          }\n        }\n\n        if (currentBlockName !== OctetString.blockName()) {\n          this.error = \"OCTET STRING may consists of OCTET STRINGs only\";\n          return -1;\n        }\n      }\n    } else {\n      this.isHexOnly = true;\n      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n      this.blockLength = inputLength;\n    }\n\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    if (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n    let retBuf = new ArrayBuffer(this.valueHex.byteLength);\n    if (sizeOnly === true) return retBuf;\n    if (this.valueHex.byteLength === 0) return retBuf;\n    retBuf = this.valueHex.slice(0);\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"OctetStringValueBlock\";\n  } //**********************************************************************************\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.isConstructed = this.isConstructed;\n    object.isHexOnly = this.isHexOnly;\n    object.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass OctetString extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"OctetString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalOctetStringValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 4; // OctetString\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.valueBlock.isConstructed = this.idBlock.isConstructed;\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm; //region Ability to encode empty OCTET STRING\n\n    if (inputLength === 0) {\n      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n      return inputOffset;\n    } //endregion\n\n\n    return super.fromBER(inputBuffer, inputOffset, inputLength);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"OctetString\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Checking that two OCTETSTRINGs are equal\r\n   * @param {OctetString} octetString\r\n   */\n\n\n  isEqual(octetString) {\n    //region Check input type\n    if (octetString instanceof OctetString === false) return false; //endregion\n    //region Compare two JSON strings\n\n    if (JSON.stringify(this) !== JSON.stringify(octetString)) return false; //endregion\n\n    return true;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 BitString type class\n//**************************************************************************************\n\n\nexports.OctetString = OctetString;\n\nclass LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalBitStringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.unusedBits = (0, _pvutils.getParametersValue)(parameters, \"unusedBits\", 0);\n    this.isConstructed = (0, _pvutils.getParametersValue)(parameters, \"isConstructed\", false);\n    this.blockLength = this.valueHex.byteLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Ability to decode zero-length BitString value\n    if (inputLength === 0) return inputOffset; //endregion\n\n    let resultOffset = -1; //region If the BISTRING supposed to be a constructed value\n\n    if (this.isConstructed === true) {\n      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n      if (resultOffset === -1) return resultOffset;\n\n      for (let i = 0; i < this.value.length; i++) {\n        const currentBlockName = this.value[i].constructor.blockName();\n\n        if (currentBlockName === EndOfContent.blockName()) {\n          if (this.isIndefiniteForm === true) break;else {\n            this.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\n            return -1;\n          }\n        }\n\n        if (currentBlockName !== BitString.blockName()) {\n          this.error = \"BIT STRING may consists of BIT STRINGs only\";\n          return -1;\n        }\n\n        if (this.unusedBits > 0 && this.value[i].valueBlock.unusedBits > 0) {\n          this.error = \"Usign of \\\"unused bits\\\" inside constructive BIT STRING allowed for least one only\";\n          return -1;\n        }\n\n        this.unusedBits = this.value[i].valueBlock.unusedBits;\n\n        if (this.unusedBits > 7) {\n          this.error = \"Unused bits for BitString must be in range 0-7\";\n          return -1;\n        }\n      }\n\n      return resultOffset;\n    } //endregion\n    //region If the BitString supposed to be a primitive value\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n\n\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n    this.unusedBits = intBuffer[0];\n\n    if (this.unusedBits > 7) {\n      this.error = \"Unused bits for BitString must be in range 0-7\";\n      return -1;\n    } //region Copy input buffer to internal buffer\n\n\n    this.valueHex = new ArrayBuffer(intBuffer.length - 1);\n    const view = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < inputLength - 1; i++) view[i] = intBuffer[i + 1]; //endregion\n\n\n    this.blockLength = intBuffer.length;\n    return inputOffset + inputLength; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    if (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n    if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength + 1);\n    if (this.valueHex.byteLength === 0) return new ArrayBuffer(0);\n    const curView = new Uint8Array(this.valueHex);\n    const retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n    const retView = new Uint8Array(retBuf);\n    retView[0] = this.unusedBits;\n\n    for (let i = 0; i < this.valueHex.byteLength; i++) retView[i + 1] = curView[i];\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BitStringValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.unusedBits = this.unusedBits;\n    object.isConstructed = this.isConstructed;\n    object.isHexOnly = this.isHexOnly;\n    object.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass BitString extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"BitString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalBitStringValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 3; // BitString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BitString\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Ability to encode empty BitString\n    if (inputLength === 0) return inputOffset; //endregion\n\n    this.valueBlock.isConstructed = this.idBlock.isConstructed;\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n    return super.fromBER(inputBuffer, inputOffset, inputLength);\n  } //**********************************************************************************\n\n  /**\r\n   * Checking that two BITSTRINGs are equal\r\n   * @param {BitString} bitString\r\n   */\n\n\n  isEqual(bitString) {\n    //region Check input type\n    if (bitString instanceof BitString === false) return false; //endregion\n    //region Compare two JSON strings\n\n    if (JSON.stringify(this) !== JSON.stringify(bitString)) return false; //endregion\n\n    return true;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Integer type class\n//**************************************************************************************\n\n/**\r\n * @extends ValueBlock\r\n */\n\n\nexports.BitString = BitString;\n\nclass LocalIntegerValueBlock extends HexBlock(ValueBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalIntegerValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    if (\"value\" in parameters) this.valueDec = parameters.value;\n  } //**********************************************************************************\n\n  /**\r\n   * Setter for \"valueHex\"\r\n   * @param {ArrayBuffer} _value\r\n   */\n\n\n  set valueHex(_value) {\n    this._valueHex = _value.slice(0);\n\n    if (_value.byteLength >= 4) {\n      this.warnings.push(\"Too big Integer for decoding, hex only\");\n      this.isHexOnly = true;\n      this._valueDec = 0;\n    } else {\n      this.isHexOnly = false;\n      if (_value.byteLength > 0) this._valueDec = _pvutils.utilDecodeTC.call(this);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Getter for \"valueHex\"\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  get valueHex() {\n    return this._valueHex;\n  } //**********************************************************************************\n\n  /**\r\n   * Getter for \"valueDec\"\r\n   * @param {number} _value\r\n   */\n\n\n  set valueDec(_value) {\n    this._valueDec = _value;\n    this.isHexOnly = false;\n    this._valueHex = (0, _pvutils.utilEncodeTC)(_value);\n  } //**********************************************************************************\n\n  /**\r\n   * Getter for \"valueDec\"\r\n   * @returns {number}\r\n   */\n\n\n  get valueDec() {\n    return this._valueDec;\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from DER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 DER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 DER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @param {number} [expectedLength=0] Expected length of converted \"valueHex\" buffer\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {\n    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);\n    if (offset === -1) return offset;\n    const view = new Uint8Array(this._valueHex);\n\n    if (view[0] === 0x00 && (view[1] & 0x80) !== 0) {\n      const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\n      const updatedView = new Uint8Array(updatedValueHex);\n      updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n      this._valueHex = updatedValueHex.slice(0);\n    } else {\n      if (expectedLength !== 0) {\n        if (this._valueHex.byteLength < expectedLength) {\n          if (expectedLength - this._valueHex.byteLength > 1) expectedLength = this._valueHex.byteLength + 1;\n          const updatedValueHex = new ArrayBuffer(expectedLength);\n          const updatedView = new Uint8Array(updatedValueHex);\n          updatedView.set(view, expectedLength - this._valueHex.byteLength);\n          this._valueHex = updatedValueHex.slice(0);\n        }\n      }\n    }\n\n    return offset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (DER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toDER(sizeOnly = false) {\n    const view = new Uint8Array(this._valueHex);\n\n    switch (true) {\n      case (view[0] & 0x80) !== 0:\n        {\n          const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength + 1);\n          const updatedView = new Uint8Array(updatedValueHex);\n          updatedView[0] = 0x00;\n          updatedView.set(view, 1);\n          this._valueHex = updatedValueHex.slice(0);\n        }\n        break;\n\n      case view[0] === 0x00 && (view[1] & 0x80) === 0:\n        {\n          const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\n          const updatedView = new Uint8Array(updatedValueHex);\n          updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n          this._valueHex = updatedValueHex.slice(0);\n        }\n        break;\n\n      default:\n    }\n\n    return this.toBER(sizeOnly);\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n    if (resultOffset === -1) return resultOffset;\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //noinspection JSCheckFunctionSignatures\n    return this.valueHex.slice(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"IntegerValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.valueDec = this.valueDec;\n    return object;\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current value to decimal string representation\r\n   */\n\n\n  toString() {\n    //region Aux functions\n    function viewAdd(first, second) {\n      //region Initial variables\n      const c = new Uint8Array([0]);\n      let firstView = new Uint8Array(first);\n      let secondView = new Uint8Array(second);\n      let firstViewCopy = firstView.slice(0);\n      const firstViewCopyLength = firstViewCopy.length - 1;\n      let secondViewCopy = secondView.slice(0);\n      const secondViewCopyLength = secondViewCopy.length - 1;\n      let value = 0;\n      const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;\n      let counter = 0; //endregion\n\n      for (let i = max; i >= 0; i--, counter++) {\n        switch (true) {\n          case counter < secondViewCopy.length:\n            value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\n            break;\n\n          default:\n            value = firstViewCopy[firstViewCopyLength - counter] + c[0];\n        }\n\n        c[0] = value / 10;\n\n        switch (true) {\n          case counter >= firstViewCopy.length:\n            firstViewCopy = (0, _pvutils.utilConcatView)(new Uint8Array([value % 10]), firstViewCopy);\n            break;\n\n          default:\n            firstViewCopy[firstViewCopyLength - counter] = value % 10;\n        }\n      }\n\n      if (c[0] > 0) firstViewCopy = (0, _pvutils.utilConcatView)(c, firstViewCopy);\n      return firstViewCopy.slice(0);\n    }\n\n    function power2(n) {\n      if (n >= powers2.length) {\n        for (let p = powers2.length; p <= n; p++) {\n          const c = new Uint8Array([0]);\n          let digits = powers2[p - 1].slice(0);\n\n          for (let i = digits.length - 1; i >= 0; i--) {\n            const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);\n            c[0] = newValue[0] / 10;\n            digits[i] = newValue[0] % 10;\n          }\n\n          if (c[0] > 0) digits = (0, _pvutils.utilConcatView)(c, digits);\n          powers2.push(digits);\n        }\n      }\n\n      return powers2[n];\n    }\n\n    function viewSub(first, second) {\n      //region Initial variables\n      let b = 0;\n      let firstView = new Uint8Array(first);\n      let secondView = new Uint8Array(second);\n      let firstViewCopy = firstView.slice(0);\n      const firstViewCopyLength = firstViewCopy.length - 1;\n      let secondViewCopy = secondView.slice(0);\n      const secondViewCopyLength = secondViewCopy.length - 1;\n      let value;\n      let counter = 0; //endregion\n\n      for (let i = secondViewCopyLength; i >= 0; i--, counter++) {\n        value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\n\n        switch (true) {\n          case value < 0:\n            b = 1;\n            firstViewCopy[firstViewCopyLength - counter] = value + 10;\n            break;\n\n          default:\n            b = 0;\n            firstViewCopy[firstViewCopyLength - counter] = value;\n        }\n      }\n\n      if (b > 0) {\n        for (let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++) {\n          value = firstViewCopy[firstViewCopyLength - counter] - b;\n\n          if (value < 0) {\n            b = 1;\n            firstViewCopy[firstViewCopyLength - counter] = value + 10;\n          } else {\n            b = 0;\n            firstViewCopy[firstViewCopyLength - counter] = value;\n            break;\n          }\n        }\n      }\n\n      return firstViewCopy.slice();\n    } //endregion\n    //region Initial variables\n\n\n    const firstBit = this._valueHex.byteLength * 8 - 1;\n    let digits = new Uint8Array(this._valueHex.byteLength * 8 / 3);\n    let bitNumber = 0;\n    let currentByte;\n    const asn1View = new Uint8Array(this._valueHex);\n    let result = \"\";\n    let flag = false; //endregion\n    //region Calculate number\n\n    for (let byteNumber = this._valueHex.byteLength - 1; byteNumber >= 0; byteNumber--) {\n      currentByte = asn1View[byteNumber];\n\n      for (let i = 0; i < 8; i++) {\n        if ((currentByte & 1) === 1) {\n          switch (bitNumber) {\n            case firstBit:\n              digits = viewSub(power2(bitNumber), digits);\n              result = \"-\";\n              break;\n\n            default:\n              digits = viewAdd(digits, power2(bitNumber));\n          }\n        }\n\n        bitNumber++;\n        currentByte >>= 1;\n      }\n    } //endregion\n    //region Print number\n\n\n    for (let i = 0; i < digits.length; i++) {\n      if (digits[i]) flag = true;\n      if (flag) result += digitsString.charAt(digits[i]);\n    }\n\n    if (flag === false) result += digitsString.charAt(0); //endregion\n\n    return result;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass Integer extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Integer\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalIntegerValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 2; // Integer\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Integer\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Compare two Integer object, or Integer and ArrayBuffer objects\r\n   * @param {!Integer|ArrayBuffer} otherValue\r\n   * @returns {boolean}\r\n   */\n\n\n  isEqual(otherValue) {\n    if (otherValue instanceof Integer) {\n      if (this.valueBlock.isHexOnly && otherValue.valueBlock.isHexOnly) // Compare two ArrayBuffers\n        return (0, _pvutils.isEqualBuffer)(this.valueBlock.valueHex, otherValue.valueBlock.valueHex);\n      if (this.valueBlock.isHexOnly === otherValue.valueBlock.isHexOnly) return this.valueBlock.valueDec === otherValue.valueBlock.valueDec;\n      return false;\n    }\n\n    if (otherValue instanceof ArrayBuffer) return (0, _pvutils.isEqualBuffer)(this.valueBlock.valueHex, otherValue);\n    return false;\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current Integer value from BER into DER format\r\n   * @returns {Integer}\r\n   */\n\n\n  convertToDER() {\n    const integer = new Integer({\n      valueHex: this.valueBlock.valueHex\n    });\n    integer.valueBlock.toDER();\n    return integer;\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current Integer value from DER to BER format\r\n   * @returns {Integer}\r\n   */\n\n\n  convertFromDER() {\n    const expectedLength = this.valueBlock.valueHex.byteLength % 2 ? this.valueBlock.valueHex.byteLength + 1 : this.valueBlock.valueHex.byteLength;\n    const integer = new Integer({\n      valueHex: this.valueBlock.valueHex\n    });\n    integer.valueBlock.fromDER(integer.valueBlock.valueHex, 0, integer.valueBlock.valueHex.byteLength, expectedLength);\n    return integer;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Enumerated type class\n//**************************************************************************************\n\n\nexports.Integer = Integer;\n\nclass Enumerated extends Integer {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Enumerated\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 10; // Enumerated\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Enumerated\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 ObjectIdentifier type class\n//**************************************************************************************\n\n\nexports.Enumerated = Enumerated;\n\nclass LocalSidValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalSidValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {number} [valueDec]\r\n   * @property {boolean} [isFirstSid]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.valueDec = (0, _pvutils.getParametersValue)(parameters, \"valueDec\", -1);\n    this.isFirstSid = (0, _pvutils.getParametersValue)(parameters, \"isFirstSid\", false);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"sidBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (inputLength === 0) return inputOffset; //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n    this.valueHex = new ArrayBuffer(inputLength);\n    let view = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < inputLength; i++) {\n      view[i] = intBuffer[i] & 0x7F;\n      this.blockLength++;\n      if ((intBuffer[i] & 0x80) === 0x00) break;\n    } //region Ajust size of valueHex buffer\n\n\n    const tempValueHex = new ArrayBuffer(this.blockLength);\n    const tempView = new Uint8Array(tempValueHex);\n\n    for (let i = 0; i < this.blockLength; i++) tempView[i] = view[i]; //noinspection JSCheckFunctionSignatures\n\n\n    this.valueHex = tempValueHex.slice(0);\n    view = new Uint8Array(this.valueHex); //endregion\n\n    if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n      this.error = \"End of input reached before message was fully decoded\";\n      return -1;\n    }\n\n    if (view[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n    if (this.blockLength <= 8) this.valueDec = (0, _pvutils.utilFromBase)(view, 7);else {\n      this.isHexOnly = true;\n      this.warnings.push(\"Too big SID for decoding, hex only\");\n    }\n    return inputOffset + this.blockLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //region Initial variables\n    let retBuf;\n    let retView; //endregion\n\n    if (this.isHexOnly) {\n      if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);\n      const curView = new Uint8Array(this.valueHex);\n      retBuf = new ArrayBuffer(this.blockLength);\n      retView = new Uint8Array(retBuf);\n\n      for (let i = 0; i < this.blockLength - 1; i++) retView[i] = curView[i] | 0x80;\n\n      retView[this.blockLength - 1] = curView[this.blockLength - 1];\n      return retBuf;\n    }\n\n    const encodedBuf = (0, _pvutils.utilToBase)(this.valueDec, 7);\n\n    if (encodedBuf.byteLength === 0) {\n      this.error = \"Error during encoding SID value\";\n      return new ArrayBuffer(0);\n    }\n\n    retBuf = new ArrayBuffer(encodedBuf.byteLength);\n\n    if (sizeOnly === false) {\n      const encodedView = new Uint8Array(encodedBuf);\n      retView = new Uint8Array(retBuf);\n\n      for (let i = 0; i < encodedBuf.byteLength - 1; i++) retView[i] = encodedView[i] | 0x80;\n\n      retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Create string representation of current SID block\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    let result = \"\";\n    if (this.isHexOnly === true) result = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);else {\n      if (this.isFirstSid) {\n        let sidValue = this.valueDec;\n        if (this.valueDec <= 39) result = \"0.\";else {\n          if (this.valueDec <= 79) {\n            result = \"1.\";\n            sidValue -= 40;\n          } else {\n            result = \"2.\";\n            sidValue -= 80;\n          }\n        }\n        result += sidValue.toString();\n      } else result = this.valueDec.toString();\n    }\n    return result;\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.valueDec = this.valueDec;\n    object.isFirstSid = this.isFirstSid;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass LocalObjectIdentifierValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalObjectIdentifierValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.fromString((0, _pvutils.getParametersValue)(parameters, \"value\", \"\"));\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = inputOffset;\n\n    while (inputLength > 0) {\n      const sidBlock = new LocalSidValueBlock();\n      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\n      if (resultOffset === -1) {\n        this.blockLength = 0;\n        this.error = sidBlock.error;\n        return resultOffset;\n      }\n\n      if (this.value.length === 0) sidBlock.isFirstSid = true;\n      this.blockLength += sidBlock.blockLength;\n      inputLength -= sidBlock.blockLength;\n      this.value.push(sidBlock);\n    }\n\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    let retBuf = new ArrayBuffer(0);\n\n    for (let i = 0; i < this.value.length; i++) {\n      const valueBuf = this.value[i].toBER(sizeOnly);\n\n      if (valueBuf.byteLength === 0) {\n        this.error = this.value[i].error;\n        return new ArrayBuffer(0);\n      }\n\n      retBuf = (0, _pvutils.utilConcatBuf)(retBuf, valueBuf);\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Create \"LocalObjectIdentifierValueBlock\" class from string\r\n   * @param {string} string Input string to convert from\r\n   * @returns {boolean}\r\n   */\n\n\n  fromString(string) {\n    this.value = []; // Clear existing SID values\n\n    let pos1 = 0;\n    let pos2 = 0;\n    let sid = \"\";\n    let flag = false;\n\n    do {\n      pos2 = string.indexOf(\".\", pos1);\n      if (pos2 === -1) sid = string.substr(pos1);else sid = string.substr(pos1, pos2 - pos1);\n      pos1 = pos2 + 1;\n\n      if (flag) {\n        const sidBlock = this.value[0];\n        let plus = 0;\n\n        switch (sidBlock.valueDec) {\n          case 0:\n            break;\n\n          case 1:\n            plus = 40;\n            break;\n\n          case 2:\n            plus = 80;\n            break;\n\n          default:\n            this.value = []; // clear SID array\n\n            return false;\n          // ???\n        }\n\n        const parsedSID = parseInt(sid, 10);\n        if (isNaN(parsedSID)) return true;\n        sidBlock.valueDec = parsedSID + plus;\n        flag = false;\n      } else {\n        const sidBlock = new LocalSidValueBlock();\n        sidBlock.valueDec = parseInt(sid, 10);\n        if (isNaN(sidBlock.valueDec)) return true;\n\n        if (this.value.length === 0) {\n          sidBlock.isFirstSid = true;\n          flag = true;\n        }\n\n        this.value.push(sidBlock);\n      }\n    } while (pos2 !== -1);\n\n    return true;\n  } //**********************************************************************************\n\n  /**\r\n   * Converts \"LocalObjectIdentifierValueBlock\" class to string\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    let result = \"\";\n    let isHexOnly = false;\n\n    for (let i = 0; i < this.value.length; i++) {\n      isHexOnly = this.value[i].isHexOnly;\n      let sidStr = this.value[i].toString();\n      if (i !== 0) result = `${result}.`;\n\n      if (isHexOnly) {\n        sidStr = `{${sidStr}}`;\n        if (this.value[i].isFirstSid) result = `2.{${sidStr} - 80}`;else result += sidStr;\n      } else result += sidStr;\n    }\n\n    return result;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"ObjectIdentifierValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.toString();\n    object.sidArray = [];\n\n    for (let i = 0; i < this.value.length; i++) object.sidArray.push(this.value[i].toJSON());\n\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass ObjectIdentifier extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"ObjectIdentifier\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalObjectIdentifierValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 6; // OBJECT IDENTIFIER\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"ObjectIdentifier\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of all string's classes\n//**************************************************************************************\n\n\nexports.ObjectIdentifier = ObjectIdentifier;\n\nclass LocalUtf8StringValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Constructor for \"LocalUtf8StringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.isHexOnly = true;\n    this.value = \"\"; // String representation of decoded ArrayBuffer\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Utf8StringValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass Utf8String extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Utf8String\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalUtf8StringValueBlock);\n    if (\"value\" in parameters) this.fromString(parameters.value);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 12; // Utf8String\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Utf8String\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n\n    try {\n      //noinspection JSDeprecatedSymbols\n      this.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value));\n    } catch (ex) {\n      this.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    //noinspection JSDeprecatedSymbols\n    const str = unescape(encodeURIComponent(inputString));\n    const strLen = str.length;\n    this.valueBlock.valueHex = new ArrayBuffer(strLen);\n    const view = new Uint8Array(this.valueBlock.valueHex);\n\n    for (let i = 0; i < strLen; i++) view[i] = str.charCodeAt(i);\n\n    this.valueBlock.value = inputString;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//region Declaration of ASN.1 RelativeObjectIdentifier type class\n//**************************************************************************************\n\n\nexports.Utf8String = Utf8String;\n\nclass LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalRelativeSidValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {number} [valueDec]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.valueDec = (0, _pvutils.getParametersValue)(parameters, \"valueDec\", -1);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"relativeSidBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (inputLength === 0) return inputOffset; //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n    this.valueHex = new ArrayBuffer(inputLength);\n    let view = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < inputLength; i++) {\n      view[i] = intBuffer[i] & 0x7F;\n      this.blockLength++;\n      if ((intBuffer[i] & 0x80) === 0x00) break;\n    } //region Ajust size of valueHex buffer\n\n\n    const tempValueHex = new ArrayBuffer(this.blockLength);\n    const tempView = new Uint8Array(tempValueHex);\n\n    for (let i = 0; i < this.blockLength; i++) tempView[i] = view[i]; //noinspection JSCheckFunctionSignatures\n\n\n    this.valueHex = tempValueHex.slice(0);\n    view = new Uint8Array(this.valueHex); //endregion\n\n    if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n      this.error = \"End of input reached before message was fully decoded\";\n      return -1;\n    }\n\n    if (view[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n    if (this.blockLength <= 8) this.valueDec = (0, _pvutils.utilFromBase)(view, 7);else {\n      this.isHexOnly = true;\n      this.warnings.push(\"Too big SID for decoding, hex only\");\n    }\n    return inputOffset + this.blockLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //region Initial variables\n    let retBuf;\n    let retView; //endregion\n\n    if (this.isHexOnly) {\n      if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);\n      const curView = new Uint8Array(this.valueHex);\n      retBuf = new ArrayBuffer(this.blockLength);\n      retView = new Uint8Array(retBuf);\n\n      for (let i = 0; i < this.blockLength - 1; i++) retView[i] = curView[i] | 0x80;\n\n      retView[this.blockLength - 1] = curView[this.blockLength - 1];\n      return retBuf;\n    }\n\n    const encodedBuf = (0, _pvutils.utilToBase)(this.valueDec, 7);\n\n    if (encodedBuf.byteLength === 0) {\n      this.error = \"Error during encoding SID value\";\n      return new ArrayBuffer(0);\n    }\n\n    retBuf = new ArrayBuffer(encodedBuf.byteLength);\n\n    if (sizeOnly === false) {\n      const encodedView = new Uint8Array(encodedBuf);\n      retView = new Uint8Array(retBuf);\n\n      for (let i = 0; i < encodedBuf.byteLength - 1; i++) retView[i] = encodedView[i] | 0x80;\n\n      retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Create string representation of current SID block\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    let result = \"\";\n    if (this.isHexOnly === true) result = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);else {\n      result = this.valueDec.toString();\n    }\n    return result;\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.valueDec = this.valueDec;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass LocalRelativeObjectIdentifierValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalRelativeObjectIdentifierValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.fromString((0, _pvutils.getParametersValue)(parameters, \"value\", \"\"));\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = inputOffset;\n\n    while (inputLength > 0) {\n      const sidBlock = new LocalRelativeSidValueBlock();\n      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\n      if (resultOffset === -1) {\n        this.blockLength = 0;\n        this.error = sidBlock.error;\n        return resultOffset;\n      }\n\n      this.blockLength += sidBlock.blockLength;\n      inputLength -= sidBlock.blockLength;\n      this.value.push(sidBlock);\n    }\n\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    let retBuf = new ArrayBuffer(0);\n\n    for (let i = 0; i < this.value.length; i++) {\n      const valueBuf = this.value[i].toBER(sizeOnly);\n\n      if (valueBuf.byteLength === 0) {\n        this.error = this.value[i].error;\n        return new ArrayBuffer(0);\n      }\n\n      retBuf = (0, _pvutils.utilConcatBuf)(retBuf, valueBuf);\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Create \"LocalRelativeObjectIdentifierValueBlock\" class from string\r\n   * @param {string} string Input string to convert from\r\n   * @returns {boolean}\r\n   */\n\n\n  fromString(string) {\n    this.value = []; // Clear existing SID values\n\n    let pos1 = 0;\n    let pos2 = 0;\n    let sid = \"\";\n\n    do {\n      pos2 = string.indexOf(\".\", pos1);\n      if (pos2 === -1) sid = string.substr(pos1);else sid = string.substr(pos1, pos2 - pos1);\n      pos1 = pos2 + 1;\n      const sidBlock = new LocalRelativeSidValueBlock();\n      sidBlock.valueDec = parseInt(sid, 10);\n      if (isNaN(sidBlock.valueDec)) return true;\n      this.value.push(sidBlock);\n    } while (pos2 !== -1);\n\n    return true;\n  } //**********************************************************************************\n\n  /**\r\n   * Converts \"LocalRelativeObjectIdentifierValueBlock\" class to string\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    let result = \"\";\n    let isHexOnly = false;\n\n    for (let i = 0; i < this.value.length; i++) {\n      isHexOnly = this.value[i].isHexOnly;\n      let sidStr = this.value[i].toString();\n      if (i !== 0) result = `${result}.`;\n\n      if (isHexOnly) {\n        sidStr = `{${sidStr}}`;\n        result += sidStr;\n      } else result += sidStr;\n    }\n\n    return result;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"RelativeObjectIdentifierValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.toString();\n    object.sidArray = [];\n\n    for (let i = 0; i < this.value.length; i++) object.sidArray.push(this.value[i].toJSON());\n\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass RelativeObjectIdentifier extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"RelativeObjectIdentifier\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalRelativeObjectIdentifierValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 13; // RELATIVE OBJECT IDENTIFIER\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"RelativeObjectIdentifier\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n\n/**\r\n * @extends LocalBaseBlock\r\n * @extends HexBlock\r\n */\n\n\nexports.RelativeObjectIdentifier = RelativeObjectIdentifier;\n\nclass LocalBmpStringValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalBmpStringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.isHexOnly = true;\n    this.value = \"\";\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BmpStringValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass BmpString extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"BmpString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalBmpStringValueBlock);\n    if (\"value\" in parameters) this.fromString(parameters.value);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 30; // BmpString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BmpString\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    //noinspection JSCheckFunctionSignatures\n    const copyBuffer = inputBuffer.slice(0);\n    const valueView = new Uint8Array(copyBuffer);\n\n    for (let i = 0; i < valueView.length; i += 2) {\n      const temp = valueView[i];\n      valueView[i] = valueView[i + 1];\n      valueView[i + 1] = temp;\n    }\n\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(copyBuffer));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    const strLength = inputString.length;\n    this.valueBlock.valueHex = new ArrayBuffer(strLength * 2);\n    const valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n    for (let i = 0; i < strLength; i++) {\n      const codeBuf = (0, _pvutils.utilToBase)(inputString.charCodeAt(i), 8);\n      const codeView = new Uint8Array(codeBuf);\n      if (codeView.length > 2) continue;\n      const dif = 2 - codeView.length;\n\n      for (let j = codeView.length - 1; j >= 0; j--) valueHexView[i * 2 + j + dif] = codeView[j];\n    }\n\n    this.valueBlock.value = inputString;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.BmpString = BmpString;\n\nclass LocalUniversalStringValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalUniversalStringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.isHexOnly = true;\n    this.value = \"\";\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"UniversalStringValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass UniversalString extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"UniversalString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalUniversalStringValueBlock);\n    if (\"value\" in parameters) this.fromString(parameters.value);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 28; // UniversalString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"UniversalString\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    //noinspection JSCheckFunctionSignatures\n    const copyBuffer = inputBuffer.slice(0);\n    const valueView = new Uint8Array(copyBuffer);\n\n    for (let i = 0; i < valueView.length; i += 4) {\n      valueView[i] = valueView[i + 3];\n      valueView[i + 1] = valueView[i + 2];\n      valueView[i + 2] = 0x00;\n      valueView[i + 3] = 0x00;\n    }\n\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    const strLength = inputString.length;\n    this.valueBlock.valueHex = new ArrayBuffer(strLength * 4);\n    const valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n    for (let i = 0; i < strLength; i++) {\n      const codeBuf = (0, _pvutils.utilToBase)(inputString.charCodeAt(i), 8);\n      const codeView = new Uint8Array(codeBuf);\n      if (codeView.length > 4) continue;\n      const dif = 4 - codeView.length;\n\n      for (let j = codeView.length - 1; j >= 0; j--) valueHexView[i * 4 + j + dif] = codeView[j];\n    }\n\n    this.valueBlock.value = inputString;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.UniversalString = UniversalString;\n\nclass LocalSimpleStringValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalSimpleStringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.value = \"\";\n    this.isHexOnly = true;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"SimpleStringValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass LocalSimpleStringBlock extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalSimpleStringBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalSimpleStringValueBlock);\n    if (\"value\" in parameters) this.fromString(parameters.value);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"SIMPLESTRING\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    const strLen = inputString.length;\n    this.valueBlock.valueHex = new ArrayBuffer(strLen);\n    const view = new Uint8Array(this.valueBlock.valueHex);\n\n    for (let i = 0; i < strLen; i++) view[i] = inputString.charCodeAt(i);\n\n    this.valueBlock.value = inputString;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nclass NumericString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"NumericString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 18; // NumericString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"NumericString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.NumericString = NumericString;\n\nclass PrintableString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"PrintableString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 19; // PrintableString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"PrintableString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.PrintableString = PrintableString;\n\nclass TeletexString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"TeletexString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 20; // TeletexString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"TeletexString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.TeletexString = TeletexString;\n\nclass VideotexString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"VideotexString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 21; // VideotexString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"VideotexString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.VideotexString = VideotexString;\n\nclass IA5String extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"IA5String\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 22; // IA5String\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"IA5String\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.IA5String = IA5String;\n\nclass GraphicString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"GraphicString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 25; // GraphicString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"GraphicString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.GraphicString = GraphicString;\n\nclass VisibleString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"VisibleString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 26; // VisibleString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"VisibleString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.VisibleString = VisibleString;\n\nclass GeneralString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"GeneralString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 27; // GeneralString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"GeneralString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.GeneralString = GeneralString;\n\nclass CharacterString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"CharacterString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 29; // CharacterString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"CharacterString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of all date and time classes\n//**************************************************************************************\n\n/**\r\n * @extends VisibleString\r\n */\n\n\nexports.CharacterString = CharacterString;\n\nclass UTCTime extends VisibleString {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"UTCTime\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {string} [value] String representatio of the date\r\n   * @property {Date} [valueDate] JavaScript \"Date\" object\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.year = 0;\n    this.month = 0;\n    this.day = 0;\n    this.hour = 0;\n    this.minute = 0;\n    this.second = 0; //region Create UTCTime from ASN.1 UTC string value\n\n    if (\"value\" in parameters) {\n      this.fromString(parameters.value);\n      this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n      const view = new Uint8Array(this.valueBlock.valueHex);\n\n      for (let i = 0; i < parameters.value.length; i++) view[i] = parameters.value.charCodeAt(i);\n    } //endregion\n    //region Create GeneralizedTime from JavaScript Date type\n\n\n    if (\"valueDate\" in parameters) {\n      this.fromDate(parameters.valueDate);\n      this.valueBlock.valueHex = this.toBuffer();\n    } //endregion\n\n\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 23; // UTCTime\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ASN.1 internal string into ArrayBuffer\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBuffer() {\n    const str = this.toString();\n    const buffer = new ArrayBuffer(str.length);\n    const view = new Uint8Array(buffer);\n\n    for (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);\n\n    return buffer;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting \"Date\" object into ASN.1 internal string\r\n   * @param {!Date} inputDate JavaScript \"Date\" object\r\n   */\n\n\n  fromDate(inputDate) {\n    this.year = inputDate.getUTCFullYear();\n    this.month = inputDate.getUTCMonth() + 1;\n    this.day = inputDate.getUTCDate();\n    this.hour = inputDate.getUTCHours();\n    this.minute = inputDate.getUTCMinutes();\n    this.second = inputDate.getUTCSeconds();\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Function converting ASN.1 internal string into \"Date\" object\r\n   * @returns {Date}\r\n   */\n\n\n  toDate() {\n    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    //region Parse input string\n    const parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\n    const parserArray = parser.exec(inputString);\n\n    if (parserArray === null) {\n      this.error = \"Wrong input string for convertion\";\n      return;\n    } //endregion\n    //region Store parsed values\n\n\n    const year = parseInt(parserArray[1], 10);\n    if (year >= 50) this.year = 1900 + year;else this.year = 2000 + year;\n    this.month = parseInt(parserArray[2], 10);\n    this.day = parseInt(parserArray[3], 10);\n    this.hour = parseInt(parserArray[4], 10);\n    this.minute = parseInt(parserArray[5], 10);\n    this.second = parseInt(parserArray[6], 10); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ASN.1 internal class into JavaScript string\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    const outputArray = new Array(7);\n    outputArray[0] = (0, _pvutils.padNumber)(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);\n    outputArray[1] = (0, _pvutils.padNumber)(this.month, 2);\n    outputArray[2] = (0, _pvutils.padNumber)(this.day, 2);\n    outputArray[3] = (0, _pvutils.padNumber)(this.hour, 2);\n    outputArray[4] = (0, _pvutils.padNumber)(this.minute, 2);\n    outputArray[5] = (0, _pvutils.padNumber)(this.second, 2);\n    outputArray[6] = \"Z\";\n    return outputArray.join(\"\");\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"UTCTime\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.year = this.year;\n    object.month = this.month;\n    object.day = this.day;\n    object.hour = this.hour;\n    object.minute = this.minute;\n    object.second = this.second;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends VisibleString\r\n */\n\n\nexports.UTCTime = UTCTime;\n\nclass GeneralizedTime extends VisibleString {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"GeneralizedTime\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {string} [value] String representatio of the date\r\n   * @property {Date} [valueDate] JavaScript \"Date\" object\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.year = 0;\n    this.month = 0;\n    this.day = 0;\n    this.hour = 0;\n    this.minute = 0;\n    this.second = 0;\n    this.millisecond = 0; //region Create UTCTime from ASN.1 UTC string value\n\n    if (\"value\" in parameters) {\n      this.fromString(parameters.value);\n      this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n      const view = new Uint8Array(this.valueBlock.valueHex);\n\n      for (let i = 0; i < parameters.value.length; i++) view[i] = parameters.value.charCodeAt(i);\n    } //endregion\n    //region Create GeneralizedTime from JavaScript Date type\n\n\n    if (\"valueDate\" in parameters) {\n      this.fromDate(parameters.valueDate);\n      this.valueBlock.valueHex = this.toBuffer();\n    } //endregion\n\n\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 24; // GeneralizedTime\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ASN.1 internal string into ArrayBuffer\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBuffer() {\n    const str = this.toString();\n    const buffer = new ArrayBuffer(str.length);\n    const view = new Uint8Array(buffer);\n\n    for (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);\n\n    return buffer;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting \"Date\" object into ASN.1 internal string\r\n   * @param {!Date} inputDate JavaScript \"Date\" object\r\n   */\n\n\n  fromDate(inputDate) {\n    this.year = inputDate.getUTCFullYear();\n    this.month = inputDate.getUTCMonth() + 1;\n    this.day = inputDate.getUTCDate();\n    this.hour = inputDate.getUTCHours();\n    this.minute = inputDate.getUTCMinutes();\n    this.second = inputDate.getUTCSeconds();\n    this.millisecond = inputDate.getUTCMilliseconds();\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Function converting ASN.1 internal string into \"Date\" object\r\n   * @returns {Date}\r\n   */\n\n\n  toDate() {\n    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    //region Initial variables\n    let isUTC = false;\n    let timeString = \"\";\n    let dateTimeString = \"\";\n    let fractionPart = 0;\n    let parser;\n    let hourDifference = 0;\n    let minuteDifference = 0; //endregion\n    //region Convert as UTC time\n\n    if (inputString[inputString.length - 1] === \"Z\") {\n      timeString = inputString.substr(0, inputString.length - 1);\n      isUTC = true;\n    } //endregion\n    //region Convert as local time\n    else {\n        //noinspection JSPrimitiveTypeWrapperUsage\n        const number = new Number(inputString[inputString.length - 1]);\n        if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n        timeString = inputString;\n      } //endregion\n    //region Check that we do not have a \"+\" and \"-\" symbols inside UTC time\n\n\n    if (isUTC) {\n      if (timeString.indexOf(\"+\") !== -1) throw new Error(\"Wrong input string for convertion\");\n      if (timeString.indexOf(\"-\") !== -1) throw new Error(\"Wrong input string for convertion\");\n    } //endregion\n    //region Get \"UTC time difference\" in case of local time\n    else {\n        let multiplier = 1;\n        let differencePosition = timeString.indexOf(\"+\");\n        let differenceString = \"\";\n\n        if (differencePosition === -1) {\n          differencePosition = timeString.indexOf(\"-\");\n          multiplier = -1;\n        }\n\n        if (differencePosition !== -1) {\n          differenceString = timeString.substr(differencePosition + 1);\n          timeString = timeString.substr(0, differencePosition);\n          if (differenceString.length !== 2 && differenceString.length !== 4) throw new Error(\"Wrong input string for convertion\"); //noinspection JSPrimitiveTypeWrapperUsage\n\n          let number = new Number(differenceString.substr(0, 2));\n          if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n          hourDifference = multiplier * number;\n\n          if (differenceString.length === 4) {\n            //noinspection JSPrimitiveTypeWrapperUsage\n            number = new Number(differenceString.substr(2, 2));\n            if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n            minuteDifference = multiplier * number;\n          }\n        }\n      } //endregion\n    //region Get position of fraction point\n\n\n    let fractionPointPosition = timeString.indexOf(\".\"); // Check for \"full stop\" symbol\n\n    if (fractionPointPosition === -1) fractionPointPosition = timeString.indexOf(\",\"); // Check for \"comma\" symbol\n    //endregion\n    //region Get fraction part\n\n    if (fractionPointPosition !== -1) {\n      //noinspection JSPrimitiveTypeWrapperUsage\n      const fractionPartCheck = new Number(`0${timeString.substr(fractionPointPosition)}`);\n      if (isNaN(fractionPartCheck.valueOf())) throw new Error(\"Wrong input string for convertion\");\n      fractionPart = fractionPartCheck.valueOf();\n      dateTimeString = timeString.substr(0, fractionPointPosition);\n    } else dateTimeString = timeString; //endregion\n    //region Parse internal date\n\n\n    switch (true) {\n      case dateTimeString.length === 8:\n        // \"YYYYMMDD\"\n        parser = /(\\d{4})(\\d{2})(\\d{2})/ig;\n        if (fractionPointPosition !== -1) throw new Error(\"Wrong input string for convertion\"); // Here we should not have a \"fraction point\"\n\n        break;\n\n      case dateTimeString.length === 10:\n        // \"YYYYMMDDHH\"\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n        if (fractionPointPosition !== -1) {\n          let fractionResult = 60 * fractionPart;\n          this.minute = Math.floor(fractionResult);\n          fractionResult = 60 * (fractionResult - this.minute);\n          this.second = Math.floor(fractionResult);\n          fractionResult = 1000 * (fractionResult - this.second);\n          this.millisecond = Math.floor(fractionResult);\n        }\n\n        break;\n\n      case dateTimeString.length === 12:\n        // \"YYYYMMDDHHMM\"\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n        if (fractionPointPosition !== -1) {\n          let fractionResult = 60 * fractionPart;\n          this.second = Math.floor(fractionResult);\n          fractionResult = 1000 * (fractionResult - this.second);\n          this.millisecond = Math.floor(fractionResult);\n        }\n\n        break;\n\n      case dateTimeString.length === 14:\n        // \"YYYYMMDDHHMMSS\"\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n        if (fractionPointPosition !== -1) {\n          const fractionResult = 1000 * fractionPart;\n          this.millisecond = Math.floor(fractionResult);\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Wrong input string for convertion\");\n    } //endregion\n    //region Put parsed values at right places\n\n\n    const parserArray = parser.exec(dateTimeString);\n    if (parserArray === null) throw new Error(\"Wrong input string for convertion\");\n\n    for (let j = 1; j < parserArray.length; j++) {\n      switch (j) {\n        case 1:\n          this.year = parseInt(parserArray[j], 10);\n          break;\n\n        case 2:\n          this.month = parseInt(parserArray[j], 10);\n          break;\n\n        case 3:\n          this.day = parseInt(parserArray[j], 10);\n          break;\n\n        case 4:\n          this.hour = parseInt(parserArray[j], 10) + hourDifference;\n          break;\n\n        case 5:\n          this.minute = parseInt(parserArray[j], 10) + minuteDifference;\n          break;\n\n        case 6:\n          this.second = parseInt(parserArray[j], 10);\n          break;\n\n        default:\n          throw new Error(\"Wrong input string for convertion\");\n      }\n    } //endregion\n    //region Get final date\n\n\n    if (isUTC === false) {\n      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n      this.year = tempDate.getUTCFullYear();\n      this.month = tempDate.getUTCMonth();\n      this.day = tempDate.getUTCDay();\n      this.hour = tempDate.getUTCHours();\n      this.minute = tempDate.getUTCMinutes();\n      this.second = tempDate.getUTCSeconds();\n      this.millisecond = tempDate.getUTCMilliseconds();\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ASN.1 internal class into JavaScript string\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    const outputArray = [];\n    outputArray.push((0, _pvutils.padNumber)(this.year, 4));\n    outputArray.push((0, _pvutils.padNumber)(this.month, 2));\n    outputArray.push((0, _pvutils.padNumber)(this.day, 2));\n    outputArray.push((0, _pvutils.padNumber)(this.hour, 2));\n    outputArray.push((0, _pvutils.padNumber)(this.minute, 2));\n    outputArray.push((0, _pvutils.padNumber)(this.second, 2));\n\n    if (this.millisecond !== 0) {\n      outputArray.push(\".\");\n      outputArray.push((0, _pvutils.padNumber)(this.millisecond, 3));\n    }\n\n    outputArray.push(\"Z\");\n    return outputArray.join(\"\");\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"GeneralizedTime\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.year = this.year;\n    object.month = this.month;\n    object.day = this.day;\n    object.hour = this.hour;\n    object.minute = this.minute;\n    object.second = this.second;\n    object.millisecond = this.millisecond;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends Utf8String\r\n */\n\n\nexports.GeneralizedTime = GeneralizedTime;\n\nclass DATE extends Utf8String {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"DATE\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 31; // DATE\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"DATE\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends Utf8String\r\n */\n\n\nexports.DATE = DATE;\n\nclass TimeOfDay extends Utf8String {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"TimeOfDay\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 32; // TimeOfDay\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"TimeOfDay\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends Utf8String\r\n */\n\n\nexports.TimeOfDay = TimeOfDay;\n\nclass DateTime extends Utf8String {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"DateTime\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 33; // DateTime\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"DateTime\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends Utf8String\r\n */\n\n\nexports.DateTime = DateTime;\n\nclass Duration extends Utf8String {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Duration\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 34; // Duration\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Duration\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends Utf8String\r\n */\n\n\nexports.Duration = Duration;\n\nclass TIME extends Utf8String {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Time\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 14; // Time\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"TIME\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Choice\n//**************************************************************************************\n\n\nexports.TIME = TIME;\n\nclass Choice {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Choice\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {Array} [value] Array of ASN.1 types for make a choice from\r\n   * @property {boolean} [optional]\r\n   */\n  constructor(parameters = {}) {\n    this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", []);\n    this.optional = (0, _pvutils.getParametersValue)(parameters, \"optional\", false);\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Any\n//**************************************************************************************\n\n\nexports.Choice = Choice;\n\nclass Any {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Any\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {string} [name]\r\n   * @property {boolean} [optional]\r\n   */\n  constructor(parameters = {}) {\n    this.name = (0, _pvutils.getParametersValue)(parameters, \"name\", \"\");\n    this.optional = (0, _pvutils.getParametersValue)(parameters, \"optional\", false);\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Repeated\n//**************************************************************************************\n\n\nexports.Any = Any;\n\nclass Repeated {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Repeated\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {string} [name]\r\n   * @property {boolean} [optional]\r\n   */\n  constructor(parameters = {}) {\n    this.name = (0, _pvutils.getParametersValue)(parameters, \"name\", \"\");\n    this.optional = (0, _pvutils.getParametersValue)(parameters, \"optional\", false);\n    this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", new Any());\n    this.local = (0, _pvutils.getParametersValue)(parameters, \"local\", false); // Could local or global array to store elements\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type RawData\n//**************************************************************************************\n\n/**\r\n * @description Special class providing ability to have \"toBER/fromBER\" for raw ArrayBuffer\r\n */\n\n\nexports.Repeated = Repeated;\n\nclass RawData {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Repeated\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {string} [name]\r\n   * @property {boolean} [optional]\r\n   */\n  constructor(parameters = {}) {\n    this.data = (0, _pvutils.getParametersValue)(parameters, \"data\", new ArrayBuffer(0));\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.data = inputBuffer.slice(inputOffset, inputLength);\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    return this.data;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major ASN.1 BER decoding function\n//**************************************************************************************\n\n/**\r\n * Internal library function for decoding ASN.1 BER\r\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n * @returns {{offset: number, result: Object}}\r\n */\n\n\nexports.RawData = RawData;\n\nfunction LocalFromBER(inputBuffer, inputOffset, inputLength) {\n  const incomingOffset = inputOffset; // Need to store initial offset since \"inputOffset\" is changing in the function\n  //region Local function changing a type for ASN.1 classes\n\n  function localChangeType(inputObject, newType) {\n    if (inputObject instanceof newType) return inputObject;\n    const newObject = new newType();\n    newObject.idBlock = inputObject.idBlock;\n    newObject.lenBlock = inputObject.lenBlock;\n    newObject.warnings = inputObject.warnings; //noinspection JSCheckFunctionSignatures\n\n    newObject.valueBeforeDecode = inputObject.valueBeforeDecode.slice(0);\n    return newObject;\n  } //endregion\n  //region Create a basic ASN.1 type since we need to return errors and warnings from the function\n\n\n  let returnObject = new BaseBlock({}, Object); //endregion\n  //region Basic check for parameters\n\n  const baseBlock = new LocalBaseBlock();\n\n  if ((0, _pvutils.checkBufferParams)(baseBlock, inputBuffer, inputOffset, inputLength) === false) {\n    returnObject.error = baseBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  } //endregion\n  //region Getting Uint8Array from ArrayBuffer\n\n\n  const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n  //region Initial checks\n\n  if (intBuffer.length === 0) {\n    this.error = \"Zero buffer length\";\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  } //endregion\n  //region Decode indentifcation block of ASN.1 BER structure\n\n\n  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\n  returnObject.warnings.concat(returnObject.idBlock.warnings);\n\n  if (resultOffset === -1) {\n    returnObject.error = returnObject.idBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n\n  inputOffset = resultOffset;\n  inputLength -= returnObject.idBlock.blockLength; //endregion\n  //region Decode length block of ASN.1 BER structure\n\n  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\n  returnObject.warnings.concat(returnObject.lenBlock.warnings);\n\n  if (resultOffset === -1) {\n    returnObject.error = returnObject.lenBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n\n  inputOffset = resultOffset;\n  inputLength -= returnObject.lenBlock.blockLength; //endregion\n  //region Check for usign indefinite length form in encoding for primitive types\n\n  if (returnObject.idBlock.isConstructed === false && returnObject.lenBlock.isIndefiniteForm === true) {\n    returnObject.error = \"Indefinite length form used for primitive encoding form\";\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  } //endregion\n  //region Switch ASN.1 block type\n\n\n  let newASN1Type = BaseBlock;\n\n  switch (returnObject.idBlock.tagClass) {\n    //region UNIVERSAL\n    case 1:\n      //region Check for reserved tag numbers\n      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {\n        returnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\n        return {\n          offset: -1,\n          result: returnObject\n        };\n      } //endregion\n\n\n      switch (returnObject.idBlock.tagNumber) {\n        //region EndOfContent type\n        case 0:\n          //region Check for EndOfContent type\n          if (returnObject.idBlock.isConstructed === true && returnObject.lenBlock.length > 0) {\n            returnObject.error = \"Type [UNIVERSAL 0] is reserved\";\n            return {\n              offset: -1,\n              result: returnObject\n            };\n          } //endregion\n\n\n          newASN1Type = EndOfContent;\n          break;\n        //endregion\n        //region Boolean type\n\n        case 1:\n          newASN1Type = Boolean;\n          break;\n        //endregion\n        //region Integer type\n\n        case 2:\n          newASN1Type = Integer;\n          break;\n        //endregion\n        //region BitString type\n\n        case 3:\n          newASN1Type = BitString;\n          break;\n        //endregion\n        //region OctetString type\n\n        case 4:\n          newASN1Type = OctetString;\n          break;\n        //endregion\n        //region Null type\n\n        case 5:\n          newASN1Type = Null;\n          break;\n        //endregion\n        //region OBJECT IDENTIFIER type\n\n        case 6:\n          newASN1Type = ObjectIdentifier;\n          break;\n        //endregion\n        //region Enumerated type\n\n        case 10:\n          newASN1Type = Enumerated;\n          break;\n        //endregion\n        //region Utf8String type\n\n        case 12:\n          newASN1Type = Utf8String;\n          break;\n        //endregion\n        //region Time type\n        //region RELATIVE OBJECT IDENTIFIER type\n\n        case 13:\n          newASN1Type = RelativeObjectIdentifier;\n          break;\n        //endregion\n\n        case 14:\n          newASN1Type = TIME;\n          break;\n        //endregion\n        //region ASN.1 reserved type\n\n        case 15:\n          returnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\n          return {\n            offset: -1,\n            result: returnObject\n          };\n        //endregion\n        //region Sequence type\n\n        case 16:\n          newASN1Type = Sequence;\n          break;\n        //endregion\n        //region Set type\n\n        case 17:\n          newASN1Type = Set;\n          break;\n        //endregion\n        //region NumericString type\n\n        case 18:\n          newASN1Type = NumericString;\n          break;\n        //endregion\n        //region PrintableString type\n\n        case 19:\n          newASN1Type = PrintableString;\n          break;\n        //endregion\n        //region TeletexString type\n\n        case 20:\n          newASN1Type = TeletexString;\n          break;\n        //endregion\n        //region VideotexString type\n\n        case 21:\n          newASN1Type = VideotexString;\n          break;\n        //endregion\n        //region IA5String type\n\n        case 22:\n          newASN1Type = IA5String;\n          break;\n        //endregion\n        //region UTCTime type\n\n        case 23:\n          newASN1Type = UTCTime;\n          break;\n        //endregion\n        //region GeneralizedTime type\n\n        case 24:\n          newASN1Type = GeneralizedTime;\n          break;\n        //endregion\n        //region GraphicString type\n\n        case 25:\n          newASN1Type = GraphicString;\n          break;\n        //endregion\n        //region VisibleString type\n\n        case 26:\n          newASN1Type = VisibleString;\n          break;\n        //endregion\n        //region GeneralString type\n\n        case 27:\n          newASN1Type = GeneralString;\n          break;\n        //endregion\n        //region UniversalString type\n\n        case 28:\n          newASN1Type = UniversalString;\n          break;\n        //endregion\n        //region CharacterString type\n\n        case 29:\n          newASN1Type = CharacterString;\n          break;\n        //endregion\n        //region BmpString type\n\n        case 30:\n          newASN1Type = BmpString;\n          break;\n        //endregion\n        //region DATE type\n\n        case 31:\n          newASN1Type = DATE;\n          break;\n        //endregion\n        //region TimeOfDay type\n\n        case 32:\n          newASN1Type = TimeOfDay;\n          break;\n        //endregion\n        //region Date-Time type\n\n        case 33:\n          newASN1Type = DateTime;\n          break;\n        //endregion\n        //region Duration type\n\n        case 34:\n          newASN1Type = Duration;\n          break;\n        //endregion\n        //region default\n\n        default:\n          {\n            let newObject;\n            if (returnObject.idBlock.isConstructed === true) newObject = new Constructed();else newObject = new Primitive();\n            newObject.idBlock = returnObject.idBlock;\n            newObject.lenBlock = returnObject.lenBlock;\n            newObject.warnings = returnObject.warnings;\n            returnObject = newObject;\n            resultOffset = returnObject.fromBER(inputBuffer, inputOffset, inputLength);\n          }\n        //endregion\n      }\n\n      break;\n    //endregion\n    //region All other tag classes\n\n    case 2: // APPLICATION\n\n    case 3: // CONTEXT-SPECIFIC\n\n    case 4: // PRIVATE\n\n    default:\n      {\n        if (returnObject.idBlock.isConstructed === true) newASN1Type = Constructed;else newASN1Type = Primitive;\n      }\n    //endregion\n  } //endregion\n  //region Change type and perform BER decoding\n\n\n  returnObject = localChangeType(returnObject, newASN1Type);\n  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm === true ? inputLength : returnObject.lenBlock.length); //endregion\n  //region Coping incoming buffer for entire ASN.1 block\n\n  returnObject.valueBeforeDecode = inputBuffer.slice(incomingOffset, incomingOffset + returnObject.blockLength); //endregion\n\n  return {\n    offset: resultOffset,\n    result: returnObject\n  };\n} //**************************************************************************************\n\n/**\r\n * Major function for decoding ASN.1 BER array into internal library structuries\r\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array of bytes\r\n */\n\n\nfunction fromBER(inputBuffer) {\n  if (inputBuffer.byteLength === 0) {\n    const result = new BaseBlock({}, Object);\n    result.error = \"Input buffer has zero length\";\n    return {\n      offset: -1,\n      result\n    };\n  }\n\n  return LocalFromBER(inputBuffer, 0, inputBuffer.byteLength);\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major scheme verification function\n//**************************************************************************************\n\n/**\r\n * Compare of two ASN.1 object trees\r\n * @param {!Object} root Root of input ASN.1 object tree\r\n * @param {!Object} inputData Input ASN.1 object tree\r\n * @param {!Object} inputSchema Input ASN.1 schema to compare with\r\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\r\n */\n\n\nfunction compareSchema(root, inputData, inputSchema) {\n  //region Special case for Choice schema element type\n  if (inputSchema instanceof Choice) {\n    const choiceResult = false;\n\n    for (let j = 0; j < inputSchema.value.length; j++) {\n      const result = compareSchema(root, inputData, inputSchema.value[j]);\n\n      if (result.verified === true) {\n        return {\n          verified: true,\n          result: root\n        };\n      }\n    }\n\n    if (choiceResult === false) {\n      const _result = {\n        verified: false,\n        result: {\n          error: \"Wrong values for Choice type\"\n        }\n      };\n      if (inputSchema.hasOwnProperty(\"name\")) _result.name = inputSchema.name;\n      return _result;\n    }\n  } //endregion\n  //region Special case for Any schema element type\n\n\n  if (inputSchema instanceof Any) {\n    //region Add named component of ASN.1 schema\n    if (inputSchema.hasOwnProperty(\"name\")) root[inputSchema.name] = inputData; //endregion\n\n    return {\n      verified: true,\n      result: root\n    };\n  } //endregion\n  //region Initial check\n\n\n  if (root instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong root object\"\n      }\n    };\n  }\n\n  if (inputData instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 data\"\n      }\n    };\n  }\n\n  if (inputSchema instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (\"idBlock\" in inputSchema === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  } //endregion\n  //region Comparing idBlock properties in ASN.1 data and ASN.1 schema\n  //region Encode and decode ASN.1 schema idBlock\n  /// <remarks>This encoding/decoding is neccessary because could be an errors in schema definition</remarks>\n\n\n  if (\"fromBER\" in inputSchema.idBlock === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (\"toBER\" in inputSchema.idBlock === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  const encodedId = inputSchema.idBlock.toBER(false);\n\n  if (encodedId.byteLength === 0) {\n    return {\n      verified: false,\n      result: {\n        error: \"Error encoding idBlock for ASN.1 schema\"\n      }\n    };\n  }\n\n  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\n\n  if (decodedOffset === -1) {\n    return {\n      verified: false,\n      result: {\n        error: \"Error decoding idBlock for ASN.1 schema\"\n      }\n    };\n  } //endregion\n  //region tagClass\n\n\n  if (inputSchema.idBlock.hasOwnProperty(\"tagClass\") === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region tagNumber\n\n\n  if (inputSchema.idBlock.hasOwnProperty(\"tagNumber\") === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region isConstructed\n\n\n  if (inputSchema.idBlock.hasOwnProperty(\"isConstructed\") === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region isHexOnly\n\n\n  if (\"isHexOnly\" in inputSchema.idBlock === false) // Since 'isHexOnly' is an inhirited property\n    {\n      return {\n        verified: false,\n        result: {\n          error: \"Wrong ASN.1 schema\"\n        }\n      };\n    }\n\n  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region valueHex\n\n\n  if (inputSchema.idBlock.isHexOnly === true) {\n    if (\"valueHex\" in inputSchema.idBlock === false) // Since 'valueHex' is an inhirited property\n      {\n        return {\n          verified: false,\n          result: {\n            error: \"Wrong ASN.1 schema\"\n          }\n        };\n      }\n\n    const schemaView = new Uint8Array(inputSchema.idBlock.valueHex);\n    const asn1View = new Uint8Array(inputData.idBlock.valueHex);\n\n    if (schemaView.length !== asn1View.length) {\n      return {\n        verified: false,\n        result: root\n      };\n    }\n\n    for (let i = 0; i < schemaView.length; i++) {\n      if (schemaView[i] !== asn1View[1]) {\n        return {\n          verified: false,\n          result: root\n        };\n      }\n    }\n  } //endregion\n  //endregion\n  //region Add named component of ASN.1 schema\n\n\n  if (inputSchema.hasOwnProperty(\"name\")) {\n    inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n    if (inputSchema.name !== \"\") root[inputSchema.name] = inputData;\n  } //endregion\n  //region Getting next ASN.1 block for comparition\n\n\n  if (inputSchema.idBlock.isConstructed === true) {\n    let admission = 0;\n    let result = {\n      verified: false\n    };\n    let maxLength = inputSchema.valueBlock.value.length;\n\n    if (maxLength > 0) {\n      if (inputSchema.valueBlock.value[0] instanceof Repeated) maxLength = inputData.valueBlock.value.length;\n    } //region Special case when constructive value has no elements\n\n\n    if (maxLength === 0) {\n      return {\n        verified: true,\n        result: root\n      };\n    } //endregion\n    //region Special case when \"inputData\" has no values and \"inputSchema\" has all optional values\n\n\n    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {\n      let _optional = true;\n\n      for (let i = 0; i < inputSchema.valueBlock.value.length; i++) _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\n\n      if (_optional === true) {\n        return {\n          verified: true,\n          result: root\n        };\n      } //region Delete early added name of block\n\n\n      if (inputSchema.hasOwnProperty(\"name\")) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n        if (inputSchema.name !== \"\") delete root[inputSchema.name];\n      } //endregion\n\n\n      root.error = \"Inconsistent object length\";\n      return {\n        verified: false,\n        result: root\n      };\n    } //endregion\n\n\n    for (let i = 0; i < maxLength; i++) {\n      //region Special case when there is an \"optional\" element of ASN.1 schema at the end\n      if (i - admission >= inputData.valueBlock.value.length) {\n        if (inputSchema.valueBlock.value[i].optional === false) {\n          const _result = {\n            verified: false,\n            result: root\n          };\n          root.error = \"Inconsistent length between ASN.1 data and schema\"; //region Delete early added name of block\n\n          if (inputSchema.hasOwnProperty(\"name\")) {\n            inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\n            if (inputSchema.name !== \"\") {\n              delete root[inputSchema.name];\n              _result.name = inputSchema.name;\n            }\n          } //endregion\n\n\n          return _result;\n        }\n      } //endregion\n      else {\n          //region Special case for Repeated type of ASN.1 schema element\n          if (inputSchema.valueBlock.value[0] instanceof Repeated) {\n            result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\n\n            if (result.verified === false) {\n              if (inputSchema.valueBlock.value[0].optional === true) admission++;else {\n                //region Delete early added name of block\n                if (inputSchema.hasOwnProperty(\"name\")) {\n                  inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n                  if (inputSchema.name !== \"\") delete root[inputSchema.name];\n                } //endregion\n\n\n                return result;\n              }\n            }\n\n            if (\"name\" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {\n              let arrayRoot = {};\n              if (\"local\" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local === true) arrayRoot = inputData;else arrayRoot = root;\n              if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\") arrayRoot[inputSchema.valueBlock.value[0].name] = [];\n              arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\n            }\n          } //endregion\n          else {\n              result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\n\n              if (result.verified === false) {\n                if (inputSchema.valueBlock.value[i].optional === true) admission++;else {\n                  //region Delete early added name of block\n                  if (inputSchema.hasOwnProperty(\"name\")) {\n                    inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n                    if (inputSchema.name !== \"\") delete root[inputSchema.name];\n                  } //endregion\n\n\n                  return result;\n                }\n              }\n            }\n        }\n    }\n\n    if (result.verified === false) // The situation may take place if last element is \"optional\" and verification failed\n      {\n        const _result = {\n          verified: false,\n          result: root\n        }; //region Delete early added name of block\n\n        if (inputSchema.hasOwnProperty(\"name\")) {\n          inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\n          if (inputSchema.name !== \"\") {\n            delete root[inputSchema.name];\n            _result.name = inputSchema.name;\n          }\n        } //endregion\n\n\n        return _result;\n      }\n\n    return {\n      verified: true,\n      result: root\n    };\n  } //endregion\n  //region Ability to parse internal value for primitive-encoded value (value of OctetString, for example)\n\n\n  if (\"primitiveSchema\" in inputSchema && \"valueHex\" in inputData.valueBlock) {\n    //region Decoding of raw ASN.1 data\n    const asn1 = fromBER(inputData.valueBlock.valueHex);\n\n    if (asn1.offset === -1) {\n      const _result = {\n        verified: false,\n        result: asn1.result\n      }; //region Delete early added name of block\n\n      if (inputSchema.hasOwnProperty(\"name\")) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\n        if (inputSchema.name !== \"\") {\n          delete root[inputSchema.name];\n          _result.name = inputSchema.name;\n        }\n      } //endregion\n\n\n      return _result;\n    } //endregion\n\n\n    return compareSchema(root, asn1.result, inputSchema.primitiveSchema);\n  }\n\n  return {\n    verified: true,\n    result: root\n  }; //endregion\n} //**************************************************************************************\n//noinspection JSUnusedGlobalSymbols\n\n/**\r\n * ASN.1 schema verification for ArrayBuffer data\r\n * @param {!ArrayBuffer} inputBuffer Input BER-encoded ASN.1 data\r\n * @param {!Object} inputSchema Input ASN.1 schema to verify against to\r\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\r\n */\n\n\nfunction verifySchema(inputBuffer, inputSchema) {\n  //region Initial check\n  if (inputSchema instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema type\"\n      }\n    };\n  } //endregion\n  //region Decoding of raw ASN.1 data\n\n\n  const asn1 = fromBER(inputBuffer);\n\n  if (asn1.offset === -1) {\n    return {\n      verified: false,\n      result: asn1.result\n    };\n  } //endregion\n  //region Compare ASN.1 struct with input schema\n\n\n  return compareSchema(asn1.result, asn1.result, inputSchema); //endregion\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major function converting JSON to ASN.1 objects\n//**************************************************************************************\n//noinspection JSUnusedGlobalSymbols\n\n/**\r\n * Converting from JSON to ASN.1 objects\r\n * @param {string|Object} json JSON string or object to convert to ASN.1 objects\r\n */\n\n\nfunction fromJSON(json) {} // TODO Implement\n//**************************************************************************************\n//endregion\n//**************************************************************************************","map":{"version":3,"sources":["../src/asn1.js"],"names":["powers2","digitsString","constructor","parameters","toJSON","blockName","blockLength","error","warnings","valueBeforeDecode","HexBlock","BaseClass","fromBER","intBuffer","inputBuffer","inputOffset","toBER","sizeOnly","object","firstOctet","retBuf","retView","number","encodedBuf","encodedView","size","i","curView","tagClassMask","tagNumberMask","count","tagNumberBufferMaxLength","intTagNumberBuffer","tempBuffer","tempBufferView","lengthBufferView","TypeError","valueBlockType","resultOffset","idBlockBuf","valueBlockSizeBuf","lenBlockBuf","valueBlockBuf","indefBuf","indefView","valueHexView","initialOffset","initialLength","indefiniteLength","currentOffset","checkLen","returnObject","LocalFromBER","inputLength","EndOfContent","valueBuf","paramaters","view","utilDecodeTC","LocalConstructedValueBlock","currentBlockName","OctetString","isEqual","octetString","JSON","BitString","bitString","_value","fromDER","expectedLength","offset","updatedValueHex","updatedView","toDER","toString","c","firstView","secondView","firstViewCopy","firstViewCopyLength","secondViewCopy","secondViewCopyLength","value","max","counter","n","p","digits","newValue","b","firstBit","bitNumber","asn1View","result","flag","byteNumber","currentByte","viewSub","power2","viewAdd","otherValue","convertToDER","integer","valueHex","convertFromDER","tempValueHex","tempView","sidValue","sidBlock","fromString","pos1","pos2","sid","string","plus","parsedSID","parseInt","isNaN","isHexOnly","sidStr","fromBuffer","String","decodeURIComponent","escape","ex","str","unescape","encodeURIComponent","strLen","copyBuffer","valueView","temp","strLength","inputString","codeBuf","codeView","dif","j","toBuffer","buffer","fromDate","inputDate","toDate","Date","parser","parserArray","year","outputArray","isUTC","timeString","dateTimeString","fractionPart","hourDifference","minuteDifference","multiplier","differencePosition","differenceString","fractionPointPosition","fractionPartCheck","fractionResult","Math","tempDate","incomingOffset","inputObject","newObject","baseBlock","newASN1Type","localChangeType","inputSchema","choiceResult","compareSchema","verified","root","_result","inputData","encodedId","decodedOffset","schemaView","admission","maxLength","_optional","arrayRoot","asn1"],"mappings":";;;;;;;;;;;AAkCA,IAAA,QAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAlCA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA;AAEA;AACA;AACA;;;AACA,MAAMA,OAAO,GAAG,CAAC,IAAA,UAAA,CAAe,CAAhC,CAAgC,CAAf,CAAD,CAAhB;AACA,MAAMC,YAAY,GAAlB,YAAA,C,CACA;AACA;AACA;AACA;AACA;;AACA;;;;;;;;;;AASA,MAAA,cAAA,CACA;AACC;;AACA;;;;;AAKAC,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC;;;AAGA,SAAA,WAAA,GAAmB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,aAAA,EAAnB,CAAmB,CAAnB;AACA;;;;AAGA,SAAA,KAAA,GAAa,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,OAAA,EAAb,EAAa,CAAb;AACA;;;;AAGA,SAAA,QAAA,GAAgB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,UAAA,EAZjB,EAYiB,CAAhB,CAZD,CAaC;;AACA;;;;AAGA,QAAG,uBAAH,UAAA,EACC,KAAA,iBAAA,GAAyBA,UAAU,CAAVA,iBAAAA,CAAAA,KAAAA,CAD1B,CAC0BA,CAAzB,CADD,KAGC,KAAA,iBAAA,GAAyB,IAAA,WAAA,CAAzB,CAAyB,CAAzB;AA5BH,GAAA,CA8BC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,WAAA;AArCF,GAAA,CAuCC;;AACA;;;;;;AAIAC,EAAAA,MAAM,GACN;AACC,WAAO;AACNC,MAAAA,SAAS,EAAE,KAAA,WAAA,CADL,SACK,EADL;AAENC,MAAAA,WAAW,EAAE,KAFP,WAAA;AAGNC,MAAAA,KAAK,EAAE,KAHD,KAAA;AAINC,MAAAA,QAAQ,EAAE,KAJJ,QAAA;AAKNC,MAAAA,iBAAiB,EAAE,CAAA,GAAA,QAAA,CAAA,gBAAA,EAAiB,KAAjB,iBAAA,EAAA,CAAA,EAA4C,KAAA,iBAAA,CAA5C,UAAA;AALb,KAAP;AA9CF,GAAA,CAsDC;;;AAtDD,C,CAwDA;AACA;AACA;AACA;AACA;;AACA;;;;;;;;;;;AAWA;;;AACO,MAAMC,QAAQ,GAAGC,SAAS,IAAI,MAAA,kBAAA,SAAA,SAAA,CACrC;AACC;AACA;;AACA;;;;;AAKAT,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA;;;;AAGA,SAAA,SAAA,GAAiB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,WAAA,EAAjB,KAAiB,CAAjB;AACA;;;;AAGA,QAAG,cAAH,UAAA,EACC,KAAA,QAAA,GAAgBA,UAAU,CAAVA,QAAAA,CAAAA,KAAAA,CADjB,CACiBA,CAAhB,CADD,KAGC,KAAA,QAAA,GAAgB,IAAA,WAAA,CAAhB,CAAgB,CAAhB;AAtBH,GAAA,CAwBC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,UAAA;AA/BF,GAAA,CAiCC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC;AACA;AACA,QAAG,CAAA,GAAA,QAAA,CAAA,iBAAA,EAAA,IAAA,EAAA,WAAA,EAAA,WAAA,EAAA,WAAA,MAAH,KAAA,EACC,OAAQ,CAJV,CAIE,CAJF,CAKC;AAEA;;AACA,UAAMC,SAAS,GAAG,IAAA,UAAA,CAAA,WAAA,EAAA,WAAA,EARnB,WAQmB,CAAlB,CARD,CASC;AAEA;;AACA,QAAGA,SAAS,CAATA,MAAAA,KAAH,CAAA,EACA;AACC,WAAA,QAAA,CAAA,IAAA,CAAA,oBAAA;AACA,aAAA,WAAA;AAfF,KAAA,CAiBC;AAEA;;;AACA,SAAA,QAAA,GAAgBC,WAAW,CAAXA,KAAAA,CAAAA,WAAAA,EAA+BC,WAAW,GApB3D,WAoBiBD,CAAhB,CApBD,CAqBC;;AAEA,SAAA,WAAA,GAAA,WAAA;AAEA,WAAQC,WAAW,GAAnB,WAAA;AAnEF,GAAA,CAqEC;;AACA;;;;;;;AAKAC,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC,QAAG,KAAA,SAAA,KAAH,IAAA,EACA;AACC,WAAA,KAAA,GAAA,sCAAA;AACA,aAAO,IAAA,WAAA,CAAP,CAAO,CAAP;AACA;;AAED,QAAGA,QAAQ,KAAX,IAAA,EACC,OAAO,IAAA,WAAA,CAAgB,KAAA,QAAA,CARzB,UAQS,CAAP,CARF,CAUC;;AACA,WAAO,KAAA,QAAA,CAAA,KAAA,CAAP,CAAO,CAAP;AAvFF,GAAA,CAyFC;;AACA;;;;;;AAIAb,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,SAAAA,GAAmB,KAAA,WAAA,CAAnBA,SAAmB,EAAnBA;AACAA,IAAAA,MAAM,CAANA,SAAAA,GAAmB,KAAnBA,SAAAA;AACAA,IAAAA,MAAM,CAANA,QAAAA,GAAkB,CAAA,GAAA,QAAA,CAAA,gBAAA,EAAiB,KAAjB,QAAA,EAAA,CAAA,EAAmC,KAAA,QAAA,CAArDA,UAAkB,CAAlBA;AAEA,WAAA,MAAA;AA9GF,GAAA,CAgHC;;;AAhHD,CADO,C,CAmHP;AACA;AACA;AACA;AACA;;;;;AACA,MAAA,wBAAA,SAAuCR,QAAQ,CAA/C,cAA+C,CAA/C,CACA;AACC;;AACA;;;;;AAKAR,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC;;AAEA,QAAG,aAAH,UAAA,EACA;AACC;AACA,WAAA,SAAA,GAAiB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAmBA,UAAU,CAA7B,OAAA,EAAA,WAAA,EAAjB,KAAiB,CAAjB;AACA,WAAA,QAAA,GAAgB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAmBA,UAAU,CAA7B,OAAA,EAAA,UAAA,EAAmD,IAAA,WAAA,CAHpE,CAGoE,CAAnD,CAAhB,CAHD,CAIC;;AAEA,WAAA,QAAA,GAAgB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAmBA,UAAU,CAA7B,OAAA,EAAA,UAAA,EAAoD,CAApE,CAAgB,CAAhB;AACA,WAAA,SAAA,GAAiB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAmBA,UAAU,CAA7B,OAAA,EAAA,WAAA,EAAqD,CAAtE,CAAiB,CAAjB;AACA,WAAA,aAAA,GAAqB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAmBA,UAAU,CAA7B,OAAA,EAAA,eAAA,EAArB,KAAqB,CAArB;AATD,KAAA,MAYA;AACC,WAAA,QAAA,GAAiB,CAAjB,CAAA;AACA,WAAA,SAAA,GAAkB,CAAlB,CAAA;AACA,WAAA,aAAA,GAAA,KAAA;AACA;AA3BH,GAAA,CA6BC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,qBAAA;AApCF,GAAA,CAsCC;;AACA;;;;;;;AAKAa,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC;AACA,QAAIE,UAAU,GAAd,CAAA;AACA,QAAA,MAAA;AACA,QAJD,OAIC,CAJD,CAKC;;AAEA,YAAO,KAAP,QAAA;AAEC,WAAA,CAAA;AACCA,QAAAA,UAAU,IADX,IACCA,CADD,CACqB;;AACpB;;AACD,WAAA,CAAA;AACCA,QAAAA,UAAU,IADX,IACCA,CADD,CACqB;;AACpB;;AACD,WAAA,CAAA;AACCA,QAAAA,UAAU,IADX,IACCA,CADD,CACqB;;AACpB;;AACD,WAAA,CAAA;AACCA,QAAAA,UAAU,IADX,IACCA,CADD,CACqB;;AACpB;;AACD;AACC,aAAA,KAAA,GAAA,mBAAA;AACA,eAAQ,IAAA,WAAA,CAAR,CAAQ,CAAR;AAhBF;;AAmBA,QAAG,KAAH,aAAA,EACCA,UAAU,IAAVA,IAAAA;;AAED,QAAI,KAAA,SAAA,GAAD,EAAC,IAAyB,CAAC,KAA9B,SAAA,EACA;AACCC,MAAAA,MAAM,GAAG,IAAA,WAAA,CAATA,CAAS,CAATA;AACAC,MAAAA,OAAO,GAAG,IAAA,UAAA,CAAVA,MAAU,CAAVA;;AAEA,UAAG,CAAH,QAAA,EACA;AACC,YAAIC,MAAM,GAAG,KAAb,SAAA;AACAA,QAAAA,MAAM,IAANA,IAAAA;AACAH,QAAAA,UAAU,IAAVA,MAAAA;AAEAE,QAAAA,OAAO,CAAPA,CAAO,CAAPA,GAAAA,UAAAA;AACA;;AAED,aAAA,MAAA;AACA;;AAED,QAAG,KAAA,SAAA,KAAH,KAAA,EACA;AACC,YAAME,UAAU,GAAG,CAAA,GAAA,QAAA,CAAA,UAAA,EAAW,KAAX,SAAA,EAAnB,CAAmB,CAAnB;AACA,YAAMC,WAAW,GAAG,IAAA,UAAA,CAApB,UAAoB,CAApB;AACA,YAAMC,IAAI,GAAGF,UAAU,CAAvB,UAAA;AAEAH,MAAAA,MAAM,GAAG,IAAA,WAAA,CAAgBK,IAAI,GAA7BL,CAAS,CAATA;AACAC,MAAAA,OAAO,GAAG,IAAA,UAAA,CAAVA,MAAU,CAAVA;AACAA,MAAAA,OAAO,CAAPA,CAAO,CAAPA,GAAcF,UAAU,GAAxBE,IAAAA;;AAEA,UAAG,CAAH,QAAA,EACA;AACC,aAAI,IAAIK,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAID,IAAI,GAAxB,CAAA,EAA+BC,CAA/B,EAAA,EACCL,OAAO,CAACK,CAAC,GAATL,CAAO,CAAPA,GAAiBG,WAAW,CAAXA,CAAW,CAAXA,GAAjBH,IAAAA;;AAEDA,QAAAA,OAAO,CAAPA,IAAO,CAAPA,GAAgBG,WAAW,CAACC,IAAI,GAAhCJ,CAA2B,CAA3BA;AACA;;AAED,aAAA,MAAA;AACA;;AAEDD,IAAAA,MAAM,GAAG,IAAA,WAAA,CAAgB,KAAA,QAAA,CAAA,UAAA,GAAzBA,CAAS,CAATA;AACAC,IAAAA,OAAO,GAAG,IAAA,UAAA,CAAVA,MAAU,CAAVA;AAEAA,IAAAA,OAAO,CAAPA,CAAO,CAAPA,GAAcF,UAAU,GAAxBE,IAAAA;;AAEA,QAAGJ,QAAQ,KAAX,KAAA,EACA;AACC,YAAMU,OAAO,GAAG,IAAA,UAAA,CAAe,KAA/B,QAAgB,CAAhB;;AAEA,WAAI,IAAID,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAIC,OAAO,CAAPA,MAAAA,GAApB,CAAA,EAAyCD,CAAzC,EAAA,EACCL,OAAO,CAACK,CAAC,GAATL,CAAO,CAAPA,GAAiBM,OAAO,CAAPA,CAAO,CAAPA,GAAjBN,IAAAA;;AAEDA,MAAAA,OAAO,CAAC,KAAA,QAAA,CAARA,UAAO,CAAPA,GAAoCM,OAAO,CAACA,OAAO,CAAPA,MAAAA,GAA5CN,CAA2C,CAA3CA;AACA;;AAED,WAAA,MAAA;AA/HF,GAAA,CAiIC;;AACA;;;;;;;;;AAOAT,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC;AACA;AACA,QAAG,CAAA,GAAA,QAAA,CAAA,iBAAA,EAAA,IAAA,EAAA,WAAA,EAAA,WAAA,EAAA,WAAA,MAAH,KAAA,EACC,OAAQ,CAJV,CAIE,CAJF,CAKC;AAEA;;AACA,UAAMC,SAAS,GAAG,IAAA,UAAA,CAAA,WAAA,EAAA,WAAA,EARnB,WAQmB,CAAlB,CARD,CASC;AAEA;;AACA,QAAGA,SAAS,CAATA,MAAAA,KAAH,CAAA,EACA;AACC,WAAA,KAAA,GAAA,oBAAA;AACA,aAAQ,CAAR,CAAA;AAfF,KAAA,CAiBC;AAEA;;;AACA,UAAMe,YAAY,GAAGf,SAAS,CAATA,CAAS,CAATA,GAArB,IAAA;;AAEA,YAAA,YAAA;AAEC,WAAA,IAAA;AACC,aAAA,QAAA,GADD,CACC,CADD,CACsB;;AACrB;;AACD,WAAA,IAAA;AACC,aAAA,QAAA,GADD,CACC,CADD,CACsB;;AACrB;;AACD,WAAA,IAAA;AACC,aAAA,QAAA,GADD,CACC,CADD,CACsB;;AACrB;;AACD,WAAA,IAAA;AACC,aAAA,QAAA,GADD,CACC,CADD,CACsB;;AACrB;;AACD;AACC,aAAA,KAAA,GAAA,mBAAA;AACA,eAAQ,CAAR,CAAA;AAhBF,KAtBD,CAwCC;AAEA;;;AACA,SAAA,aAAA,GAAqB,CAACA,SAAS,CAATA,CAAS,CAATA,GAAD,IAAA,MA3CtB,IA2CC,CA3CD,CA4CC;AAEA;;AACA,SAAA,SAAA,GAAA,KAAA;AAEA,UAAMgB,aAAa,GAAGhB,SAAS,CAATA,CAAS,CAATA,GAjDvB,IAiDC,CAjDD,CAmDC;;AACA,QAAGgB,aAAa,KAAhB,IAAA,EACA;AACC,WAAA,SAAA,GAAA,aAAA;AACA,WAAA,WAAA,GAAA,CAAA;AAHD,KAAA,CAKA;AACA;AANA,SAQA;AACC,YAAIC,KAAK,GAAT,CAAA;AAEA,aAAA,QAAA,GAAgB,IAAA,WAAA,CAAhB,GAAgB,CAAhB;AACA,YAAIC,wBAAwB,GAA5B,GAAA;AACA,YAAIC,kBAAkB,GAAG,IAAA,UAAA,CAAe,KALzC,QAK0B,CAAzB,CALD,CAOC;;AACA,eAAMnB,SAAS,CAATA,KAAS,CAATA,GAAN,IAAA,EACA;AACCmB,UAAAA,kBAAkB,CAACF,KAAK,GAAxBE,CAAkB,CAAlBA,GAAgCnB,SAAS,CAATA,KAAS,CAATA,GAAhCmB,IAAAA;AACAF,UAAAA,KAAK;;AAEL,cAAGA,KAAK,IAAIjB,SAAS,CAArB,MAAA,EACA;AACC,iBAAA,KAAA,GAAA,uDAAA;AACA,mBAAQ,CAAR,CAAA;AAPF,WAAA,CAUC;;;AACA,cAAGiB,KAAK,KAAR,wBAAA,EACA;AACCC,YAAAA,wBAAwB,IAAxBA,GAAAA;AAEA,kBAAME,UAAU,GAAG,IAAA,WAAA,CAAnB,wBAAmB,CAAnB;AACA,kBAAMC,cAAc,GAAG,IAAA,UAAA,CAAvB,UAAuB,CAAvB;;AAEA,iBAAI,IAAIR,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAGM,kBAAkB,CAArC,MAAA,EAA8CN,CAA9C,EAAA,EACCQ,cAAc,CAAdA,CAAc,CAAdA,GAAoBF,kBAAkB,CAAtCE,CAAsC,CAAtCA;;AAED,iBAAA,QAAA,GAAgB,IAAA,WAAA,CAAhB,wBAAgB,CAAhB;AACAF,YAAAA,kBAAkB,GAAG,IAAA,UAAA,CAAe,KAApCA,QAAqB,CAArBA;AAtBF,WAAA,CAwBC;;AACA;;AAED,aAAA,WAAA,GAAoBF,KAAK,GAAzB,CAAA;AACAE,QAAAA,kBAAkB,CAACF,KAAK,GAAxBE,CAAkB,CAAlBA,GAAgCnB,SAAS,CAATA,KAAS,CAATA,GArCjC,IAqCCmB,CArCD,CAqC0D;AAEzD;;AACA,cAAMC,UAAU,GAAG,IAAA,WAAA,CAAnB,KAAmB,CAAnB;AACA,cAAMC,cAAc,GAAG,IAAA,UAAA,CAAvB,UAAuB,CAAvB;;AAEA,aAAI,IAAIR,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAhB,KAAA,EAA0BA,CAA1B,EAAA,EACCQ,cAAc,CAAdA,CAAc,CAAdA,GAAoBF,kBAAkB,CAAtCE,CAAsC,CAAtCA;;AAED,aAAA,QAAA,GAAgB,IAAA,WAAA,CAAhB,KAAgB,CAAhB;AACAF,QAAAA,kBAAkB,GAAG,IAAA,UAAA,CAAe,KAApCA,QAAqB,CAArBA;AACAA,QAAAA,kBAAkB,CAAlBA,GAAAA,CAhDD,cAgDCA,EAhDD,CAiDC;AAEA;;AACA,YAAG,KAAA,WAAA,IAAH,CAAA,EACC,KAAA,SAAA,GAAiB,CAAA,GAAA,QAAA,CAAA,YAAA,EAAA,kBAAA,EADlB,CACkB,CAAjB,CADD,KAGA;AACC,eAAA,SAAA,GAAA,IAAA;AACA,eAAA,QAAA,CAAA,IAAA,CAAA,wCAAA;AAzDF,SAAA,CA2DC;AAvHF,OAAA,CAyHC;AACA;AAEA;;;AACA,QAAK,KAAA,QAAA,KAAF,CAAE,IACH,KADF,aAAA,EAEA;AACC,cAAO,KAAP,SAAA;AAEC,aAFD,CAEC,CAFD,CAEU;;AACT,aAHD,CAGC,CAHD,CAGU;;AACT,aAJD,CAIC,CAJD,CAIU;;AACT,aALD,CAKC,CALD,CAKU;;AACT,aAND,CAMC,CAND,CAMU;;AACT,aAPD,EAOC,CAPD,CAOU;;AACT,aARD,EAQC,CARD,CAQU;;AACT,aAAA,EAAA;AACA,aAAA,EAAA;AACA,aAAA,EAAA;AACA,aAAA,EAAA;AACA,aAAA,EAAA;AACA,aAAA,EAAA;AACC,eAAA,KAAA,GAAA,8CAAA;AACA,iBAAQ,CAAR,CAAA;;AACD;AAjBD;AAhIF,KAAA,CAoJC;;;AAEA,WAAQjB,WAAW,GAAG,KAtJvB,WAsJC,CAtJD,CAsJ0C;AAhS3C,GAAA,CAkSC;;AACA;;;;;;;;;;;;;;AAYAX,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,SAAAA,GAAmB,KAAA,WAAA,CAAnBA,SAAmB,EAAnBA;AACAA,IAAAA,MAAM,CAANA,QAAAA,GAAkB,KAAlBA,QAAAA;AACAA,IAAAA,MAAM,CAANA,SAAAA,GAAmB,KAAnBA,SAAAA;AACAA,IAAAA,MAAM,CAANA,aAAAA,GAAuB,KAAvBA,aAAAA;AAEA,WAAA,MAAA;AAhUF,GAAA,CAkUC;;;AAlUD,C,CAoUA;AACA;AACA;AACA;AACA;;;AACA,MAAA,gBAAA,SAAA,cAAA,CACA;AACC;;AACA;;;;;AAKAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC;;AAEA,QAAG,cAAH,UAAA,EACA;AACC,WAAA,gBAAA,GAAwB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAmBA,UAAU,CAA7B,QAAA,EAAA,kBAAA,EAAxB,KAAwB,CAAxB;AACA,WAAA,YAAA,GAAoB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAmBA,UAAU,CAA7B,QAAA,EAAA,cAAA,EAApB,KAAoB,CAApB;AACA,WAAA,MAAA,GAAc,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAmBA,UAAU,CAA7B,QAAA,EAAA,QAAA,EAAd,CAAc,CAAd;AAJD,KAAA,MAOA;AACC,WAAA,gBAAA,GAAA,KAAA;AACA,WAAA,YAAA,GAAA,KAAA;AACA,WAAA,MAAA,GAAA,CAAA;AACA;AAtBH,GAAA,CAwBC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,aAAA;AA/BF,GAAA,CAiCC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC;AACA;AACA,QAAG,CAAA,GAAA,QAAA,CAAA,iBAAA,EAAA,IAAA,EAAA,WAAA,EAAA,WAAA,EAAA,WAAA,MAAH,KAAA,EACC,OAAQ,CAJV,CAIE,CAJF,CAKC;AAEA;;AACA,UAAMC,SAAS,GAAG,IAAA,UAAA,CAAA,WAAA,EAAA,WAAA,EARnB,WAQmB,CAAlB,CARD,CASC;AAEA;;AACA,QAAGA,SAAS,CAATA,MAAAA,KAAH,CAAA,EACA;AACC,WAAA,KAAA,GAAA,oBAAA;AACA,aAAQ,CAAR,CAAA;AACA;;AAED,QAAGA,SAAS,CAATA,CAAS,CAATA,KAAH,IAAA,EACA;AACC,WAAA,KAAA,GAAA,2CAAA;AACA,aAAQ,CAAR,CAAA;AArBF,KAAA,CAuBC;AAEA;;;AACA,SAAA,gBAAA,GAAwBA,SAAS,CAATA,CAAS,CAATA,KA1BzB,IA0BC,CA1BD,CA2BC;AAEA;;AACA,QAAG,KAAA,gBAAA,KAAH,IAAA,EACA;AACC,WAAA,WAAA,GAAA,CAAA;AACA,aAAQE,WAAW,GAAG,KAAtB,WAAA;AAjCF,KAAA,CAmCC;AAEA;;;AACA,SAAA,YAAA,GAAoB,CAAC,EAAEF,SAAS,CAATA,CAAS,CAATA,GAtCxB,IAsCsB,CAArB,CAtCD,CAuCC;AAEA;;AACA,QAAG,KAAA,YAAA,KAAH,KAAA,EACA;AACC,WAAA,MAAA,GAAeA,SAAS,CAAxB,CAAwB,CAAxB;AACA,WAAA,WAAA,GAAA,CAAA;AACA,aAAQE,WAAW,GAAG,KAAtB,WAAA;AA9CF,KAAA,CAgDC;AAEA;;;AACA,UAAMe,KAAK,GAAGjB,SAAS,CAATA,CAAS,CAATA,GAAd,IAAA;;AAEA,QAAGiB,KAAK,GAAR,CAAA,EAAc;AACd;AACC,aAAA,KAAA,GAAA,iBAAA;AACA,eAAQ,CAAR,CAAA;AACA;;AAED,QAAIA,KAAK,GAAN,CAACA,GAAajB,SAAS,CAA1B,MAAA,EACA;AACC,WAAA,KAAA,GAAA,uDAAA;AACA,aAAQ,CAAR,CAAA;AACA;;AAED,UAAMsB,gBAAgB,GAAG,IAAA,UAAA,CAAzB,KAAyB,CAAzB;;AAEA,SAAI,IAAIT,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAhB,KAAA,EAA0BA,CAA1B,EAAA,EACCS,gBAAgB,CAAhBA,CAAgB,CAAhBA,GAAsBtB,SAAS,CAACa,CAAC,GAAjCS,CAA+B,CAA/BA;;AAED,QAAGA,gBAAgB,CAACL,KAAK,GAAtBK,CAAgB,CAAhBA,KAAH,IAAA,EACC,KAAA,QAAA,CAAA,IAAA,CAAA,gCAAA;AAED,SAAA,MAAA,GAAc,CAAA,GAAA,QAAA,CAAA,YAAA,EAAA,gBAAA,EAAd,CAAc,CAAd;AAEA,QAAG,KAAA,YAAA,IAAsB,KAAA,MAAA,IAAzB,GAAA,EACC,KAAA,QAAA,CAAA,IAAA,CAAA,uCAAA;AAED,SAAA,WAAA,GAAmBL,KAAK,GA9EzB,CA8EC,CA9ED,CA+EC;;AAEA,WAAQf,WAAW,GAAG,KAjFvB,WAiFC,CAjFD,CAiF0C;AA3H3C,GAAA,CA6HC;;AACA;;;;;;;AAKAC,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC;AACA,QAAA,MAAA;AACA,QAHD,OAGC,CAHD,CAIC;;AAEA,QAAG,KAAA,MAAA,GAAH,GAAA,EACC,KAAA,YAAA,GAAA,IAAA;;AAED,QAAG,KAAH,gBAAA,EACA;AACCG,MAAAA,MAAM,GAAG,IAAA,WAAA,CAATA,CAAS,CAATA;;AAEA,UAAGH,QAAQ,KAAX,KAAA,EACA;AACCI,QAAAA,OAAO,GAAG,IAAA,UAAA,CAAVA,MAAU,CAAVA;AACAA,QAAAA,OAAO,CAAPA,CAAO,CAAPA,GAAAA,IAAAA;AACA;;AAED,aAAA,MAAA;AACA;;AAED,QAAG,KAAA,YAAA,KAAH,IAAA,EACA;AACC,YAAME,UAAU,GAAG,CAAA,GAAA,QAAA,CAAA,UAAA,EAAW,KAAX,MAAA,EAAnB,CAAmB,CAAnB;;AAEA,UAAGA,UAAU,CAAVA,UAAAA,GAAH,GAAA,EACA;AACC,aAAA,KAAA,GAAA,gBAAA;AACA,eAAQ,IAAA,WAAA,CAAR,CAAQ,CAAR;AACA;;AAEDH,MAAAA,MAAM,GAAG,IAAA,WAAA,CAAgBG,UAAU,CAAVA,UAAAA,GAAzBH,CAAS,CAATA;AAEA,UAAGH,QAAQ,KAAX,IAAA,EACC,OAAA,MAAA;AAED,YAAMO,WAAW,GAAG,IAAA,UAAA,CAApB,UAAoB,CAApB;AACAH,MAAAA,OAAO,GAAG,IAAA,UAAA,CAAVA,MAAU,CAAVA;AAEAA,MAAAA,OAAO,CAAPA,CAAO,CAAPA,GAAaE,UAAU,CAAVA,UAAAA,GAAbF,IAAAA;;AAEA,WAAI,IAAIK,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAGH,UAAU,CAA7B,UAAA,EAA0CG,CAA1C,EAAA,EACCL,OAAO,CAACK,CAAC,GAATL,CAAO,CAAPA,GAAiBG,WAAW,CAA5BH,CAA4B,CAA5BA;;AAED,aAAA,MAAA;AACA;;AAEDD,IAAAA,MAAM,GAAG,IAAA,WAAA,CAATA,CAAS,CAATA;;AAEA,QAAGH,QAAQ,KAAX,KAAA,EACA;AACCI,MAAAA,OAAO,GAAG,IAAA,UAAA,CAAVA,MAAU,CAAVA;AAEAA,MAAAA,OAAO,CAAPA,CAAO,CAAPA,GAAa,KAAbA,MAAAA;AACA;;AAED,WAAA,MAAA;AA7LF,GAAA,CA+LC;;AACA;;;;;;AAIAjB,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,SAAAA,GAAmB,KAAA,WAAA,CAAnBA,SAAmB,EAAnBA;AACAA,IAAAA,MAAM,CAANA,gBAAAA,GAA0B,KAA1BA,gBAAAA;AACAA,IAAAA,MAAM,CAANA,YAAAA,GAAsB,KAAtBA,YAAAA;AACAA,IAAAA,MAAM,CAANA,MAAAA,GAAgB,KAAhBA,MAAAA;AAEA,WAAA,MAAA;AArNF,GAAA,CAuNC;;;AAvND,C,CAyNA;AACA;AACA;AACA;AACA;;;AACO,MAAA,UAAA,SAAA,cAAA,CACP;AACC;;AACA;;;;AAIAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AARF,GAAA,CAUC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,YAAA;AAjBF,GAAA,CAmBC;AACA;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC;AACA,UAAMwB,SAAS,CAFhB,+EAEgB,CAAf,CAFD,CAGC;AAhCF,GAAA,CAkCC;AACA;;AACA;;;;;;;AAKApB,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC;AACA,UAAMmB,SAAS,CAFhB,+EAEgB,CAAf,CAFD,CAGC;AA7CF,GAAA,CA+CC;;;AA/CD,C,CAiDA;AACA;AACA;AACA;AACA;;;;;AACO,MAAA,SAAA,SAAA,cAAA,CACP;AACC;;AACA;;;;;;;;AAQAlC,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EAAkBkC,cAAc,GAAhC,UAAA,EACX;AACC,UAAA,UAAA;AAEA,QAAG,UAAH,UAAA,EACC,KAAA,IAAA,GAAYlC,UAAU,CAAtB,IAAA;AACD,QAAG,cAAH,UAAA,EACC,KAAA,QAAA,GAAgBA,UAAU,CAA1B,QAAA;AACD,QAAG,qBAAH,UAAA,EACC,KAAA,eAAA,GAAuBA,UAAU,CAAjC,eAAA;AAED,SAAA,OAAA,GAAe,IAAA,wBAAA,CAAf,UAAe,CAAf;AACA,SAAA,QAAA,GAAgB,IAAA,gBAAA,CAAhB,UAAgB,CAAhB;AACA,SAAA,UAAA,GAAkB,IAAA,cAAA,CAAlB,UAAkB,CAAlB;AAvBF,GAAA,CAyBC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,WAAA;AAhCF,GAAA,CAkCC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC,UAAM0B,YAAY,GAAG,KAAA,UAAA,CAAA,OAAA,CAAA,WAAA,EAAA,WAAA,EAAmD,KAAA,QAAA,CAAA,gBAAA,KAAD,IAAC,GAAD,WAAC,GAAyD,KAAA,QAAA,CAAjI,MAAqB,CAArB;;AACA,QAAGA,YAAY,KAAM,CAArB,CAAA,EACA;AACC,WAAA,KAAA,GAAa,KAAA,UAAA,CAAb,KAAA;AACA,aAAA,YAAA;AACA;;AAED,QAAG,KAAA,OAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,OAAA,CAApB,WAAA;AAED,QAAG,KAAA,QAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,QAAA,CAApB,WAAA;AAED,QAAG,KAAA,UAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,UAAA,CAApB,WAAA;AAED,WAAA,YAAA;AA5DF,GAAA,CA8DC;;AACA;;;;;;;AAKAtB,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC,QAAA,MAAA;AAEA,UAAMsB,UAAU,GAAG,KAAA,OAAA,CAAA,KAAA,CAAnB,QAAmB,CAAnB;AACA,UAAMC,iBAAiB,GAAG,KAAA,UAAA,CAAA,KAAA,CAA1B,IAA0B,CAA1B;AAEA,SAAA,QAAA,CAAA,MAAA,GAAuBA,iBAAiB,CAAxC,UAAA;AACA,UAAMC,WAAW,GAAG,KAAA,QAAA,CAAA,KAAA,CAApB,QAAoB,CAApB;AAEArB,IAAAA,MAAM,GAAG,CAAA,GAAA,QAAA,CAAA,aAAA,EAAA,UAAA,EAATA,WAAS,CAATA;AAEA,QAAA,aAAA;AAEA,QAAGH,QAAQ,KAAX,KAAA,EACCyB,aAAa,GAAG,KAAA,UAAA,CAAA,KAAA,CADjB,QACiB,CAAhBA,CADD,KAGCA,aAAa,GAAG,IAAA,WAAA,CAAgB,KAAA,QAAA,CAAhCA,MAAgB,CAAhBA;AAEDtB,IAAAA,MAAM,GAAG,CAAA,GAAA,QAAA,CAAA,aAAA,EAAA,MAAA,EAATA,aAAS,CAATA;;AAEA,QAAG,KAAA,QAAA,CAAA,gBAAA,KAAH,IAAA,EACA;AACC,YAAMuB,QAAQ,GAAG,IAAA,WAAA,CAAjB,CAAiB,CAAjB;;AAEA,UAAG1B,QAAQ,KAAX,KAAA,EACA;AACC,cAAM2B,SAAS,GAAG,IAAA,UAAA,CAAlB,QAAkB,CAAlB;AAEAA,QAAAA,SAAS,CAATA,CAAS,CAATA,GAAAA,IAAAA;AACAA,QAAAA,SAAS,CAATA,CAAS,CAATA,GAAAA,IAAAA;AACA;;AAEDxB,MAAAA,MAAM,GAAG,CAAA,GAAA,QAAA,CAAA,aAAA,EAAA,MAAA,EAATA,QAAS,CAATA;AACA;;AAED,WAAA,MAAA;AAxGF,GAAA,CA0GC;;AACA;;;;;;AAIAhB,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,OAAAA,GAAiB,KAAA,OAAA,CAAjBA,MAAiB,EAAjBA;AACAA,IAAAA,MAAM,CAANA,QAAAA,GAAkB,KAAA,QAAA,CAAlBA,MAAkB,EAAlBA;AACAA,IAAAA,MAAM,CAANA,UAAAA,GAAoB,KAAA,UAAA,CAApBA,MAAoB,EAApBA;AAEA,QAAG,UAAH,IAAA,EACCA,MAAM,CAANA,IAAAA,GAAc,KAAdA,IAAAA;AACD,QAAG,cAAH,IAAA,EACCA,MAAM,CAANA,QAAAA,GAAkB,KAAlBA,QAAAA;AACD,QAAG,qBAAH,IAAA,EACCA,MAAM,CAANA,eAAAA,GAAyB,KAAA,eAAA,CAAzBA,MAAyB,EAAzBA;AAED,WAAA,MAAA;AAtIF,GAAA,CAwIC;;;AAxID,C,CA0IA;AACA;AACA;AACA;AACA;;;;;AACA,MAAA,wBAAA,SAAA,UAAA,CACA;AACC;;AACA;;;;;AAKAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UADD,UACC,EADD,CAGC;;AACA,QAAG,cAAH,UAAA,EACC,KAAA,QAAA,GAAgBA,UAAU,CAAVA,QAAAA,CAAAA,KAAAA,CADjB,CACiBA,CAAhB,CADD,KAGC,KAAA,QAAA,GAAgB,IAAA,WAAA,CAAhB,CAAgB,CAAhB;AAED,SAAA,SAAA,GAAiB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,WAAA,EATlB,IASkB,CAAjB,CATD,CAUC;AAlBF,GAAA,CAoBC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC;AACA;AACA,QAAG,CAAA,GAAA,QAAA,CAAA,iBAAA,EAAA,IAAA,EAAA,WAAA,EAAA,WAAA,EAAA,WAAA,MAAH,KAAA,EACC,OAAQ,CAJV,CAIE,CAJF,CAKC;AAEA;;AACA,UAAMC,SAAS,GAAG,IAAA,UAAA,CAAA,WAAA,EAAA,WAAA,EARnB,WAQmB,CAAlB,CARD,CASC;AAEA;;AACA,QAAGA,SAAS,CAATA,MAAAA,KAAH,CAAA,EACA;AACC,WAAA,QAAA,CAAA,IAAA,CAAA,oBAAA;AACA,aAAA,WAAA;AAfF,KAAA,CAiBC;AAEA;;;AACA,SAAA,QAAA,GAAgB,IAAA,WAAA,CAAgBA,SAAS,CAAzC,MAAgB,CAAhB;AACA,UAAMgC,YAAY,GAAG,IAAA,UAAA,CAAe,KAApC,QAAqB,CAArB;;AAEA,SAAI,IAAInB,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAGb,SAAS,CAA5B,MAAA,EAAqCa,CAArC,EAAA,EACCmB,YAAY,CAAZA,CAAY,CAAZA,GAAkBhC,SAAS,CAxB7B,CAwB6B,CAA3BgC,CAxBF,CAyBC;;;AAEA,SAAA,WAAA,GAAA,WAAA;AAEA,WAAQ9B,WAAW,GAAnB,WAAA;AA1DF,GAAA,CA4DC;AACA;;AACA;;;;;;;AAKAC,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC,WAAO,KAAA,QAAA,CAAA,KAAA,CAAP,CAAO,CAAP;AArEF,GAAA,CAuEC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,qBAAA;AA9EF,GAAA,CAgFC;;AACA;;;;;;AAIAb,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,QAAAA,GAAkB,CAAA,GAAA,QAAA,CAAA,gBAAA,EAAiB,KAAjB,QAAA,EAAA,CAAA,EAAmC,KAAA,QAAA,CAArDA,UAAkB,CAAlBA;AACAA,IAAAA,MAAM,CAANA,SAAAA,GAAmB,KAAnBA,SAAAA;AAEA,WAAA,MAAA;AApGF,GAAA,CAsGC;;;AAtGD,C,CAwGA;;;AACO,MAAA,SAAA,SAAA,SAAA,CACP;AACC;;AACA;;;;;AAKAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA,EAAA,wBAAA;AAEA,SAAA,OAAA,CAAA,aAAA,GAAA,KAAA;AAXF,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,WAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;AACA;AACA;AACA;AACA;;;;;AACA,MAAA,0BAAA,SAAA,UAAA,CACA;AACC;;AACA;;;;AAIAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,KAAA,GAAa,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,OAAA,EAAb,EAAa,CAAb;AACA,SAAA,gBAAA,GAAwB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,kBAAA,EAAxB,KAAwB,CAAxB;AAXF,GAAA,CAaC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC;AACA,UAAMkC,aAAa,GAAnB,WAAA;AACA,UAAMC,aAAa,GAHpB,WAGC,CAHD,CAIC;AAEA;AACA;;AACA,QAAG,CAAA,GAAA,QAAA,CAAA,iBAAA,EAAA,IAAA,EAAA,WAAA,EAAA,WAAA,EAAA,WAAA,MAAH,KAAA,EACC,OAAQ,CATV,CASE,CATF,CAUC;AAEA;;AACA,UAAMlC,SAAS,GAAG,IAAA,UAAA,CAAA,WAAA,EAAA,WAAA,EAbnB,WAamB,CAAlB,CAbD,CAcC;AAEA;;AACA,QAAGA,SAAS,CAATA,MAAAA,KAAH,CAAA,EACA;AACC,WAAA,QAAA,CAAA,IAAA,CAAA,oBAAA;AACA,aAAA,WAAA;AApBF,KAAA,CAsBC;AAEA;;;AACA,aAAA,QAAA,CAAA,gBAAA,EAAA,MAAA,EACA;AACC,UAAGmC,gBAAgB,KAAnB,IAAA,EACC,OAAA,CAAA;AAED,aAAA,MAAA;AA9BF,KAAA,CAgCC;;;AAEA,QAAIC,aAAa,GAAjB,WAAA;;AAEA,WAAMC,QAAQ,CAAC,KAAD,gBAAA,EAARA,WAAQ,CAARA,GAAN,CAAA,EACA;AACC,YAAMC,YAAY,GAAGC,YAAY,CAAA,WAAA,EAAA,aAAA,EAAjC,WAAiC,CAAjC;;AACA,UAAGD,YAAY,CAAZA,MAAAA,KAAyB,CAA5B,CAAA,EACA;AACC,aAAA,KAAA,GAAaA,YAAY,CAAZA,MAAAA,CAAb,KAAA;AACA,aAAA,QAAA,CAAA,MAAA,CAAqBA,YAAY,CAAZA,MAAAA,CAArB,QAAA;AACA,eAAQ,CAAR,CAAA;AACA;;AAEDF,MAAAA,aAAa,GAAGE,YAAY,CAA5BF,MAAAA;AAEA,WAAA,WAAA,IAAoBE,YAAY,CAAZA,MAAAA,CAApB,WAAA;AACAE,MAAAA,WAAW,IAAIF,YAAY,CAAZA,MAAAA,CAAfE,WAAAA;AAEA,WAAA,KAAA,CAAA,IAAA,CAAgBF,YAAY,CAA5B,MAAA;AAEA,UAAI,KAAA,gBAAA,KAAD,IAAC,IAAoCA,YAAY,CAAZA,MAAAA,CAAAA,WAAAA,CAAAA,SAAAA,OAAgDG,YAAY,CAApG,SAAwFA,EAAxF,EACC;AACD;;AAED,QAAG,KAAA,gBAAA,KAAH,IAAA,EACA;AACC,UAAG,KAAA,KAAA,CAAW,KAAA,KAAA,CAAA,MAAA,GAAX,CAAA,EAAA,WAAA,CAAA,SAAA,OAA8DA,YAAY,CAA7E,SAAiEA,EAAjE,EACC,KAAA,KAAA,CADD,GACC,GADD,KAGC,KAAA,QAAA,CAAA,IAAA,CAAA,+BAAA;AA9DH,KAAA,CAiEC;;;AACA,SAAA,iBAAA,GAAyBxC,WAAW,CAAXA,KAAAA,CAAAA,aAAAA,EAAiCgC,aAAa,GAlExE,aAkE0BhC,CAAzB,CAlED,CAmEC;;AAEA,WAAA,aAAA;AA3FF,GAAA,CA6FC;;AACA;;;;;;;AAKAE,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC,QAAIG,MAAM,GAAG,IAAA,WAAA,CAAb,CAAa,CAAb;;AAEA,SAAI,IAAIM,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAG,KAAA,KAAA,CAAnB,MAAA,EAAsCA,CAAtC,EAAA,EACA;AACC,YAAM6B,QAAQ,GAAG,KAAA,KAAA,CAAA,CAAA,EAAA,KAAA,CAAjB,QAAiB,CAAjB;AACAnC,MAAAA,MAAM,GAAG,CAAA,GAAA,QAAA,CAAA,aAAA,EAAA,MAAA,EAATA,QAAS,CAATA;AACA;;AAED,WAAA,MAAA;AA7GF,GAAA,CA+GC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,uBAAA;AAtHF,GAAA,CAwHC;;AACA;;;;;;AAIAhB,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,gBAAAA,GAA0B,KAA1BA,gBAAAA;AACAA,IAAAA,MAAM,CAANA,KAAAA,GAAAA,EAAAA;;AACA,SAAI,IAAIQ,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAG,KAAA,KAAA,CAAnB,MAAA,EAAsCA,CAAtC,EAAA,EACCR,MAAM,CAANA,KAAAA,CAAAA,IAAAA,CAAkB,KAAA,KAAA,CAAA,CAAA,EAAlBA,MAAkB,EAAlBA;;AAED,WAAA,MAAA;AA9IF,GAAA,CAgJC;;;AAhJD,C,CAkJA;;;AACO,MAAA,WAAA,SAAA,SAAA,CACP;AACC;;AACA;;;;AAIAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA,EAAA,0BAAA;AAEA,SAAA,OAAA,CAAA,aAAA,GAAA,IAAA;AAVF,GAAA,CAYC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,aAAA;AAnBF,GAAA,CAqBC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC,SAAA,UAAA,CAAA,gBAAA,GAAmC,KAAA,QAAA,CAAnC,gBAAA;AAEA,UAAM0B,YAAY,GAAG,KAAA,UAAA,CAAA,OAAA,CAAA,WAAA,EAAA,WAAA,EAAmD,KAAA,QAAA,CAAA,gBAAA,KAAD,IAAC,GAAD,WAAC,GAAyD,KAAA,QAAA,CAAjI,MAAqB,CAArB;;AACA,QAAGA,YAAY,KAAM,CAArB,CAAA,EACA;AACC,WAAA,KAAA,GAAa,KAAA,UAAA,CAAb,KAAA;AACA,aAAA,YAAA;AACA;;AAED,QAAG,KAAA,OAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,OAAA,CAApB,WAAA;AAED,QAAG,KAAA,QAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,QAAA,CAApB,WAAA;AAED,QAAG,KAAA,UAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,UAAA,CAApB,WAAA;AAED,WAAA,YAAA;AAjDF,GAAA,CAmDC;;;AAnDD,C,CAqDA;AACA;AACA;AACA;AACA;;;;;AACA,MAAA,2BAAA,SAAA,UAAA,CACA;AACC;;AACA;;;;AAIApC,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AARF,GAAA,CAUC;AACA;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC;AACA,WAFD,WAEC,CAFD,CAGC;AAvBF,GAAA,CAyBC;AACA;;AACA;;;;;;;AAKAI,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC,WAAO,IAAA,WAAA,CAAP,CAAO,CAAP;AAlCF,GAAA,CAoCC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,wBAAA;AA3CF,GAAA,CA6CC;;;AA7CD,C,CA+CA;;;AACO,MAAA,YAAA,SAAA,SAAA,CACP;AACC;AACAf,EAAAA,WAAW,CAACsD,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA,EAAA,2BAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,CAIC,CAJD,CAI6B;AAP9B,GAAA,CASC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,cAAA;AAhBF,GAAA,CAkBC;;;AAlBD,C,CAoBA;AACA;AACA;AACA;AACA;;;;;AACA,MAAA,sBAAA,SAAA,UAAA,CACA;AACC;;AACA;;;;AAIAtD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,KAAA,GAAa,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,OAAA,EAAb,KAAa,CAAb;AACA,SAAA,SAAA,GAAiB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,WAAA,EAAjB,KAAiB,CAAjB;AAEA,QAAG,cAAH,UAAA,EACC,KAAA,QAAA,GAAgBA,UAAU,CAAVA,QAAAA,CAAAA,KAAAA,CADjB,CACiBA,CAAhB,CADD,KAGA;AACC,WAAA,QAAA,GAAgB,IAAA,WAAA,CAAhB,CAAgB,CAAhB;;AACA,UAAG,KAAA,KAAA,KAAH,IAAA,EACA;AACC,cAAMsD,IAAI,GAAG,IAAA,UAAA,CAAe,KAA5B,QAAa,CAAb;AACAA,QAAAA,IAAI,CAAJA,CAAI,CAAJA,GAAAA,IAAAA;AACA;AACD;AAvBH,GAAA,CAyBC;;AACA;;;;;;;;;AAOA7C,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC;AACA;AACA,QAAG,CAAA,GAAA,QAAA,CAAA,iBAAA,EAAA,IAAA,EAAA,WAAA,EAAA,WAAA,EAAA,WAAA,MAAH,KAAA,EACC,OAAQ,CAJV,CAIE,CAJF,CAKC;AAEA;;AACA,UAAMC,SAAS,GAAG,IAAA,UAAA,CAAA,WAAA,EAAA,WAAA,EARnB,WAQmB,CAAlB,CARD,CASC;;AAEA,QAAGwC,WAAW,GAAd,CAAA,EACC,KAAA,QAAA,CAAA,IAAA,CAAA,4CAAA;AAED,SAAA,SAAA,GAdD,IAcC,CAdD,CAgBC;;AACA,SAAA,QAAA,GAAgB,IAAA,WAAA,CAAgBxC,SAAS,CAAzC,MAAgB,CAAhB;AACA,UAAM4C,IAAI,GAAG,IAAA,UAAA,CAAe,KAA5B,QAAa,CAAb;;AAEA,SAAI,IAAI/B,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAGb,SAAS,CAA5B,MAAA,EAAqCa,CAArC,EAAA,EACC+B,IAAI,CAAJA,CAAI,CAAJA,GAAU5C,SAAS,CArBrB,CAqBqB,CAAnB4C,CArBF,CAsBC;;;AAEA,QAAGC,QAAAA,CAAAA,YAAAA,CAAAA,IAAAA,CAAAA,IAAAA,MAAH,CAAA,EACC,KAAA,KAAA,GADD,IACC,CADD,KAGC,KAAA,KAAA,GAAA,KAAA;AAED,SAAA,WAAA,GAAA,WAAA;AAEA,WAAQ3C,WAAW,GAAnB,WAAA;AAjEF,GAAA,CAmEC;AACA;;AACA;;;;;;;AAKAC,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC,WAAO,KAAP,QAAA;AA5EF,GAAA,CA8EC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,mBAAA;AArFF,GAAA,CAuFC;;AACA;;;;;;AAIAb,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,KAAAA,GAAe,KAAfA,KAAAA;AACAA,IAAAA,MAAM,CAANA,SAAAA,GAAmB,KAAnBA,SAAAA;AACAA,IAAAA,MAAM,CAANA,QAAAA,GAAkB,CAAA,GAAA,QAAA,CAAA,gBAAA,EAAiB,KAAjB,QAAA,EAAA,CAAA,EAAmC,KAAA,QAAA,CAArDA,UAAkB,CAAlBA;AAEA,WAAA,MAAA;AA5GF,GAAA,CA8GC;;;AA9GD,C,CAgHA;;;AACO,MAAA,OAAA,SAAA,SAAA,CACP;AACC;;AACA;;;;AAIAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA,EAAA,sBAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,CAIC,CAJD,CAI6B;AAX9B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,SAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;AACA;AACA;AACA;AACA;;;;;AACO,MAAA,QAAA,SAAA,WAAA,CACP;AACC;;AACA;;;;AAIAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAX/B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,UAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;;;;;AACO,MAAA,GAAA,SAAA,WAAA,CACP;AACC;;AACA;;;;AAIAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAX/B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,KAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;AACA;AACA;AACA;AACA;;;;;AACO,MAAA,IAAA,SAAA,SAAA,CACP;AACC;;AACA;;;;AAIAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA,EADD,cACC,EADD,CACoC;;AAEnC,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,CAIC,CAJD,CAI6B;AAX9B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,MAAA;AApBF,GAAA,CAsBC;AACA;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC,QAAG,KAAA,QAAA,CAAA,MAAA,GAAH,CAAA,EACC,KAAA,QAAA,CAAA,IAAA,CAAA,8CAAA;AAED,QAAG,KAAA,OAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,OAAA,CAApB,WAAA;AAED,QAAG,KAAA,QAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,QAAA,CAApB,WAAA;AAED,SAAA,WAAA,IAAA,WAAA;;AAEA,QAAIG,WAAW,GAAZ,WAACA,GAA6BD,WAAW,CAA5C,UAAA,EACA;AACC,WAAA,KAAA,GAAA,+FAAA;AACA,aAAQ,CAAR,CAAA;AACA;;AAED,WAAQC,WAAW,GAAnB,WAAA;AAlDF,GAAA,CAoDC;;AACA;;;;;;;AAKAC,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC,UAAMG,MAAM,GAAG,IAAA,WAAA,CAAf,CAAe,CAAf;AAEA,QAAGH,QAAQ,KAAX,IAAA,EACC,OAAA,MAAA;AAED,UAAMI,OAAO,GAAG,IAAA,UAAA,CAAhB,MAAgB,CAAhB;AACAA,IAAAA,OAAO,CAAPA,CAAO,CAAPA,GAAAA,IAAAA;AACAA,IAAAA,OAAO,CAAPA,CAAO,CAAPA,GAAAA,IAAAA;AAEA,WAAA,MAAA;AArEF,GAAA,CAuEC;;;AAvED,C,CAyEA;AACA;AACA;AACA;AACA;;;;;AACA,MAAA,0BAAA,SAAyCX,QAAQ,CAAjD,0BAAiD,CAAjD,CACA;AACC;;AACA;;;;;AAKAR,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,aAAA,GAAqB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,eAAA,EAArB,KAAqB,CAArB;AAXF,GAAA,CAaC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC,QAAI0B,YAAY,GAAhB,CAAA;;AAEA,QAAG,KAAA,aAAA,KAAH,IAAA,EACA;AACC,WAAA,SAAA,GAAA,KAAA;AAEAA,MAAAA,YAAY,GAAGqB,0BAA0B,CAA1BA,SAAAA,CAAAA,OAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,WAAAA,EAAAA,WAAAA,EAAfrB,WAAeqB,CAAfrB;AACA,UAAGA,YAAY,KAAM,CAArB,CAAA,EACC,OAAA,YAAA;;AAED,WAAI,IAAIZ,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAG,KAAA,KAAA,CAAnB,MAAA,EAAsCA,CAAtC,EAAA,EACA;AACC,cAAMkC,gBAAgB,GAAG,KAAA,KAAA,CAAA,CAAA,EAAA,WAAA,CAAzB,SAAyB,EAAzB;;AAEA,YAAGA,gBAAgB,KAAKN,YAAY,CAApC,SAAwBA,EAAxB,EACA;AACC,cAAG,KAAA,gBAAA,KAAH,IAAA,EAAA,MAAA,KAGA;AACC,iBAAA,KAAA,GAAA,6EAAA;AACA,mBAAQ,CAAR,CAAA;AACA;AACD;;AAED,YAAGM,gBAAgB,KAAKC,WAAW,CAAnC,SAAwBA,EAAxB,EACA;AACC,eAAA,KAAA,GAAA,iDAAA;AACA,iBAAQ,CAAR,CAAA;AACA;AACD;AA5BF,KAAA,MA+BA;AACC,WAAA,SAAA,GAAA,IAAA;AAEAvB,MAAAA,YAAY,GAAG,MAAA,OAAA,CAAA,WAAA,EAAA,WAAA,EAAfA,WAAe,CAAfA;AACA,WAAA,WAAA,GAAA,WAAA;AACA;;AAED,WAAA,YAAA;AA/DF,GAAA,CAiEC;;AACA;;;;;;;AAKAtB,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC,QAAG,KAAA,aAAA,KAAH,IAAA,EACC,OAAO0C,0BAA0B,CAA1BA,SAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAP,QAAOA,CAAP;AAED,QAAIvC,MAAM,GAAG,IAAA,WAAA,CAAgB,KAAA,QAAA,CAA7B,UAAa,CAAb;AAEA,QAAGH,QAAQ,KAAX,IAAA,EACC,OAAA,MAAA;AAED,QAAG,KAAA,QAAA,CAAA,UAAA,KAAH,CAAA,EACC,OAAA,MAAA;AAEDG,IAAAA,MAAM,GAAG,KAAA,QAAA,CAAA,KAAA,CAATA,CAAS,CAATA;AAEA,WAAA,MAAA;AAtFF,GAAA,CAwFC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,uBAAA;AA/FF,GAAA,CAiGC;;;AACAhB,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,aAAAA,GAAuB,KAAvBA,aAAAA;AACAA,IAAAA,MAAM,CAANA,SAAAA,GAAmB,KAAnBA,SAAAA;AACAA,IAAAA,MAAM,CAANA,QAAAA,GAAkB,CAAA,GAAA,QAAA,CAAA,gBAAA,EAAiB,KAAjB,QAAA,EAAA,CAAA,EAAmC,KAAA,QAAA,CAArDA,UAAkB,CAAlBA;AAEA,WAAA,MAAA;AAlHF,GAAA,CAoHC;;;AApHD,C,CAsHA;;;AACO,MAAA,WAAA,SAAA,SAAA,CACP;AACC;;AACA;;;;AAIAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA,EAAA,0BAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,CAIC,CAJD,CAI6B;AAX9B,GAAA,CAaC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC,SAAA,UAAA,CAAA,aAAA,GAAgC,KAAA,OAAA,CAAhC,aAAA;AACA,SAAA,UAAA,CAAA,gBAAA,GAAmC,KAAA,QAAA,CAFpC,gBAEC,CAFD,CAIC;;AACA,QAAGyC,WAAW,KAAd,CAAA,EACA;AACC,UAAG,KAAA,OAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,OAAA,CAApB,WAAA;AAED,UAAG,KAAA,QAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,QAAA,CAApB,WAAA;AAED,aAAA,WAAA;AAbF,KAAA,CAeC;;;AAEA,WAAO,MAAA,OAAA,CAAA,WAAA,EAAA,WAAA,EAAP,WAAO,CAAP;AAvCF,GAAA,CAyCC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,aAAA;AAhDF,GAAA,CAkDC;AACA;;AACA;;;;;;AAIAS,EAAAA,OAAO,CAAA,WAAA,EACP;AACC;AACA,QAAIC,WAAW,YAAZ,WAACA,KAAJ,KAAA,EACC,OAHF,KAGE,CAHF,CAIC;AAEA;;AACA,QAAGC,IAAI,CAAJA,SAAAA,CAAAA,IAAAA,MAAyBA,IAAI,CAAJA,SAAAA,CAA5B,WAA4BA,CAA5B,EACC,OARF,KAQE,CARF,CASC;;AAEA,WAAA,IAAA;AApEF,GAAA,CAsEC;;;AAtED,C,CAwEA;AACA;AACA;AACA;AACA;;;;;AACA,MAAA,wBAAA,SAAuCtD,QAAQ,CAA/C,0BAA+C,CAA/C,CACA;AACC;;AACA;;;;;AAKAR,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,UAAA,GAAkB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,YAAA,EAAlB,CAAkB,CAAlB;AACA,SAAA,aAAA,GAAqB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,eAAA,EAArB,KAAqB,CAArB;AACA,SAAA,WAAA,GAAmB,KAAA,QAAA,CAAnB,UAAA;AAbF,GAAA,CAeC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC;AACA,QAAGyC,WAAW,KAAd,CAAA,EACC,OAHF,WAGE,CAHF,CAIC;;AAEA,QAAIf,YAAY,GAAI,CANrB,CAMC,CAND,CAQC;;AACA,QAAG,KAAA,aAAA,KAAH,IAAA,EACA;AACCA,MAAAA,YAAY,GAAGqB,0BAA0B,CAA1BA,SAAAA,CAAAA,OAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,WAAAA,EAAAA,WAAAA,EAAfrB,WAAeqB,CAAfrB;AACA,UAAGA,YAAY,KAAM,CAArB,CAAA,EACC,OAAA,YAAA;;AAED,WAAI,IAAIZ,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAG,KAAA,KAAA,CAAnB,MAAA,EAAsCA,CAAtC,EAAA,EACA;AACC,cAAMkC,gBAAgB,GAAG,KAAA,KAAA,CAAA,CAAA,EAAA,WAAA,CAAzB,SAAyB,EAAzB;;AAEA,YAAGA,gBAAgB,KAAKN,YAAY,CAApC,SAAwBA,EAAxB,EACA;AACC,cAAG,KAAA,gBAAA,KAAH,IAAA,EAAA,MAAA,KAGA;AACC,iBAAA,KAAA,GAAA,yEAAA;AACA,mBAAQ,CAAR,CAAA;AACA;AACD;;AAED,YAAGM,gBAAgB,KAAKK,SAAS,CAAjC,SAAwBA,EAAxB,EACA;AACC,eAAA,KAAA,GAAA,6CAAA;AACA,iBAAQ,CAAR,CAAA;AACA;;AAED,YAAI,KAAA,UAAA,GAAD,CAAC,IAAyB,KAAA,KAAA,CAAA,CAAA,EAAA,UAAA,CAAA,UAAA,GAA7B,CAAA,EACA;AACC,eAAA,KAAA,GAAA,oFAAA;AACA,iBAAQ,CAAR,CAAA;AACA;;AAED,aAAA,UAAA,GAAkB,KAAA,KAAA,CAAA,CAAA,EAAA,UAAA,CAAlB,UAAA;;AACA,YAAG,KAAA,UAAA,GAAH,CAAA,EACA;AACC,eAAA,KAAA,GAAA,gDAAA;AACA,iBAAQ,CAAR,CAAA;AACA;AACD;;AAED,aAAA,YAAA;AAlDF,KAAA,CAoDC;AACA;AACA;AACA;;;AACA,QAAG,CAAA,GAAA,QAAA,CAAA,iBAAA,EAAA,IAAA,EAAA,WAAA,EAAA,WAAA,EAAA,WAAA,MAAH,KAAA,EACC,OAAQ,CAzDV,CAyDE,CAzDF,CA0DC;;AAEA,UAAMpD,SAAS,GAAG,IAAA,UAAA,CAAA,WAAA,EAAA,WAAA,EAAlB,WAAkB,CAAlB;AAEA,SAAA,UAAA,GAAkBA,SAAS,CAA3B,CAA2B,CAA3B;;AAEA,QAAG,KAAA,UAAA,GAAH,CAAA,EACA;AACC,WAAA,KAAA,GAAA,gDAAA;AACA,aAAQ,CAAR,CAAA;AAnEF,KAAA,CAsEC;;;AACA,SAAA,QAAA,GAAgB,IAAA,WAAA,CAAgBA,SAAS,CAATA,MAAAA,GAAhC,CAAgB,CAAhB;AACA,UAAM4C,IAAI,GAAG,IAAA,UAAA,CAAe,KAA5B,QAAa,CAAb;;AACA,SAAI,IAAI/B,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAI2B,WAAW,GAA/B,CAAA,EAAsC3B,CAAtC,EAAA,EACC+B,IAAI,CAAJA,CAAI,CAAJA,GAAU5C,SAAS,CAACa,CAAC,GA1EvB,CA0EqB,CAAnB+B,CA1EF,CA2EC;;;AAEA,SAAA,WAAA,GAAmB5C,SAAS,CAA5B,MAAA;AAEA,WAAQE,WAAW,GA/EpB,WA+EC,CA/ED,CAgFC;AAxGF,GAAA,CA0GC;;AACA;;;;;;;AAKAC,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC,QAAG,KAAA,aAAA,KAAH,IAAA,EACC,OAAO0C,0BAA0B,CAA1BA,SAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAP,QAAOA,CAAP;AAED,QAAG1C,QAAQ,KAAX,IAAA,EACC,OAAQ,IAAA,WAAA,CAAgB,KAAA,QAAA,CAAA,UAAA,GAAxB,CAAQ,CAAR;AAED,QAAG,KAAA,QAAA,CAAA,UAAA,KAAH,CAAA,EACC,OAAQ,IAAA,WAAA,CAAR,CAAQ,CAAR;AAED,UAAMU,OAAO,GAAG,IAAA,UAAA,CAAe,KAA/B,QAAgB,CAAhB;AAEA,UAAMP,MAAM,GAAG,IAAA,WAAA,CAAgB,KAAA,QAAA,CAAA,UAAA,GAA/B,CAAe,CAAf;AACA,UAAMC,OAAO,GAAG,IAAA,UAAA,CAAhB,MAAgB,CAAhB;AAEAA,IAAAA,OAAO,CAAPA,CAAO,CAAPA,GAAa,KAAbA,UAAAA;;AAEA,SAAI,IAAIK,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAG,KAAA,QAAA,CAAnB,UAAA,EAA6CA,CAA7C,EAAA,EACCL,OAAO,CAACK,CAAC,GAATL,CAAO,CAAPA,GAAiBM,OAAO,CAAxBN,CAAwB,CAAxBA;;AAED,WAAA,MAAA;AArIF,GAAA,CAuIC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,qBAAA;AA9IF,GAAA,CAgJC;;AACA;;;;;;AAIAjB,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,UAAAA,GAAoB,KAApBA,UAAAA;AACAA,IAAAA,MAAM,CAANA,aAAAA,GAAuB,KAAvBA,aAAAA;AACAA,IAAAA,MAAM,CAANA,SAAAA,GAAmB,KAAnBA,SAAAA;AACAA,IAAAA,MAAM,CAANA,QAAAA,GAAkB,CAAA,GAAA,QAAA,CAAA,gBAAA,EAAiB,KAAjB,QAAA,EAAA,CAAA,EAAmC,KAAA,QAAA,CAArDA,UAAkB,CAAlBA;AAEA,WAAA,MAAA;AAtKF,GAAA,CAwKC;;;AAxKD,C,CA0KA;;;AACO,MAAA,SAAA,SAAA,SAAA,CACP;AACC;;AACA;;;;AAIAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA,EAAA,wBAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,CAIC,CAJD,CAI6B;AAX9B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,WAAA;AApBF,GAAA,CAsBC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC;AACA,QAAGyC,WAAW,KAAd,CAAA,EACC,OAHF,WAGE,CAHF,CAIC;;AAEA,SAAA,UAAA,CAAA,aAAA,GAAgC,KAAA,OAAA,CAAhC,aAAA;AACA,SAAA,UAAA,CAAA,gBAAA,GAAmC,KAAA,QAAA,CAAnC,gBAAA;AAEA,WAAO,MAAA,OAAA,CAAA,WAAA,EAAA,WAAA,EAAP,WAAO,CAAP;AAxCF,GAAA,CA0CC;;AACA;;;;;;AAIAS,EAAAA,OAAO,CAAA,SAAA,EACP;AACC;AACA,QAAII,SAAS,YAAV,SAACA,KAAJ,KAAA,EACC,OAHF,KAGE,CAHF,CAIC;AAEA;;AACA,QAAGF,IAAI,CAAJA,SAAAA,CAAAA,IAAAA,MAAyBA,IAAI,CAAJA,SAAAA,CAA5B,SAA4BA,CAA5B,EACC,OARF,KAQE,CARF,CASC;;AAEA,WAAA,IAAA;AA3DF,GAAA,CA6DC;;;AA7DD,C,CA+DA;AACA;AACA;AACA;AACA;;AACA;;;;;;;AAGA,MAAA,sBAAA,SAAqCtD,QAAQ,CAA7C,UAA6C,CAA7C,CACA;AACC;;AACA;;;;;AAKAR,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,QAAG,WAAH,UAAA,EACC,KAAA,QAAA,GAAgBA,UAAU,CAA1B,KAAA;AAZH,GAAA,CAcC;;AACA;;;;;;AAIA,MAAA,QAAA,CAAA,MAAA,EACA;AACC,SAAA,SAAA,GAAiBgE,MAAM,CAANA,KAAAA,CAAjB,CAAiBA,CAAjB;;AAEA,QAAGA,MAAM,CAANA,UAAAA,IAAH,CAAA,EACA;AACC,WAAA,QAAA,CAAA,IAAA,CAAA,wCAAA;AACA,WAAA,SAAA,GAAA,IAAA;AACA,WAAA,SAAA,GAAA,CAAA;AAJD,KAAA,MAOA;AACC,WAAA,SAAA,GAAA,KAAA;AAEA,UAAGA,MAAM,CAANA,UAAAA,GAAH,CAAA,EACC,KAAA,SAAA,GAAiBT,QAAAA,CAAAA,YAAAA,CAAAA,IAAAA,CAAjB,IAAiBA,CAAjB;AACD;AAnCH,GAAA,CAqCC;;AACA;;;;;;AAIA,MAAA,QAAA,GACA;AACC,WAAO,KAAP,SAAA;AA5CF,GAAA,CA8CC;;AACA;;;;;;AAIA,MAAA,QAAA,CAAA,MAAA,EACA;AACC,SAAA,SAAA,GAAA,MAAA;AAEA,SAAA,SAAA,GAAA,KAAA;AACA,SAAA,SAAA,GAAiB,CAAA,GAAA,QAAA,CAAA,YAAA,EAAjB,MAAiB,CAAjB;AAxDF,GAAA,CA0DC;;AACA;;;;;;AAIA,MAAA,QAAA,GACA;AACC,WAAO,KAAP,SAAA;AAjEF,GAAA,CAmEC;;AACA;;;;;;;;;;AAQAU,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EAAwCC,cAAc,GAAtD,CAAA,EACP;AACC,UAAMC,MAAM,GAAG,KAAA,OAAA,CAAA,WAAA,EAAA,WAAA,EAAf,WAAe,CAAf;AACA,QAAGA,MAAM,KAAM,CAAf,CAAA,EACC,OAAA,MAAA;AAED,UAAMb,IAAI,GAAG,IAAA,UAAA,CAAe,KAA5B,SAAa,CAAb;;AAEA,QAAIA,IAAI,CAAJA,CAAI,CAAJA,KAAD,IAACA,IAAsB,CAACA,IAAI,CAAJA,CAAI,CAAJA,GAAD,IAAA,MAA1B,CAAA,EACA;AACC,YAAMc,eAAe,GAAG,IAAA,WAAA,CAAgB,KAAA,SAAA,CAAA,UAAA,GAAxC,CAAwB,CAAxB;AACA,YAAMC,WAAW,GAAG,IAAA,UAAA,CAApB,eAAoB,CAApB;AAEAA,MAAAA,WAAW,CAAXA,GAAAA,CAAgB,IAAA,UAAA,CAAe,KAAf,SAAA,EAAA,CAAA,EAAkC,KAAA,SAAA,CAAA,UAAA,GAAlDA,CAAgB,CAAhBA;AAEA,WAAA,SAAA,GAAiBD,eAAe,CAAfA,KAAAA,CAAjB,CAAiBA,CAAjB;AAPD,KAAA,MAUA;AACC,UAAGF,cAAc,KAAjB,CAAA,EACA;AACC,YAAG,KAAA,SAAA,CAAA,UAAA,GAAH,cAAA,EACA;AACC,cAAIA,cAAc,GAAG,KAAA,SAAA,CAAlB,UAACA,GAAJ,CAAA,EACCA,cAAc,GAAG,KAAA,SAAA,CAAA,UAAA,GAAjBA,CAAAA;AAED,gBAAME,eAAe,GAAG,IAAA,WAAA,CAAxB,cAAwB,CAAxB;AACA,gBAAMC,WAAW,GAAG,IAAA,UAAA,CAApB,eAAoB,CAApB;AAEAA,UAAAA,WAAW,CAAXA,GAAAA,CAAAA,IAAAA,EAAsBH,cAAc,GAAG,KAAA,SAAA,CAAvCG,UAAAA;AAEA,eAAA,SAAA,GAAiBD,eAAe,CAAfA,KAAAA,CAAjB,CAAiBA,CAAjB;AACA;AACD;AACD;;AAED,WAAA,MAAA;AAhHF,GAAA,CAkHC;;AACA;;;;;;;AAKAE,EAAAA,KAAK,CAACxD,QAAQ,GAAT,KAAA,EACL;AACC,UAAMwC,IAAI,GAAG,IAAA,UAAA,CAAe,KAA5B,SAAa,CAAb;;AAEA,YAAA,IAAA;AAEC,WAAM,CAACA,IAAI,CAAJA,CAAI,CAAJA,GAAD,IAAA,MAAN,CAAA;AACC;AACC,gBAAMc,eAAe,GAAG,IAAA,WAAA,CAAgB,KAAA,SAAA,CAAA,UAAA,GAAxC,CAAwB,CAAxB;AACA,gBAAMC,WAAW,GAAG,IAAA,UAAA,CAApB,eAAoB,CAApB;AAEAA,UAAAA,WAAW,CAAXA,CAAW,CAAXA,GAAAA,IAAAA;AACAA,UAAAA,WAAW,CAAXA,GAAAA,CAAAA,IAAAA,EAAAA,CAAAA;AAEA,eAAA,SAAA,GAAiBD,eAAe,CAAfA,KAAAA,CAAjB,CAAiBA,CAAjB;AACA;AACD;;AACD,WAAOd,IAAI,CAAJA,CAAI,CAAJA,KAAD,IAACA,IAAsB,CAACA,IAAI,CAAJA,CAAI,CAAJA,GAAD,IAAA,MAA7B,CAAA;AACC;AACC,gBAAMc,eAAe,GAAG,IAAA,WAAA,CAAgB,KAAA,SAAA,CAAA,UAAA,GAAxC,CAAwB,CAAxB;AACA,gBAAMC,WAAW,GAAG,IAAA,UAAA,CAApB,eAAoB,CAApB;AAEAA,UAAAA,WAAW,CAAXA,GAAAA,CAAgB,IAAA,UAAA,CAAe,KAAf,SAAA,EAAA,CAAA,EAAkC,KAAA,SAAA,CAAA,UAAA,GAAlDA,CAAgB,CAAhBA;AAEA,eAAA,SAAA,GAAiBD,eAAe,CAAfA,KAAAA,CAAjB,CAAiBA,CAAjB;AACA;AACD;;AACD;AAvBD;;AA0BA,WAAO,KAAA,KAAA,CAAP,QAAO,CAAP;AAtJF,GAAA,CAwJC;;AACA;;;;;;;;;AAOA3D,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC,UAAM0B,YAAY,GAAG,MAAA,OAAA,CAAA,WAAA,EAAA,WAAA,EAArB,WAAqB,CAArB;AACA,QAAGA,YAAY,KAAM,CAArB,CAAA,EACC,OAAA,YAAA;AAED,SAAA,WAAA,GAAA,WAAA;AAEA,WAAQvB,WAAW,GAAnB,WAAA;AAxKF,GAAA,CA0KC;;AACA;;;;;;;AAKAC,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC;AACA,WAAO,KAAA,QAAA,CAAA,KAAA,CAAP,CAAO,CAAP;AAnLF,GAAA,CAqLC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,mBAAA;AA5LF,GAAA,CA8LC;AACA;;AACA;;;;;;AAIAb,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,QAAAA,GAAkB,KAAlBA,QAAAA;AAEA,WAAA,MAAA;AAlNF,GAAA,CAoNC;;AACA;;;;;AAGAwD,EAAAA,QAAQ,GACR;AACC;AACA,aAAA,OAAA,CAAA,KAAA,EAAA,MAAA,EACA;AACC;AACA,YAAMC,CAAC,GAAG,IAAA,UAAA,CAAe,CAAzB,CAAyB,CAAf,CAAV;AAEA,UAAIC,SAAS,GAAG,IAAA,UAAA,CAAhB,KAAgB,CAAhB;AACA,UAAIC,UAAU,GAAG,IAAA,UAAA,CAAjB,MAAiB,CAAjB;AAEA,UAAIC,aAAa,GAAGF,SAAS,CAATA,KAAAA,CAApB,CAAoBA,CAApB;AACA,YAAMG,mBAAmB,GAAGD,aAAa,CAAbA,MAAAA,GAA5B,CAAA;AACA,UAAIE,cAAc,GAAGH,UAAU,CAAVA,KAAAA,CAArB,CAAqBA,CAArB;AACA,YAAMI,oBAAoB,GAAGD,cAAc,CAAdA,MAAAA,GAA7B,CAAA;AAEA,UAAIE,KAAK,GAAT,CAAA;AAEA,YAAMC,GAAG,GAAIF,oBAAoB,GAArB,mBAACA,GAAD,mBAACA,GAAb,oBAAA;AAEA,UAAIG,OAAO,GAhBZ,CAgBC,CAhBD,CAiBC;;AAEA,WAAI,IAAI1D,CAAC,GAAT,GAAA,EAAiBA,CAAC,IAAlB,CAAA,EAAyBA,CAAC,IAAI0D,OAA9B,EAAA,EACA;AACC,gBAAA,IAAA;AAEC,eAAMA,OAAO,GAAGJ,cAAc,CAA9B,MAAA;AACCE,YAAAA,KAAK,GAAGJ,aAAa,CAACC,mBAAmB,GAAjCD,OAAa,CAAbA,GAA+CE,cAAc,CAACC,oBAAoB,GAAlFH,OAA6D,CAA7DA,GAAgGH,CAAC,CAAzGO,CAAyG,CAAzGA;AACA;;AACD;AACCA,YAAAA,KAAK,GAAGJ,aAAa,CAACC,mBAAmB,GAAjCD,OAAa,CAAbA,GAA+CH,CAAC,CAAxDO,CAAwD,CAAxDA;AANF;;AASAP,QAAAA,CAAC,CAADA,CAAC,CAADA,GAAOO,KAAK,GAAZP,EAAAA;;AAEA,gBAAA,IAAA;AAEC,eAAMS,OAAO,IAAIN,aAAa,CAA9B,MAAA;AACCA,YAAAA,aAAa,GAAG,CAAA,GAAA,QAAA,CAAA,cAAA,EAAe,IAAA,UAAA,CAAe,CAACI,KAAK,GAApC,EAA8B,CAAf,CAAf,EAAhBJ,aAAgB,CAAhBA;AACA;;AACD;AACCA,YAAAA,aAAa,CAACC,mBAAmB,GAAjCD,OAAa,CAAbA,GAA+CI,KAAK,GAApDJ,EAAAA;AANF;AAQA;;AAED,UAAGH,CAAC,CAADA,CAAC,CAADA,GAAH,CAAA,EACCG,aAAa,GAAG,CAAA,GAAA,QAAA,CAAA,cAAA,EAAA,CAAA,EAAhBA,aAAgB,CAAhBA;AAED,aAAOA,aAAa,CAAbA,KAAAA,CAAP,CAAOA,CAAP;AACA;;AAED,aAAA,MAAA,CAAA,CAAA,EACA;AACC,UAAGO,CAAC,IAAIrF,OAAO,CAAf,MAAA,EACA;AACC,aAAI,IAAIsF,CAAC,GAAGtF,OAAO,CAAnB,MAAA,EAA4BsF,CAAC,IAA7B,CAAA,EAAoCA,CAApC,EAAA,EACA;AACC,gBAAMX,CAAC,GAAG,IAAA,UAAA,CAAe,CAAzB,CAAyB,CAAf,CAAV;AACA,cAAIY,MAAM,GAAIvF,OAAO,CAACsF,CAAC,GAAV,CAAQ,CAAPtF,CAAD,KAACA,CAAd,CAAcA,CAAd;;AAEA,eAAI,IAAI0B,CAAC,GAAI6D,MAAM,CAANA,MAAAA,GAAb,CAAA,EAAiC7D,CAAC,IAAlC,CAAA,EAAwCA,CAAxC,EAAA,EACA;AACC,kBAAM8D,QAAQ,GAAG,IAAA,UAAA,CAAe,CAAC,CAACD,MAAM,CAANA,CAAM,CAANA,IAAD,CAAA,IAAmBZ,CAAC,CAArD,CAAqD,CAArB,CAAf,CAAjB;AACAA,YAAAA,CAAC,CAADA,CAAC,CAADA,GAAOa,QAAQ,CAARA,CAAQ,CAARA,GAAPb,EAAAA;AACAY,YAAAA,MAAM,CAANA,CAAM,CAANA,GAAYC,QAAQ,CAARA,CAAQ,CAARA,GAAZD,EAAAA;AACA;;AAED,cAAIZ,CAAC,CAADA,CAAC,CAADA,GAAJ,CAAA,EACCY,MAAM,GAAG,CAAA,GAAA,QAAA,CAAA,cAAA,EAAA,CAAA,EAATA,MAAS,CAATA;AAEDvF,UAAAA,OAAO,CAAPA,IAAAA,CAAAA,MAAAA;AACA;AACD;;AAED,aAAOA,OAAO,CAAd,CAAc,CAAd;AACA;;AAED,aAAA,OAAA,CAAA,KAAA,EAAA,MAAA,EACA;AACC;AACA,UAAIyF,CAAC,GAAL,CAAA;AAEA,UAAIb,SAAS,GAAG,IAAA,UAAA,CAAhB,KAAgB,CAAhB;AACA,UAAIC,UAAU,GAAG,IAAA,UAAA,CAAjB,MAAiB,CAAjB;AAEA,UAAIC,aAAa,GAAGF,SAAS,CAATA,KAAAA,CAApB,CAAoBA,CAApB;AACA,YAAMG,mBAAmB,GAAGD,aAAa,CAAbA,MAAAA,GAA5B,CAAA;AACA,UAAIE,cAAc,GAAGH,UAAU,CAAVA,KAAAA,CAArB,CAAqBA,CAArB;AACA,YAAMI,oBAAoB,GAAGD,cAAc,CAAdA,MAAAA,GAA7B,CAAA;AAEA,UAAA,KAAA;AAEA,UAAII,OAAO,GAdZ,CAcC,CAdD,CAeC;;AAEA,WAAI,IAAI1D,CAAC,GAAT,oBAAA,EAAkCA,CAAC,IAAnC,CAAA,EAA0CA,CAAC,IAAI0D,OAA/C,EAAA,EACA;AACCF,QAAAA,KAAK,GAAGJ,aAAa,CAACC,mBAAmB,GAAjCD,OAAa,CAAbA,GAA+CE,cAAc,CAACC,oBAAoB,GAAlFH,OAA6D,CAA7DA,GAARI,CAAAA;;AAEA,gBAAA,IAAA;AAEC,eAAMA,KAAK,GAAX,CAAA;AACCO,YAAAA,CAAC,GAADA,CAAAA;AACAX,YAAAA,aAAa,CAACC,mBAAmB,GAAjCD,OAAa,CAAbA,GAA+CI,KAAK,GAApDJ,EAAAA;AACA;;AACD;AACCW,YAAAA,CAAC,GAADA,CAAAA;AACAX,YAAAA,aAAa,CAACC,mBAAmB,GAAjCD,OAAa,CAAbA,GAAAA,KAAAA;AARF;AAUA;;AAED,UAAGW,CAAC,GAAJ,CAAA,EACA;AACC,aAAI,IAAI/D,CAAC,GAAIqD,mBAAmB,GAAnBA,oBAAAA,GAAb,CAAA,EAA8DrD,CAAC,IAA/D,CAAA,EAAsEA,CAAC,IAAI0D,OAA3E,EAAA,EACA;AACCF,UAAAA,KAAK,GAAGJ,aAAa,CAACC,mBAAmB,GAAjCD,OAAa,CAAbA,GAARI,CAAAA;;AAEA,cAAGA,KAAK,GAAR,CAAA,EACA;AACCO,YAAAA,CAAC,GAADA,CAAAA;AACAX,YAAAA,aAAa,CAACC,mBAAmB,GAAjCD,OAAa,CAAbA,GAA+CI,KAAK,GAApDJ,EAAAA;AAHD,WAAA,MAMA;AACCW,YAAAA,CAAC,GAADA,CAAAA;AACAX,YAAAA,aAAa,CAACC,mBAAmB,GAAjCD,OAAa,CAAbA,GAAAA,KAAAA;AACA;AACA;AACD;AACD;;AAED,aAAOA,aAAa,CAApB,KAAOA,EAAP;AAnIF,KAAA,CAqIC;AAEA;;;AACA,UAAMY,QAAQ,GAAI,KAAA,SAAA,CAAA,UAAA,GAAD,CAAC,GAAlB,CAAA;AAEA,QAAIH,MAAM,GAAG,IAAA,UAAA,CAAgB,KAAA,SAAA,CAAA,UAAA,GAAD,CAAC,GAA7B,CAAa,CAAb;AACA,QAAII,SAAS,GAAb,CAAA;AACA,QAAA,WAAA;AAEA,UAAMC,QAAQ,GAAG,IAAA,UAAA,CAAe,KAAhC,SAAiB,CAAjB;AAEA,QAAIC,MAAM,GAAV,EAAA;AAEA,QAAIC,IAAI,GAlJT,KAkJC,CAlJD,CAmJC;AAEA;;AACA,SAAI,IAAIC,UAAU,GAAI,KAAA,SAAA,CAAA,UAAA,GAAtB,CAAA,EAAsDA,UAAU,IAAhE,CAAA,EAAuEA,UAAvE,EAAA,EACA;AACCC,MAAAA,WAAW,GAAGJ,QAAQ,CAAtBI,UAAsB,CAAtBA;;AAEA,WAAI,IAAItE,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAhB,CAAA,EAAsBA,CAAtB,EAAA,EACA;AACC,YAAG,CAACsE,WAAW,GAAZ,CAAA,MAAH,CAAA,EACA;AACC,kBAAA,SAAA;AAEC,iBAAA,QAAA;AACCT,cAAAA,MAAM,GAAGU,OAAO,CAACC,MAAM,CAAP,SAAO,CAAP,EAAhBX,MAAgB,CAAhBA;AACAM,cAAAA,MAAM,GAANA,GAAAA;AACA;;AACD;AACCN,cAAAA,MAAM,GAAGY,OAAO,CAAA,MAAA,EAASD,MAAM,CAA/BX,SAA+B,CAAf,CAAhBA;AAPF;AASA;;AAEDI,QAAAA,SAAS;AACTK,QAAAA,WAAW,KAAXA,CAAAA;AACA;AA3KH,KAAA,CA6KC;AAEA;;;AACA,SAAI,IAAItE,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAG6D,MAAM,CAAzB,MAAA,EAAkC7D,CAAlC,EAAA,EACA;AACC,UAAG6D,MAAM,CAAT,CAAS,CAAT,EACCO,IAAI,GAAJA,IAAAA;AAED,UAAA,IAAA,EACCD,MAAM,IAAI5F,YAAY,CAAZA,MAAAA,CAAoBsF,MAAM,CAApCM,CAAoC,CAA1B5F,CAAV4F;AACD;;AAED,QAAGC,IAAI,KAAP,KAAA,EACCD,MAAM,IAAI5F,YAAY,CAAZA,MAAAA,CA1LZ,CA0LYA,CAAV4F,CA1LF,CA2LC;;AAEA,WAAA,MAAA;AAtZF,GAAA,CAwZC;;;AAxZD,C,CA0ZA;;;AACO,MAAA,OAAA,SAAA,SAAA,CACP;AACC;;AACA;;;;AAIA3F,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA,EAAA,sBAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,CAIC,CAJD,CAI6B;AAX9B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,SAAA;AApBF,GAAA,CAsBC;AACA;;AACA;;;;;;;AAKA2D,EAAAA,OAAO,CAAA,UAAA,EACP;AACC,QAAGsC,UAAU,YAAb,OAAA,EACA;AACC,UAAG,KAAA,UAAA,CAAA,SAAA,IAA6BA,UAAU,CAAVA,UAAAA,CAAhC,SAAA,EAAiE;AAChE,eAAO,CAAA,GAAA,QAAA,CAAA,aAAA,EAAc,KAAA,UAAA,CAAd,QAAA,EAAwCA,UAAU,CAAVA,UAAAA,CAA/C,QAAO,CAAP;AAED,UAAG,KAAA,UAAA,CAAA,SAAA,KAA8BA,UAAU,CAAVA,UAAAA,CAAjC,SAAA,EACC,OAAQ,KAAA,UAAA,CAAA,QAAA,KAA6BA,UAAU,CAAVA,UAAAA,CAArC,QAAA;AAED,aAAA,KAAA;AACA;;AAED,QAAGA,UAAU,YAAb,WAAA,EACC,OAAO,CAAA,GAAA,QAAA,CAAA,aAAA,EAAc,KAAA,UAAA,CAAd,QAAA,EAAP,UAAO,CAAP;AAED,WAAA,KAAA;AA7CF,GAAA,CA+CC;;AACA;;;;;;AAIAC,EAAAA,YAAY,GACZ;AACC,UAAMC,OAAO,GAAG,IAAA,OAAA,CAAY;AAAEC,MAAAA,QAAQ,EAAE,KAAA,UAAA,CAAgBA;AAA5B,KAAZ,CAAhB;AACAD,IAAAA,OAAO,CAAPA,UAAAA,CAAAA,KAAAA;AAEA,WAAA,OAAA;AAzDF,GAAA,CA2DC;;AACA;;;;;;AAIAE,EAAAA,cAAc,GACd;AACC,UAAMnC,cAAc,GAAI,KAAA,UAAA,CAAA,QAAA,CAAA,UAAA,GAAD,CAAC,GAA4C,KAAA,UAAA,CAAA,QAAA,CAAA,UAAA,GAA7C,CAAC,GAAuF,KAAA,UAAA,CAAA,QAAA,CAA/G,UAAA;AACA,UAAMiC,OAAO,GAAG,IAAA,OAAA,CAAY;AAAEC,MAAAA,QAAQ,EAAE,KAAA,UAAA,CAAgBA;AAA5B,KAAZ,CAAhB;AACAD,IAAAA,OAAO,CAAPA,UAAAA,CAAAA,OAAAA,CAA2BA,OAAO,CAAPA,UAAAA,CAA3BA,QAAAA,EAAAA,CAAAA,EAA2DA,OAAO,CAAPA,UAAAA,CAAAA,QAAAA,CAA3DA,UAAAA,EAAAA,cAAAA;AAEA,WAAA,OAAA;AAtEF,GAAA,CAwEC;;;AAxED,C,CA0EA;AACA;AACA;AACA;AACA;;;;;AACO,MAAA,UAAA,SAAA,OAAA,CACP;AACC;;AACA;;;;AAIApG,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAX/B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,YAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;AACA;AACA;AACA;AACA;;;;;AACA,MAAA,kBAAA,SAAiCO,QAAQ,CAAzC,cAAyC,CAAzC,CACA;AACC;;AACA;;;;;;AAMAR,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,QAAA,GAAgB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,UAAA,EAA2C,CAA3D,CAAgB,CAAhB;AACA,SAAA,UAAA,GAAkB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,YAAA,EAAlB,KAAkB,CAAlB;AAbF,GAAA,CAeC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,UAAA;AAtBF,GAAA,CAwBC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC,QAAGyC,WAAW,KAAd,CAAA,EACC,OAFF,WAEE,CAFF,CAIC;AACA;;AACA,QAAG,CAAA,GAAA,QAAA,CAAA,iBAAA,EAAA,IAAA,EAAA,WAAA,EAAA,WAAA,EAAA,WAAA,MAAH,KAAA,EACC,OAAQ,CAPV,CAOE,CAPF,CAQC;;AAEA,UAAMxC,SAAS,GAAG,IAAA,UAAA,CAAA,WAAA,EAAA,WAAA,EAAlB,WAAkB,CAAlB;AAEA,SAAA,QAAA,GAAgB,IAAA,WAAA,CAAhB,WAAgB,CAAhB;AACA,QAAI4C,IAAI,GAAG,IAAA,UAAA,CAAe,KAA1B,QAAW,CAAX;;AAEA,SAAI,IAAI/B,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAhB,WAAA,EAAgCA,CAAhC,EAAA,EACA;AACC+B,MAAAA,IAAI,CAAJA,CAAI,CAAJA,GAAU5C,SAAS,CAATA,CAAS,CAATA,GAAV4C,IAAAA;AAEA,WAAA,WAAA;AAEA,UAAG,CAAC5C,SAAS,CAATA,CAAS,CAATA,GAAD,IAAA,MAAH,IAAA,EACC;AAtBH,KAAA,CAyBC;;;AACA,UAAM4F,YAAY,GAAG,IAAA,WAAA,CAAgB,KAArC,WAAqB,CAArB;AACA,UAAMC,QAAQ,GAAG,IAAA,UAAA,CAAjB,YAAiB,CAAjB;;AAEA,SAAI,IAAIhF,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAG,KAAnB,WAAA,EAAqCA,CAArC,EAAA,EACCgF,QAAQ,CAARA,CAAQ,CAARA,GAAcjD,IAAI,CA9BpB,CA8BoB,CAAlBiD,CA9BF,CAgCC;;;AACA,SAAA,QAAA,GAAgBD,YAAY,CAAZA,KAAAA,CAAhB,CAAgBA,CAAhB;AACAhD,IAAAA,IAAI,GAAG,IAAA,UAAA,CAAe,KAlCvB,QAkCQ,CAAPA,CAlCD,CAmCC;;AAEA,QAAG,CAAC5C,SAAS,CAAC,KAAA,WAAA,GAAVA,CAAS,CAATA,GAAD,IAAA,MAAH,IAAA,EACA;AACC,WAAA,KAAA,GAAA,uDAAA;AACA,aAAQ,CAAR,CAAA;AACA;;AAED,QAAG4C,IAAI,CAAJA,CAAI,CAAJA,KAAH,IAAA,EACC,KAAA,QAAA,CAAA,IAAA,CAAA,wCAAA;AAED,QAAG,KAAA,WAAA,IAAH,CAAA,EACC,KAAA,QAAA,GAAgB,CAAA,GAAA,QAAA,CAAA,YAAA,EAAA,IAAA,EADjB,CACiB,CAAhB,CADD,KAGA;AACC,WAAA,SAAA,GAAA,IAAA;AACA,WAAA,QAAA,CAAA,IAAA,CAAA,oCAAA;AACA;AAED,WAAQ1C,WAAW,GAAG,KAAtB,WAAA;AAvFF,GAAA,CAyFC;;AACA;;;;;;;AAKAC,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC;AACA,QAAA,MAAA;AACA,QAHD,OAGC,CAHD,CAIC;;AAEA,QAAG,KAAH,SAAA,EACA;AACC,UAAGA,QAAQ,KAAX,IAAA,EACC,OAAQ,IAAA,WAAA,CAAgB,KAAA,QAAA,CAAxB,UAAQ,CAAR;AAED,YAAMU,OAAO,GAAG,IAAA,UAAA,CAAe,KAA/B,QAAgB,CAAhB;AAEAP,MAAAA,MAAM,GAAG,IAAA,WAAA,CAAgB,KAAzBA,WAAS,CAATA;AACAC,MAAAA,OAAO,GAAG,IAAA,UAAA,CAAVA,MAAU,CAAVA;;AAEA,WAAI,IAAIK,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAI,KAAA,WAAA,GAApB,CAAA,EAA2CA,CAA3C,EAAA,EACCL,OAAO,CAAPA,CAAO,CAAPA,GAAaM,OAAO,CAAPA,CAAO,CAAPA,GAAbN,IAAAA;;AAEDA,MAAAA,OAAO,CAAC,KAAA,WAAA,GAARA,CAAO,CAAPA,GAAgCM,OAAO,CAAC,KAAA,WAAA,GAAxCN,CAAuC,CAAvCA;AAEA,aAAA,MAAA;AACA;;AAED,UAAME,UAAU,GAAG,CAAA,GAAA,QAAA,CAAA,UAAA,EAAW,KAAX,QAAA,EAAnB,CAAmB,CAAnB;;AACA,QAAGA,UAAU,CAAVA,UAAAA,KAAH,CAAA,EACA;AACC,WAAA,KAAA,GAAA,iCAAA;AACA,aAAQ,IAAA,WAAA,CAAR,CAAQ,CAAR;AACA;;AAEDH,IAAAA,MAAM,GAAG,IAAA,WAAA,CAAgBG,UAAU,CAAnCH,UAAS,CAATA;;AAEA,QAAGH,QAAQ,KAAX,KAAA,EACA;AACC,YAAMO,WAAW,GAAG,IAAA,UAAA,CAApB,UAAoB,CAApB;AACAH,MAAAA,OAAO,GAAG,IAAA,UAAA,CAAVA,MAAU,CAAVA;;AAEA,WAAI,IAAIK,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAIH,UAAU,CAAVA,UAAAA,GAApB,CAAA,EAAgDG,CAAhD,EAAA,EACCL,OAAO,CAAPA,CAAO,CAAPA,GAAaG,WAAW,CAAXA,CAAW,CAAXA,GAAbH,IAAAA;;AAEDA,MAAAA,OAAO,CAACE,UAAU,CAAVA,UAAAA,GAARF,CAAO,CAAPA,GAAqCG,WAAW,CAACD,UAAU,CAAVA,UAAAA,GAAjDF,CAAgD,CAAhDA;AACA;;AAED,WAAA,MAAA;AA5IF,GAAA,CA8IC;;AACA;;;;;;AAIAqD,EAAAA,QAAQ,GACR;AACC,QAAImB,MAAM,GAAV,EAAA;AAEA,QAAG,KAAA,SAAA,KAAH,IAAA,EACCA,MAAM,GAAG,CAAA,GAAA,QAAA,CAAA,gBAAA,EAAiB,KAAjB,QAAA,EAAA,CAAA,EAAmC,KAAA,QAAA,CAD7C,UACU,CAATA,CADD,KAGA;AACC,UAAG,KAAH,UAAA,EACA;AACC,YAAIc,QAAQ,GAAG,KAAf,QAAA;AAEA,YAAG,KAAA,QAAA,IAAH,EAAA,EACCd,MAAM,GADP,IACCA,CADD,KAGA;AACC,cAAG,KAAA,QAAA,IAAH,EAAA,EACA;AACCA,YAAAA,MAAM,GAANA,IAAAA;AACAc,YAAAA,QAAQ,IAARA,EAAAA;AAHD,WAAA,MAMA;AACCd,YAAAA,MAAM,GAANA,IAAAA;AACAc,YAAAA,QAAQ,IAARA,EAAAA;AACA;AACD;AAEDd,QAAAA,MAAM,IAAIc,QAAQ,CAAlBd,QAAUc,EAAVd;AApBD,OAAA,MAuBCA,MAAM,GAAG,KAAA,QAAA,CAATA,QAAS,EAATA;AACD;AAED,WAAA,MAAA;AArLF,GAAA,CAuLC;AACA;;AACA;;;;;;AAIAzF,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,QAAAA,GAAkB,KAAlBA,QAAAA;AACAA,IAAAA,MAAM,CAANA,UAAAA,GAAoB,KAApBA,UAAAA;AAEA,WAAA,MAAA;AA5MF,GAAA,CA8MC;;;AA9MD,C,CAgNA;;;AACA,MAAA,+BAAA,SAAA,UAAA,CACA;AACC;;AACA;;;;;AAKAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,UAAA,CAAgB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,OAAA,EAAhB,EAAgB,CAAhB;AAXF,GAAA,CAaC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC,QAAI0B,YAAY,GAAhB,WAAA;;AAEA,WAAMe,WAAW,GAAjB,CAAA,EACA;AACC,YAAMuD,QAAQ,GAAG,IAAjB,kBAAiB,EAAjB;AACAtE,MAAAA,YAAY,GAAGsE,QAAQ,CAARA,OAAAA,CAAAA,WAAAA,EAAAA,YAAAA,EAAftE,WAAesE,CAAftE;;AACA,UAAGA,YAAY,KAAM,CAArB,CAAA,EACA;AACC,aAAA,WAAA,GAAA,CAAA;AACA,aAAA,KAAA,GAAasE,QAAQ,CAArB,KAAA;AACA,eAAA,YAAA;AACA;;AAED,UAAG,KAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACCA,QAAQ,CAARA,UAAAA,GAAAA,IAAAA;AAED,WAAA,WAAA,IAAoBA,QAAQ,CAA5B,WAAA;AACAvD,MAAAA,WAAW,IAAIuD,QAAQ,CAAvBvD,WAAAA;AAEA,WAAA,KAAA,CAAA,IAAA,CAAA,QAAA;AACA;;AAED,WAAA,YAAA;AA7CF,GAAA,CA+CC;;AACA;;;;;;;AAKArC,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC,QAAIG,MAAM,GAAG,IAAA,WAAA,CAAb,CAAa,CAAb;;AAEA,SAAI,IAAIM,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAG,KAAA,KAAA,CAAnB,MAAA,EAAsCA,CAAtC,EAAA,EACA;AACC,YAAM6B,QAAQ,GAAG,KAAA,KAAA,CAAA,CAAA,EAAA,KAAA,CAAjB,QAAiB,CAAjB;;AACA,UAAGA,QAAQ,CAARA,UAAAA,KAAH,CAAA,EACA;AACC,aAAA,KAAA,GAAa,KAAA,KAAA,CAAA,CAAA,EAAb,KAAA;AACA,eAAQ,IAAA,WAAA,CAAR,CAAQ,CAAR;AACA;;AAEDnC,MAAAA,MAAM,GAAG,CAAA,GAAA,QAAA,CAAA,aAAA,EAAA,MAAA,EAATA,QAAS,CAATA;AACA;;AAED,WAAA,MAAA;AArEF,GAAA,CAuEC;;AACA;;;;;;;AAKAyF,EAAAA,UAAU,CAAA,MAAA,EACV;AACC,SAAA,KAAA,GADD,EACC,CADD,CACkB;;AAEjB,QAAIC,IAAI,GAAR,CAAA;AACA,QAAIC,IAAI,GAAR,CAAA;AAEA,QAAIC,GAAG,GAAP,EAAA;AAEA,QAAIlB,IAAI,GAAR,KAAA;;AAEA,OACA;AACCiB,MAAAA,IAAI,GAAGE,MAAM,CAANA,OAAAA,CAAAA,GAAAA,EAAPF,IAAOE,CAAPF;AACA,UAAGA,IAAI,KAAM,CAAb,CAAA,EACCC,GAAG,GAAGC,MAAM,CAANA,MAAAA,CADP,IACOA,CAAND,CADD,KAGCA,GAAG,GAAGC,MAAM,CAANA,MAAAA,CAAAA,IAAAA,EAAoBF,IAAI,GAA9BC,IAAMC,CAAND;AAEDF,MAAAA,IAAI,GAAGC,IAAI,GAAXD,CAAAA;;AAEA,UAAA,IAAA,EACA;AACC,cAAMF,QAAQ,GAAG,KAAA,KAAA,CAAjB,CAAiB,CAAjB;AAEA,YAAIM,IAAI,GAAR,CAAA;;AAEA,gBAAON,QAAQ,CAAf,QAAA;AAEC,eAAA,CAAA;AACC;;AACD,eAAA,CAAA;AACCM,YAAAA,IAAI,GAAJA,EAAAA;AACA;;AACD,eAAA,CAAA;AACCA,YAAAA,IAAI,GAAJA,EAAAA;AACA;;AACD;AACC,iBAAA,KAAA,GADD,EACC,CADD,CACkB;;AACjB,mBAAA,KAAA;AAAc;AAZhB;;AAeA,cAAMC,SAAS,GAAGC,QAAQ,CAAA,GAAA,EAA1B,EAA0B,CAA1B;AACA,YAAGC,KAAK,CAAR,SAAQ,CAAR,EACC,OAAA,IAAA;AAEDT,QAAAA,QAAQ,CAARA,QAAAA,GAAoBO,SAAS,GAA7BP,IAAAA;AAEAd,QAAAA,IAAI,GAAJA,KAAAA;AA3BD,OAAA,MA8BA;AACC,cAAMc,QAAQ,GAAG,IAAjB,kBAAiB,EAAjB;AACAA,QAAAA,QAAQ,CAARA,QAAAA,GAAoBQ,QAAQ,CAAA,GAAA,EAA5BR,EAA4B,CAA5BA;AACA,YAAGS,KAAK,CAACT,QAAQ,CAAjB,QAAQ,CAAR,EACC,OAAA,IAAA;;AAED,YAAG,KAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACA;AACCA,UAAAA,QAAQ,CAARA,UAAAA,GAAAA,IAAAA;AACAd,UAAAA,IAAI,GAAJA,IAAAA;AACA;;AAED,aAAA,KAAA,CAAA,IAAA,CAAA,QAAA;AACA;AArDF,KAAA,QAsDQiB,IAAI,KAAM,CAtDlB,CAAA;;AAwDA,WAAA,IAAA;AAhJF,GAAA,CAkJC;;AACA;;;;;;AAIArC,EAAAA,QAAQ,GACR;AACC,QAAImB,MAAM,GAAV,EAAA;AACA,QAAIyB,SAAS,GAAb,KAAA;;AAEA,SAAI,IAAI5F,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAG,KAAA,KAAA,CAAnB,MAAA,EAAsCA,CAAtC,EAAA,EACA;AACC4F,MAAAA,SAAS,GAAG,KAAA,KAAA,CAAA,CAAA,EAAZA,SAAAA;AAEA,UAAIC,MAAM,GAAG,KAAA,KAAA,CAAA,CAAA,EAAb,QAAa,EAAb;AAEA,UAAG7F,CAAC,KAAJ,CAAA,EACCmE,MAAM,GAAI,GAAEA,MAAZA,GAAAA;;AAED,UAAA,SAAA,EACA;AACC0B,QAAAA,MAAM,GAAI,IAAGA,MAAbA,GAAAA;AAEA,YAAG,KAAA,KAAA,CAAA,CAAA,EAAH,UAAA,EACC1B,MAAM,GAAI,MAAK0B,MADhB,QACC1B,CADD,KAGCA,MAAM,IAANA,MAAAA;AAPF,OAAA,MAUCA,MAAM,IAANA,MAAAA;AACD;;AAED,WAAA,MAAA;AAlLF,GAAA,CAoLC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,4BAAA;AA3LF,GAAA,CA6LC;;AACA;;;;;;AAIAzF,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,KAAAA,GAAe,KAAfA,QAAe,EAAfA;AACAA,IAAAA,MAAM,CAANA,QAAAA,GAAAA,EAAAA;;AACA,SAAI,IAAIQ,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAG,KAAA,KAAA,CAAnB,MAAA,EAAsCA,CAAtC,EAAA,EACCR,MAAM,CAANA,QAAAA,CAAAA,IAAAA,CAAqB,KAAA,KAAA,CAAA,CAAA,EAArBA,MAAqB,EAArBA;;AAED,WAAA,MAAA;AAnNF,GAAA,CAqNC;;;AArND,C,CAuNA;;AACA;;;;;AAGO,MAAA,gBAAA,SAAA,SAAA,CACP;AACC;;AACA;;;;;AAKAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA,EAAA,+BAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,CAIC,CAJD,CAI6B;AAZ9B,GAAA,CAcC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,kBAAA;AArBF,GAAA,CAuBC;;;AAvBD,C,CAyBA;AACA;AACA;AACA;AACA;;;;;AACA,MAAA,yBAAA,SAAwCO,QAAQ,CAAhD,cAAgD,CAAhD,CACA;AACC;AACA;;AACA;;;;AAIAR,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,SAAA,GAAA,IAAA;AACA,SAAA,KAAA,GAJD,EAIC,CAJD,CAIkB;AAZnB,GAAA,CAcC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,sBAAA;AArBF,GAAA,CAuBC;AACA;;AACA;;;;;;AAIAC,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,KAAAA,GAAe,KAAfA,KAAAA;AAEA,WAAA,MAAA;AA3CF,GAAA,CA6CC;;;AA7CD,C,CA+CA;;AACA;;;;;AAGO,MAAA,UAAA,SAAA,SAAA,CACP;AACC;;AACA;;;;;AAKAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA,EAAA,yBAAA;AAEA,QAAG,WAAH,UAAA,EACC,KAAA,UAAA,CAAgBA,UAAU,CAA1B,KAAA;AAED,SAAA,OAAA,CAAA,QAAA,GAND,CAMC,CAND,CAM4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAPD,EAOC,CAPD,CAO8B;AAf/B,GAAA,CAiBC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,YAAA;AAxBF,GAAA,CA0BC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC,UAAM0B,YAAY,GAAG,KAAA,UAAA,CAAA,OAAA,CAAA,WAAA,EAAA,WAAA,EAAmD,KAAA,QAAA,CAAA,gBAAA,KAAD,IAAC,GAAD,WAAC,GAAyD,KAAA,QAAA,CAAjI,MAAqB,CAArB;;AACA,QAAGA,YAAY,KAAM,CAArB,CAAA,EACA;AACC,WAAA,KAAA,GAAa,KAAA,UAAA,CAAb,KAAA;AACA,aAAA,YAAA;AACA;;AAED,SAAA,UAAA,CAAgB,KAAA,UAAA,CAAhB,QAAA;AAEA,QAAG,KAAA,OAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,OAAA,CAApB,WAAA;AAED,QAAG,KAAA,QAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,QAAA,CAApB,WAAA;AAED,QAAG,KAAA,UAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,UAAA,CAApB,WAAA;AAED,WAAA,YAAA;AAtDF,GAAA,CAwDC;;AACA;;;;;;AAIAkF,EAAAA,UAAU,CAAA,WAAA,EACV;AACC,SAAA,UAAA,CAAA,KAAA,GAAwBC,MAAM,CAANA,YAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAgC,IAAA,UAAA,CAAxD,WAAwD,CAAhCA,CAAxB;;AAEA,QACA;AACC;AACA,WAAA,UAAA,CAAA,KAAA,GAAwBC,kBAAkB,CAACC,MAAM,CAAC,KAAA,UAAA,CAAlD,KAAiD,CAAP,CAA1C;AAHD,KAAA,CAKA,OAAA,EAAA,EACA;AACC,WAAA,QAAA,CAAA,IAAA,CAAoB,sCAAqCC,EAAzD,oBAAA;AACA;AAzEH,GAAA,CA2EC;;AACA;;;;;;AAIAf,EAAAA,UAAU,CAAA,WAAA,EACV;AACC;AACA,UAAMgB,GAAG,GAAGC,QAAQ,CAACC,kBAAkB,CAAvC,WAAuC,CAAnB,CAApB;AACA,UAAMC,MAAM,GAAGH,GAAG,CAAlB,MAAA;AAEA,SAAA,UAAA,CAAA,QAAA,GAA2B,IAAA,WAAA,CAA3B,MAA2B,CAA3B;AACA,UAAMpE,IAAI,GAAG,IAAA,UAAA,CAAe,KAAA,UAAA,CAA5B,QAAa,CAAb;;AAEA,SAAI,IAAI/B,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAhB,MAAA,EAA2BA,CAA3B,EAAA,EACC+B,IAAI,CAAJA,CAAI,CAAJA,GAAUoE,GAAG,CAAHA,UAAAA,CAAVpE,CAAUoE,CAAVpE;;AAED,SAAA,UAAA,CAAA,KAAA,GAAA,WAAA;AA5FF,GAAA,CA8FC;;;AA9FD,C,CAgGA;AACA;AACA;;;;;AACA,MAAA,0BAAA,SAAyC/C,QAAQ,CAAjD,cAAiD,CAAjD,CACA;AACC;;AACA;;;;;AAKAR,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,QAAA,GAAgB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,UAAA,EAA2C,CAA3D,CAAgB,CAAhB;AAXF,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,kBAAA;AApBF,GAAA,CAsBC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC,QAAIyC,WAAW,KAAf,CAAA,EACC,OAFF,WAEE,CAFF,CAIC;AACA;;AACA,QAAI,CAAA,GAAA,QAAA,CAAA,iBAAA,EAAA,IAAA,EAAA,WAAA,EAAA,WAAA,EAAA,WAAA,MAAJ,KAAA,EACC,OAAQ,CAPV,CAOE,CAPF,CAQC;;AAEA,UAAMxC,SAAS,GAAG,IAAA,UAAA,CAAA,WAAA,EAAA,WAAA,EAAlB,WAAkB,CAAlB;AAEA,SAAA,QAAA,GAAgB,IAAA,WAAA,CAAhB,WAAgB,CAAhB;AACA,QAAI4C,IAAI,GAAG,IAAA,UAAA,CAAe,KAA1B,QAAW,CAAX;;AAEA,SAAK,IAAI/B,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,WAAA,EAAiCA,CAAjC,EAAA,EACA;AACC+B,MAAAA,IAAI,CAAJA,CAAI,CAAJA,GAAU5C,SAAS,CAATA,CAAS,CAATA,GAAV4C,IAAAA;AAEA,WAAA,WAAA;AAEA,UAAI,CAAC5C,SAAS,CAATA,CAAS,CAATA,GAAD,IAAA,MAAJ,IAAA,EACC;AAtBH,KAAA,CAyBC;;;AACA,UAAM4F,YAAY,GAAG,IAAA,WAAA,CAAgB,KAArC,WAAqB,CAArB;AACA,UAAMC,QAAQ,GAAG,IAAA,UAAA,CAAjB,YAAiB,CAAjB;;AAEA,SAAK,IAAIhF,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAG,KAApB,WAAA,EAAsCA,CAAtC,EAAA,EACCgF,QAAQ,CAARA,CAAQ,CAARA,GAAcjD,IAAI,CA9BpB,CA8BoB,CAAlBiD,CA9BF,CAgCC;;;AACA,SAAA,QAAA,GAAgBD,YAAY,CAAZA,KAAAA,CAAhB,CAAgBA,CAAhB;AACAhD,IAAAA,IAAI,GAAG,IAAA,UAAA,CAAe,KAlCvB,QAkCQ,CAAPA,CAlCD,CAmCC;;AAEA,QAAI,CAAC5C,SAAS,CAAC,KAAA,WAAA,GAAVA,CAAS,CAATA,GAAD,IAAA,MAAJ,IAAA,EACA;AACC,WAAA,KAAA,GAAA,uDAAA;AACA,aAAQ,CAAR,CAAA;AACA;;AAED,QAAI4C,IAAI,CAAJA,CAAI,CAAJA,KAAJ,IAAA,EACC,KAAA,QAAA,CAAA,IAAA,CAAA,wCAAA;AAED,QAAI,KAAA,WAAA,IAAJ,CAAA,EACC,KAAA,QAAA,GAAgB,CAAA,GAAA,QAAA,CAAA,YAAA,EAAA,IAAA,EADjB,CACiB,CAAhB,CADD,KAGA;AACC,WAAA,SAAA,GAAA,IAAA;AACA,WAAA,QAAA,CAAA,IAAA,CAAA,oCAAA;AACA;AAED,WAAQ1C,WAAW,GAAG,KAAtB,WAAA;AArFF,GAAA,CAuFC;;AACA;;;;;;;AAKAC,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC;AACA,QAAA,MAAA;AACA,QAHD,OAGC,CAHD,CAIC;;AAEA,QAAI,KAAJ,SAAA,EACA;AACC,UAAIA,QAAQ,KAAZ,IAAA,EACC,OAAQ,IAAA,WAAA,CAAgB,KAAA,QAAA,CAAxB,UAAQ,CAAR;AAED,YAAMU,OAAO,GAAG,IAAA,UAAA,CAAe,KAA/B,QAAgB,CAAhB;AAEAP,MAAAA,MAAM,GAAG,IAAA,WAAA,CAAgB,KAAzBA,WAAS,CAATA;AACAC,MAAAA,OAAO,GAAG,IAAA,UAAA,CAAVA,MAAU,CAAVA;;AAEA,WAAK,IAAIK,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAI,KAAA,WAAA,GAArB,CAAA,EAA4CA,CAA5C,EAAA,EACCL,OAAO,CAAPA,CAAO,CAAPA,GAAaM,OAAO,CAAPA,CAAO,CAAPA,GAAbN,IAAAA;;AAEDA,MAAAA,OAAO,CAAC,KAAA,WAAA,GAARA,CAAO,CAAPA,GAAgCM,OAAO,CAAC,KAAA,WAAA,GAAxCN,CAAuC,CAAvCA;AAEA,aAAA,MAAA;AACA;;AAED,UAAME,UAAU,GAAG,CAAA,GAAA,QAAA,CAAA,UAAA,EAAW,KAAX,QAAA,EAAnB,CAAmB,CAAnB;;AACA,QAAIA,UAAU,CAAVA,UAAAA,KAAJ,CAAA,EACA;AACC,WAAA,KAAA,GAAA,iCAAA;AACA,aAAQ,IAAA,WAAA,CAAR,CAAQ,CAAR;AACA;;AAEDH,IAAAA,MAAM,GAAG,IAAA,WAAA,CAAgBG,UAAU,CAAnCH,UAAS,CAATA;;AAEA,QAAIH,QAAQ,KAAZ,KAAA,EACA;AACC,YAAMO,WAAW,GAAG,IAAA,UAAA,CAApB,UAAoB,CAApB;AACAH,MAAAA,OAAO,GAAG,IAAA,UAAA,CAAVA,MAAU,CAAVA;;AAEA,WAAK,IAAIK,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAIH,UAAU,CAAVA,UAAAA,GAArB,CAAA,EAAiDG,CAAjD,EAAA,EACCL,OAAO,CAAPA,CAAO,CAAPA,GAAaG,WAAW,CAAXA,CAAW,CAAXA,GAAbH,IAAAA;;AAEDA,MAAAA,OAAO,CAACE,UAAU,CAAVA,UAAAA,GAARF,CAAO,CAAPA,GAAqCG,WAAW,CAACD,UAAU,CAAVA,UAAAA,GAAjDF,CAAgD,CAAhDA;AACA;;AAED,WAAA,MAAA;AA1IF,GAAA,CA4IC;;AACA;;;;;;AAIAqD,EAAAA,QAAQ,GACR;AACC,QAAImB,MAAM,GAAV,EAAA;AAEA,QAAI,KAAA,SAAA,KAAJ,IAAA,EACCA,MAAM,GAAG,CAAA,GAAA,QAAA,CAAA,gBAAA,EAAiB,KAAjB,QAAA,EAAA,CAAA,EAAmC,KAAA,QAAA,CAD7C,UACU,CAATA,CADD,KAEK;AACJA,MAAAA,MAAM,GAAG,KAAA,QAAA,CAATA,QAAS,EAATA;AACA;AAED,WAAA,MAAA;AA3JF,GAAA,CA6JC;AACA;;AACA;;;;;;AAIAzF,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QAAI;AACHA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AADD,KAAA,CAEE,OAAA,EAAA,EAAW,CANd,CAAA,CAOC;;;AAEAA,IAAAA,MAAM,CAANA,QAAAA,GAAkB,KAAlBA,QAAAA;AAEA,WAAA,MAAA;AA/KF,GAAA,CAiLC;;;AAjLD,C,CAmLA;;;AACA,MAAA,uCAAA,SAAA,UAAA,CAAiE;AAChE;;AACA;;;;;AAKAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,UAAA,CAAgB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,OAAA,EAAhB,EAAgB,CAAhB;AAX+D,GAAA,CAahE;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC,QAAI0B,YAAY,GAAhB,WAAA;;AAEA,WAAOe,WAAW,GAAlB,CAAA,EACA;AACC,YAAMuD,QAAQ,GAAG,IAAjB,0BAAiB,EAAjB;AACAtE,MAAAA,YAAY,GAAGsE,QAAQ,CAARA,OAAAA,CAAAA,WAAAA,EAAAA,YAAAA,EAAftE,WAAesE,CAAftE;;AACA,UAAIA,YAAY,KAAM,CAAtB,CAAA,EACA;AACC,aAAA,WAAA,GAAA,CAAA;AACA,aAAA,KAAA,GAAasE,QAAQ,CAArB,KAAA;AACA,eAAA,YAAA;AACA;;AAED,WAAA,WAAA,IAAoBA,QAAQ,CAA5B,WAAA;AACAvD,MAAAA,WAAW,IAAIuD,QAAQ,CAAvBvD,WAAAA;AAEA,WAAA,KAAA,CAAA,IAAA,CAAA,QAAA;AACA;;AAED,WAAA,YAAA;AA1C+D,GAAA,CA4ChE;;AACA;;;;;;;AAKArC,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC,QAAIG,MAAM,GAAG,IAAA,WAAA,CAAb,CAAa,CAAb;;AAEA,SAAK,IAAIM,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAG,KAAA,KAAA,CAApB,MAAA,EAAuCA,CAAvC,EAAA,EACA;AACC,YAAM6B,QAAQ,GAAG,KAAA,KAAA,CAAA,CAAA,EAAA,KAAA,CAAjB,QAAiB,CAAjB;;AACA,UAAIA,QAAQ,CAARA,UAAAA,KAAJ,CAAA,EACA;AACC,aAAA,KAAA,GAAa,KAAA,KAAA,CAAA,CAAA,EAAb,KAAA;AACA,eAAQ,IAAA,WAAA,CAAR,CAAQ,CAAR;AACA;;AAEDnC,MAAAA,MAAM,GAAG,CAAA,GAAA,QAAA,CAAA,aAAA,EAAA,MAAA,EAATA,QAAS,CAATA;AACA;;AAED,WAAA,MAAA;AAlE+D,GAAA,CAoEhE;;AACA;;;;;;;AAKAyF,EAAAA,UAAU,CAAA,MAAA,EACV;AACC,SAAA,KAAA,GADD,EACC,CADD,CACkB;;AAEjB,QAAIC,IAAI,GAAR,CAAA;AACA,QAAIC,IAAI,GAAR,CAAA;AAEA,QAAIC,GAAG,GAAP,EAAA;;AAEA,OACA;AACCD,MAAAA,IAAI,GAAGE,MAAM,CAANA,OAAAA,CAAAA,GAAAA,EAAPF,IAAOE,CAAPF;AACA,UAAIA,IAAI,KAAM,CAAd,CAAA,EACCC,GAAG,GAAGC,MAAM,CAANA,MAAAA,CADP,IACOA,CAAND,CADD,KAGCA,GAAG,GAAGC,MAAM,CAANA,MAAAA,CAAAA,IAAAA,EAAoBF,IAAI,GAA9BC,IAAMC,CAAND;AAEDF,MAAAA,IAAI,GAAGC,IAAI,GAAXD,CAAAA;AAEA,YAAMF,QAAQ,GAAG,IAAjB,0BAAiB,EAAjB;AACAA,MAAAA,QAAQ,CAARA,QAAAA,GAAoBQ,QAAQ,CAAA,GAAA,EAA5BR,EAA4B,CAA5BA;AACA,UAAIS,KAAK,CAACT,QAAQ,CAAlB,QAAS,CAAT,EACC,OAAA,IAAA;AAED,WAAA,KAAA,CAAA,IAAA,CAAA,QAAA;AAfD,KAAA,QAiBSG,IAAI,KAAM,CAjBnB,CAAA;;AAmBA,WAAA,IAAA;AAtG+D,GAAA,CAwGhE;;AACA;;;;;;AAIArC,EAAAA,QAAQ,GACR;AACC,QAAImB,MAAM,GAAV,EAAA;AACA,QAAIyB,SAAS,GAAb,KAAA;;AAEA,SAAK,IAAI5F,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAG,KAAA,KAAA,CAApB,MAAA,EAAuCA,CAAvC,EAAA,EACA;AACC4F,MAAAA,SAAS,GAAG,KAAA,KAAA,CAAA,CAAA,EAAZA,SAAAA;AAEA,UAAIC,MAAM,GAAG,KAAA,KAAA,CAAA,CAAA,EAAb,QAAa,EAAb;AAEA,UAAI7F,CAAC,KAAL,CAAA,EACCmE,MAAM,GAAI,GAAEA,MAAZA,GAAAA;;AAED,UAAA,SAAA,EACA;AACC0B,QAAAA,MAAM,GAAI,IAAGA,MAAbA,GAAAA;AACA1B,QAAAA,MAAM,IAANA,MAAAA;AAHD,OAAA,MAKCA,MAAM,IAANA,MAAAA;AACD;;AAED,WAAA,MAAA;AAnI+D,GAAA,CAqIhE;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,oCAAA;AA5I+D,GAAA,CA8IhE;;AACA;;;;;;AAIAzF,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAGE,OAAA,EAAA,EAAW,CAPd,CAAA,CAQC;;;AAEAA,IAAAA,MAAM,CAANA,KAAAA,GAAe,KAAfA,QAAe,EAAfA;AACAA,IAAAA,MAAM,CAANA,QAAAA,GAAAA,EAAAA;;AACA,SAAK,IAAIQ,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAG,KAAA,KAAA,CAApB,MAAA,EAAuCA,CAAvC,EAAA,EACCR,MAAM,CAANA,QAAAA,CAAAA,IAAAA,CAAqB,KAAA,KAAA,CAAA,CAAA,EAArBA,MAAqB,EAArBA;;AAED,WAAA,MAAA;AAnK+D,GAAA,CAqKhE;;;AArKgE,C,CAuKjE;;AACA;;;;;AAGO,MAAA,wBAAA,SAAA,SAAA,CACP;AACC;;AACA;;;;;AAKAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA,EAAA,uCAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAZ/B,GAAA,CAcC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,0BAAA;AArBF,GAAA,CAuBC;;;AAvBD,C,CAyBA;AACA;AACA;;AACA;;;;;;;;AAIA,MAAA,wBAAA,SAAuCO,QAAQ,CAA/C,cAA+C,CAA/C,CACA;AACC;;AACA;;;;AAIAR,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,SAAA,GAAA,IAAA;AACA,SAAA,KAAA,GAAA,EAAA;AAXF,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,qBAAA;AApBF,GAAA,CAsBC;AACA;;AACA;;;;;;AAIAC,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,KAAAA,GAAe,KAAfA,KAAAA;AAEA,WAAA,MAAA;AA1CF,GAAA,CA4CC;;;AA5CD,C,CA8CA;;AACA;;;;;AAGO,MAAA,SAAA,SAAA,SAAA,CACP;AACC;;AACA;;;;AAIAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA,EAAA,wBAAA;AAEA,QAAG,WAAH,UAAA,EACC,KAAA,UAAA,CAAgBA,UAAU,CAA1B,KAAA;AAED,SAAA,OAAA,CAAA,QAAA,GAND,CAMC,CAND,CAM4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAPD,EAOC,CAPD,CAO8B;AAd/B,GAAA,CAgBC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,WAAA;AAvBF,GAAA,CAyBC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC,UAAM0B,YAAY,GAAG,KAAA,UAAA,CAAA,OAAA,CAAA,WAAA,EAAA,WAAA,EAAmD,KAAA,QAAA,CAAA,gBAAA,KAAD,IAAC,GAAD,WAAC,GAAyD,KAAA,QAAA,CAAjI,MAAqB,CAArB;;AACA,QAAGA,YAAY,KAAM,CAArB,CAAA,EACA;AACC,WAAA,KAAA,GAAa,KAAA,UAAA,CAAb,KAAA;AACA,aAAA,YAAA;AACA;;AAED,SAAA,UAAA,CAAgB,KAAA,UAAA,CAAhB,QAAA;AAEA,QAAG,KAAA,OAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,OAAA,CAApB,WAAA;AAED,QAAG,KAAA,QAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,QAAA,CAApB,WAAA;AAED,QAAG,KAAA,UAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,UAAA,CAApB,WAAA;AAED,WAAA,YAAA;AArDF,GAAA,CAuDC;;AACA;;;;;;AAIAkF,EAAAA,UAAU,CAAA,WAAA,EACV;AACC;AACA,UAAMS,UAAU,GAAGnH,WAAW,CAAXA,KAAAA,CAAnB,CAAmBA,CAAnB;AACA,UAAMoH,SAAS,GAAG,IAAA,UAAA,CAAlB,UAAkB,CAAlB;;AAEA,SAAI,IAAIxG,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAGwG,SAAS,CAA5B,MAAA,EAAqCxG,CAAC,IAAtC,CAAA,EACA;AACC,YAAMyG,IAAI,GAAGD,SAAS,CAAtB,CAAsB,CAAtB;AAEAA,MAAAA,SAAS,CAATA,CAAS,CAATA,GAAeA,SAAS,CAACxG,CAAC,GAA1BwG,CAAwB,CAAxBA;AACAA,MAAAA,SAAS,CAACxG,CAAC,GAAXwG,CAAS,CAATA,GAAAA,IAAAA;AACA;;AAED,SAAA,UAAA,CAAA,KAAA,GAAwBT,MAAM,CAANA,YAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAgC,IAAA,WAAA,CAAxD,UAAwD,CAAhCA,CAAxB;AA1EF,GAAA,CA4EC;;AACA;;;;;;AAIAZ,EAAAA,UAAU,CAAA,WAAA,EACV;AACC,UAAMuB,SAAS,GAAGC,WAAW,CAA7B,MAAA;AAEA,SAAA,UAAA,CAAA,QAAA,GAA2B,IAAA,WAAA,CAAgBD,SAAS,GAApD,CAA2B,CAA3B;AACA,UAAMvF,YAAY,GAAG,IAAA,UAAA,CAAe,KAAA,UAAA,CAApC,QAAqB,CAArB;;AAEA,SAAI,IAAInB,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAhB,SAAA,EAA8BA,CAA9B,EAAA,EACA;AACC,YAAM4G,OAAO,GAAG,CAAA,GAAA,QAAA,CAAA,UAAA,EAAWD,WAAW,CAAXA,UAAAA,CAAX,CAAWA,CAAX,EAAhB,CAAgB,CAAhB;AACA,YAAME,QAAQ,GAAG,IAAA,UAAA,CAAjB,OAAiB,CAAjB;AACA,UAAGA,QAAQ,CAARA,MAAAA,GAAH,CAAA,EACC;AAED,YAAMC,GAAG,GAAG,IAAID,QAAQ,CAAxB,MAAA;;AAEA,WAAI,IAAIE,CAAC,GAAIF,QAAQ,CAARA,MAAAA,GAAb,CAAA,EAAmCE,CAAC,IAApC,CAAA,EAA2CA,CAA3C,EAAA,EACC5F,YAAY,CAACnB,CAAC,GAADA,CAAAA,GAAAA,CAAAA,GAAbmB,GAAY,CAAZA,GAAgC0F,QAAQ,CAAxC1F,CAAwC,CAAxCA;AACD;;AAED,SAAA,UAAA,CAAA,KAAA,GAAA,WAAA;AArGF,GAAA,CAuGC;;;AAvGD,C,CAyGA;;;;;AACA,MAAA,8BAAA,SAA6CnC,QAAQ,CAArD,cAAqD,CAArD,CACA;AACC;;AACA;;;;AAIAR,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,SAAA,GAAA,IAAA;AACA,SAAA,KAAA,GAAA,EAAA;AAXF,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,2BAAA;AApBF,GAAA,CAsBC;AACA;;AACA;;;;;;AAIAC,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,KAAAA,GAAe,KAAfA,KAAAA;AAEA,WAAA,MAAA;AA1CF,GAAA,CA4CC;;;AA5CD,C,CA8CA;;AACA;;;;;AAGO,MAAA,eAAA,SAAA,SAAA,CACP;AACC;;AACA;;;;AAIAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA,EAAA,8BAAA;AAEA,QAAG,WAAH,UAAA,EACC,KAAA,UAAA,CAAgBA,UAAU,CAA1B,KAAA;AAED,SAAA,OAAA,CAAA,QAAA,GAND,CAMC,CAND,CAM4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAPD,EAOC,CAPD,CAO8B;AAd/B,GAAA,CAgBC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,iBAAA;AAvBF,GAAA,CAyBC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC,UAAM0B,YAAY,GAAG,KAAA,UAAA,CAAA,OAAA,CAAA,WAAA,EAAA,WAAA,EAAmD,KAAA,QAAA,CAAA,gBAAA,KAAD,IAAC,GAAD,WAAC,GAAyD,KAAA,QAAA,CAAjI,MAAqB,CAArB;;AACA,QAAGA,YAAY,KAAM,CAArB,CAAA,EACA;AACC,WAAA,KAAA,GAAa,KAAA,UAAA,CAAb,KAAA;AACA,aAAA,YAAA;AACA;;AAED,SAAA,UAAA,CAAgB,KAAA,UAAA,CAAhB,QAAA;AAEA,QAAG,KAAA,OAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,OAAA,CAApB,WAAA;AAED,QAAG,KAAA,QAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,QAAA,CAApB,WAAA;AAED,QAAG,KAAA,UAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,UAAA,CAApB,WAAA;AAED,WAAA,YAAA;AArDF,GAAA,CAuDC;;AACA;;;;;;AAIAkF,EAAAA,UAAU,CAAA,WAAA,EACV;AACC;AACA,UAAMS,UAAU,GAAGnH,WAAW,CAAXA,KAAAA,CAAnB,CAAmBA,CAAnB;AACA,UAAMoH,SAAS,GAAG,IAAA,UAAA,CAAlB,UAAkB,CAAlB;;AAEA,SAAI,IAAIxG,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAGwG,SAAS,CAA5B,MAAA,EAAqCxG,CAAC,IAAtC,CAAA,EACA;AACCwG,MAAAA,SAAS,CAATA,CAAS,CAATA,GAAeA,SAAS,CAACxG,CAAC,GAA1BwG,CAAwB,CAAxBA;AACAA,MAAAA,SAAS,CAACxG,CAAC,GAAXwG,CAAS,CAATA,GAAmBA,SAAS,CAACxG,CAAC,GAA9BwG,CAA4B,CAA5BA;AACAA,MAAAA,SAAS,CAACxG,CAAC,GAAXwG,CAAS,CAATA,GAAAA,IAAAA;AACAA,MAAAA,SAAS,CAACxG,CAAC,GAAXwG,CAAS,CAATA,GAAAA,IAAAA;AACA;;AAED,SAAA,UAAA,CAAA,KAAA,GAAwBT,MAAM,CAANA,YAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAgC,IAAA,WAAA,CAAxD,UAAwD,CAAhCA,CAAxB;AA1EF,GAAA,CA4EC;;AACA;;;;;;AAIAZ,EAAAA,UAAU,CAAA,WAAA,EACV;AACC,UAAMuB,SAAS,GAAGC,WAAW,CAA7B,MAAA;AAEA,SAAA,UAAA,CAAA,QAAA,GAA2B,IAAA,WAAA,CAAgBD,SAAS,GAApD,CAA2B,CAA3B;AACA,UAAMvF,YAAY,GAAG,IAAA,UAAA,CAAe,KAAA,UAAA,CAApC,QAAqB,CAArB;;AAEA,SAAI,IAAInB,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAhB,SAAA,EAA8BA,CAA9B,EAAA,EACA;AACC,YAAM4G,OAAO,GAAG,CAAA,GAAA,QAAA,CAAA,UAAA,EAAWD,WAAW,CAAXA,UAAAA,CAAX,CAAWA,CAAX,EAAhB,CAAgB,CAAhB;AACA,YAAME,QAAQ,GAAG,IAAA,UAAA,CAAjB,OAAiB,CAAjB;AACA,UAAGA,QAAQ,CAARA,MAAAA,GAAH,CAAA,EACC;AAED,YAAMC,GAAG,GAAG,IAAID,QAAQ,CAAxB,MAAA;;AAEA,WAAI,IAAIE,CAAC,GAAIF,QAAQ,CAARA,MAAAA,GAAb,CAAA,EAAmCE,CAAC,IAApC,CAAA,EAA2CA,CAA3C,EAAA,EACC5F,YAAY,CAACnB,CAAC,GAADA,CAAAA,GAAAA,CAAAA,GAAbmB,GAAY,CAAZA,GAAgC0F,QAAQ,CAAxC1F,CAAwC,CAAxCA;AACD;;AAED,SAAA,UAAA,CAAA,KAAA,GAAA,WAAA;AArGF,GAAA,CAuGC;;;AAvGD,C,CAyGA;;;;;AACA,MAAA,2BAAA,SAA0CnC,QAAQ,CAAlD,cAAkD,CAAlD,CACA;AACC;;AACA;;;;AAIAR,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,KAAA,GAAA,EAAA;AACA,SAAA,SAAA,GAAA,IAAA;AAXF,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,wBAAA;AApBF,GAAA,CAsBC;AACA;;AACA;;;;;;AAIAC,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,KAAAA,GAAe,KAAfA,KAAAA;AAEA,WAAA,MAAA;AA1CF,GAAA,CA4CC;;;AA5CD,C,CA8CA;;AACA;;;;;AAGA,MAAA,sBAAA,SAAA,SAAA,CACA;AACC;;AACA;;;;AAIAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA,EAAA,2BAAA;AAEA,QAAG,WAAH,UAAA,EACC,KAAA,UAAA,CAAgBA,UAAU,CAA1B,KAAA;AAXH,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,cAAA;AApBF,GAAA,CAsBC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC,UAAM0B,YAAY,GAAG,KAAA,UAAA,CAAA,OAAA,CAAA,WAAA,EAAA,WAAA,EAAmD,KAAA,QAAA,CAAA,gBAAA,KAAD,IAAC,GAAD,WAAC,GAAyD,KAAA,QAAA,CAAjI,MAAqB,CAArB;;AACA,QAAGA,YAAY,KAAM,CAArB,CAAA,EACA;AACC,WAAA,KAAA,GAAa,KAAA,UAAA,CAAb,KAAA;AACA,aAAA,YAAA;AACA;;AAED,SAAA,UAAA,CAAgB,KAAA,UAAA,CAAhB,QAAA;AAEA,QAAG,KAAA,OAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,OAAA,CAApB,WAAA;AAED,QAAG,KAAA,QAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,QAAA,CAApB,WAAA;AAED,QAAG,KAAA,UAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,UAAA,CAApB,WAAA;AAED,WAAA,YAAA;AAlDF,GAAA,CAoDC;;AACA;;;;;;AAIAkF,EAAAA,UAAU,CAAA,WAAA,EACV;AACC,SAAA,UAAA,CAAA,KAAA,GAAwBC,MAAM,CAANA,YAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAgC,IAAA,UAAA,CAAxD,WAAwD,CAAhCA,CAAxB;AA3DF,GAAA,CA6DC;;AACA;;;;;;AAIAZ,EAAAA,UAAU,CAAA,WAAA,EACV;AACC,UAAMmB,MAAM,GAAGK,WAAW,CAA1B,MAAA;AAEA,SAAA,UAAA,CAAA,QAAA,GAA2B,IAAA,WAAA,CAA3B,MAA2B,CAA3B;AACA,UAAM5E,IAAI,GAAG,IAAA,UAAA,CAAe,KAAA,UAAA,CAA5B,QAAa,CAAb;;AAEA,SAAI,IAAI/B,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAhB,MAAA,EAA2BA,CAA3B,EAAA,EACC+B,IAAI,CAAJA,CAAI,CAAJA,GAAU4E,WAAW,CAAXA,UAAAA,CAAV5E,CAAU4E,CAAV5E;;AAED,SAAA,UAAA,CAAA,KAAA,GAAA,WAAA;AA5EF,GAAA,CA8EC;;;AA9ED,C,CAgFA;;AACA;;;;;AAGO,MAAA,aAAA,SAAA,sBAAA,CACP;AACC;;AACA;;;;AAIAvD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAX/B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,eAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;;AACA;;;;;;;AAGO,MAAA,eAAA,SAAA,sBAAA,CACP;AACC;;AACA;;;;AAIAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAX/B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,iBAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;;AACA;;;;;;;AAGO,MAAA,aAAA,SAAA,sBAAA,CACP;AACC;;AACA;;;;AAIAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAX/B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,eAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;;AACA;;;;;;;AAGO,MAAA,cAAA,SAAA,sBAAA,CACP;AACC;;AACA;;;;AAIAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAX/B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,gBAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;;AACA;;;;;;;AAGO,MAAA,SAAA,SAAA,sBAAA,CACP;AACC;;AACA;;;;AAIAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAX/B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,WAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;;AACA;;;;;;;AAGO,MAAA,aAAA,SAAA,sBAAA,CACP;AACC;;AACA;;;;AAIAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAX/B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,eAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;;AACA;;;;;;;AAGO,MAAA,aAAA,SAAA,sBAAA,CACP;AACC;;AACA;;;;AAIAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAX/B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,eAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;;AACA;;;;;;;AAGO,MAAA,aAAA,SAAA,sBAAA,CACP;AACC;;AACA;;;;AAIAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAX/B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,eAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;;AACA;;;;;;;AAGO,MAAA,eAAA,SAAA,sBAAA,CACP;AACC;;AACA;;;;AAIAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAX/B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,iBAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;AACA;AACA;AACA;AACA;;AACA;;;;;;;AAGO,MAAA,OAAA,SAAA,aAAA,CACP;AACC;;AACA;;;;;;AAMAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,IAAA,GAAA,CAAA;AACA,SAAA,KAAA,GAAA,CAAA;AACA,SAAA,GAAA,GAAA,CAAA;AACA,SAAA,IAAA,GAAA,CAAA;AACA,SAAA,MAAA,GAAA,CAAA;AACA,SAAA,MAAA,GARD,CAQC,CARD,CAUC;;AACA,QAAG,WAAH,UAAA,EACA;AACC,WAAA,UAAA,CAAgBA,UAAU,CAA1B,KAAA;AAEA,WAAA,UAAA,CAAA,QAAA,GAA2B,IAAA,WAAA,CAAgBA,UAAU,CAAVA,KAAAA,CAA3C,MAA2B,CAA3B;AACA,YAAMsD,IAAI,GAAG,IAAA,UAAA,CAAe,KAAA,UAAA,CAA5B,QAAa,CAAb;;AAEA,WAAI,IAAI/B,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAGvB,UAAU,CAAVA,KAAAA,CAAnB,MAAA,EAA4CuB,CAA5C,EAAA,EACC+B,IAAI,CAAJA,CAAI,CAAJA,GAAUtD,UAAU,CAAVA,KAAAA,CAAAA,UAAAA,CAAVsD,CAAUtD,CAAVsD;AAnBH,KAAA,CAqBC;AACA;;;AACA,QAAG,eAAH,UAAA,EACA;AACC,WAAA,QAAA,CAActD,UAAU,CAAxB,SAAA;AACA,WAAA,UAAA,CAAA,QAAA,GAA2B,KAA3B,QAA2B,EAA3B;AA1BF,KAAA,CA4BC;;;AAEA,SAAA,OAAA,CAAA,QAAA,GA9BD,CA8BC,CA9BD,CA8B4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GA/BD,EA+BC,CA/BD,CA+B8B;AAxC/B,GAAA,CA0CC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC,UAAM0B,YAAY,GAAG,KAAA,UAAA,CAAA,OAAA,CAAA,WAAA,EAAA,WAAA,EAAmD,KAAA,QAAA,CAAA,gBAAA,KAAD,IAAC,GAAD,WAAC,GAAyD,KAAA,QAAA,CAAjI,MAAqB,CAArB;;AACA,QAAGA,YAAY,KAAM,CAArB,CAAA,EACA;AACC,WAAA,KAAA,GAAa,KAAA,UAAA,CAAb,KAAA;AACA,aAAA,YAAA;AACA;;AAED,SAAA,UAAA,CAAgB,KAAA,UAAA,CAAhB,QAAA;AAEA,QAAG,KAAA,OAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,OAAA,CAApB,WAAA;AAED,QAAG,KAAA,QAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,QAAA,CAApB,WAAA;AAED,QAAG,KAAA,UAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,UAAA,CAApB,WAAA;AAED,WAAA,YAAA;AAtEF,GAAA,CAwEC;;AACA;;;;;;AAIAkF,EAAAA,UAAU,CAAA,WAAA,EACV;AACC,SAAA,UAAA,CAAgBC,MAAM,CAANA,YAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAgC,IAAA,UAAA,CAAhD,WAAgD,CAAhCA,CAAhB;AA/EF,GAAA,CAiFC;;AACA;;;;;;AAIAiB,EAAAA,QAAQ,GACR;AACC,UAAMb,GAAG,GAAG,KAAZ,QAAY,EAAZ;AAEA,UAAMc,MAAM,GAAG,IAAA,WAAA,CAAgBd,GAAG,CAAlC,MAAe,CAAf;AACA,UAAMpE,IAAI,GAAG,IAAA,UAAA,CAAb,MAAa,CAAb;;AAEA,SAAI,IAAI/B,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAGmG,GAAG,CAAtB,MAAA,EAA+BnG,CAA/B,EAAA,EACC+B,IAAI,CAAJA,CAAI,CAAJA,GAAUoE,GAAG,CAAHA,UAAAA,CAAVpE,CAAUoE,CAAVpE;;AAED,WAAA,MAAA;AAhGF,GAAA,CAkGC;;AACA;;;;;;AAIAmF,EAAAA,QAAQ,CAAA,SAAA,EACR;AACC,SAAA,IAAA,GAAYC,SAAS,CAArB,cAAYA,EAAZ;AACA,SAAA,KAAA,GAAaA,SAAS,CAATA,WAAAA,KAAb,CAAA;AACA,SAAA,GAAA,GAAWA,SAAS,CAApB,UAAWA,EAAX;AACA,SAAA,IAAA,GAAYA,SAAS,CAArB,WAAYA,EAAZ;AACA,SAAA,MAAA,GAAcA,SAAS,CAAvB,aAAcA,EAAd;AACA,SAAA,MAAA,GAAcA,SAAS,CAAvB,aAAcA,EAAd;AA9GF,GAAA,CAgHC;AACA;;AACA;;;;;;AAIAC,EAAAA,MAAM,GACN;AACC,WAAQ,IAAA,IAAA,CAASC,IAAI,CAAJA,GAAAA,CAAS,KAATA,IAAAA,EAAoB,KAAA,KAAA,GAApBA,CAAAA,EAAoC,KAApCA,GAAAA,EAA8C,KAA9CA,IAAAA,EAAyD,KAAzDA,MAAAA,EAAsE,KAAvF,MAAiBA,CAAT,CAAR;AAxHF,GAAA,CA0HC;;AACA;;;;;;AAIAlC,EAAAA,UAAU,CAAA,WAAA,EACV;AACC;AACA,UAAMmC,MAAM,GAAZ,+CAAA;AACA,UAAMC,WAAW,GAAGD,MAAM,CAANA,IAAAA,CAApB,WAAoBA,CAApB;;AACA,QAAGC,WAAW,KAAd,IAAA,EACA;AACC,WAAA,KAAA,GAAA,mCAAA;AACA;AAPF,KAAA,CASC;AAEA;;;AACA,UAAMC,IAAI,GAAG9B,QAAQ,CAAC6B,WAAW,CAAZ,CAAY,CAAZ,EAArB,EAAqB,CAArB;AACA,QAAGC,IAAI,IAAP,EAAA,EACC,KAAA,IAAA,GAAY,OADb,IACC,CADD,KAGC,KAAA,IAAA,GAAY,OAAZ,IAAA;AAED,SAAA,KAAA,GAAa9B,QAAQ,CAAC6B,WAAW,CAAZ,CAAY,CAAZ,EAArB,EAAqB,CAArB;AACA,SAAA,GAAA,GAAW7B,QAAQ,CAAC6B,WAAW,CAAZ,CAAY,CAAZ,EAAnB,EAAmB,CAAnB;AACA,SAAA,IAAA,GAAY7B,QAAQ,CAAC6B,WAAW,CAAZ,CAAY,CAAZ,EAApB,EAAoB,CAApB;AACA,SAAA,MAAA,GAAc7B,QAAQ,CAAC6B,WAAW,CAAZ,CAAY,CAAZ,EAAtB,EAAsB,CAAtB;AACA,SAAA,MAAA,GAAc7B,QAAQ,CAAC6B,WAAW,CAAZ,CAAY,CAAZ,EAtBvB,EAsBuB,CAAtB,CAtBD,CAuBC;AAvJF,GAAA,CAyJC;;AACA;;;;;;AAIAvE,EAAAA,QAAQ,GACR;AACC,UAAMyE,WAAW,GAAG,IAAA,KAAA,CAApB,CAAoB,CAApB;AAEAA,IAAAA,WAAW,CAAXA,CAAW,CAAXA,GAAiB,CAAA,GAAA,QAAA,CAAA,SAAA,EAAY,KAAA,IAAA,GAAD,IAAC,GAAqB,KAAA,IAAA,GAAtB,IAAC,GAA0C,KAAA,IAAA,GAAtD,IAAA,EAAjBA,CAAiB,CAAjBA;AACAA,IAAAA,WAAW,CAAXA,CAAW,CAAXA,GAAiB,CAAA,GAAA,QAAA,CAAA,SAAA,EAAU,KAAV,KAAA,EAAjBA,CAAiB,CAAjBA;AACAA,IAAAA,WAAW,CAAXA,CAAW,CAAXA,GAAiB,CAAA,GAAA,QAAA,CAAA,SAAA,EAAU,KAAV,GAAA,EAAjBA,CAAiB,CAAjBA;AACAA,IAAAA,WAAW,CAAXA,CAAW,CAAXA,GAAiB,CAAA,GAAA,QAAA,CAAA,SAAA,EAAU,KAAV,IAAA,EAAjBA,CAAiB,CAAjBA;AACAA,IAAAA,WAAW,CAAXA,CAAW,CAAXA,GAAiB,CAAA,GAAA,QAAA,CAAA,SAAA,EAAU,KAAV,MAAA,EAAjBA,CAAiB,CAAjBA;AACAA,IAAAA,WAAW,CAAXA,CAAW,CAAXA,GAAiB,CAAA,GAAA,QAAA,CAAA,SAAA,EAAU,KAAV,MAAA,EAAjBA,CAAiB,CAAjBA;AACAA,IAAAA,WAAW,CAAXA,CAAW,CAAXA,GAAAA,GAAAA;AAEA,WAAOA,WAAW,CAAXA,IAAAA,CAAP,EAAOA,CAAP;AA1KF,GAAA,CA4KC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,SAAA;AAnLF,GAAA,CAqLC;;AACA;;;;;;AAIA/I,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,IAAAA,GAAc,KAAdA,IAAAA;AACAA,IAAAA,MAAM,CAANA,KAAAA,GAAe,KAAfA,KAAAA;AACAA,IAAAA,MAAM,CAANA,GAAAA,GAAa,KAAbA,GAAAA;AACAA,IAAAA,MAAM,CAANA,IAAAA,GAAc,KAAdA,IAAAA;AACAA,IAAAA,MAAM,CAANA,MAAAA,GAAgB,KAAhBA,MAAAA;AACAA,IAAAA,MAAM,CAANA,MAAAA,GAAgB,KAAhBA,MAAAA;AAEA,WAAA,MAAA;AA7MF,GAAA,CA+MC;;;AA/MD,C,CAiNA;;AACA;;;;;;;AAGO,MAAA,eAAA,SAAA,aAAA,CACP;AACC;;AACA;;;;;;AAMAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,IAAA,GAAA,CAAA;AACA,SAAA,KAAA,GAAA,CAAA;AACA,SAAA,GAAA,GAAA,CAAA;AACA,SAAA,IAAA,GAAA,CAAA;AACA,SAAA,MAAA,GAAA,CAAA;AACA,SAAA,MAAA,GAAA,CAAA;AACA,SAAA,WAAA,GATD,CASC,CATD,CAWC;;AACA,QAAG,WAAH,UAAA,EACA;AACC,WAAA,UAAA,CAAgBA,UAAU,CAA1B,KAAA;AAEA,WAAA,UAAA,CAAA,QAAA,GAA2B,IAAA,WAAA,CAAgBA,UAAU,CAAVA,KAAAA,CAA3C,MAA2B,CAA3B;AACA,YAAMsD,IAAI,GAAG,IAAA,UAAA,CAAe,KAAA,UAAA,CAA5B,QAAa,CAAb;;AAEA,WAAI,IAAI/B,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAGvB,UAAU,CAAVA,KAAAA,CAAnB,MAAA,EAA4CuB,CAA5C,EAAA,EACC+B,IAAI,CAAJA,CAAI,CAAJA,GAAUtD,UAAU,CAAVA,KAAAA,CAAAA,UAAAA,CAAVsD,CAAUtD,CAAVsD;AApBH,KAAA,CAsBC;AACA;;;AACA,QAAG,eAAH,UAAA,EACA;AACC,WAAA,QAAA,CAActD,UAAU,CAAxB,SAAA;AACA,WAAA,UAAA,CAAA,QAAA,GAA2B,KAA3B,QAA2B,EAA3B;AA3BF,KAAA,CA6BC;;;AAEA,SAAA,OAAA,CAAA,QAAA,GA/BD,CA+BC,CA/BD,CA+B4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAhCD,EAgCC,CAhCD,CAgC8B;AAzC/B,GAAA,CA2CC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC,UAAM0B,YAAY,GAAG,KAAA,UAAA,CAAA,OAAA,CAAA,WAAA,EAAA,WAAA,EAAmD,KAAA,QAAA,CAAA,gBAAA,KAAD,IAAC,GAAD,WAAC,GAAyD,KAAA,QAAA,CAAjI,MAAqB,CAArB;;AACA,QAAGA,YAAY,KAAM,CAArB,CAAA,EACA;AACC,WAAA,KAAA,GAAa,KAAA,UAAA,CAAb,KAAA;AACA,aAAA,YAAA;AACA;;AAED,SAAA,UAAA,CAAgB,KAAA,UAAA,CAAhB,QAAA;AAEA,QAAG,KAAA,OAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,OAAA,CAApB,WAAA;AAED,QAAG,KAAA,QAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,QAAA,CAApB,WAAA;AAED,QAAG,KAAA,UAAA,CAAA,KAAA,CAAA,MAAA,KAAH,CAAA,EACC,KAAA,WAAA,IAAoB,KAAA,UAAA,CAApB,WAAA;AAED,WAAA,YAAA;AAvEF,GAAA,CAyEC;;AACA;;;;;;AAIAkF,EAAAA,UAAU,CAAA,WAAA,EACV;AACC,SAAA,UAAA,CAAgBC,MAAM,CAANA,YAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAgC,IAAA,UAAA,CAAhD,WAAgD,CAAhCA,CAAhB;AAhFF,GAAA,CAkFC;;AACA;;;;;;AAIAiB,EAAAA,QAAQ,GACR;AACC,UAAMb,GAAG,GAAG,KAAZ,QAAY,EAAZ;AAEA,UAAMc,MAAM,GAAG,IAAA,WAAA,CAAgBd,GAAG,CAAlC,MAAe,CAAf;AACA,UAAMpE,IAAI,GAAG,IAAA,UAAA,CAAb,MAAa,CAAb;;AAEA,SAAI,IAAI/B,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAGmG,GAAG,CAAtB,MAAA,EAA+BnG,CAA/B,EAAA,EACC+B,IAAI,CAAJA,CAAI,CAAJA,GAAUoE,GAAG,CAAHA,UAAAA,CAAVpE,CAAUoE,CAAVpE;;AAED,WAAA,MAAA;AAjGF,GAAA,CAmGC;;AACA;;;;;;AAIAmF,EAAAA,QAAQ,CAAA,SAAA,EACR;AACC,SAAA,IAAA,GAAYC,SAAS,CAArB,cAAYA,EAAZ;AACA,SAAA,KAAA,GAAaA,SAAS,CAATA,WAAAA,KAAb,CAAA;AACA,SAAA,GAAA,GAAWA,SAAS,CAApB,UAAWA,EAAX;AACA,SAAA,IAAA,GAAYA,SAAS,CAArB,WAAYA,EAAZ;AACA,SAAA,MAAA,GAAcA,SAAS,CAAvB,aAAcA,EAAd;AACA,SAAA,MAAA,GAAcA,SAAS,CAAvB,aAAcA,EAAd;AACA,SAAA,WAAA,GAAmBA,SAAS,CAA5B,kBAAmBA,EAAnB;AAhHF,GAAA,CAkHC;AACA;;AACA;;;;;;AAIAC,EAAAA,MAAM,GACN;AACC,WAAQ,IAAA,IAAA,CAASC,IAAI,CAAJA,GAAAA,CAAS,KAATA,IAAAA,EAAoB,KAAA,KAAA,GAApBA,CAAAA,EAAoC,KAApCA,GAAAA,EAA8C,KAA9CA,IAAAA,EAAyD,KAAzDA,MAAAA,EAAsE,KAAtEA,MAAAA,EAAmF,KAApG,WAAiBA,CAAT,CAAR;AA1HF,GAAA,CA4HC;;AACA;;;;;;AAIAlC,EAAAA,UAAU,CAAA,WAAA,EACV;AACC;AACA,QAAIuC,KAAK,GAAT,KAAA;AAEA,QAAIC,UAAU,GAAd,EAAA;AACA,QAAIC,cAAc,GAAlB,EAAA;AACA,QAAIC,YAAY,GAAhB,CAAA;AAEA,QAAA,MAAA;AAEA,QAAIC,cAAc,GAAlB,CAAA;AACA,QAAIC,gBAAgB,GAXrB,CAWC,CAXD,CAYC;AAEA;;AACA,QAAGpB,WAAW,CAACA,WAAW,CAAXA,MAAAA,GAAZA,CAAW,CAAXA,KAAH,GAAA,EACA;AACCgB,MAAAA,UAAU,GAAGhB,WAAW,CAAXA,MAAAA,CAAAA,CAAAA,EAAsBA,WAAW,CAAXA,MAAAA,GAAnCgB,CAAahB,CAAbgB;AAEAD,MAAAA,KAAK,GAALA,IAAAA;AAJD,KAAA,CAMA;AACA;AAPA,SASA;AACC;AACA,cAAM9H,MAAM,GAAG,IAAA,MAAA,CAAW+G,WAAW,CAACA,WAAW,CAAXA,MAAAA,GAAtC,CAAqC,CAAtB,CAAf;AAEA,YAAGhB,KAAK,CAAC/F,MAAM,CAAf,OAASA,EAAD,CAAR,EACC,MAAM,IAAA,KAAA,CAAN,mCAAM,CAAN;AAED+H,QAAAA,UAAU,GAAVA,WAAAA;AA/BF,OAAA,CAiCC;AAEA;;;AACA,QAAA,KAAA,EACA;AACC,UAAGA,UAAU,CAAVA,OAAAA,CAAAA,GAAAA,MAA6B,CAAhC,CAAA,EACC,MAAM,IAAA,KAAA,CAAN,mCAAM,CAAN;AAED,UAAGA,UAAU,CAAVA,OAAAA,CAAAA,GAAAA,MAA6B,CAAhC,CAAA,EACC,MAAM,IAAA,KAAA,CAAN,mCAAM,CAAN;AANF,KAAA,CAQA;AACA;AATA,SAWA;AACC,YAAIK,UAAU,GAAd,CAAA;AACA,YAAIC,kBAAkB,GAAGN,UAAU,CAAVA,OAAAA,CAAzB,GAAyBA,CAAzB;AACA,YAAIO,gBAAgB,GAApB,EAAA;;AAEA,YAAGD,kBAAkB,KAAM,CAA3B,CAAA,EACA;AACCA,UAAAA,kBAAkB,GAAGN,UAAU,CAAVA,OAAAA,CAArBM,GAAqBN,CAArBM;AACAD,UAAAA,UAAU,GAAI,CAAdA,CAAAA;AACA;;AAED,YAAGC,kBAAkB,KAAM,CAA3B,CAAA,EACA;AACCC,UAAAA,gBAAgB,GAAGP,UAAU,CAAVA,MAAAA,CAAkBM,kBAAkB,GAAvDC,CAAmBP,CAAnBO;AACAP,UAAAA,UAAU,GAAGA,UAAU,CAAVA,MAAAA,CAAAA,CAAAA,EAAbA,kBAAaA,CAAbA;AAEA,cAAIO,gBAAgB,CAAhBA,MAAAA,KAAD,CAACA,IAAmCA,gBAAgB,CAAhBA,MAAAA,KAAvC,CAAA,EACC,MAAM,IAAA,KAAA,CALR,mCAKQ,CAAN,CALF,CAOC;;AACA,cAAItI,MAAM,GAAG,IAAA,MAAA,CAAWsI,gBAAgB,CAAhBA,MAAAA,CAAAA,CAAAA,EAAxB,CAAwBA,CAAX,CAAb;AAEA,cAAGvC,KAAK,CAAC/F,MAAM,CAAf,OAASA,EAAD,CAAR,EACC,MAAM,IAAA,KAAA,CAAN,mCAAM,CAAN;AAEDkI,UAAAA,cAAc,GAAGE,UAAU,GAA3BF,MAAAA;;AAEA,cAAGI,gBAAgB,CAAhBA,MAAAA,KAAH,CAAA,EACA;AACC;AACAtI,YAAAA,MAAM,GAAG,IAAA,MAAA,CAAWsI,gBAAgB,CAAhBA,MAAAA,CAAAA,CAAAA,EAApBtI,CAAoBsI,CAAX,CAATtI;AAEA,gBAAG+F,KAAK,CAAC/F,MAAM,CAAf,OAASA,EAAD,CAAR,EACC,MAAM,IAAA,KAAA,CAAN,mCAAM,CAAN;AAEDmI,YAAAA,gBAAgB,GAAGC,UAAU,GAA7BD,MAAAA;AACA;AACD;AApFH,OAAA,CAsFC;AAEA;;;AACA,QAAII,qBAAqB,GAAGR,UAAU,CAAVA,OAAAA,CAzF7B,GAyF6BA,CAA5B,CAzFD,CAyFsD;;AACrD,QAAGQ,qBAAqB,KAAM,CAA9B,CAAA,EACCA,qBAAqB,GAAGR,UAAU,CAAVA,OAAAA,CA3F1B,GA2F0BA,CAAxBQ,CA3FF,CA2FmD;AAClD;AAEA;;AACA,QAAGA,qBAAqB,KAAM,CAA9B,CAAA,EACA;AACC;AACA,YAAMC,iBAAiB,GAAG,IAAA,MAAA,CAAY,IAAGT,UAAU,CAAVA,MAAAA,CAAAA,qBAAAA,CAAzC,EAA0B,CAA1B;AAEA,UAAGhC,KAAK,CAACyC,iBAAiB,CAA1B,OAASA,EAAD,CAAR,EACC,MAAM,IAAA,KAAA,CAAN,mCAAM,CAAN;AAEDP,MAAAA,YAAY,GAAGO,iBAAiB,CAAhCP,OAAeO,EAAfP;AAEAD,MAAAA,cAAc,GAAGD,UAAU,CAAVA,MAAAA,CAAAA,CAAAA,EAAjBC,qBAAiBD,CAAjBC;AAVD,KAAA,MAaCA,cAAc,GA5GhB,UA4GEA,CA5GF,CA6GC;AAEA;;;AACA,YAAA,IAAA;AAEC,WAAMA,cAAc,CAAdA,MAAAA,KAAN,CAAA;AAAoC;AACnCN,QAAAA,MAAM,GAANA,yBAAAA;AACA,YAAGa,qBAAqB,KAAM,CAA9B,CAAA,EACC,MAAM,IAAA,KAAA,CAHR,mCAGQ,CAAN,CAHF,CAGwD;;AACvD;;AACD,WAAMP,cAAc,CAAdA,MAAAA,KAAN,EAAA;AAAqC;AACpCN,QAAAA,MAAM,GAANA,gCAAAA;;AAEA,YAAGa,qBAAqB,KAAM,CAA9B,CAAA,EACA;AACC,cAAIE,cAAc,GAAG,KAArB,YAAA;AACA,eAAA,MAAA,GAAcC,IAAI,CAAJA,KAAAA,CAAd,cAAcA,CAAd;AAEAD,UAAAA,cAAc,GAAG,MAAMA,cAAc,GAAG,KAAxCA,MAAiB,CAAjBA;AACA,eAAA,MAAA,GAAcC,IAAI,CAAJA,KAAAA,CAAd,cAAcA,CAAd;AAEAD,UAAAA,cAAc,GAAG,QAAQA,cAAc,GAAG,KAA1CA,MAAiB,CAAjBA;AACA,eAAA,WAAA,GAAmBC,IAAI,CAAJA,KAAAA,CAAnB,cAAmBA,CAAnB;AACA;;AACD;;AACD,WAAMV,cAAc,CAAdA,MAAAA,KAAN,EAAA;AAAqC;AACpCN,QAAAA,MAAM,GAANA,uCAAAA;;AAEA,YAAGa,qBAAqB,KAAM,CAA9B,CAAA,EACA;AACC,cAAIE,cAAc,GAAG,KAArB,YAAA;AACA,eAAA,MAAA,GAAcC,IAAI,CAAJA,KAAAA,CAAd,cAAcA,CAAd;AAEAD,UAAAA,cAAc,GAAG,QAAQA,cAAc,GAAG,KAA1CA,MAAiB,CAAjBA;AACA,eAAA,WAAA,GAAmBC,IAAI,CAAJA,KAAAA,CAAnB,cAAmBA,CAAnB;AACA;;AACD;;AACD,WAAMV,cAAc,CAAdA,MAAAA,KAAN,EAAA;AAAqC;AACpCN,QAAAA,MAAM,GAANA,8CAAAA;;AAEA,YAAGa,qBAAqB,KAAM,CAA9B,CAAA,EACA;AACC,gBAAME,cAAc,GAAG,OAAvB,YAAA;AACA,eAAA,WAAA,GAAmBC,IAAI,CAAJA,KAAAA,CAAnB,cAAmBA,CAAnB;AACA;;AACD;;AACD;AACC,cAAM,IAAA,KAAA,CAAN,mCAAM,CAAN;AA5CF,KAhHD,CA8JC;AAEA;;;AACA,UAAMf,WAAW,GAAGD,MAAM,CAANA,IAAAA,CAApB,cAAoBA,CAApB;AACA,QAAGC,WAAW,KAAd,IAAA,EACC,MAAM,IAAA,KAAA,CAAN,mCAAM,CAAN;;AAED,SAAI,IAAIR,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAGQ,WAAW,CAA9B,MAAA,EAAuCR,CAAvC,EAAA,EACA;AACC,cAAA,CAAA;AAEC,aAAA,CAAA;AACC,eAAA,IAAA,GAAYrB,QAAQ,CAAC6B,WAAW,CAAZ,CAAY,CAAZ,EAApB,EAAoB,CAApB;AACA;;AACD,aAAA,CAAA;AACC,eAAA,KAAA,GAAa7B,QAAQ,CAAC6B,WAAW,CAAZ,CAAY,CAAZ,EAArB,EAAqB,CAArB;AACA;;AACD,aAAA,CAAA;AACC,eAAA,GAAA,GAAW7B,QAAQ,CAAC6B,WAAW,CAAZ,CAAY,CAAZ,EAAnB,EAAmB,CAAnB;AACA;;AACD,aAAA,CAAA;AACC,eAAA,IAAA,GAAY7B,QAAQ,CAAC6B,WAAW,CAAZ,CAAY,CAAZ,EAAR7B,EAAQ,CAARA,GAAZ,cAAA;AACA;;AACD,aAAA,CAAA;AACC,eAAA,MAAA,GAAcA,QAAQ,CAAC6B,WAAW,CAAZ,CAAY,CAAZ,EAAR7B,EAAQ,CAARA,GAAd,gBAAA;AACA;;AACD,aAAA,CAAA;AACC,eAAA,MAAA,GAAcA,QAAQ,CAAC6B,WAAW,CAAZ,CAAY,CAAZ,EAAtB,EAAsB,CAAtB;AACA;;AACD;AACC,gBAAM,IAAA,KAAA,CAAN,mCAAM,CAAN;AArBF;AAvKF,KAAA,CA+LC;AAEA;;;AACA,QAAGG,KAAK,KAAR,KAAA,EACA;AACC,YAAMa,QAAQ,GAAG,IAAA,IAAA,CAAS,KAAT,IAAA,EAAoB,KAApB,KAAA,EAAgC,KAAhC,GAAA,EAA0C,KAA1C,IAAA,EAAqD,KAArD,MAAA,EAAkE,KAAlE,MAAA,EAA+E,KAAhG,WAAiB,CAAjB;AAEA,WAAA,IAAA,GAAYA,QAAQ,CAApB,cAAYA,EAAZ;AACA,WAAA,KAAA,GAAaA,QAAQ,CAArB,WAAaA,EAAb;AACA,WAAA,GAAA,GAAWA,QAAQ,CAAnB,SAAWA,EAAX;AACA,WAAA,IAAA,GAAYA,QAAQ,CAApB,WAAYA,EAAZ;AACA,WAAA,MAAA,GAAcA,QAAQ,CAAtB,aAAcA,EAAd;AACA,WAAA,MAAA,GAAcA,QAAQ,CAAtB,aAAcA,EAAd;AACA,WAAA,WAAA,GAAmBA,QAAQ,CAA3B,kBAAmBA,EAAnB;AA5MF,KAAA,CA8MC;;AAhVF,GAAA,CAkVC;;AACA;;;;;;AAIAvF,EAAAA,QAAQ,GACR;AACC,UAAMyE,WAAW,GAAjB,EAAA;AAEAA,IAAAA,WAAW,CAAXA,IAAAA,CAAiB,CAAA,GAAA,QAAA,CAAA,SAAA,EAAU,KAAV,IAAA,EAAjBA,CAAiB,CAAjBA;AACAA,IAAAA,WAAW,CAAXA,IAAAA,CAAiB,CAAA,GAAA,QAAA,CAAA,SAAA,EAAU,KAAV,KAAA,EAAjBA,CAAiB,CAAjBA;AACAA,IAAAA,WAAW,CAAXA,IAAAA,CAAiB,CAAA,GAAA,QAAA,CAAA,SAAA,EAAU,KAAV,GAAA,EAAjBA,CAAiB,CAAjBA;AACAA,IAAAA,WAAW,CAAXA,IAAAA,CAAiB,CAAA,GAAA,QAAA,CAAA,SAAA,EAAU,KAAV,IAAA,EAAjBA,CAAiB,CAAjBA;AACAA,IAAAA,WAAW,CAAXA,IAAAA,CAAiB,CAAA,GAAA,QAAA,CAAA,SAAA,EAAU,KAAV,MAAA,EAAjBA,CAAiB,CAAjBA;AACAA,IAAAA,WAAW,CAAXA,IAAAA,CAAiB,CAAA,GAAA,QAAA,CAAA,SAAA,EAAU,KAAV,MAAA,EAAjBA,CAAiB,CAAjBA;;AACA,QAAG,KAAA,WAAA,KAAH,CAAA,EACA;AACCA,MAAAA,WAAW,CAAXA,IAAAA,CAAAA,GAAAA;AACAA,MAAAA,WAAW,CAAXA,IAAAA,CAAiB,CAAA,GAAA,QAAA,CAAA,SAAA,EAAU,KAAV,WAAA,EAAjBA,CAAiB,CAAjBA;AACA;;AACDA,IAAAA,WAAW,CAAXA,IAAAA,CAAAA,GAAAA;AAEA,WAAOA,WAAW,CAAXA,IAAAA,CAAP,EAAOA,CAAP;AAxWF,GAAA,CA0WC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,iBAAA;AAjXF,GAAA,CAmXC;;AACA;;;;;;AAIA/I,EAAAA,MAAM,GACN;AACC,QAAIc,MAAM,GADX,EACC,CADD,CAGC;;AACA,QACA;AACCA,MAAAA,MAAM,GAAG,MAATA,MAAS,EAATA;AAFD,KAAA,CAIA,OAAA,EAAA,EAAS,CARV,CAAA,CASC;;;AAEAA,IAAAA,MAAM,CAANA,IAAAA,GAAc,KAAdA,IAAAA;AACAA,IAAAA,MAAM,CAANA,KAAAA,GAAe,KAAfA,KAAAA;AACAA,IAAAA,MAAM,CAANA,GAAAA,GAAa,KAAbA,GAAAA;AACAA,IAAAA,MAAM,CAANA,IAAAA,GAAc,KAAdA,IAAAA;AACAA,IAAAA,MAAM,CAANA,MAAAA,GAAgB,KAAhBA,MAAAA;AACAA,IAAAA,MAAM,CAANA,MAAAA,GAAgB,KAAhBA,MAAAA;AACAA,IAAAA,MAAM,CAANA,WAAAA,GAAqB,KAArBA,WAAAA;AAEA,WAAA,MAAA;AA5YF,GAAA,CA8YC;;;AA9YD,C,CAgZA;;AACA;;;;;;;AAGO,MAAA,IAAA,SAAA,UAAA,CACP;AACC;;AACA;;;;AAIAhB,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAX/B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,MAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;;AACA;;;;;;;AAGO,MAAA,SAAA,SAAA,UAAA,CACP;AACC;;AACA;;;;AAIAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAX/B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,WAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;;AACA;;;;;;;AAGO,MAAA,QAAA,SAAA,UAAA,CACP;AACC;;AACA;;;;AAIAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAX/B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,UAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;;AACA;;;;;;;AAGO,MAAA,QAAA,SAAA,UAAA,CACP;AACC;;AACA;;;;AAIAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAX/B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,UAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;;AACA;;;;;;;AAGO,MAAA,IAAA,SAAA,UAAA,CACP;AACC;;AACA;;;;AAIAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,UAAA,UAAA;AAEA,SAAA,OAAA,CAAA,QAAA,GAHD,CAGC,CAHD,CAG4B;;AAC3B,SAAA,OAAA,CAAA,SAAA,GAJD,EAIC,CAJD,CAI8B;AAX/B,GAAA,CAaC;;AACA;;;;;;AAIA,SAAA,SAAA,GACA;AACC,WAAA,MAAA;AApBF,GAAA,CAsBC;;;AAtBD,C,CAwBA;AACA;AACA;AACA;AACA;;;;;AACO,MAAA,MAAA,CACP;AACC;;AACA;;;;;;AAMAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,SAAA,KAAA,GAAa,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,OAAA,EAAb,EAAa,CAAb;AACA,SAAA,QAAA,GAAgB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,UAAA,EAAhB,KAAgB,CAAhB;AAXF,GAAA,CAaC;;;AAbD,C,CAeA;AACA;AACA;AACA;AACA;;;;;AACO,MAAA,GAAA,CACP;AACC;;AACA;;;;;;AAMAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,SAAA,IAAA,GAAY,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,MAAA,EAAZ,EAAY,CAAZ;AACA,SAAA,QAAA,GAAgB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,UAAA,EAAhB,KAAgB,CAAhB;AAXF,GAAA,CAaC;;;AAbD,C,CAeA;AACA;AACA;AACA;AACA;;;;;AACO,MAAA,QAAA,CACP;AACC;;AACA;;;;;;AAMAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,SAAA,IAAA,GAAY,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,MAAA,EAAZ,EAAY,CAAZ;AACA,SAAA,QAAA,GAAgB,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,UAAA,EAAhB,KAAgB,CAAhB;AACA,SAAA,KAAA,GAAa,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,OAAA,EAAwC,IAArD,GAAqD,EAAxC,CAAb;AACA,SAAA,KAAA,GAAa,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,OAAA,EAJd,KAIc,CAAb,CAJD,CAI8D;AAb/D,GAAA,CAeC;;;AAfD,C,CAiBA;AACA;AACA;AACA;AACA;;AACA;;;;;;;AAGO,MAAA,OAAA,CACP;AACC;;AACA;;;;;;AAMAD,EAAAA,WAAW,CAACC,UAAU,GAAX,EAAA,EACX;AACC,SAAA,IAAA,GAAY,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAA,UAAA,EAAA,MAAA,EAAuC,IAAA,WAAA,CAAnD,CAAmD,CAAvC,CAAZ;AAVF,GAAA,CAYC;;AACA;;;;;;;;;AAOAS,EAAAA,OAAO,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACP;AACC,SAAA,IAAA,GAAYE,WAAW,CAAXA,KAAAA,CAAAA,WAAAA,EAAZ,WAAYA,CAAZ;AACA,WAAQC,WAAW,GAAnB,WAAA;AAvBF,GAAA,CAyBC;;AACA;;;;;;;AAKAC,EAAAA,KAAK,CAACC,QAAQ,GAAT,KAAA,EACL;AACC,WAAO,KAAP,IAAA;AAjCF,GAAA,CAmCC;;;AAnCD,C,CAqCA;AACA;AACA;AACA;AACA;;AACA;;;;;;;;;;;AAOA,SAAA,YAAA,CAAA,WAAA,EAAA,WAAA,EAAA,WAAA,EACA;AACC,QAAMiJ,cAAc,GADrB,WACC,CADD,CACqC;AAEpC;;AACA,WAAA,eAAA,CAAA,WAAA,EAAA,OAAA,EACA;AACC,QAAGC,WAAW,YAAd,OAAA,EACC,OAAA,WAAA;AAED,UAAMC,SAAS,GAAG,IAAlB,OAAkB,EAAlB;AACAA,IAAAA,SAAS,CAATA,OAAAA,GAAoBD,WAAW,CAA/BC,OAAAA;AACAA,IAAAA,SAAS,CAATA,QAAAA,GAAqBD,WAAW,CAAhCC,QAAAA;AACAA,IAAAA,SAAS,CAATA,QAAAA,GAAqBD,WAAW,CAPjC,QAOCC,CAPD,CAQC;;AACAA,IAAAA,SAAS,CAATA,iBAAAA,GAA8BD,WAAW,CAAXA,iBAAAA,CAAAA,KAAAA,CAA9BC,CAA8BD,CAA9BC;AAEA,WAAA,SAAA;AAhBF,GAAA,CAkBC;AAEA;;;AACA,MAAIjH,YAAY,GAAG,IAAA,SAAA,CAAA,EAAA,EArBpB,MAqBoB,CAAnB,CArBD,CAsBC;AAEA;;AACA,QAAMkH,SAAS,GAAG,IAAlB,cAAkB,EAAlB;;AACA,MAAG,CAAA,GAAA,QAAA,CAAA,iBAAA,EAAA,SAAA,EAAA,WAAA,EAAA,WAAA,EAAA,WAAA,MAAH,KAAA,EACA;AACClH,IAAAA,YAAY,CAAZA,KAAAA,GAAqBkH,SAAS,CAA9BlH,KAAAA;AACA,WAAO;AACNmB,MAAAA,MAAM,EAAG,CADH,CAAA;AAENuB,MAAAA,MAAM,EAAE1C;AAFF,KAAP;AA7BF,GAAA,CAkCC;AAEA;;;AACA,QAAMtC,SAAS,GAAG,IAAA,UAAA,CAAA,WAAA,EAAA,WAAA,EArCnB,WAqCmB,CAAlB,CArCD,CAsCC;AAEA;;AACA,MAAGA,SAAS,CAATA,MAAAA,KAAH,CAAA,EACA;AACC,SAAA,KAAA,GAAA,oBAAA;AACA,WAAO;AACNyD,MAAAA,MAAM,EAAG,CADH,CAAA;AAENuB,MAAAA,MAAM,EAAE1C;AAFF,KAAP;AA5CF,GAAA,CAiDC;AAEA;;;AACA,MAAIb,YAAY,GAAGa,YAAY,CAAZA,OAAAA,CAAAA,OAAAA,CAAAA,WAAAA,EAAAA,WAAAA,EAAnB,WAAmBA,CAAnB;AACAA,EAAAA,YAAY,CAAZA,QAAAA,CAAAA,MAAAA,CAA6BA,YAAY,CAAZA,OAAAA,CAA7BA,QAAAA;;AACA,MAAGb,YAAY,KAAM,CAArB,CAAA,EACA;AACCa,IAAAA,YAAY,CAAZA,KAAAA,GAAqBA,YAAY,CAAZA,OAAAA,CAArBA,KAAAA;AACA,WAAO;AACNmB,MAAAA,MAAM,EAAG,CADH,CAAA;AAENuB,MAAAA,MAAM,EAAE1C;AAFF,KAAP;AAIA;;AAEDpC,EAAAA,WAAW,GAAXA,YAAAA;AACAsC,EAAAA,WAAW,IAAIF,YAAY,CAAZA,OAAAA,CAhEhB,WAgECE,CAhED,CAiEC;AAEA;;AACAf,EAAAA,YAAY,GAAGa,YAAY,CAAZA,QAAAA,CAAAA,OAAAA,CAAAA,WAAAA,EAAAA,WAAAA,EAAfb,WAAea,CAAfb;AACAa,EAAAA,YAAY,CAAZA,QAAAA,CAAAA,MAAAA,CAA6BA,YAAY,CAAZA,QAAAA,CAA7BA,QAAAA;;AACA,MAAGb,YAAY,KAAM,CAArB,CAAA,EACA;AACCa,IAAAA,YAAY,CAAZA,KAAAA,GAAqBA,YAAY,CAAZA,QAAAA,CAArBA,KAAAA;AACA,WAAO;AACNmB,MAAAA,MAAM,EAAG,CADH,CAAA;AAENuB,MAAAA,MAAM,EAAE1C;AAFF,KAAP;AAIA;;AAEDpC,EAAAA,WAAW,GAAXA,YAAAA;AACAsC,EAAAA,WAAW,IAAIF,YAAY,CAAZA,QAAAA,CAhFhB,WAgFCE,CAhFD,CAiFC;AAEA;;AACA,MAAIF,YAAY,CAAZA,OAAAA,CAAAA,aAAAA,KAAD,KAACA,IACFA,YAAY,CAAZA,QAAAA,CAAAA,gBAAAA,KADF,IAAA,EAEA;AACCA,IAAAA,YAAY,CAAZA,KAAAA,GAAAA,yDAAAA;AACA,WAAO;AACNmB,MAAAA,MAAM,EAAG,CADH,CAAA;AAENuB,MAAAA,MAAM,EAAE1C;AAFF,KAAP;AAxFF,GAAA,CA6FC;AAEA;;;AACA,MAAImH,WAAW,GAAf,SAAA;;AAEA,UAAOnH,YAAY,CAAZA,OAAAA,CAAP,QAAA;AAEC;AACA,SAAA,CAAA;AACC;AACA,UAAIA,YAAY,CAAZA,OAAAA,CAAAA,SAAAA,IAAD,EAACA,IACFA,YAAY,CAAZA,OAAAA,CAAAA,SAAAA,KADF,KAAA,EAEA;AACCA,QAAAA,YAAY,CAAZA,KAAAA,GAAAA,4DAAAA;AACA,eAAO;AACNmB,UAAAA,MAAM,EAAG,CADH,CAAA;AAENuB,UAAAA,MAAM,EAAE1C;AAFF,SAAP;AANF,OAAA,CAWC;;;AAEA,cAAOA,YAAY,CAAZA,OAAAA,CAAP,SAAA;AAEC;AACA,aAAA,CAAA;AACC;AACA,cAAIA,YAAY,CAAZA,OAAAA,CAAAA,aAAAA,KAAD,IAACA,IACFA,YAAY,CAAZA,QAAAA,CAAAA,MAAAA,GADF,CAAA,EAEA;AACCA,YAAAA,YAAY,CAAZA,KAAAA,GAAAA,gCAAAA;AACA,mBAAO;AACNmB,cAAAA,MAAM,EAAG,CADH,CAAA;AAENuB,cAAAA,MAAM,EAAE1C;AAFF,aAAP;AANF,WAAA,CAWC;;;AAEAmH,UAAAA,WAAW,GAAXA,YAAAA;AAEA;AACD;AACA;;AACA,aAAA,CAAA;AACCA,UAAAA,WAAW,GAAXA,OAAAA;AACA;AACD;AACA;;AACA,aAAA,CAAA;AACCA,UAAAA,WAAW,GAAXA,OAAAA;AACA;AACD;AACA;;AACA,aAAA,CAAA;AACCA,UAAAA,WAAW,GAAXA,SAAAA;AACA;AACD;AACA;;AACA,aAAA,CAAA;AACCA,UAAAA,WAAW,GAAXA,WAAAA;AACA;AACD;AACA;;AACA,aAAA,CAAA;AACCA,UAAAA,WAAW,GAAXA,IAAAA;AACA;AACD;AACA;;AACA,aAAA,CAAA;AACCA,UAAAA,WAAW,GAAXA,gBAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,UAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,UAAAA;AACA;AACD;AACA;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,wBAAAA;AACA;AACD;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,IAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCnH,UAAAA,YAAY,CAAZA,KAAAA,GAAAA,8CAAAA;AACA,iBAAO;AACNmB,YAAAA,MAAM,EAAG,CADH,CAAA;AAENuB,YAAAA,MAAM,EAAE1C;AAFF,WAAP;AAID;AACA;;AACA,aAAA,EAAA;AACCmH,UAAAA,WAAW,GAAXA,QAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,GAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,aAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,eAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,aAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,cAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,SAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,OAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,eAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,aAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,aAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,aAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,eAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,eAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,SAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,IAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,SAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,QAAAA;AACA;AACD;AACA;;AACA,aAAA,EAAA;AACCA,UAAAA,WAAW,GAAXA,QAAAA;AACA;AACD;AACA;;AACA;AACC;AACC,gBAAA,SAAA;AAEA,gBAAGnH,YAAY,CAAZA,OAAAA,CAAAA,aAAAA,KAAH,IAAA,EACCiH,SAAS,GAAG,IADb,WACa,EAAZA,CADD,KAGCA,SAAS,GAAG,IAAZA,SAAY,EAAZA;AAEDA,YAAAA,SAAS,CAATA,OAAAA,GAAoBjH,YAAY,CAAhCiH,OAAAA;AACAA,YAAAA,SAAS,CAATA,QAAAA,GAAqBjH,YAAY,CAAjCiH,QAAAA;AACAA,YAAAA,SAAS,CAATA,QAAAA,GAAqBjH,YAAY,CAAjCiH,QAAAA;AAEAjH,YAAAA,YAAY,GAAZA,SAAAA;AAEAb,YAAAA,YAAY,GAAGa,YAAY,CAAZA,OAAAA,CAAAA,WAAAA,EAAAA,WAAAA,EAAfb,WAAea,CAAfb;AACA;AACF;AA/LD;;AAiMA;AACD;AACA;;AACA,SApND,CAoNC,CApND,CAoNS;;AACR,SArND,CAqNC,CArND,CAqNS;;AACR,SAtND,CAsNC,CAtND,CAsNS;;AACR;AACC;AACC,YAAGa,YAAY,CAAZA,OAAAA,CAAAA,aAAAA,KAAH,IAAA,EACCmH,WAAW,GADZ,WACCA,CADD,KAGCA,WAAW,GAAXA,SAAAA;AACD;AACF;AA9ND,GAlGD,CAkUC;AAEA;;;AACAnH,EAAAA,YAAY,GAAGoH,eAAe,CAAA,YAAA,EAA9BpH,WAA8B,CAA9BA;AACAb,EAAAA,YAAY,GAAGa,YAAY,CAAZA,OAAAA,CAAAA,WAAAA,EAAAA,WAAAA,EAAgDA,YAAY,CAAZA,QAAAA,CAAAA,gBAAAA,KAAD,IAACA,GAAD,WAACA,GAAiEA,YAAY,CAAZA,QAAAA,CAtUjI,MAsUgBA,CAAfb,CAtUD,CAuUC;AAEA;;AACAa,EAAAA,YAAY,CAAZA,iBAAAA,GAAiCrC,WAAW,CAAXA,KAAAA,CAAAA,cAAAA,EAAkCoJ,cAAc,GAAG/G,YAAY,CA1UjG,WA0UkCrC,CAAjCqC,CA1UD,CA2UC;;AAEA,SAAO;AACNmB,IAAAA,MAAM,EADA,YAAA;AAENuB,IAAAA,MAAM,EAAE1C;AAFF,GAAP;EAKD;;AACA;;;;;;AAIO,SAAA,OAAA,CAAA,WAAA,EACP;AACC,MAAGrC,WAAW,CAAXA,UAAAA,KAAH,CAAA,EACA;AACC,UAAM+E,MAAM,GAAG,IAAA,SAAA,CAAA,EAAA,EAAf,MAAe,CAAf;AACAA,IAAAA,MAAM,CAANA,KAAAA,GAAAA,8BAAAA;AAEA,WAAO;AACNvB,MAAAA,MAAM,EAAG,CADH,CAAA;AAENuB,MAAAA;AAFM,KAAP;AAIA;;AAED,SAAOzC,YAAY,CAAA,WAAA,EAAA,CAAA,EAAiBtC,WAAW,CAA/C,UAAmB,CAAnB;EAED;AACA;AACA;AACA;AACA;;AACA;;;;;;;;;AAOO,SAAA,aAAA,CAAA,IAAA,EAAA,SAAA,EAAA,WAAA,EACP;AACC;AACA,MAAG0J,WAAW,YAAd,MAAA,EACA;AACC,UAAMC,YAAY,GAAlB,KAAA;;AAEA,SAAI,IAAIhC,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAG+B,WAAW,CAAXA,KAAAA,CAAnB,MAAA,EAA6C/B,CAA7C,EAAA,EACA;AACC,YAAM5C,MAAM,GAAG6E,aAAa,CAAA,IAAA,EAAA,SAAA,EAAkBF,WAAW,CAAXA,KAAAA,CAA9C,CAA8CA,CAAlB,CAA5B;;AACA,UAAG3E,MAAM,CAANA,QAAAA,KAAH,IAAA,EACA;AACC,eAAO;AACN8E,UAAAA,QAAQ,EADF,IAAA;AAEN9E,UAAAA,MAAM,EAAE+E;AAFF,SAAP;AAIA;AACD;;AAED,QAAGH,YAAY,KAAf,KAAA,EACA;AACC,YAAMI,OAAO,GAAG;AACfF,QAAAA,QAAQ,EADO,KAAA;AAEf9E,QAAAA,MAAM,EAAE;AACPtF,UAAAA,KAAK,EAAE;AADA;AAFO,OAAhB;AAOA,UAAGiK,WAAW,CAAXA,cAAAA,CAAH,MAAGA,CAAH,EACCK,OAAO,CAAPA,IAAAA,GAAeL,WAAW,CAA1BK,IAAAA;AAED,aAAA,OAAA;AACA;AA/BH,GAAA,CAiCC;AAEA;;;AACA,MAAGL,WAAW,YAAd,GAAA,EACA;AACC;AACA,QAAGA,WAAW,CAAXA,cAAAA,CAAH,MAAGA,CAAH,EACCI,IAAI,CAACJ,WAAW,CAAhBI,IAAI,CAAJA,GAHF,SAGEA,CAHF,CAIC;;AAEA,WAAO;AACND,MAAAA,QAAQ,EADF,IAAA;AAEN9E,MAAAA,MAAM,EAAE+E;AAFF,KAAP;AA3CF,GAAA,CAgDC;AAEA;;;AACA,MAAIA,IAAI,YAAL,MAACA,KAAJ,KAAA,EACA;AACC,WAAO;AACND,MAAAA,QAAQ,EADF,KAAA;AAEN9E,MAAAA,MAAM,EAAE;AAAEtF,QAAAA,KAAK,EAAE;AAAT;AAFF,KAAP;AAIA;;AAED,MAAIuK,SAAS,YAAV,MAACA,KAAJ,KAAA,EACA;AACC,WAAO;AACNH,MAAAA,QAAQ,EADF,KAAA;AAEN9E,MAAAA,MAAM,EAAE;AAAEtF,QAAAA,KAAK,EAAE;AAAT;AAFF,KAAP;AAIA;;AAED,MAAIiK,WAAW,YAAZ,MAACA,KAAJ,KAAA,EACA;AACC,WAAO;AACNG,MAAAA,QAAQ,EADF,KAAA;AAEN9E,MAAAA,MAAM,EAAE;AAAEtF,QAAAA,KAAK,EAAE;AAAT;AAFF,KAAP;AAIA;;AAED,MAAI,aAAD,WAAC,KAAJ,KAAA,EACA;AACC,WAAO;AACNoK,MAAAA,QAAQ,EADF,KAAA;AAEN9E,MAAAA,MAAM,EAAE;AAAEtF,QAAAA,KAAK,EAAE;AAAT;AAFF,KAAP;AA7EF,GAAA,CAkFC;AAEA;AACA;AACA;;;AACA,MAAI,aAAaiK,WAAW,CAAzB,OAAC,KAAJ,KAAA,EACA;AACC,WAAO;AACNG,MAAAA,QAAQ,EADF,KAAA;AAEN9E,MAAAA,MAAM,EAAE;AAAEtF,QAAAA,KAAK,EAAE;AAAT;AAFF,KAAP;AAIA;;AAED,MAAI,WAAWiK,WAAW,CAAvB,OAAC,KAAJ,KAAA,EACA;AACC,WAAO;AACNG,MAAAA,QAAQ,EADF,KAAA;AAEN9E,MAAAA,MAAM,EAAE;AAAEtF,QAAAA,KAAK,EAAE;AAAT;AAFF,KAAP;AAIA;;AAED,QAAMwK,SAAS,GAAGP,WAAW,CAAXA,OAAAA,CAAAA,KAAAA,CAAlB,KAAkBA,CAAlB;;AACA,MAAGO,SAAS,CAATA,UAAAA,KAAH,CAAA,EACA;AACC,WAAO;AACNJ,MAAAA,QAAQ,EADF,KAAA;AAEN9E,MAAAA,MAAM,EAAE;AAAEtF,QAAAA,KAAK,EAAE;AAAT;AAFF,KAAP;AAIA;;AAED,QAAMyK,aAAa,GAAGR,WAAW,CAAXA,OAAAA,CAAAA,OAAAA,CAAAA,SAAAA,EAAAA,CAAAA,EAA0CO,SAAS,CAAzE,UAAsBP,CAAtB;;AACA,MAAGQ,aAAa,KAAM,CAAtB,CAAA,EACA;AACC,WAAO;AACNL,MAAAA,QAAQ,EADF,KAAA;AAEN9E,MAAAA,MAAM,EAAE;AAAEtF,QAAAA,KAAK,EAAE;AAAT;AAFF,KAAP;AAnHF,GAAA,CAwHC;AAEA;;;AACA,MAAGiK,WAAW,CAAXA,OAAAA,CAAAA,cAAAA,CAAAA,UAAAA,MAAH,KAAA,EACA;AACC,WAAO;AACNG,MAAAA,QAAQ,EADF,KAAA;AAEN9E,MAAAA,MAAM,EAAE;AAAEtF,QAAAA,KAAK,EAAE;AAAT;AAFF,KAAP;AAIA;;AAED,MAAGiK,WAAW,CAAXA,OAAAA,CAAAA,QAAAA,KAAiCM,SAAS,CAATA,OAAAA,CAApC,QAAA,EACA;AACC,WAAO;AACNH,MAAAA,QAAQ,EADF,KAAA;AAEN9E,MAAAA,MAAM,EAAE+E;AAFF,KAAP;AArIF,GAAA,CA0IC;AACA;;;AACA,MAAGJ,WAAW,CAAXA,OAAAA,CAAAA,cAAAA,CAAAA,WAAAA,MAAH,KAAA,EACA;AACC,WAAO;AACNG,MAAAA,QAAQ,EADF,KAAA;AAEN9E,MAAAA,MAAM,EAAE;AAAEtF,QAAAA,KAAK,EAAE;AAAT;AAFF,KAAP;AAIA;;AAED,MAAGiK,WAAW,CAAXA,OAAAA,CAAAA,SAAAA,KAAkCM,SAAS,CAATA,OAAAA,CAArC,SAAA,EACA;AACC,WAAO;AACNH,MAAAA,QAAQ,EADF,KAAA;AAEN9E,MAAAA,MAAM,EAAE+E;AAFF,KAAP;AAtJF,GAAA,CA2JC;AACA;;;AACA,MAAGJ,WAAW,CAAXA,OAAAA,CAAAA,cAAAA,CAAAA,eAAAA,MAAH,KAAA,EACA;AACC,WAAO;AACNG,MAAAA,QAAQ,EADF,KAAA;AAEN9E,MAAAA,MAAM,EAAE;AAAEtF,QAAAA,KAAK,EAAE;AAAT;AAFF,KAAP;AAIA;;AAED,MAAGiK,WAAW,CAAXA,OAAAA,CAAAA,aAAAA,KAAsCM,SAAS,CAATA,OAAAA,CAAzC,aAAA,EACA;AACC,WAAO;AACNH,MAAAA,QAAQ,EADF,KAAA;AAEN9E,MAAAA,MAAM,EAAE+E;AAFF,KAAP;AAvKF,GAAA,CA4KC;AACA;;;AACA,MAAI,eAAeJ,WAAW,CAA3B,OAAC,KAAJ,KAAA,EAAmD;AACnD;AACC,aAAO;AACNG,QAAAA,QAAQ,EADF,KAAA;AAEN9E,QAAAA,MAAM,EAAE;AAAEtF,UAAAA,KAAK,EAAE;AAAT;AAFF,OAAP;AAIA;;AAED,MAAGiK,WAAW,CAAXA,OAAAA,CAAAA,SAAAA,KAAkCM,SAAS,CAATA,OAAAA,CAArC,SAAA,EACA;AACC,WAAO;AACNH,MAAAA,QAAQ,EADF,KAAA;AAEN9E,MAAAA,MAAM,EAAE+E;AAFF,KAAP;AAxLF,GAAA,CA6LC;AACA;;;AACA,MAAGJ,WAAW,CAAXA,OAAAA,CAAAA,SAAAA,KAAH,IAAA,EACA;AACC,QAAI,cAAcA,WAAW,CAA1B,OAAC,KAAJ,KAAA,EAAkD;AAClD;AACC,eAAO;AACNG,UAAAA,QAAQ,EADF,KAAA;AAEN9E,UAAAA,MAAM,EAAE;AAAEtF,YAAAA,KAAK,EAAE;AAAT;AAFF,SAAP;AAIA;;AAED,UAAM0K,UAAU,GAAG,IAAA,UAAA,CAAeT,WAAW,CAAXA,OAAAA,CAAlC,QAAmB,CAAnB;AACA,UAAM5E,QAAQ,GAAG,IAAA,UAAA,CAAekF,SAAS,CAATA,OAAAA,CAAhC,QAAiB,CAAjB;;AAEA,QAAGG,UAAU,CAAVA,MAAAA,KAAsBrF,QAAQ,CAAjC,MAAA,EACA;AACC,aAAO;AACN+E,QAAAA,QAAQ,EADF,KAAA;AAEN9E,QAAAA,MAAM,EAAE+E;AAFF,OAAP;AAIA;;AAED,SAAI,IAAIlJ,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAGuJ,UAAU,CAA7B,MAAA,EAAsCvJ,CAAtC,EAAA,EACA;AACC,UAAGuJ,UAAU,CAAVA,CAAU,CAAVA,KAAkBrF,QAAQ,CAA7B,CAA6B,CAA7B,EACA;AACC,eAAO;AACN+E,UAAAA,QAAQ,EADF,KAAA;AAEN9E,UAAAA,MAAM,EAAE+E;AAFF,SAAP;AAIA;AACD;AA7NH,GAAA,CA+NC;AACA;AAEA;;;AACA,MAAGJ,WAAW,CAAXA,cAAAA,CAAH,MAAGA,CAAH,EACA;AACCA,IAAAA,WAAW,CAAXA,IAAAA,GAAmBA,WAAW,CAAXA,IAAAA,CAAAA,OAAAA,CAAAA,YAAAA,EAAnBA,EAAmBA,CAAnBA;AACA,QAAGA,WAAW,CAAXA,IAAAA,KAAH,EAAA,EACCI,IAAI,CAACJ,WAAW,CAAhBI,IAAI,CAAJA,GAAAA,SAAAA;AAvOH,GAAA,CAyOC;AAEA;;;AACA,MAAGJ,WAAW,CAAXA,OAAAA,CAAAA,aAAAA,KAAH,IAAA,EACA;AACC,QAAIU,SAAS,GAAb,CAAA;AACA,QAAIrF,MAAM,GAAG;AAAE8E,MAAAA,QAAQ,EAAE;AAAZ,KAAb;AAEA,QAAIQ,SAAS,GAAGX,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAhB,MAAA;;AAEA,QAAGW,SAAS,GAAZ,CAAA,EACA;AACC,UAAGX,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAAA,CAAAA,aAAH,QAAA,EACCW,SAAS,GAAGL,SAAS,CAATA,UAAAA,CAAAA,KAAAA,CAAZK,MAAAA;AATH,KAAA,CAYC;;;AACA,QAAGA,SAAS,KAAZ,CAAA,EACA;AACC,aAAO;AACNR,QAAAA,QAAQ,EADF,IAAA;AAEN9E,QAAAA,MAAM,EAAE+E;AAFF,OAAP;AAfF,KAAA,CAoBC;AAEA;;;AACA,QAAIE,SAAS,CAATA,UAAAA,CAAAA,KAAAA,CAAAA,MAAAA,KAAD,CAACA,IACFN,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAAA,MAAAA,KADF,CAAA,EAEA;AACC,UAAIY,SAAS,GAAb,IAAA;;AAEA,WAAI,IAAI1J,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAG8I,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAnB,MAAA,EAAwD9I,CAAxD,EAAA,EACC0J,SAAS,GAAGA,SAAS,KAAKZ,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAAA,QAAAA,IAA1BY,KAAqB,CAArBA;;AAED,UAAGA,SAAS,KAAZ,IAAA,EACA;AACC,eAAO;AACNT,UAAAA,QAAQ,EADF,IAAA;AAEN9E,UAAAA,MAAM,EAAE+E;AAFF,SAAP;AARF,OAAA,CAcC;;;AACA,UAAGJ,WAAW,CAAXA,cAAAA,CAAH,MAAGA,CAAH,EACA;AACCA,QAAAA,WAAW,CAAXA,IAAAA,GAAmBA,WAAW,CAAXA,IAAAA,CAAAA,OAAAA,CAAAA,YAAAA,EAAnBA,EAAmBA,CAAnBA;AACA,YAAGA,WAAW,CAAXA,IAAAA,KAAH,EAAA,EACC,OAAOI,IAAI,CAACJ,WAAW,CAAvB,IAAW,CAAX;AAnBH,OAAA,CAqBC;;;AAEAI,MAAAA,IAAI,CAAJA,KAAAA,GAAAA,4BAAAA;AAEA,aAAO;AACND,QAAAA,QAAQ,EADF,KAAA;AAEN9E,QAAAA,MAAM,EAAE+E;AAFF,OAAP;AAlDF,KAAA,CAuDC;;;AAEA,SAAI,IAAIlJ,CAAC,GAAT,CAAA,EAAeA,CAAC,GAAhB,SAAA,EAA8BA,CAA9B,EAAA,EACA;AACC;AACA,UAAIA,CAAC,GAAF,SAACA,IAAkBoJ,SAAS,CAATA,UAAAA,CAAAA,KAAAA,CAAtB,MAAA,EACA;AACC,YAAGN,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAAA,QAAAA,KAAH,KAAA,EACA;AACC,gBAAMK,OAAO,GAAG;AACfF,YAAAA,QAAQ,EADO,KAAA;AAEf9E,YAAAA,MAAM,EAAE+E;AAFO,WAAhB;AAKAA,UAAAA,IAAI,CAAJA,KAAAA,GAND,mDAMCA,CAND,CAQC;;AACA,cAAGJ,WAAW,CAAXA,cAAAA,CAAH,MAAGA,CAAH,EACA;AACCA,YAAAA,WAAW,CAAXA,IAAAA,GAAmBA,WAAW,CAAXA,IAAAA,CAAAA,OAAAA,CAAAA,YAAAA,EAAnBA,EAAmBA,CAAnBA;;AACA,gBAAGA,WAAW,CAAXA,IAAAA,KAAH,EAAA,EACA;AACC,qBAAOI,IAAI,CAACJ,WAAW,CAAvB,IAAW,CAAX;AACAK,cAAAA,OAAO,CAAPA,IAAAA,GAAeL,WAAW,CAA1BK,IAAAA;AACA;AAhBH,WAAA,CAkBC;;;AAEA,iBAAA,OAAA;AACA;AAxBF,OAAA,CA0BA;AA1BA,WA4BA;AACC;AACA,cAAGL,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAAA,CAAAA,aAAH,QAAA,EACA;AACC3E,YAAAA,MAAM,GAAG6E,aAAa,CAAA,IAAA,EAAOI,SAAS,CAATA,UAAAA,CAAAA,KAAAA,CAAP,CAAOA,CAAP,EAAsCN,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAA5D3E,KAAsB,CAAtBA;;AACA,gBAAGA,MAAM,CAANA,QAAAA,KAAH,KAAA,EACA;AACC,kBAAG2E,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAAA,QAAAA,KAAH,IAAA,EACCU,SADD,GAAA,KAGA;AACC;AACA,oBAAGV,WAAW,CAAXA,cAAAA,CAAH,MAAGA,CAAH,EACA;AACCA,kBAAAA,WAAW,CAAXA,IAAAA,GAAmBA,WAAW,CAAXA,IAAAA,CAAAA,OAAAA,CAAAA,YAAAA,EAAnBA,EAAmBA,CAAnBA;AACA,sBAAGA,WAAW,CAAXA,IAAAA,KAAH,EAAA,EACC,OAAOI,IAAI,CAACJ,WAAW,CAAvB,IAAW,CAAX;AANH,iBAAA,CAQC;;;AAEA,uBAAA,MAAA;AACA;AACD;;AAED,gBAAI,UAAUA,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAX,CAAWA,CAAV,IAA+CA,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAAA,IAAAA,CAAAA,MAAAA,GAAnD,CAAA,EACA;AACC,kBAAIa,SAAS,GAAb,EAAA;AAEA,kBAAI,WAAWb,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAZ,CAAYA,CAAX,IAAgDA,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAAA,KAAAA,KAApD,IAAA,EACCa,SAAS,GADV,SACCA,CADD,KAGCA,SAAS,GAATA,IAAAA;AAED,kBAAG,OAAOA,SAAS,CAACb,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAjB,IAAgB,CAAhB,KAAH,WAAA,EACCa,SAAS,CAACb,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAVa,IAAS,CAATA,GAAAA,EAAAA;AAEDA,cAAAA,SAAS,CAACb,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAVa,IAAS,CAATA,CAAAA,IAAAA,CAAqDP,SAAS,CAATA,UAAAA,CAAAA,KAAAA,CAArDO,CAAqDP,CAArDO;AACA;AAnCF,WAAA,CAqCA;AArCA,eAuCA;AACCxF,cAAAA,MAAM,GAAG6E,aAAa,CAAA,IAAA,EAAOI,SAAS,CAATA,UAAAA,CAAAA,KAAAA,CAA2BpJ,CAAC,GAAnC,SAAOoJ,CAAP,EAAkDN,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAxE3E,CAAwE2E,CAAlD,CAAtB3E;;AACA,kBAAGA,MAAM,CAANA,QAAAA,KAAH,KAAA,EACA;AACC,oBAAG2E,WAAW,CAAXA,UAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAAA,QAAAA,KAAH,IAAA,EACCU,SADD,GAAA,KAGA;AACC;AACA,sBAAGV,WAAW,CAAXA,cAAAA,CAAH,MAAGA,CAAH,EACA;AACCA,oBAAAA,WAAW,CAAXA,IAAAA,GAAmBA,WAAW,CAAXA,IAAAA,CAAAA,OAAAA,CAAAA,YAAAA,EAAnBA,EAAmBA,CAAnBA;AACA,wBAAGA,WAAW,CAAXA,IAAAA,KAAH,EAAA,EACC,OAAOI,IAAI,CAACJ,WAAW,CAAvB,IAAW,CAAX;AANH,mBAAA,CAQC;;;AAEA,yBAAA,MAAA;AACA;AACD;AACD;AACD;AACD;;AAED,QAAG3E,MAAM,CAANA,QAAAA,KAAH,KAAA,EAA8B;AAC9B;AACC,cAAMgF,OAAO,GAAG;AACfF,UAAAA,QAAQ,EADO,KAAA;AAEf9E,UAAAA,MAAM,EAAE+E;AAFO,SAAhB,CADD,CAMC;;AACA,YAAGJ,WAAW,CAAXA,cAAAA,CAAH,MAAGA,CAAH,EACA;AACCA,UAAAA,WAAW,CAAXA,IAAAA,GAAmBA,WAAW,CAAXA,IAAAA,CAAAA,OAAAA,CAAAA,YAAAA,EAAnBA,EAAmBA,CAAnBA;;AACA,cAAGA,WAAW,CAAXA,IAAAA,KAAH,EAAA,EACA;AACC,mBAAOI,IAAI,CAACJ,WAAW,CAAvB,IAAW,CAAX;AACAK,YAAAA,OAAO,CAAPA,IAAAA,GAAeL,WAAW,CAA1BK,IAAAA;AACA;AAdH,SAAA,CAgBC;;;AAEA,eAAA,OAAA;AACA;;AAED,WAAO;AACNF,MAAAA,QAAQ,EADF,IAAA;AAEN9E,MAAAA,MAAM,EAAE+E;AAFF,KAAP;AA5ZF,GAAA,CAiaC;AACA;;;AACA,MAAI,qBAAD,WAAC,IACF,cAAcE,SAAS,CADzB,UAAA,EAEA;AACC;AACA,UAAMQ,IAAI,GAAG1K,OAAO,CAACkK,SAAS,CAATA,UAAAA,CAArB,QAAoB,CAApB;;AACA,QAAGQ,IAAI,CAAJA,MAAAA,KAAiB,CAApB,CAAA,EACA;AACC,YAAMT,OAAO,GAAG;AACfF,QAAAA,QAAQ,EADO,KAAA;AAEf9E,QAAAA,MAAM,EAAEyF,IAAI,CAACzF;AAFE,OAAhB,CADD,CAMC;;AACA,UAAG2E,WAAW,CAAXA,cAAAA,CAAH,MAAGA,CAAH,EACA;AACCA,QAAAA,WAAW,CAAXA,IAAAA,GAAmBA,WAAW,CAAXA,IAAAA,CAAAA,OAAAA,CAAAA,YAAAA,EAAnBA,EAAmBA,CAAnBA;;AACA,YAAGA,WAAW,CAAXA,IAAAA,KAAH,EAAA,EACA;AACC,iBAAOI,IAAI,CAACJ,WAAW,CAAvB,IAAW,CAAX;AACAK,UAAAA,OAAO,CAAPA,IAAAA,GAAeL,WAAW,CAA1BK,IAAAA;AACA;AAdH,OAAA,CAgBC;;;AAEA,aAAA,OAAA;AAtBF,KAAA,CAwBC;;;AAEA,WAAOH,aAAa,CAAA,IAAA,EAAOY,IAAI,CAAX,MAAA,EAAoBd,WAAW,CAAnD,eAAoB,CAApB;AACA;;AAED,SAAO;AACNG,IAAAA,QAAQ,EADF,IAAA;AAEN9E,IAAAA,MAAM,EAAE+E;AAFF,GAAP,CAlcD,CAscC;EAED;AACA;;AACA;;;;;;;;AAMO,SAAA,YAAA,CAAA,WAAA,EAAA,WAAA,EACP;AACC;AACA,MAAIJ,WAAW,YAAZ,MAACA,KAAJ,KAAA,EACA;AACC,WAAO;AACNG,MAAAA,QAAQ,EADF,KAAA;AAEN9E,MAAAA,MAAM,EAAE;AAAEtF,QAAAA,KAAK,EAAE;AAAT;AAFF,KAAP;AAJF,GAAA,CASC;AAEA;;;AACA,QAAM+K,IAAI,GAAG1K,OAAO,CAApB,WAAoB,CAApB;;AACA,MAAG0K,IAAI,CAAJA,MAAAA,KAAiB,CAApB,CAAA,EACA;AACC,WAAO;AACNX,MAAAA,QAAQ,EADF,KAAA;AAEN9E,MAAAA,MAAM,EAAEyF,IAAI,CAACzF;AAFP,KAAP;AAfF,GAAA,CAoBC;AAEA;;;AACA,SAAO6E,aAAa,CAACY,IAAI,CAAL,MAAA,EAAcA,IAAI,CAAlB,MAAA,EAvBrB,WAuBqB,CAApB,CAvBD,CAwBC;EAED;AACA;AACA;AACA;AACA;AACA;;AACA;;;;;;AAIO,SAAA,QAAA,CAAA,IAAA,EACP,CADO,C,CAEN;AAED;AACA;AACA","sourcesContent":["/* eslint-disable indent */\r\n/*\r\n * Copyright (c) 2016-2018, Peculiar Ventures\r\n * All rights reserved.\r\n *\r\n * Author 2016-2018, Yury Strozhevsky <www.strozhevsky.com>.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n * 3. Neither the name of the copyright holder nor the names of its contributors\r\n *    may be used to endorse or promote products derived from this software without\r\n *    specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\r\n * OF SUCH DAMAGE.\r\n *\r\n */\r\n//**************************************************************************************\r\nimport { getParametersValue, padNumber, isEqualBuffer, bufferToHexCodes, checkBufferParams, utilToBase, utilFromBase, utilEncodeTC, utilDecodeTC, utilConcatBuf, utilConcatView } from \"pvutils\";\r\n//**************************************************************************************\r\n//region Declaration of global variables\r\n//**************************************************************************************\r\nconst powers2 = [new Uint8Array([1])];\r\nconst digitsString = \"0123456789\";\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration for \"LocalBaseBlock\" class\r\n//**************************************************************************************\r\n/**\r\n * Class used as a base block for all remaining ASN.1 classes\r\n * @typedef LocalBaseBlock\r\n * @interface\r\n * @property {number} blockLength\r\n * @property {string} error\r\n * @property {Array.<string>} warnings\r\n * @property {ArrayBuffer} valueBeforeDecode\r\n */\r\nclass LocalBaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalBaseBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {ArrayBuffer} [valueBeforeDecode]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\t/**\r\n\t\t * @type {number} blockLength\r\n\t\t */\r\n\t\tthis.blockLength = getParametersValue(parameters, \"blockLength\", 0);\r\n\t\t/**\r\n\t\t * @type {string} error\r\n\t\t */\r\n\t\tthis.error = getParametersValue(parameters, \"error\", \"\");\r\n\t\t/**\r\n\t\t * @type {Array.<string>} warnings\r\n\t\t */\r\n\t\tthis.warnings = getParametersValue(parameters, \"warnings\", []);\r\n\t\t//noinspection JSCheckFunctionSignatures\r\n\t\t/**\r\n\t\t * @type {ArrayBuffer} valueBeforeDecode\r\n\t\t */\r\n\t\tif(\"valueBeforeDecode\" in parameters)\r\n\t\t\tthis.valueBeforeDecode = parameters.valueBeforeDecode.slice(0);\r\n\t\telse\r\n\t\t\tthis.valueBeforeDecode = new ArrayBuffer(0);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"baseBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\treturn {\r\n\t\t\tblockName: this.constructor.blockName(),\r\n\t\t\tblockLength: this.blockLength,\r\n\t\t\terror: this.error,\r\n\t\t\twarnings: this.warnings,\r\n\t\t\tvalueBeforeDecode: bufferToHexCodes(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength)\r\n\t\t};\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Description for \"HexBlock\" class\r\n//**************************************************************************************\r\n/**\r\n * Class used as a base block for all remaining ASN.1 classes\r\n * @extends LocalBaseBlock\r\n * @typedef HexBlock\r\n * @property {number} blockLength\r\n * @property {string} error\r\n * @property {Array.<string>} warnings\r\n * @property {ArrayBuffer} valueBeforeDecode\r\n * @property {boolean} isHexOnly\r\n * @property {ArrayBuffer} valueHex\r\n */\r\n//noinspection JSUnusedLocalSymbols\r\nexport const HexBlock = BaseClass => class LocalHexBlockMixin extends BaseClass\r\n{\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Constructor for \"HexBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {ArrayBuffer} [valueHex]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\t/**\r\n\t\t * @type {boolean}\r\n\t\t */\r\n\t\tthis.isHexOnly = getParametersValue(parameters, \"isHexOnly\", false);\r\n\t\t/**\r\n\t\t * @type {ArrayBuffer}\r\n\t\t */\r\n\t\tif(\"valueHex\" in parameters)\r\n\t\t\tthis.valueHex = parameters.valueHex.slice(0);\r\n\t\telse\r\n\t\t\tthis.valueHex = new ArrayBuffer(0);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"hexBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\t//region Basic check for parameters\r\n\t\t//noinspection JSCheckFunctionSignatures\r\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\r\n\t\t\treturn (-1);\r\n\t\t//endregion\r\n\r\n\t\t//region Getting Uint8Array from ArrayBuffer\r\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\r\n\t\t//endregion\r\n\r\n\t\t//region Initial checks\r\n\t\tif(intBuffer.length === 0)\r\n\t\t{\r\n\t\t\tthis.warnings.push(\"Zero buffer length\");\r\n\t\t\treturn inputOffset;\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Copy input buffer to internal buffer\r\n\t\tthis.valueHex = inputBuffer.slice(inputOffset, inputOffset + inputLength);\r\n\t\t//endregion\r\n\r\n\t\tthis.blockLength = inputLength;\r\n\r\n\t\treturn (inputOffset + inputLength);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\tif(this.isHexOnly !== true)\r\n\t\t{\r\n\t\t\tthis.error = \"Flag \\\"isHexOnly\\\" is not set, abort\";\r\n\t\t\treturn new ArrayBuffer(0);\r\n\t\t}\r\n\r\n\t\tif(sizeOnly === true)\r\n\t\t\treturn new ArrayBuffer(this.valueHex.byteLength);\r\n\r\n\t\t//noinspection JSCheckFunctionSignatures\r\n\t\treturn this.valueHex.slice(0);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {Object}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.blockName = this.constructor.blockName();\r\n\t\tobject.isHexOnly = this.isHexOnly;\r\n\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n};\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of identification block class\r\n//**************************************************************************************\r\nclass LocalIdentificationBlock extends HexBlock(LocalBaseBlock)\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalBaseBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {Object} [idBlock]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tif(\"idBlock\" in parameters)\r\n\t\t{\r\n\t\t\t//region Properties from hexBlock class\r\n\t\t\tthis.isHexOnly = getParametersValue(parameters.idBlock, \"isHexOnly\", false);\r\n\t\t\tthis.valueHex = getParametersValue(parameters.idBlock, \"valueHex\", new ArrayBuffer(0));\r\n\t\t\t//endregion\r\n\r\n\t\t\tthis.tagClass = getParametersValue(parameters.idBlock, \"tagClass\", (-1));\r\n\t\t\tthis.tagNumber = getParametersValue(parameters.idBlock, \"tagNumber\", (-1));\r\n\t\t\tthis.isConstructed = getParametersValue(parameters.idBlock, \"isConstructed\", false);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.tagClass = (-1);\r\n\t\t\tthis.tagNumber = (-1);\r\n\t\t\tthis.isConstructed = false;\r\n\t\t}\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"identificationBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tlet firstOctet = 0;\r\n\t\tlet retBuf;\r\n\t\tlet retView;\r\n\t\t//endregion\r\n\r\n\t\tswitch(this.tagClass)\r\n\t\t{\r\n\t\t\tcase 1:\r\n\t\t\t\tfirstOctet |= 0x00; // UNIVERSAL\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tfirstOctet |= 0x40; // APPLICATION\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tfirstOctet |= 0x80; // CONTEXT-SPECIFIC\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tfirstOctet |= 0xC0; // PRIVATE\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthis.error = \"Unknown tag class\";\r\n\t\t\t\treturn (new ArrayBuffer(0));\r\n\t\t}\r\n\r\n\t\tif(this.isConstructed)\r\n\t\t\tfirstOctet |= 0x20;\r\n\r\n\t\tif((this.tagNumber < 31) && (!this.isHexOnly))\r\n\t\t{\r\n\t\t\tretBuf = new ArrayBuffer(1);\r\n\t\t\tretView = new Uint8Array(retBuf);\r\n\r\n\t\t\tif(!sizeOnly)\r\n\t\t\t{\r\n\t\t\t\tlet number = this.tagNumber;\r\n\t\t\t\tnumber &= 0x1F;\r\n\t\t\t\tfirstOctet |= number;\r\n\r\n\t\t\t\tretView[0] = firstOctet;\r\n\t\t\t}\r\n\r\n\t\t\treturn retBuf;\r\n\t\t}\r\n\r\n\t\tif(this.isHexOnly === false)\r\n\t\t{\r\n\t\t\tconst encodedBuf = utilToBase(this.tagNumber, 7);\r\n\t\t\tconst encodedView = new Uint8Array(encodedBuf);\r\n\t\t\tconst size = encodedBuf.byteLength;\r\n\r\n\t\t\tretBuf = new ArrayBuffer(size + 1);\r\n\t\t\tretView = new Uint8Array(retBuf);\r\n\t\t\tretView[0] = (firstOctet | 0x1F);\r\n\r\n\t\t\tif(!sizeOnly)\r\n\t\t\t{\r\n\t\t\t\tfor(let i = 0; i < (size - 1); i++)\r\n\t\t\t\t\tretView[i + 1] = encodedView[i] | 0x80;\r\n\r\n\t\t\t\tretView[size] = encodedView[size - 1];\r\n\t\t\t}\r\n\r\n\t\t\treturn retBuf;\r\n\t\t}\r\n\r\n\t\tretBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\r\n\t\tretView = new Uint8Array(retBuf);\r\n\r\n\t\tretView[0] = (firstOctet | 0x1F);\r\n\r\n\t\tif(sizeOnly === false)\r\n\t\t{\r\n\t\t\tconst curView = new Uint8Array(this.valueHex);\r\n\r\n\t\t\tfor(let i = 0; i < (curView.length - 1); i++)\r\n\t\t\t\tretView[i + 1] = curView[i] | 0x80;\r\n\r\n\t\t\tretView[this.valueHex.byteLength] = curView[curView.length - 1];\r\n\t\t}\r\n\r\n\t\treturn retBuf;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number}\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\t//region Basic check for parameters\r\n\t\t//noinspection JSCheckFunctionSignatures\r\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\r\n\t\t\treturn (-1);\r\n\t\t//endregion\r\n\r\n\t\t//region Getting Uint8Array from ArrayBuffer\r\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\r\n\t\t//endregion\r\n\r\n\t\t//region Initial checks\r\n\t\tif(intBuffer.length === 0)\r\n\t\t{\r\n\t\t\tthis.error = \"Zero buffer length\";\r\n\t\t\treturn (-1);\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Find tag class\r\n\t\tconst tagClassMask = intBuffer[0] & 0xC0;\r\n\r\n\t\tswitch(tagClassMask)\r\n\t\t{\r\n\t\t\tcase 0x00:\r\n\t\t\t\tthis.tagClass = (1); // UNIVERSAL\r\n\t\t\t\tbreak;\r\n\t\t\tcase 0x40:\r\n\t\t\t\tthis.tagClass = (2); // APPLICATION\r\n\t\t\t\tbreak;\r\n\t\t\tcase 0x80:\r\n\t\t\t\tthis.tagClass = (3); // CONTEXT-SPECIFIC\r\n\t\t\t\tbreak;\r\n\t\t\tcase 0xC0:\r\n\t\t\t\tthis.tagClass = (4); // PRIVATE\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthis.error = \"Unknown tag class\";\r\n\t\t\t\treturn (-1);\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Find it's constructed or not\r\n\t\tthis.isConstructed = (intBuffer[0] & 0x20) === 0x20;\r\n\t\t//endregion\r\n\r\n\t\t//region Find tag number\r\n\t\tthis.isHexOnly = false;\r\n\r\n\t\tconst tagNumberMask = intBuffer[0] & 0x1F;\r\n\r\n\t\t//region Simple case (tag number < 31)\r\n\t\tif(tagNumberMask !== 0x1F)\r\n\t\t{\r\n\t\t\tthis.tagNumber = (tagNumberMask);\r\n\t\t\tthis.blockLength = 1;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t//region Tag number bigger or equal to 31\r\n\t\telse\r\n\t\t{\r\n\t\t\tlet count = 1;\r\n\r\n\t\t\tthis.valueHex = new ArrayBuffer(255);\r\n\t\t\tlet tagNumberBufferMaxLength = 255;\r\n\t\t\tlet intTagNumberBuffer = new Uint8Array(this.valueHex);\r\n\r\n\t\t\t//noinspection JSBitwiseOperatorUsage\r\n\t\t\twhile(intBuffer[count] & 0x80)\r\n\t\t\t{\r\n\t\t\t\tintTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\r\n\t\t\t\tcount++;\r\n\r\n\t\t\t\tif(count >= intBuffer.length)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.error = \"End of input reached before message was fully decoded\";\r\n\t\t\t\t\treturn (-1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//region In case if tag number length is greater than 255 bytes (rare but possible case)\r\n\t\t\t\tif(count === tagNumberBufferMaxLength)\r\n\t\t\t\t{\r\n\t\t\t\t\ttagNumberBufferMaxLength += 255;\r\n\r\n\t\t\t\t\tconst tempBuffer = new ArrayBuffer(tagNumberBufferMaxLength);\r\n\t\t\t\t\tconst tempBufferView = new Uint8Array(tempBuffer);\r\n\r\n\t\t\t\t\tfor(let i = 0; i < intTagNumberBuffer.length; i++)\r\n\t\t\t\t\t\ttempBufferView[i] = intTagNumberBuffer[i];\r\n\r\n\t\t\t\t\tthis.valueHex = new ArrayBuffer(tagNumberBufferMaxLength);\r\n\t\t\t\t\tintTagNumberBuffer = new Uint8Array(this.valueHex);\r\n\t\t\t\t}\r\n\t\t\t\t//endregion\r\n\t\t\t}\r\n\r\n\t\t\tthis.blockLength = (count + 1);\r\n\t\t\tintTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F; // Write last byte to buffer\r\n\r\n\t\t\t//region Cut buffer\r\n\t\t\tconst tempBuffer = new ArrayBuffer(count);\r\n\t\t\tconst tempBufferView = new Uint8Array(tempBuffer);\r\n\r\n\t\t\tfor(let i = 0; i < count; i++)\r\n\t\t\t\ttempBufferView[i] = intTagNumberBuffer[i];\r\n\r\n\t\t\tthis.valueHex = new ArrayBuffer(count);\r\n\t\t\tintTagNumberBuffer = new Uint8Array(this.valueHex);\r\n\t\t\tintTagNumberBuffer.set(tempBufferView);\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Try to convert long tag number to short form\r\n\t\t\tif(this.blockLength <= 9)\r\n\t\t\t\tthis.tagNumber = utilFromBase(intTagNumberBuffer, 7);\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis.isHexOnly = true;\r\n\t\t\t\tthis.warnings.push(\"Tag too long, represented as hex-coded\");\r\n\t\t\t}\r\n\t\t\t//endregion\r\n\t\t}\r\n\t\t//endregion\r\n\t\t//endregion\r\n\r\n\t\t//region Check if constructed encoding was using for primitive type\r\n\t\tif(((this.tagClass === 1)) &&\r\n\t\t\t(this.isConstructed))\r\n\t\t{\r\n\t\t\tswitch(this.tagNumber)\r\n\t\t\t{\r\n\t\t\t\tcase 1:  // Boolean\r\n\t\t\t\tcase 2:  // REAL\r\n\t\t\t\tcase 5:  // Null\r\n\t\t\t\tcase 6:  // OBJECT IDENTIFIER\r\n\t\t\t\tcase 9:  // REAL\r\n\t\t\t\tcase 13: // RELATIVE OBJECT IDENTIFIER\r\n\t\t\t\tcase 14: // Time\r\n\t\t\t\tcase 23:\r\n\t\t\t\tcase 24:\r\n\t\t\t\tcase 31:\r\n\t\t\t\tcase 32:\r\n\t\t\t\tcase 33:\r\n\t\t\t\tcase 34:\r\n\t\t\t\t\tthis.error = \"Constructed encoding used for primitive type\";\r\n\t\t\t\t\treturn (-1);\r\n\t\t\t\tdefault:\r\n\t\t\t}\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\treturn (inputOffset + this.blockLength); // Return current offset in input buffer\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {{blockName: string,\r\n\t *  tagClass: number,\r\n\t *  tagNumber: number,\r\n\t *  isConstructed: boolean,\r\n\t *  isHexOnly: boolean,\r\n\t *  valueHex: ArrayBuffer,\r\n\t *  blockLength: number,\r\n\t *  error: string, warnings: Array.<string>,\r\n\t *  valueBeforeDecode: string}}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.blockName = this.constructor.blockName();\r\n\t\tobject.tagClass = this.tagClass;\r\n\t\tobject.tagNumber = this.tagNumber;\r\n\t\tobject.isConstructed = this.isConstructed;\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of length block class\r\n//**************************************************************************************\r\nclass LocalLengthBlock extends LocalBaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalLengthBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {Object} [lenBlock]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tif(\"lenBlock\" in parameters)\r\n\t\t{\r\n\t\t\tthis.isIndefiniteForm = getParametersValue(parameters.lenBlock, \"isIndefiniteForm\", false);\r\n\t\t\tthis.longFormUsed = getParametersValue(parameters.lenBlock, \"longFormUsed\", false);\r\n\t\t\tthis.length = getParametersValue(parameters.lenBlock, \"length\", 0);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.isIndefiniteForm = false;\r\n\t\t\tthis.longFormUsed = false;\r\n\t\t\tthis.length = 0;\r\n\t\t}\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"lengthBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number}\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\t//region Basic check for parameters\r\n\t\t//noinspection JSCheckFunctionSignatures\r\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\r\n\t\t\treturn (-1);\r\n\t\t//endregion\r\n\r\n\t\t//region Getting Uint8Array from ArrayBuffer\r\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\r\n\t\t//endregion\r\n\r\n\t\t//region Initial checks\r\n\t\tif(intBuffer.length === 0)\r\n\t\t{\r\n\t\t\tthis.error = \"Zero buffer length\";\r\n\t\t\treturn (-1);\r\n\t\t}\r\n\r\n\t\tif(intBuffer[0] === 0xFF)\r\n\t\t{\r\n\t\t\tthis.error = \"Length block 0xFF is reserved by standard\";\r\n\t\t\treturn (-1);\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Check for length form type\r\n\t\tthis.isIndefiniteForm = intBuffer[0] === 0x80;\r\n\t\t//endregion\r\n\r\n\t\t//region Stop working in case of indefinite length form\r\n\t\tif(this.isIndefiniteForm === true)\r\n\t\t{\r\n\t\t\tthis.blockLength = 1;\r\n\t\t\treturn (inputOffset + this.blockLength);\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Check is long form of length encoding using\r\n\t\tthis.longFormUsed = !!(intBuffer[0] & 0x80);\r\n\t\t//endregion\r\n\r\n\t\t//region Stop working in case of short form of length value\r\n\t\tif(this.longFormUsed === false)\r\n\t\t{\r\n\t\t\tthis.length = (intBuffer[0]);\r\n\t\t\tthis.blockLength = 1;\r\n\t\t\treturn (inputOffset + this.blockLength);\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Calculate length value in case of long form\r\n\t\tconst count = intBuffer[0] & 0x7F;\r\n\r\n\t\tif(count > 8) // Too big length value\r\n\t\t{\r\n\t\t\tthis.error = \"Too big integer\";\r\n\t\t\treturn (-1);\r\n\t\t}\r\n\r\n\t\tif((count + 1) > intBuffer.length)\r\n\t\t{\r\n\t\t\tthis.error = \"End of input reached before message was fully decoded\";\r\n\t\t\treturn (-1);\r\n\t\t}\r\n\r\n\t\tconst lengthBufferView = new Uint8Array(count);\r\n\r\n\t\tfor(let i = 0; i < count; i++)\r\n\t\t\tlengthBufferView[i] = intBuffer[i + 1];\r\n\r\n\t\tif(lengthBufferView[count - 1] === 0x00)\r\n\t\t\tthis.warnings.push(\"Needlessly long encoded length\");\r\n\r\n\t\tthis.length = utilFromBase(lengthBufferView, 8);\r\n\r\n\t\tif(this.longFormUsed && (this.length <= 127))\r\n\t\t\tthis.warnings.push(\"Unneccesary usage of long length form\");\r\n\r\n\t\tthis.blockLength = count + 1;\r\n\t\t//endregion\r\n\r\n\t\treturn (inputOffset + this.blockLength); // Return current offset in input buffer\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tlet retBuf;\r\n\t\tlet retView;\r\n\t\t//endregion\r\n\r\n\t\tif(this.length > 127)\r\n\t\t\tthis.longFormUsed = true;\r\n\r\n\t\tif(this.isIndefiniteForm)\r\n\t\t{\r\n\t\t\tretBuf = new ArrayBuffer(1);\r\n\r\n\t\t\tif(sizeOnly === false)\r\n\t\t\t{\r\n\t\t\t\tretView = new Uint8Array(retBuf);\r\n\t\t\t\tretView[0] = 0x80;\r\n\t\t\t}\r\n\r\n\t\t\treturn retBuf;\r\n\t\t}\r\n\r\n\t\tif(this.longFormUsed === true)\r\n\t\t{\r\n\t\t\tconst encodedBuf = utilToBase(this.length, 8);\r\n\r\n\t\t\tif(encodedBuf.byteLength > 127)\r\n\t\t\t{\r\n\t\t\t\tthis.error = \"Too big length\";\r\n\t\t\t\treturn (new ArrayBuffer(0));\r\n\t\t\t}\r\n\r\n\t\t\tretBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\r\n\r\n\t\t\tif(sizeOnly === true)\r\n\t\t\t\treturn retBuf;\r\n\r\n\t\t\tconst encodedView = new Uint8Array(encodedBuf);\r\n\t\t\tretView = new Uint8Array(retBuf);\r\n\r\n\t\t\tretView[0] = encodedBuf.byteLength | 0x80;\r\n\r\n\t\t\tfor(let i = 0; i < encodedBuf.byteLength; i++)\r\n\t\t\t\tretView[i + 1] = encodedView[i];\r\n\r\n\t\t\treturn retBuf;\r\n\t\t}\r\n\r\n\t\tretBuf = new ArrayBuffer(1);\r\n\r\n\t\tif(sizeOnly === false)\r\n\t\t{\r\n\t\t\tretView = new Uint8Array(retBuf);\r\n\r\n\t\t\tretView[0] = this.length;\r\n\t\t}\r\n\r\n\t\treturn retBuf;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.blockName = this.constructor.blockName();\r\n\t\tobject.isIndefiniteForm = this.isIndefiniteForm;\r\n\t\tobject.longFormUsed = this.longFormUsed;\r\n\t\tobject.length = this.length;\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of value block class\r\n//**************************************************************************************\r\nexport class ValueBlock extends LocalBaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"ValueBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"valueBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols,JSUnusedLocalSymbols\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number}\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\t//region Throw an exception for a function which needs to be specified in extended classes\r\n\t\tthrow TypeError(\"User need to make a specific function in a class which extends \\\"ValueBlock\\\"\");\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedLocalSymbols\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\t//region Throw an exception for a function which needs to be specified in extended classes\r\n\t\tthrow TypeError(\"User need to make a specific function in a class which extends \\\"ValueBlock\\\"\");\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of basic ASN.1 block class\r\n//**************************************************************************************\r\nexport class BaseBlock extends LocalBaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"BaseBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {Object} [primitiveSchema]\r\n\t * @property {string} [name]\r\n\t * @property {boolean} [optional]\r\n\t * @param valueBlockType Type of value block\r\n\t */\r\n\tconstructor(parameters = {}, valueBlockType = ValueBlock)\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tif(\"name\" in parameters)\r\n\t\t\tthis.name = parameters.name;\r\n\t\tif(\"optional\" in parameters)\r\n\t\t\tthis.optional = parameters.optional;\r\n\t\tif(\"primitiveSchema\" in parameters)\r\n\t\t\tthis.primitiveSchema = parameters.primitiveSchema;\r\n\r\n\t\tthis.idBlock = new LocalIdentificationBlock(parameters);\r\n\t\tthis.lenBlock = new LocalLengthBlock(parameters);\r\n\t\tthis.valueBlock = new valueBlockType(parameters);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"BaseBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number}\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\r\n\t\tif(resultOffset === (-1))\r\n\t\t{\r\n\t\t\tthis.error = this.valueBlock.error;\r\n\t\t\treturn resultOffset;\r\n\t\t}\r\n\r\n\t\tif(this.idBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.idBlock.blockLength;\r\n\r\n\t\tif(this.lenBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\r\n\r\n\t\tif(this.valueBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\r\n\r\n\t\treturn resultOffset;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\tlet retBuf;\r\n\r\n\t\tconst idBlockBuf = this.idBlock.toBER(sizeOnly);\r\n\t\tconst valueBlockSizeBuf = this.valueBlock.toBER(true);\r\n\r\n\t\tthis.lenBlock.length = valueBlockSizeBuf.byteLength;\r\n\t\tconst lenBlockBuf = this.lenBlock.toBER(sizeOnly);\r\n\r\n\t\tretBuf = utilConcatBuf(idBlockBuf, lenBlockBuf);\r\n\r\n\t\tlet valueBlockBuf;\r\n\r\n\t\tif(sizeOnly === false)\r\n\t\t\tvalueBlockBuf = this.valueBlock.toBER(sizeOnly);\r\n\t\telse\r\n\t\t\tvalueBlockBuf = new ArrayBuffer(this.lenBlock.length);\r\n\r\n\t\tretBuf = utilConcatBuf(retBuf, valueBlockBuf);\r\n\r\n\t\tif(this.lenBlock.isIndefiniteForm === true)\r\n\t\t{\r\n\t\t\tconst indefBuf = new ArrayBuffer(2);\r\n\r\n\t\t\tif(sizeOnly === false)\r\n\t\t\t{\r\n\t\t\t\tconst indefView = new Uint8Array(indefBuf);\r\n\r\n\t\t\t\tindefView[0] = 0x00;\r\n\t\t\t\tindefView[1] = 0x00;\r\n\t\t\t}\r\n\r\n\t\t\tretBuf = utilConcatBuf(retBuf, indefBuf);\r\n\t\t}\r\n\r\n\t\treturn retBuf;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.idBlock = this.idBlock.toJSON();\r\n\t\tobject.lenBlock = this.lenBlock.toJSON();\r\n\t\tobject.valueBlock = this.valueBlock.toJSON();\r\n\r\n\t\tif(\"name\" in this)\r\n\t\t\tobject.name = this.name;\r\n\t\tif(\"optional\" in this)\r\n\t\t\tobject.optional = this.optional;\r\n\t\tif(\"primitiveSchema\" in this)\r\n\t\t\tobject.primitiveSchema = this.primitiveSchema.toJSON();\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of basic block for all PRIMITIVE types\r\n//**************************************************************************************\r\nclass LocalPrimitiveValueBlock extends ValueBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalPrimitiveValueBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {ArrayBuffer} [valueBeforeDecode]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\t//region Variables from \"hexBlock\" class\r\n\t\tif(\"valueHex\" in parameters)\r\n\t\t\tthis.valueHex = parameters.valueHex.slice(0);\r\n\t\telse\r\n\t\t\tthis.valueHex = new ArrayBuffer(0);\r\n\r\n\t\tthis.isHexOnly = getParametersValue(parameters, \"isHexOnly\", true);\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number}\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\t//region Basic check for parameters\r\n\t\t//noinspection JSCheckFunctionSignatures\r\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\r\n\t\t\treturn (-1);\r\n\t\t//endregion\r\n\r\n\t\t//region Getting Uint8Array from ArrayBuffer\r\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\r\n\t\t//endregion\r\n\r\n\t\t//region Initial checks\r\n\t\tif(intBuffer.length === 0)\r\n\t\t{\r\n\t\t\tthis.warnings.push(\"Zero buffer length\");\r\n\t\t\treturn inputOffset;\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Copy input buffer into internal buffer\r\n\t\tthis.valueHex = new ArrayBuffer(intBuffer.length);\r\n\t\tconst valueHexView = new Uint8Array(this.valueHex);\r\n\r\n\t\tfor(let i = 0; i < intBuffer.length; i++)\r\n\t\t\tvalueHexView[i] = intBuffer[i];\r\n\t\t//endregion\r\n\r\n\t\tthis.blockLength = inputLength;\r\n\r\n\t\treturn (inputOffset + inputLength);\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedLocalSymbols\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\treturn this.valueHex.slice(0);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"PrimitiveValueBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\r\n\t\tobject.isHexOnly = this.isHexOnly;\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\nexport class Primitive extends BaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"Primitive\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {ArrayBuffer} [valueHex]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters, LocalPrimitiveValueBlock);\r\n\r\n\t\tthis.idBlock.isConstructed = false;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"PRIMITIVE\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of basic block for all CONSTRUCTED types\r\n//**************************************************************************************\r\nclass LocalConstructedValueBlock extends ValueBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalConstructedValueBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.value = getParametersValue(parameters, \"value\", []);\r\n\t\tthis.isIndefiniteForm = getParametersValue(parameters, \"isIndefiniteForm\", false);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number}\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\t//region Store initial offset and length\r\n\t\tconst initialOffset = inputOffset;\r\n\t\tconst initialLength = inputLength;\r\n\t\t//endregion\r\n\r\n\t\t//region Basic check for parameters\r\n\t\t//noinspection JSCheckFunctionSignatures\r\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\r\n\t\t\treturn (-1);\r\n\t\t//endregion\r\n\r\n\t\t//region Getting Uint8Array from ArrayBuffer\r\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\r\n\t\t//endregion\r\n\r\n\t\t//region Initial checks\r\n\t\tif(intBuffer.length === 0)\r\n\t\t{\r\n\t\t\tthis.warnings.push(\"Zero buffer length\");\r\n\t\t\treturn inputOffset;\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Aux function\r\n\t\tfunction checkLen(indefiniteLength, length)\r\n\t\t{\r\n\t\t\tif(indefiniteLength === true)\r\n\t\t\t\treturn 1;\r\n\r\n\t\t\treturn length;\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\tlet currentOffset = inputOffset;\r\n\r\n\t\twhile(checkLen(this.isIndefiniteForm, inputLength) > 0)\r\n\t\t{\r\n\t\t\tconst returnObject = LocalFromBER(inputBuffer, currentOffset, inputLength);\r\n\t\t\tif(returnObject.offset === (-1))\r\n\t\t\t{\r\n\t\t\t\tthis.error = returnObject.result.error;\r\n\t\t\t\tthis.warnings.concat(returnObject.result.warnings);\r\n\t\t\t\treturn (-1);\r\n\t\t\t}\r\n\r\n\t\t\tcurrentOffset = returnObject.offset;\r\n\r\n\t\t\tthis.blockLength += returnObject.result.blockLength;\r\n\t\t\tinputLength -= returnObject.result.blockLength;\r\n\r\n\t\t\tthis.value.push(returnObject.result);\r\n\r\n\t\t\tif((this.isIndefiniteForm === true) && (returnObject.result.constructor.blockName() === EndOfContent.blockName()))\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif(this.isIndefiniteForm === true)\r\n\t\t{\r\n\t\t\tif(this.value[this.value.length - 1].constructor.blockName() === EndOfContent.blockName())\r\n\t\t\t\tthis.value.pop();\r\n\t\t\telse\r\n\t\t\t\tthis.warnings.push(\"No EndOfContent block encoded\");\r\n\t\t}\r\n\r\n\t\t//region Copy \"inputBuffer\" to \"valueBeforeDecode\"\r\n\t\tthis.valueBeforeDecode = inputBuffer.slice(initialOffset, initialOffset + initialLength);\r\n\t\t//endregion\r\n\r\n\t\treturn currentOffset;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\tlet retBuf = new ArrayBuffer(0);\r\n\r\n\t\tfor(let i = 0; i < this.value.length; i++)\r\n\t\t{\r\n\t\t\tconst valueBuf = this.value[i].toBER(sizeOnly);\r\n\t\t\tretBuf = utilConcatBuf(retBuf, valueBuf);\r\n\t\t}\r\n\r\n\t\treturn retBuf;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"ConstructedValueBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.isIndefiniteForm = this.isIndefiniteForm;\r\n\t\tobject.value = [];\r\n\t\tfor(let i = 0; i < this.value.length; i++)\r\n\t\t\tobject.value.push(this.value[i].toJSON());\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\nexport class Constructed extends BaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"Constructed\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters, LocalConstructedValueBlock);\r\n\r\n\t\tthis.idBlock.isConstructed = true;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"CONSTRUCTED\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number}\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\tthis.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n\r\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\r\n\t\tif(resultOffset === (-1))\r\n\t\t{\r\n\t\t\tthis.error = this.valueBlock.error;\r\n\t\t\treturn resultOffset;\r\n\t\t}\r\n\r\n\t\tif(this.idBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.idBlock.blockLength;\r\n\r\n\t\tif(this.lenBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\r\n\r\n\t\tif(this.valueBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\r\n\r\n\t\treturn resultOffset;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of ASN.1 EndOfContent type class\r\n//**************************************************************************************\r\nclass LocalEndOfContentValueBlock extends ValueBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalEndOfContentValueBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number}\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\t//region There is no \"value block\" for EndOfContent type and we need to return the same offset\r\n\t\treturn inputOffset;\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedLocalSymbols\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\treturn new ArrayBuffer(0);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"EndOfContentValueBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\nexport class EndOfContent extends BaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\tconstructor(paramaters = {})\r\n\t{\r\n\t\tsuper(paramaters, LocalEndOfContentValueBlock);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 0; // EndOfContent\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"EndOfContent\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of ASN.1 Boolean type class\r\n//**************************************************************************************\r\nclass LocalBooleanValueBlock extends ValueBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalBooleanValueBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\t\t\r\n\t\tthis.value = getParametersValue(parameters, \"value\", false);\r\n\t\tthis.isHexOnly = getParametersValue(parameters, \"isHexOnly\", false);\r\n\t\t\r\n\t\tif(\"valueHex\" in parameters)\r\n\t\t\tthis.valueHex = parameters.valueHex.slice(0);\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.valueHex = new ArrayBuffer(1);\r\n\t\t\tif(this.value === true)\r\n\t\t\t{\r\n\t\t\t\tconst view = new Uint8Array(this.valueHex);\r\n\t\t\t\tview[0] = 0xFF;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\t//region Basic check for parameters\r\n\t\t//noinspection JSCheckFunctionSignatures\r\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\r\n\t\t\treturn (-1);\r\n\t\t//endregion\r\n\r\n\t\t//region Getting Uint8Array from ArrayBuffer\r\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\r\n\t\t//endregion\r\n\r\n\t\tif(inputLength > 1)\r\n\t\t\tthis.warnings.push(\"Boolean value encoded in more then 1 octet\");\r\n\r\n\t\tthis.isHexOnly = true;\r\n\r\n\t\t//region Copy input buffer to internal array\r\n\t\tthis.valueHex = new ArrayBuffer(intBuffer.length);\r\n\t\tconst view = new Uint8Array(this.valueHex);\r\n\r\n\t\tfor(let i = 0; i < intBuffer.length; i++)\r\n\t\t\tview[i] = intBuffer[i];\r\n\t\t//endregion\r\n\t\t\r\n\t\tif(utilDecodeTC.call(this) !== 0 )\r\n\t\t\tthis.value = true;\r\n\t\telse\r\n\t\t\tthis.value = false;\r\n\r\n\t\tthis.blockLength = inputLength;\r\n\r\n\t\treturn (inputOffset + inputLength);\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedLocalSymbols\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\treturn this.valueHex;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"BooleanValueBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.value = this.value;\r\n\t\tobject.isHexOnly = this.isHexOnly;\r\n\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\nexport class Boolean extends BaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"Boolean\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters, LocalBooleanValueBlock);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 1; // Boolean\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"Boolean\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of ASN.1 Sequence and Set type classes\r\n//**************************************************************************************\r\nexport class Sequence extends Constructed\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"Sequence\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 16; // Sequence\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"Sequence\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\nexport class Set extends Constructed\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"Set\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 17; // Set\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"Set\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of ASN.1 Null type class\r\n//**************************************************************************************\r\nexport class Null extends BaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"Null\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters, LocalBaseBlock); // We will not have a call to \"Null value block\" because of specified \"fromBER\" and \"toBER\" functions\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 5; // Null\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"Null\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedLocalSymbols\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\tif(this.lenBlock.length > 0)\r\n\t\t\tthis.warnings.push(\"Non-zero length of value block for Null type\");\r\n\r\n\t\tif(this.idBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.idBlock.blockLength;\r\n\r\n\t\tif(this.lenBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\r\n\t\t\r\n\t\tthis.blockLength += inputLength;\r\n\t\t\r\n\t\tif((inputOffset + inputLength) > inputBuffer.byteLength)\r\n\t\t{\r\n\t\t\tthis.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\r\n\t\t\treturn (-1);\r\n\t\t}\r\n\t\t\r\n\t\treturn (inputOffset + inputLength);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\tconst retBuf = new ArrayBuffer(2);\r\n\r\n\t\tif(sizeOnly === true)\r\n\t\t\treturn retBuf;\r\n\r\n\t\tconst retView = new Uint8Array(retBuf);\r\n\t\tretView[0] = 0x05;\r\n\t\tretView[1] = 0x00;\r\n\r\n\t\treturn retBuf;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of ASN.1 OctetString type class\r\n//**************************************************************************************\r\nclass LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock)\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalOctetStringValueBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {ArrayBuffer} [valueHex]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.isConstructed = getParametersValue(parameters, \"isConstructed\", false);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\tlet resultOffset = 0;\r\n\r\n\t\tif(this.isConstructed === true)\r\n\t\t{\r\n\t\t\tthis.isHexOnly = false;\r\n\r\n\t\t\tresultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\r\n\t\t\tif(resultOffset === (-1))\r\n\t\t\t\treturn resultOffset;\r\n\r\n\t\t\tfor(let i = 0; i < this.value.length; i++)\r\n\t\t\t{\r\n\t\t\t\tconst currentBlockName = this.value[i].constructor.blockName();\r\n\r\n\t\t\t\tif(currentBlockName === EndOfContent.blockName())\r\n\t\t\t\t{\r\n\t\t\t\t\tif(this.isIndefiniteForm === true)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\r\n\t\t\t\t\t\treturn (-1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(currentBlockName !== OctetString.blockName())\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.error = \"OCTET STRING may consists of OCTET STRINGs only\";\r\n\t\t\t\t\treturn (-1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.isHexOnly = true;\r\n\r\n\t\t\tresultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\r\n\t\t\tthis.blockLength = inputLength;\r\n\t\t}\r\n\r\n\t\treturn resultOffset;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\tif(this.isConstructed === true)\r\n\t\t\treturn LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\r\n\r\n\t\tlet retBuf = new ArrayBuffer(this.valueHex.byteLength);\r\n\r\n\t\tif(sizeOnly === true)\r\n\t\t\treturn retBuf;\r\n\r\n\t\tif(this.valueHex.byteLength === 0)\r\n\t\t\treturn retBuf;\r\n\r\n\t\tretBuf = this.valueHex.slice(0);\r\n\r\n\t\treturn retBuf;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"OctetStringValueBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.isConstructed = this.isConstructed;\r\n\t\tobject.isHexOnly = this.isHexOnly;\r\n\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\nexport class OctetString extends BaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"OctetString\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters, LocalOctetStringValueBlock);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 4; // OctetString\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\tthis.valueBlock.isConstructed = this.idBlock.isConstructed;\r\n\t\tthis.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n\r\n\t\t//region Ability to encode empty OCTET STRING\r\n\t\tif(inputLength === 0)\r\n\t\t{\r\n\t\t\tif(this.idBlock.error.length === 0)\r\n\t\t\t\tthis.blockLength += this.idBlock.blockLength;\r\n\r\n\t\t\tif(this.lenBlock.error.length === 0)\r\n\t\t\t\tthis.blockLength += this.lenBlock.blockLength;\r\n\r\n\t\t\treturn inputOffset;\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\treturn super.fromBER(inputBuffer, inputOffset, inputLength);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"OctetString\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Checking that two OCTETSTRINGs are equal\r\n\t * @param {OctetString} octetString\r\n\t */\r\n\tisEqual(octetString)\r\n\t{\r\n\t\t//region Check input type\r\n\t\tif((octetString instanceof OctetString) === false)\r\n\t\t\treturn false;\r\n\t\t//endregion\r\n\r\n\t\t//region Compare two JSON strings\r\n\t\tif(JSON.stringify(this) !== JSON.stringify(octetString))\r\n\t\t\treturn false;\r\n\t\t//endregion\r\n\r\n\t\treturn true;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of ASN.1 BitString type class\r\n//**************************************************************************************\r\nclass LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock)\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalBitStringValueBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {ArrayBuffer} [valueHex]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.unusedBits = getParametersValue(parameters, \"unusedBits\", 0);\r\n\t\tthis.isConstructed = getParametersValue(parameters, \"isConstructed\", false);\r\n\t\tthis.blockLength = this.valueHex.byteLength;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\t//region Ability to decode zero-length BitString value\r\n\t\tif(inputLength === 0)\r\n\t\t\treturn inputOffset;\r\n\t\t//endregion\r\n\r\n\t\tlet resultOffset = (-1);\r\n\r\n\t\t//region If the BISTRING supposed to be a constructed value\r\n\t\tif(this.isConstructed === true)\r\n\t\t{\r\n\t\t\tresultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\r\n\t\t\tif(resultOffset === (-1))\r\n\t\t\t\treturn resultOffset;\r\n\r\n\t\t\tfor(let i = 0; i < this.value.length; i++)\r\n\t\t\t{\r\n\t\t\t\tconst currentBlockName = this.value[i].constructor.blockName();\r\n\r\n\t\t\t\tif(currentBlockName === EndOfContent.blockName())\r\n\t\t\t\t{\r\n\t\t\t\t\tif(this.isIndefiniteForm === true)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\r\n\t\t\t\t\t\treturn (-1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(currentBlockName !== BitString.blockName())\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.error = \"BIT STRING may consists of BIT STRINGs only\";\r\n\t\t\t\t\treturn (-1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif((this.unusedBits > 0) && (this.value[i].valueBlock.unusedBits > 0))\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.error = \"Usign of \\\"unused bits\\\" inside constructive BIT STRING allowed for least one only\";\r\n\t\t\t\t\treturn (-1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.unusedBits = this.value[i].valueBlock.unusedBits;\r\n\t\t\t\tif(this.unusedBits > 7)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.error = \"Unused bits for BitString must be in range 0-7\";\r\n\t\t\t\t\treturn (-1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn resultOffset;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t//region If the BitString supposed to be a primitive value\r\n\t\t//region Basic check for parameters\r\n\t\t//noinspection JSCheckFunctionSignatures\r\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\r\n\t\t\treturn (-1);\r\n\t\t//endregion\r\n\r\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\r\n\r\n\t\tthis.unusedBits = intBuffer[0];\r\n\t\t\r\n\t\tif(this.unusedBits > 7)\r\n\t\t{\r\n\t\t\tthis.error = \"Unused bits for BitString must be in range 0-7\";\r\n\t\t\treturn (-1);\r\n\t\t}\r\n\r\n\t\t//region Copy input buffer to internal buffer\r\n\t\tthis.valueHex = new ArrayBuffer(intBuffer.length - 1);\r\n\t\tconst view = new Uint8Array(this.valueHex);\r\n\t\tfor(let i = 0; i < (inputLength - 1); i++)\r\n\t\t\tview[i] = intBuffer[i + 1];\r\n\t\t//endregion\r\n\r\n\t\tthis.blockLength = intBuffer.length;\r\n\r\n\t\treturn (inputOffset + inputLength);\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\tif(this.isConstructed === true)\r\n\t\t\treturn LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\r\n\r\n\t\tif(sizeOnly === true)\r\n\t\t\treturn (new ArrayBuffer(this.valueHex.byteLength + 1));\r\n\r\n\t\tif(this.valueHex.byteLength === 0)\r\n\t\t\treturn (new ArrayBuffer(0));\r\n\r\n\t\tconst curView = new Uint8Array(this.valueHex);\r\n\r\n\t\tconst retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\r\n\t\tconst retView = new Uint8Array(retBuf);\r\n\r\n\t\tretView[0] = this.unusedBits;\r\n\r\n\t\tfor(let i = 0; i < this.valueHex.byteLength; i++)\r\n\t\t\tretView[i + 1] = curView[i];\r\n\r\n\t\treturn retBuf;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"BitStringValueBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.unusedBits = this.unusedBits;\r\n\t\tobject.isConstructed = this.isConstructed;\r\n\t\tobject.isHexOnly = this.isHexOnly;\r\n\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\nexport class BitString extends BaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"BitString\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters, LocalBitStringValueBlock);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 3; // BitString\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"BitString\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\t//region Ability to encode empty BitString\r\n\t\tif(inputLength === 0)\r\n\t\t\treturn inputOffset;\r\n\t\t//endregion\r\n\r\n\t\tthis.valueBlock.isConstructed = this.idBlock.isConstructed;\r\n\t\tthis.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n\r\n\t\treturn super.fromBER(inputBuffer, inputOffset, inputLength);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Checking that two BITSTRINGs are equal\r\n\t * @param {BitString} bitString\r\n\t */\r\n\tisEqual(bitString)\r\n\t{\r\n\t\t//region Check input type\r\n\t\tif((bitString instanceof BitString) === false)\r\n\t\t\treturn false;\r\n\t\t//endregion\r\n\r\n\t\t//region Compare two JSON strings\r\n\t\tif(JSON.stringify(this) !== JSON.stringify(bitString))\r\n\t\t\treturn false;\r\n\t\t//endregion\r\n\r\n\t\treturn true;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of ASN.1 Integer type class\r\n//**************************************************************************************\r\n/**\r\n * @extends ValueBlock\r\n */\r\nclass LocalIntegerValueBlock extends HexBlock(ValueBlock)\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalIntegerValueBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {ArrayBuffer} [valueHex]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tif(\"value\" in parameters)\r\n\t\t\tthis.valueDec = parameters.value;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Setter for \"valueHex\"\r\n\t * @param {ArrayBuffer} _value\r\n\t */\r\n\tset valueHex(_value)\r\n\t{\r\n\t\tthis._valueHex = _value.slice(0);\r\n\r\n\t\tif(_value.byteLength >= 4)\r\n\t\t{\r\n\t\t\tthis.warnings.push(\"Too big Integer for decoding, hex only\");\r\n\t\t\tthis.isHexOnly = true;\r\n\t\t\tthis._valueDec = 0;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.isHexOnly = false;\r\n\r\n\t\t\tif(_value.byteLength > 0)\r\n\t\t\t\tthis._valueDec = utilDecodeTC.call(this);\r\n\t\t}\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Getter for \"valueHex\"\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\tget valueHex()\r\n\t{\r\n\t\treturn this._valueHex;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Getter for \"valueDec\"\r\n\t * @param {number} _value\r\n\t */\r\n\tset valueDec(_value)\r\n\t{\r\n\t\tthis._valueDec = _value;\r\n\r\n\t\tthis.isHexOnly = false;\r\n\t\tthis._valueHex = utilEncodeTC(_value);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Getter for \"valueDec\"\r\n\t * @returns {number}\r\n\t */\r\n\tget valueDec()\r\n\t{\r\n\t\treturn this._valueDec;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from DER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 DER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 DER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @param {number} [expectedLength=0] Expected length of converted \"valueHex\" buffer\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0)\r\n\t{\r\n\t\tconst offset = this.fromBER(inputBuffer, inputOffset, inputLength);\r\n\t\tif(offset === (-1))\r\n\t\t\treturn offset;\r\n\r\n\t\tconst view = new Uint8Array(this._valueHex);\r\n\r\n\t\tif((view[0] === 0x00) && ((view[1] & 0x80) !== 0))\r\n\t\t{\r\n\t\t\tconst updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\r\n\t\t\tconst updatedView = new Uint8Array(updatedValueHex);\r\n\r\n\t\t\tupdatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\r\n\r\n\t\t\tthis._valueHex = updatedValueHex.slice(0);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(expectedLength !== 0)\r\n\t\t\t{\r\n\t\t\t\tif(this._valueHex.byteLength < expectedLength)\r\n\t\t\t\t{\r\n\t\t\t\t\tif((expectedLength - this._valueHex.byteLength) > 1)\r\n\t\t\t\t\t\texpectedLength = this._valueHex.byteLength + 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\tconst updatedValueHex = new ArrayBuffer(expectedLength);\r\n\t\t\t\t\tconst updatedView = new Uint8Array(updatedValueHex);\r\n\r\n\t\t\t\t\tupdatedView.set(view, expectedLength - this._valueHex.byteLength);\r\n\r\n\t\t\t\t\tthis._valueHex = updatedValueHex.slice(0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn offset;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (DER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoDER(sizeOnly = false)\r\n\t{\r\n\t\tconst view = new Uint8Array(this._valueHex);\r\n\r\n\t\tswitch(true)\r\n\t\t{\r\n\t\t\tcase ((view[0] & 0x80) !== 0):\r\n\t\t\t\t{\r\n\t\t\t\t\tconst updatedValueHex = new ArrayBuffer(this._valueHex.byteLength + 1);\r\n\t\t\t\t\tconst updatedView = new Uint8Array(updatedValueHex);\r\n\r\n\t\t\t\t\tupdatedView[0] = 0x00;\r\n\t\t\t\t\tupdatedView.set(view, 1);\r\n\r\n\t\t\t\t\tthis._valueHex = updatedValueHex.slice(0);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase ((view[0] === 0x00) && ((view[1] & 0x80) === 0)):\r\n\t\t\t\t{\r\n\t\t\t\t\tconst updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\r\n\t\t\t\t\tconst updatedView = new Uint8Array(updatedValueHex);\r\n\r\n\t\t\t\t\tupdatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\r\n\r\n\t\t\t\t\tthis._valueHex = updatedValueHex.slice(0);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t}\r\n\r\n\t\treturn this.toBER(sizeOnly);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\tconst resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\r\n\t\tif(resultOffset === (-1))\r\n\t\t\treturn resultOffset;\r\n\r\n\t\tthis.blockLength = inputLength;\r\n\r\n\t\treturn (inputOffset + inputLength);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\t//noinspection JSCheckFunctionSignatures\r\n\t\treturn this.valueHex.slice(0);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"IntegerValueBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {Object}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.valueDec = this.valueDec;\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convert current value to decimal string representation\r\n\t */\r\n\ttoString()\r\n\t{\r\n\t\t//region Aux functions\r\n\t\tfunction viewAdd(first, second)\r\n\t\t{\r\n\t\t\t//region Initial variables\r\n\t\t\tconst c = new Uint8Array([0]);\r\n\t\t\t\r\n\t\t\tlet firstView = new Uint8Array(first);\r\n\t\t\tlet secondView = new Uint8Array(second);\r\n\t\t\t\r\n\t\t\tlet firstViewCopy = firstView.slice(0);\r\n\t\t\tconst firstViewCopyLength = firstViewCopy.length - 1;\r\n\t\t\tlet secondViewCopy = secondView.slice(0);\r\n\t\t\tconst secondViewCopyLength = secondViewCopy.length - 1;\r\n\t\t\t\r\n\t\t\tlet value = 0;\r\n\t\t\t\r\n\t\t\tconst max = (secondViewCopyLength < firstViewCopyLength) ? firstViewCopyLength : secondViewCopyLength;\r\n\t\t\t\r\n\t\t\tlet counter = 0;\r\n\t\t\t//endregion\r\n\t\t\t\r\n\t\t\tfor(let i = max; i >= 0; i--, counter++)\r\n\t\t\t{\r\n\t\t\t\tswitch(true)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase (counter < secondViewCopy.length):\r\n\t\t\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] + c[0];\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tc[0] = value / 10;\r\n\t\t\t\t\r\n\t\t\t\tswitch(true)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase (counter >= firstViewCopy.length):\r\n\t\t\t\t\t\tfirstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value % 10;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(c[0] > 0)\r\n\t\t\t\tfirstViewCopy = utilConcatView(c, firstViewCopy);\r\n\t\t\t\r\n\t\t\treturn firstViewCopy.slice(0);\r\n\t\t}\r\n\t\t\r\n\t\tfunction power2(n)\r\n\t\t{\r\n\t\t\tif(n >= powers2.length)\r\n\t\t\t{\r\n\t\t\t\tfor(let p = powers2.length; p <= n; p++)\r\n\t\t\t\t{\r\n\t\t\t\t\tconst c = new Uint8Array([0]);\r\n\t\t\t\t\tlet digits = (powers2[p - 1]).slice(0);\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor(let i = (digits.length - 1); i >=0; i--)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tconst newValue = new Uint8Array([(digits[i] << 1) + c[0]]);\r\n\t\t\t\t\t\tc[0] = newValue[0] / 10;\r\n\t\t\t\t\t\tdigits[i] = newValue[0] % 10;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (c[0] > 0)\r\n\t\t\t\t\t\tdigits = utilConcatView(c, digits);\r\n\t\t\t\t\t\r\n\t\t\t\t\tpowers2.push(digits);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn powers2[n];\r\n\t\t}\r\n\t\t\r\n\t\tfunction viewSub(first, second)\r\n\t\t{\r\n\t\t\t//region Initial variables\r\n\t\t\tlet b = 0;\r\n\t\t\t\r\n\t\t\tlet firstView = new Uint8Array(first);\r\n\t\t\tlet secondView = new Uint8Array(second);\r\n\t\t\t\r\n\t\t\tlet firstViewCopy = firstView.slice(0);\r\n\t\t\tconst firstViewCopyLength = firstViewCopy.length - 1;\r\n\t\t\tlet secondViewCopy = secondView.slice(0);\r\n\t\t\tconst secondViewCopyLength = secondViewCopy.length - 1;\r\n\t\t\t\r\n\t\t\tlet value;\r\n\t\t\t\r\n\t\t\tlet counter = 0;\r\n\t\t\t//endregion\r\n\t\t\t\r\n\t\t\tfor(let i = secondViewCopyLength; i >= 0; i--, counter++)\r\n\t\t\t{\r\n\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\r\n\t\t\t\t\r\n\t\t\t\tswitch(true)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase (value < 0):\r\n\t\t\t\t\t\tb = 1;\r\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value + 10;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tb = 0;\r\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(b > 0)\r\n\t\t\t{\r\n\t\t\t\tfor(let i = (firstViewCopyLength - secondViewCopyLength + 1); i >= 0; i--, counter++)\r\n\t\t\t\t{\r\n\t\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] - b;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(value < 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tb = 1;\r\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value + 10;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tb = 0;\r\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn firstViewCopy.slice();\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Initial variables\r\n\t\tconst firstBit = (this._valueHex.byteLength * 8) - 1;\r\n\t\t\r\n\t\tlet digits = new Uint8Array((this._valueHex.byteLength * 8) / 3);\r\n\t\tlet bitNumber = 0;\r\n\t\tlet currentByte;\r\n\t\t\r\n\t\tconst asn1View = new Uint8Array(this._valueHex);\r\n\t\t\r\n\t\tlet result = \"\";\r\n\t\t\r\n\t\tlet flag = false;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Calculate number\r\n\t\tfor(let byteNumber = (this._valueHex.byteLength - 1); byteNumber >= 0; byteNumber--)\r\n\t\t{\r\n\t\t\tcurrentByte = asn1View[byteNumber];\r\n\t\t\t\r\n\t\t\tfor(let i = 0; i < 8; i++)\r\n\t\t\t{\r\n\t\t\t\tif((currentByte & 1) === 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tswitch(bitNumber)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcase firstBit:\r\n\t\t\t\t\t\t\tdigits = viewSub(power2(bitNumber), digits);\r\n\t\t\t\t\t\t\tresult = \"-\";\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tdigits = viewAdd(digits, power2(bitNumber));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tbitNumber++;\r\n\t\t\t\tcurrentByte >>= 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Print number\r\n\t\tfor(let i = 0; i < digits.length; i++)\r\n\t\t{\r\n\t\t\tif(digits[i])\r\n\t\t\t\tflag = true;\r\n\t\t\t\r\n\t\t\tif(flag)\r\n\t\t\t\tresult += digitsString.charAt(digits[i]);\r\n\t\t}\r\n\t\t\r\n\t\tif(flag === false)\r\n\t\t\tresult += digitsString.charAt(0);\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\nexport class Integer extends BaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"Integer\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters, LocalIntegerValueBlock);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 2; // Integer\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"Integer\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Compare two Integer object, or Integer and ArrayBuffer objects\r\n\t * @param {!Integer|ArrayBuffer} otherValue\r\n\t * @returns {boolean}\r\n\t */\r\n\tisEqual(otherValue)\r\n\t{\r\n\t\tif(otherValue instanceof Integer)\r\n\t\t{\r\n\t\t\tif(this.valueBlock.isHexOnly && otherValue.valueBlock.isHexOnly) // Compare two ArrayBuffers\r\n\t\t\t\treturn isEqualBuffer(this.valueBlock.valueHex, otherValue.valueBlock.valueHex);\r\n\r\n\t\t\tif(this.valueBlock.isHexOnly === otherValue.valueBlock.isHexOnly)\r\n\t\t\t\treturn (this.valueBlock.valueDec === otherValue.valueBlock.valueDec);\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tif(otherValue instanceof ArrayBuffer)\r\n\t\t\treturn isEqualBuffer(this.valueBlock.valueHex, otherValue);\r\n\r\n\t\treturn false;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convert current Integer value from BER into DER format\r\n\t * @returns {Integer}\r\n\t */\r\n\tconvertToDER()\r\n\t{\r\n\t\tconst integer = new Integer({ valueHex: this.valueBlock.valueHex });\r\n\t\tinteger.valueBlock.toDER();\r\n\r\n\t\treturn integer;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convert current Integer value from DER to BER format\r\n\t * @returns {Integer}\r\n\t */\r\n\tconvertFromDER()\r\n\t{\r\n\t\tconst expectedLength = (this.valueBlock.valueHex.byteLength % 2) ? (this.valueBlock.valueHex.byteLength + 1) : this.valueBlock.valueHex.byteLength;\r\n\t\tconst integer = new Integer({ valueHex: this.valueBlock.valueHex });\r\n\t\tinteger.valueBlock.fromDER(integer.valueBlock.valueHex, 0, integer.valueBlock.valueHex.byteLength, expectedLength);\r\n\t\t\r\n\t\treturn integer;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of ASN.1 Enumerated type class\r\n//**************************************************************************************\r\nexport class Enumerated extends Integer\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"Enumerated\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 10; // Enumerated\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"Enumerated\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of ASN.1 ObjectIdentifier type class\r\n//**************************************************************************************\r\nclass LocalSidValueBlock extends HexBlock(LocalBaseBlock)\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalSidValueBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {number} [valueDec]\r\n\t * @property {boolean} [isFirstSid]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.valueDec = getParametersValue(parameters, \"valueDec\", -1);\r\n\t\tthis.isFirstSid = getParametersValue(parameters, \"isFirstSid\", false);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"sidBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\tif(inputLength === 0)\r\n\t\t\treturn inputOffset;\r\n\r\n\t\t//region Basic check for parameters\r\n\t\t//noinspection JSCheckFunctionSignatures\r\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\r\n\t\t\treturn (-1);\r\n\t\t//endregion\r\n\r\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\r\n\r\n\t\tthis.valueHex = new ArrayBuffer(inputLength);\r\n\t\tlet view = new Uint8Array(this.valueHex);\r\n\r\n\t\tfor(let i = 0; i < inputLength; i++)\r\n\t\t{\r\n\t\t\tview[i] = intBuffer[i] & 0x7F;\r\n\r\n\t\t\tthis.blockLength++;\r\n\r\n\t\t\tif((intBuffer[i] & 0x80) === 0x00)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t//region Ajust size of valueHex buffer\r\n\t\tconst tempValueHex = new ArrayBuffer(this.blockLength);\r\n\t\tconst tempView = new Uint8Array(tempValueHex);\r\n\r\n\t\tfor(let i = 0; i < this.blockLength; i++)\r\n\t\t\ttempView[i] = view[i];\r\n\r\n\t\t//noinspection JSCheckFunctionSignatures\r\n\t\tthis.valueHex = tempValueHex.slice(0);\r\n\t\tview = new Uint8Array(this.valueHex);\r\n\t\t//endregion\r\n\r\n\t\tif((intBuffer[this.blockLength - 1] & 0x80) !== 0x00)\r\n\t\t{\r\n\t\t\tthis.error = \"End of input reached before message was fully decoded\";\r\n\t\t\treturn (-1);\r\n\t\t}\r\n\r\n\t\tif(view[0] === 0x00)\r\n\t\t\tthis.warnings.push(\"Needlessly long format of SID encoding\");\r\n\r\n\t\tif(this.blockLength <= 8)\r\n\t\t\tthis.valueDec = utilFromBase(view, 7);\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.isHexOnly = true;\r\n\t\t\tthis.warnings.push(\"Too big SID for decoding, hex only\");\r\n\t\t}\r\n\r\n\t\treturn (inputOffset + this.blockLength);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tlet retBuf;\r\n\t\tlet retView;\r\n\t\t//endregion\r\n\r\n\t\tif(this.isHexOnly)\r\n\t\t{\r\n\t\t\tif(sizeOnly === true)\r\n\t\t\t\treturn (new ArrayBuffer(this.valueHex.byteLength));\r\n\r\n\t\t\tconst curView = new Uint8Array(this.valueHex);\r\n\r\n\t\t\tretBuf = new ArrayBuffer(this.blockLength);\r\n\t\t\tretView = new Uint8Array(retBuf);\r\n\r\n\t\t\tfor(let i = 0; i < (this.blockLength - 1); i++)\r\n\t\t\t\tretView[i] = curView[i] | 0x80;\r\n\r\n\t\t\tretView[this.blockLength - 1] = curView[this.blockLength - 1];\r\n\r\n\t\t\treturn retBuf;\r\n\t\t}\r\n\r\n\t\tconst encodedBuf = utilToBase(this.valueDec, 7);\r\n\t\tif(encodedBuf.byteLength === 0)\r\n\t\t{\r\n\t\t\tthis.error = \"Error during encoding SID value\";\r\n\t\t\treturn (new ArrayBuffer(0));\r\n\t\t}\r\n\r\n\t\tretBuf = new ArrayBuffer(encodedBuf.byteLength);\r\n\r\n\t\tif(sizeOnly === false)\r\n\t\t{\r\n\t\t\tconst encodedView = new Uint8Array(encodedBuf);\r\n\t\t\tretView = new Uint8Array(retBuf);\r\n\r\n\t\t\tfor(let i = 0; i < (encodedBuf.byteLength - 1); i++)\r\n\t\t\t\tretView[i] = encodedView[i] | 0x80;\r\n\r\n\t\t\tretView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\r\n\t\t}\r\n\r\n\t\treturn retBuf;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Create string representation of current SID block\r\n\t * @returns {string}\r\n\t */\r\n\ttoString()\r\n\t{\r\n\t\tlet result = \"\";\r\n\r\n\t\tif(this.isHexOnly === true)\r\n\t\t\tresult = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(this.isFirstSid)\r\n\t\t\t{\r\n\t\t\t\tlet sidValue = this.valueDec;\r\n\r\n\t\t\t\tif(this.valueDec <= 39)\r\n\t\t\t\t\tresult = \"0.\";\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif(this.valueDec <= 79)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresult = \"1.\";\r\n\t\t\t\t\t\tsidValue -= 40;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresult = \"2.\";\r\n\t\t\t\t\t\tsidValue -= 80;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tresult += sidValue.toString();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tresult = this.valueDec.toString();\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {Object}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.valueDec = this.valueDec;\r\n\t\tobject.isFirstSid = this.isFirstSid;\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\nclass LocalObjectIdentifierValueBlock extends ValueBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalObjectIdentifierValueBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {ArrayBuffer} [valueHex]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.fromString(getParametersValue(parameters, \"value\", \"\"));\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\tlet resultOffset = inputOffset;\r\n\r\n\t\twhile(inputLength > 0)\r\n\t\t{\r\n\t\t\tconst sidBlock = new LocalSidValueBlock();\r\n\t\t\tresultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\r\n\t\t\tif(resultOffset === (-1))\r\n\t\t\t{\r\n\t\t\t\tthis.blockLength = 0;\r\n\t\t\t\tthis.error = sidBlock.error;\r\n\t\t\t\treturn resultOffset;\r\n\t\t\t}\r\n\r\n\t\t\tif(this.value.length === 0)\r\n\t\t\t\tsidBlock.isFirstSid = true;\r\n\r\n\t\t\tthis.blockLength += sidBlock.blockLength;\r\n\t\t\tinputLength -= sidBlock.blockLength;\r\n\r\n\t\t\tthis.value.push(sidBlock);\r\n\t\t}\r\n\r\n\t\treturn resultOffset;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\tlet retBuf = new ArrayBuffer(0);\r\n\r\n\t\tfor(let i = 0; i < this.value.length; i++)\r\n\t\t{\r\n\t\t\tconst valueBuf = this.value[i].toBER(sizeOnly);\r\n\t\t\tif(valueBuf.byteLength === 0)\r\n\t\t\t{\r\n\t\t\t\tthis.error = this.value[i].error;\r\n\t\t\t\treturn (new ArrayBuffer(0));\r\n\t\t\t}\r\n\r\n\t\t\tretBuf = utilConcatBuf(retBuf, valueBuf);\r\n\t\t}\r\n\r\n\t\treturn retBuf;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Create \"LocalObjectIdentifierValueBlock\" class from string\r\n\t * @param {string} string Input string to convert from\r\n\t * @returns {boolean}\r\n\t */\r\n\tfromString(string)\r\n\t{\r\n\t\tthis.value = []; // Clear existing SID values\r\n\r\n\t\tlet pos1 = 0;\r\n\t\tlet pos2 = 0;\r\n\r\n\t\tlet sid = \"\";\r\n\r\n\t\tlet flag = false;\r\n\r\n\t\tdo\r\n\t\t{\r\n\t\t\tpos2 = string.indexOf(\".\", pos1);\r\n\t\t\tif(pos2 === (-1))\r\n\t\t\t\tsid = string.substr(pos1);\r\n\t\t\telse\r\n\t\t\t\tsid = string.substr(pos1, pos2 - pos1);\r\n\r\n\t\t\tpos1 = pos2 + 1;\r\n\r\n\t\t\tif(flag)\r\n\t\t\t{\r\n\t\t\t\tconst sidBlock = this.value[0];\r\n\r\n\t\t\t\tlet plus = 0;\r\n\r\n\t\t\t\tswitch(sidBlock.valueDec)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tplus = 40;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tplus = 80;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthis.value = []; // clear SID array\r\n\t\t\t\t\t\treturn false; // ???\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst parsedSID = parseInt(sid, 10);\r\n\t\t\t\tif(isNaN(parsedSID))\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\tsidBlock.valueDec = parsedSID + plus;\r\n\r\n\t\t\t\tflag = false;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tconst sidBlock = new LocalSidValueBlock();\r\n\t\t\t\tsidBlock.valueDec = parseInt(sid, 10);\r\n\t\t\t\tif(isNaN(sidBlock.valueDec))\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\tif(this.value.length === 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tsidBlock.isFirstSid = true;\r\n\t\t\t\t\tflag = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.value.push(sidBlock);\r\n\t\t\t}\r\n\t\t} while(pos2 !== (-1));\r\n\r\n\t\treturn true;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Converts \"LocalObjectIdentifierValueBlock\" class to string\r\n\t * @returns {string}\r\n\t */\r\n\ttoString()\r\n\t{\r\n\t\tlet result = \"\";\r\n\t\tlet isHexOnly = false;\r\n\r\n\t\tfor(let i = 0; i < this.value.length; i++)\r\n\t\t{\r\n\t\t\tisHexOnly = this.value[i].isHexOnly;\r\n\r\n\t\t\tlet sidStr = this.value[i].toString();\r\n\r\n\t\t\tif(i !== 0)\r\n\t\t\t\tresult = `${result}.`;\r\n\r\n\t\t\tif(isHexOnly)\r\n\t\t\t{\r\n\t\t\t\tsidStr = `{${sidStr}}`;\r\n\r\n\t\t\t\tif(this.value[i].isFirstSid)\r\n\t\t\t\t\tresult = `2.{${sidStr} - 80}`;\r\n\t\t\t\telse\r\n\t\t\t\t\tresult += sidStr;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tresult += sidStr;\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"ObjectIdentifierValueBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {Object}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.value = this.toString();\r\n\t\tobject.sidArray = [];\r\n\t\tfor(let i = 0; i < this.value.length; i++)\r\n\t\t\tobject.sidArray.push(this.value[i].toJSON());\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends BaseBlock\r\n */\r\nexport class ObjectIdentifier extends BaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"ObjectIdentifier\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {ArrayBuffer} [valueHex]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters, LocalObjectIdentifierValueBlock);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 6; // OBJECT IDENTIFIER\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"ObjectIdentifier\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of all string's classes\r\n//**************************************************************************************\r\nclass LocalUtf8StringValueBlock extends HexBlock(LocalBaseBlock)\r\n{\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Constructor for \"LocalUtf8StringValueBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.isHexOnly = true;\r\n\t\tthis.value = \"\"; // String representation of decoded ArrayBuffer\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"Utf8StringValueBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {Object}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.value = this.value;\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends BaseBlock\r\n */\r\nexport class Utf8String extends BaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"Utf8String\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {ArrayBuffer} [valueHex]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters, LocalUtf8StringValueBlock);\r\n\r\n\t\tif(\"value\" in parameters)\r\n\t\t\tthis.fromString(parameters.value);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 12; // Utf8String\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"Utf8String\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\r\n\t\tif(resultOffset === (-1))\r\n\t\t{\r\n\t\t\tthis.error = this.valueBlock.error;\r\n\t\t\treturn resultOffset;\r\n\t\t}\r\n\r\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\r\n\r\n\t\tif(this.idBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.idBlock.blockLength;\r\n\r\n\t\tif(this.lenBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\r\n\r\n\t\tif(this.valueBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\r\n\r\n\t\treturn resultOffset;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting ArrayBuffer into ASN.1 internal string\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t */\r\n\tfromBuffer(inputBuffer)\r\n\t{\r\n\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\t//noinspection JSDeprecatedSymbols\r\n\t\t\tthis.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value));\r\n\t\t}\r\n\t\tcatch(ex)\r\n\t\t{\r\n\t\t\tthis.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\r\n\t\t}\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting JavaScript string into ASN.1 internal class\r\n\t * @param {!string} inputString ASN.1 BER encoded array\r\n\t */\r\n\tfromString(inputString)\r\n\t{\r\n\t\t//noinspection JSDeprecatedSymbols\r\n\t\tconst str = unescape(encodeURIComponent(inputString));\r\n\t\tconst strLen = str.length;\r\n\r\n\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLen);\r\n\t\tconst view = new Uint8Array(this.valueBlock.valueHex);\r\n\r\n\t\tfor(let i = 0; i < strLen; i++)\r\n\t\t\tview[i] = str.charCodeAt(i);\r\n\r\n\t\tthis.valueBlock.value = inputString;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//region Declaration of ASN.1 RelativeObjectIdentifier type class\r\n//**************************************************************************************\r\nclass LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock)\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalRelativeSidValueBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {number} [valueDec]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.valueDec = getParametersValue(parameters, \"valueDec\", -1);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"relativeSidBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\tif (inputLength === 0)\r\n\t\t\treturn inputOffset;\r\n\r\n\t\t//region Basic check for parameters\r\n\t\t//noinspection JSCheckFunctionSignatures\r\n\t\tif (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\r\n\t\t\treturn (-1);\r\n\t\t//endregion\r\n\r\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\r\n\r\n\t\tthis.valueHex = new ArrayBuffer(inputLength);\r\n\t\tlet view = new Uint8Array(this.valueHex);\r\n\r\n\t\tfor (let i = 0; i < inputLength; i++)\r\n\t\t{\r\n\t\t\tview[i] = intBuffer[i] & 0x7F;\r\n\r\n\t\t\tthis.blockLength++;\r\n\r\n\t\t\tif ((intBuffer[i] & 0x80) === 0x00)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t//region Ajust size of valueHex buffer\r\n\t\tconst tempValueHex = new ArrayBuffer(this.blockLength);\r\n\t\tconst tempView = new Uint8Array(tempValueHex);\r\n\r\n\t\tfor (let i = 0; i < this.blockLength; i++)\r\n\t\t\ttempView[i] = view[i];\r\n\r\n\t\t//noinspection JSCheckFunctionSignatures\r\n\t\tthis.valueHex = tempValueHex.slice(0);\r\n\t\tview = new Uint8Array(this.valueHex);\r\n\t\t//endregion\r\n\r\n\t\tif ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00)\r\n\t\t{\r\n\t\t\tthis.error = \"End of input reached before message was fully decoded\";\r\n\t\t\treturn (-1);\r\n\t\t}\r\n\r\n\t\tif (view[0] === 0x00)\r\n\t\t\tthis.warnings.push(\"Needlessly long format of SID encoding\");\r\n\r\n\t\tif (this.blockLength <= 8)\r\n\t\t\tthis.valueDec = utilFromBase(view, 7);\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.isHexOnly = true;\r\n\t\t\tthis.warnings.push(\"Too big SID for decoding, hex only\");\r\n\t\t}\r\n\r\n\t\treturn (inputOffset + this.blockLength);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tlet retBuf;\r\n\t\tlet retView;\r\n\t\t//endregion\r\n\r\n\t\tif (this.isHexOnly)\r\n\t\t{\r\n\t\t\tif (sizeOnly === true)\r\n\t\t\t\treturn (new ArrayBuffer(this.valueHex.byteLength));\r\n\r\n\t\t\tconst curView = new Uint8Array(this.valueHex);\r\n\r\n\t\t\tretBuf = new ArrayBuffer(this.blockLength);\r\n\t\t\tretView = new Uint8Array(retBuf);\r\n\r\n\t\t\tfor (let i = 0; i < (this.blockLength - 1); i++)\r\n\t\t\t\tretView[i] = curView[i] | 0x80;\r\n\r\n\t\t\tretView[this.blockLength - 1] = curView[this.blockLength - 1];\r\n\r\n\t\t\treturn retBuf;\r\n\t\t}\r\n\r\n\t\tconst encodedBuf = utilToBase(this.valueDec, 7);\r\n\t\tif (encodedBuf.byteLength === 0)\r\n\t\t{\r\n\t\t\tthis.error = \"Error during encoding SID value\";\r\n\t\t\treturn (new ArrayBuffer(0));\r\n\t\t}\r\n\r\n\t\tretBuf = new ArrayBuffer(encodedBuf.byteLength);\r\n\r\n\t\tif (sizeOnly === false)\r\n\t\t{\r\n\t\t\tconst encodedView = new Uint8Array(encodedBuf);\r\n\t\t\tretView = new Uint8Array(retBuf);\r\n\r\n\t\t\tfor (let i = 0; i < (encodedBuf.byteLength - 1); i++)\r\n\t\t\t\tretView[i] = encodedView[i] | 0x80;\r\n\r\n\t\t\tretView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\r\n\t\t}\r\n\r\n\t\treturn retBuf;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Create string representation of current SID block\r\n\t * @returns {string}\r\n\t */\r\n\ttoString()\r\n\t{\r\n\t\tlet result = \"\";\r\n\r\n\t\tif (this.isHexOnly === true)\r\n\t\t\tresult = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\r\n\t\telse {\r\n\t\t\tresult = this.valueDec.toString();\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {Object}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry {\r\n\t\t\tobject = super.toJSON();\r\n\t\t} catch (ex) {}\r\n\t\t//endregion\r\n\r\n\t\tobject.valueDec = this.valueDec;\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\nclass LocalRelativeObjectIdentifierValueBlock extends ValueBlock {\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalRelativeObjectIdentifierValueBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {ArrayBuffer} [valueHex]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.fromString(getParametersValue(parameters, \"value\", \"\"));\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\tlet resultOffset = inputOffset;\r\n\r\n\t\twhile (inputLength > 0)\r\n\t\t{\r\n\t\t\tconst sidBlock = new LocalRelativeSidValueBlock();\r\n\t\t\tresultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\r\n\t\t\tif (resultOffset === (-1))\r\n\t\t\t{\r\n\t\t\t\tthis.blockLength = 0;\r\n\t\t\t\tthis.error = sidBlock.error;\r\n\t\t\t\treturn resultOffset;\r\n\t\t\t}\r\n\r\n\t\t\tthis.blockLength += sidBlock.blockLength;\r\n\t\t\tinputLength -= sidBlock.blockLength;\r\n\r\n\t\t\tthis.value.push(sidBlock);\r\n\t\t}\r\n\r\n\t\treturn resultOffset;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\tlet retBuf = new ArrayBuffer(0);\r\n\r\n\t\tfor (let i = 0; i < this.value.length; i++)\r\n\t\t{\r\n\t\t\tconst valueBuf = this.value[i].toBER(sizeOnly);\r\n\t\t\tif (valueBuf.byteLength === 0)\r\n\t\t\t{\r\n\t\t\t\tthis.error = this.value[i].error;\r\n\t\t\t\treturn (new ArrayBuffer(0));\r\n\t\t\t}\r\n\r\n\t\t\tretBuf = utilConcatBuf(retBuf, valueBuf);\r\n\t\t}\r\n\r\n\t\treturn retBuf;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Create \"LocalRelativeObjectIdentifierValueBlock\" class from string\r\n\t * @param {string} string Input string to convert from\r\n\t * @returns {boolean}\r\n\t */\r\n\tfromString(string)\r\n\t{\r\n\t\tthis.value = []; // Clear existing SID values\r\n\r\n\t\tlet pos1 = 0;\r\n\t\tlet pos2 = 0;\r\n\r\n\t\tlet sid = \"\";\r\n\r\n\t\tdo\r\n\t\t{\r\n\t\t\tpos2 = string.indexOf(\".\", pos1);\r\n\t\t\tif (pos2 === (-1))\r\n\t\t\t\tsid = string.substr(pos1);\r\n\t\t\telse\r\n\t\t\t\tsid = string.substr(pos1, pos2 - pos1);\r\n\r\n\t\t\tpos1 = pos2 + 1;\r\n\r\n\t\t\tconst sidBlock = new LocalRelativeSidValueBlock();\r\n\t\t\tsidBlock.valueDec = parseInt(sid, 10);\r\n\t\t\tif (isNaN(sidBlock.valueDec))\r\n\t\t\t\treturn true;\r\n\r\n\t\t\tthis.value.push(sidBlock);\r\n\r\n\t\t} while (pos2 !== (-1));\r\n\r\n\t\treturn true;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Converts \"LocalRelativeObjectIdentifierValueBlock\" class to string\r\n\t * @returns {string}\r\n\t */\r\n\ttoString()\r\n\t{\r\n\t\tlet result = \"\";\r\n\t\tlet isHexOnly = false;\r\n\r\n\t\tfor (let i = 0; i < this.value.length; i++)\r\n\t\t{\r\n\t\t\tisHexOnly = this.value[i].isHexOnly;\r\n\r\n\t\t\tlet sidStr = this.value[i].toString();\r\n\r\n\t\t\tif (i !== 0)\r\n\t\t\t\tresult = `${result}.`;\r\n\r\n\t\t\tif (isHexOnly)\r\n\t\t\t{\r\n\t\t\t\tsidStr = `{${sidStr}}`;\r\n\t\t\t\tresult += sidStr;\r\n\t\t\t} else\r\n\t\t\t\tresult += sidStr;\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"RelativeObjectIdentifierValueBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {Object}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t} catch (ex) {}\r\n\t\t//endregion\r\n\r\n\t\tobject.value = this.toString();\r\n\t\tobject.sidArray = [];\r\n\t\tfor (let i = 0; i < this.value.length; i++)\r\n\t\t\tobject.sidArray.push(this.value[i].toJSON());\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends BaseBlock\r\n */\r\nexport class RelativeObjectIdentifier extends BaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"RelativeObjectIdentifier\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {ArrayBuffer} [valueHex]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters, LocalRelativeObjectIdentifierValueBlock);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 13; // RELATIVE OBJECT IDENTIFIER\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"RelativeObjectIdentifier\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n/**\r\n * @extends LocalBaseBlock\r\n * @extends HexBlock\r\n */\r\nclass LocalBmpStringValueBlock extends HexBlock(LocalBaseBlock)\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalBmpStringValueBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.isHexOnly = true;\r\n\t\tthis.value = \"\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"BmpStringValueBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {Object}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.value = this.value;\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends BaseBlock\r\n */\r\nexport class BmpString extends BaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"BmpString\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters, LocalBmpStringValueBlock);\r\n\r\n\t\tif(\"value\" in parameters)\r\n\t\t\tthis.fromString(parameters.value);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 30; // BmpString\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"BmpString\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\r\n\t\tif(resultOffset === (-1))\r\n\t\t{\r\n\t\t\tthis.error = this.valueBlock.error;\r\n\t\t\treturn resultOffset;\r\n\t\t}\r\n\r\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\r\n\r\n\t\tif(this.idBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.idBlock.blockLength;\r\n\r\n\t\tif(this.lenBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\r\n\r\n\t\tif(this.valueBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\r\n\r\n\t\treturn resultOffset;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting ArrayBuffer into ASN.1 internal string\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t */\r\n\tfromBuffer(inputBuffer)\r\n\t{\r\n\t\t//noinspection JSCheckFunctionSignatures\r\n\t\tconst copyBuffer = inputBuffer.slice(0);\r\n\t\tconst valueView = new Uint8Array(copyBuffer);\r\n\r\n\t\tfor(let i = 0; i < valueView.length; i += 2)\r\n\t\t{\r\n\t\t\tconst temp = valueView[i];\r\n\r\n\t\t\tvalueView[i] = valueView[i + 1];\r\n\t\t\tvalueView[i + 1] = temp;\r\n\t\t}\r\n\r\n\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(copyBuffer));\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting JavaScript string into ASN.1 internal class\r\n\t * @param {!string} inputString ASN.1 BER encoded array\r\n\t */\r\n\tfromString(inputString)\r\n\t{\r\n\t\tconst strLength = inputString.length;\r\n\r\n\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLength * 2);\r\n\t\tconst valueHexView = new Uint8Array(this.valueBlock.valueHex);\r\n\r\n\t\tfor(let i = 0; i < strLength; i++)\r\n\t\t{\r\n\t\t\tconst codeBuf = utilToBase(inputString.charCodeAt(i), 8);\r\n\t\t\tconst codeView = new Uint8Array(codeBuf);\r\n\t\t\tif(codeView.length > 2)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tconst dif = 2 - codeView.length;\r\n\r\n\t\t\tfor(let j = (codeView.length - 1); j >= 0; j--)\r\n\t\t\t\tvalueHexView[i * 2 + j + dif] = codeView[j];\r\n\t\t}\r\n\r\n\t\tthis.valueBlock.value = inputString;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\nclass LocalUniversalStringValueBlock extends HexBlock(LocalBaseBlock)\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalUniversalStringValueBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.isHexOnly = true;\r\n\t\tthis.value = \"\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"UniversalStringValueBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {Object}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.value = this.value;\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends BaseBlock\r\n */\r\nexport class UniversalString extends BaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"UniversalString\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters, LocalUniversalStringValueBlock);\r\n\r\n\t\tif(\"value\" in parameters)\r\n\t\t\tthis.fromString(parameters.value);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 28; // UniversalString\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"UniversalString\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\r\n\t\tif(resultOffset === (-1))\r\n\t\t{\r\n\t\t\tthis.error = this.valueBlock.error;\r\n\t\t\treturn resultOffset;\r\n\t\t}\r\n\r\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\r\n\r\n\t\tif(this.idBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.idBlock.blockLength;\r\n\r\n\t\tif(this.lenBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\r\n\r\n\t\tif(this.valueBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\r\n\r\n\t\treturn resultOffset;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting ArrayBuffer into ASN.1 internal string\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t */\r\n\tfromBuffer(inputBuffer)\r\n\t{\r\n\t\t//noinspection JSCheckFunctionSignatures\r\n\t\tconst copyBuffer = inputBuffer.slice(0);\r\n\t\tconst valueView = new Uint8Array(copyBuffer);\r\n\r\n\t\tfor(let i = 0; i < valueView.length; i += 4)\r\n\t\t{\r\n\t\t\tvalueView[i] = valueView[i + 3];\r\n\t\t\tvalueView[i + 1] = valueView[i + 2];\r\n\t\t\tvalueView[i + 2] = 0x00;\r\n\t\t\tvalueView[i + 3] = 0x00;\r\n\t\t}\r\n\r\n\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting JavaScript string into ASN.1 internal class\r\n\t * @param {!string} inputString ASN.1 BER encoded array\r\n\t */\r\n\tfromString(inputString)\r\n\t{\r\n\t\tconst strLength = inputString.length;\r\n\r\n\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLength * 4);\r\n\t\tconst valueHexView = new Uint8Array(this.valueBlock.valueHex);\r\n\r\n\t\tfor(let i = 0; i < strLength; i++)\r\n\t\t{\r\n\t\t\tconst codeBuf = utilToBase(inputString.charCodeAt(i), 8);\r\n\t\t\tconst codeView = new Uint8Array(codeBuf);\r\n\t\t\tif(codeView.length > 4)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tconst dif = 4 - codeView.length;\r\n\r\n\t\t\tfor(let j = (codeView.length - 1); j >= 0; j--)\r\n\t\t\t\tvalueHexView[i * 4 + j + dif] = codeView[j];\r\n\t\t}\r\n\r\n\t\tthis.valueBlock.value = inputString;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\nclass LocalSimpleStringValueBlock extends HexBlock(LocalBaseBlock)\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalSimpleStringValueBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.value = \"\";\r\n\t\tthis.isHexOnly = true;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"SimpleStringValueBlock\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {Object}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.value = this.value;\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends BaseBlock\r\n */\r\nclass LocalSimpleStringBlock extends BaseBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"LocalSimpleStringBlock\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters, LocalSimpleStringValueBlock);\r\n\r\n\t\tif(\"value\" in parameters)\r\n\t\t\tthis.fromString(parameters.value);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"SIMPLESTRING\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\r\n\t\tif(resultOffset === (-1))\r\n\t\t{\r\n\t\t\tthis.error = this.valueBlock.error;\r\n\t\t\treturn resultOffset;\r\n\t\t}\r\n\r\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\r\n\r\n\t\tif(this.idBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.idBlock.blockLength;\r\n\r\n\t\tif(this.lenBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\r\n\r\n\t\tif(this.valueBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\r\n\r\n\t\treturn resultOffset;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting ArrayBuffer into ASN.1 internal string\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t */\r\n\tfromBuffer(inputBuffer)\r\n\t{\r\n\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting JavaScript string into ASN.1 internal class\r\n\t * @param {!string} inputString ASN.1 BER encoded array\r\n\t */\r\n\tfromString(inputString)\r\n\t{\r\n\t\tconst strLen = inputString.length;\r\n\r\n\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLen);\r\n\t\tconst view = new Uint8Array(this.valueBlock.valueHex);\r\n\r\n\t\tfor(let i = 0; i < strLen; i++)\r\n\t\t\tview[i] = inputString.charCodeAt(i);\r\n\r\n\t\tthis.valueBlock.value = inputString;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\r\nexport class NumericString extends LocalSimpleStringBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"NumericString\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 18; // NumericString\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"NumericString\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\r\nexport class PrintableString extends LocalSimpleStringBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"PrintableString\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 19; // PrintableString\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"PrintableString\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\r\nexport class TeletexString extends LocalSimpleStringBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"TeletexString\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 20; // TeletexString\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"TeletexString\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\r\nexport class VideotexString extends LocalSimpleStringBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"VideotexString\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 21; // VideotexString\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"VideotexString\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\r\nexport class IA5String extends LocalSimpleStringBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"IA5String\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 22; // IA5String\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"IA5String\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\r\nexport class GraphicString extends LocalSimpleStringBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"GraphicString\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 25; // GraphicString\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"GraphicString\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\r\nexport class VisibleString extends LocalSimpleStringBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"VisibleString\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 26; // VisibleString\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"VisibleString\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\r\nexport class GeneralString extends LocalSimpleStringBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"GeneralString\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 27; // GeneralString\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"GeneralString\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\r\nexport class CharacterString extends LocalSimpleStringBlock\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"CharacterString\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 29; // CharacterString\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"CharacterString\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of all date and time classes\r\n//**************************************************************************************\r\n/**\r\n * @extends VisibleString\r\n */\r\nexport class UTCTime extends VisibleString\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"UTCTime\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {string} [value] String representatio of the date\r\n\t * @property {Date} [valueDate] JavaScript \"Date\" object\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.year = 0;\r\n\t\tthis.month = 0;\r\n\t\tthis.day = 0;\r\n\t\tthis.hour = 0;\r\n\t\tthis.minute = 0;\r\n\t\tthis.second = 0;\r\n\r\n\t\t//region Create UTCTime from ASN.1 UTC string value\r\n\t\tif(\"value\" in parameters)\r\n\t\t{\r\n\t\t\tthis.fromString(parameters.value);\r\n\r\n\t\t\tthis.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\r\n\t\t\tconst view = new Uint8Array(this.valueBlock.valueHex);\r\n\r\n\t\t\tfor(let i = 0; i < parameters.value.length; i++)\r\n\t\t\t\tview[i] = parameters.value.charCodeAt(i);\r\n\t\t}\r\n\t\t//endregion\r\n\t\t//region Create GeneralizedTime from JavaScript Date type\r\n\t\tif(\"valueDate\" in parameters)\r\n\t\t{\r\n\t\t\tthis.fromDate(parameters.valueDate);\r\n\t\t\tthis.valueBlock.valueHex = this.toBuffer();\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 23; // UTCTime\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\r\n\t\tif(resultOffset === (-1))\r\n\t\t{\r\n\t\t\tthis.error = this.valueBlock.error;\r\n\t\t\treturn resultOffset;\r\n\t\t}\r\n\r\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\r\n\r\n\t\tif(this.idBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.idBlock.blockLength;\r\n\r\n\t\tif(this.lenBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\r\n\r\n\t\tif(this.valueBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\r\n\r\n\t\treturn resultOffset;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting ArrayBuffer into ASN.1 internal string\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t */\r\n\tfromBuffer(inputBuffer)\r\n\t{\r\n\t\tthis.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting ASN.1 internal string into ArrayBuffer\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBuffer()\r\n\t{\r\n\t\tconst str = this.toString();\r\n\r\n\t\tconst buffer = new ArrayBuffer(str.length);\r\n\t\tconst view = new Uint8Array(buffer);\r\n\r\n\t\tfor(let i = 0; i < str.length; i++)\r\n\t\t\tview[i] = str.charCodeAt(i);\r\n\r\n\t\treturn buffer;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting \"Date\" object into ASN.1 internal string\r\n\t * @param {!Date} inputDate JavaScript \"Date\" object\r\n\t */\r\n\tfromDate(inputDate)\r\n\t{\r\n\t\tthis.year = inputDate.getUTCFullYear();\r\n\t\tthis.month = inputDate.getUTCMonth() + 1;\r\n\t\tthis.day = inputDate.getUTCDate();\r\n\t\tthis.hour = inputDate.getUTCHours();\r\n\t\tthis.minute = inputDate.getUTCMinutes();\r\n\t\tthis.second = inputDate.getUTCSeconds();\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Function converting ASN.1 internal string into \"Date\" object\r\n\t * @returns {Date}\r\n\t */\r\n\ttoDate()\r\n\t{\r\n\t\treturn (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second)));\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting JavaScript string into ASN.1 internal class\r\n\t * @param {!string} inputString ASN.1 BER encoded array\r\n\t */\r\n\tfromString(inputString)\r\n\t{\r\n\t\t//region Parse input string\r\n\t\tconst parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\r\n\t\tconst parserArray = parser.exec(inputString);\r\n\t\tif(parserArray === null)\r\n\t\t{\r\n\t\t\tthis.error = \"Wrong input string for convertion\";\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Store parsed values\r\n\t\tconst year = parseInt(parserArray[1], 10);\r\n\t\tif(year >= 50)\r\n\t\t\tthis.year = 1900 + year;\r\n\t\telse\r\n\t\t\tthis.year = 2000 + year;\r\n\r\n\t\tthis.month = parseInt(parserArray[2], 10);\r\n\t\tthis.day = parseInt(parserArray[3], 10);\r\n\t\tthis.hour = parseInt(parserArray[4], 10);\r\n\t\tthis.minute = parseInt(parserArray[5], 10);\r\n\t\tthis.second = parseInt(parserArray[6], 10);\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting ASN.1 internal class into JavaScript string\r\n\t * @returns {string}\r\n\t */\r\n\ttoString()\r\n\t{\r\n\t\tconst outputArray = new Array(7);\r\n\r\n\t\toutputArray[0] = padNumber(((this.year < 2000) ? (this.year - 1900) : (this.year - 2000)), 2);\r\n\t\toutputArray[1] = padNumber(this.month, 2);\r\n\t\toutputArray[2] = padNumber(this.day, 2);\r\n\t\toutputArray[3] = padNumber(this.hour, 2);\r\n\t\toutputArray[4] = padNumber(this.minute, 2);\r\n\t\toutputArray[5] = padNumber(this.second, 2);\r\n\t\toutputArray[6] = \"Z\";\r\n\r\n\t\treturn outputArray.join(\"\");\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"UTCTime\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {Object}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.year = this.year;\r\n\t\tobject.month = this.month;\r\n\t\tobject.day = this.day;\r\n\t\tobject.hour = this.hour;\r\n\t\tobject.minute = this.minute;\r\n\t\tobject.second = this.second;\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends VisibleString\r\n */\r\nexport class GeneralizedTime extends VisibleString\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"GeneralizedTime\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {string} [value] String representatio of the date\r\n\t * @property {Date} [valueDate] JavaScript \"Date\" object\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.year = 0;\r\n\t\tthis.month = 0;\r\n\t\tthis.day = 0;\r\n\t\tthis.hour = 0;\r\n\t\tthis.minute = 0;\r\n\t\tthis.second = 0;\r\n\t\tthis.millisecond = 0;\r\n\r\n\t\t//region Create UTCTime from ASN.1 UTC string value\r\n\t\tif(\"value\" in parameters)\r\n\t\t{\r\n\t\t\tthis.fromString(parameters.value);\r\n\r\n\t\t\tthis.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\r\n\t\t\tconst view = new Uint8Array(this.valueBlock.valueHex);\r\n\r\n\t\t\tfor(let i = 0; i < parameters.value.length; i++)\r\n\t\t\t\tview[i] = parameters.value.charCodeAt(i);\r\n\t\t}\r\n\t\t//endregion\r\n\t\t//region Create GeneralizedTime from JavaScript Date type\r\n\t\tif(\"valueDate\" in parameters)\r\n\t\t{\r\n\t\t\tthis.fromDate(parameters.valueDate);\r\n\t\t\tthis.valueBlock.valueHex = this.toBuffer();\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 24; // GeneralizedTime\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\r\n\t\tif(resultOffset === (-1))\r\n\t\t{\r\n\t\t\tthis.error = this.valueBlock.error;\r\n\t\t\treturn resultOffset;\r\n\t\t}\r\n\r\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\r\n\r\n\t\tif(this.idBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.idBlock.blockLength;\r\n\r\n\t\tif(this.lenBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\r\n\r\n\t\tif(this.valueBlock.error.length === 0)\r\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\r\n\r\n\t\treturn resultOffset;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting ArrayBuffer into ASN.1 internal string\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t */\r\n\tfromBuffer(inputBuffer)\r\n\t{\r\n\t\tthis.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting ASN.1 internal string into ArrayBuffer\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBuffer()\r\n\t{\r\n\t\tconst str = this.toString();\r\n\r\n\t\tconst buffer = new ArrayBuffer(str.length);\r\n\t\tconst view = new Uint8Array(buffer);\r\n\r\n\t\tfor(let i = 0; i < str.length; i++)\r\n\t\t\tview[i] = str.charCodeAt(i);\r\n\r\n\t\treturn buffer;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting \"Date\" object into ASN.1 internal string\r\n\t * @param {!Date} inputDate JavaScript \"Date\" object\r\n\t */\r\n\tfromDate(inputDate)\r\n\t{\r\n\t\tthis.year = inputDate.getUTCFullYear();\r\n\t\tthis.month = inputDate.getUTCMonth() + 1;\r\n\t\tthis.day = inputDate.getUTCDate();\r\n\t\tthis.hour = inputDate.getUTCHours();\r\n\t\tthis.minute = inputDate.getUTCMinutes();\r\n\t\tthis.second = inputDate.getUTCSeconds();\r\n\t\tthis.millisecond = inputDate.getUTCMilliseconds();\r\n\t}\r\n\t//**********************************************************************************\r\n\t//noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Function converting ASN.1 internal string into \"Date\" object\r\n\t * @returns {Date}\r\n\t */\r\n\ttoDate()\r\n\t{\r\n\t\treturn (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)));\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting JavaScript string into ASN.1 internal class\r\n\t * @param {!string} inputString ASN.1 BER encoded array\r\n\t */\r\n\tfromString(inputString)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tlet isUTC = false;\r\n\r\n\t\tlet timeString = \"\";\r\n\t\tlet dateTimeString = \"\";\r\n\t\tlet fractionPart = 0;\r\n\r\n\t\tlet parser;\r\n\r\n\t\tlet hourDifference = 0;\r\n\t\tlet minuteDifference = 0;\r\n\t\t//endregion\r\n\r\n\t\t//region Convert as UTC time\r\n\t\tif(inputString[inputString.length - 1] === \"Z\")\r\n\t\t{\r\n\t\t\ttimeString = inputString.substr(0, inputString.length - 1);\r\n\r\n\t\t\tisUTC = true;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t//region Convert as local time\r\n\t\telse\r\n\t\t{\r\n\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\r\n\t\t\tconst number = new Number(inputString[inputString.length - 1]);\r\n\r\n\t\t\tif(isNaN(number.valueOf()))\r\n\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\r\n\r\n\t\t\ttimeString = inputString;\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Check that we do not have a \"+\" and \"-\" symbols inside UTC time\r\n\t\tif(isUTC)\r\n\t\t{\r\n\t\t\tif(timeString.indexOf(\"+\") !== (-1))\r\n\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\r\n\r\n\t\t\tif(timeString.indexOf(\"-\") !== (-1))\r\n\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\r\n\t\t}\r\n\t\t//endregion\r\n\t\t//region Get \"UTC time difference\" in case of local time\r\n\t\telse\r\n\t\t{\r\n\t\t\tlet multiplier = 1;\r\n\t\t\tlet differencePosition = timeString.indexOf(\"+\");\r\n\t\t\tlet differenceString = \"\";\r\n\r\n\t\t\tif(differencePosition === (-1))\r\n\t\t\t{\r\n\t\t\t\tdifferencePosition = timeString.indexOf(\"-\");\r\n\t\t\t\tmultiplier = (-1);\r\n\t\t\t}\r\n\r\n\t\t\tif(differencePosition !== (-1))\r\n\t\t\t{\r\n\t\t\t\tdifferenceString = timeString.substr(differencePosition + 1);\r\n\t\t\t\ttimeString = timeString.substr(0, differencePosition);\r\n\r\n\t\t\t\tif((differenceString.length !== 2) && (differenceString.length !== 4))\r\n\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\r\n\r\n\t\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\r\n\t\t\t\tlet number = new Number(differenceString.substr(0, 2));\r\n\r\n\t\t\t\tif(isNaN(number.valueOf()))\r\n\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\r\n\r\n\t\t\t\thourDifference = multiplier * number;\r\n\r\n\t\t\t\tif(differenceString.length === 4)\r\n\t\t\t\t{\r\n\t\t\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\r\n\t\t\t\t\tnumber = new Number(differenceString.substr(2, 2));\r\n\r\n\t\t\t\t\tif(isNaN(number.valueOf()))\r\n\t\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\r\n\r\n\t\t\t\t\tminuteDifference = multiplier * number;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Get position of fraction point\r\n\t\tlet fractionPointPosition = timeString.indexOf(\".\"); // Check for \"full stop\" symbol\r\n\t\tif(fractionPointPosition === (-1))\r\n\t\t\tfractionPointPosition = timeString.indexOf(\",\"); // Check for \"comma\" symbol\r\n\t\t//endregion\r\n\r\n\t\t//region Get fraction part\r\n\t\tif(fractionPointPosition !== (-1))\r\n\t\t{\r\n\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\r\n\t\t\tconst fractionPartCheck = new Number(`0${timeString.substr(fractionPointPosition)}`);\r\n\r\n\t\t\tif(isNaN(fractionPartCheck.valueOf()))\r\n\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\r\n\r\n\t\t\tfractionPart = fractionPartCheck.valueOf();\r\n\r\n\t\t\tdateTimeString = timeString.substr(0, fractionPointPosition);\r\n\t\t}\r\n\t\telse\r\n\t\t\tdateTimeString = timeString;\r\n\t\t//endregion\r\n\r\n\t\t//region Parse internal date\r\n\t\tswitch(true)\r\n\t\t{\r\n\t\t\tcase (dateTimeString.length === 8): // \"YYYYMMDD\"\r\n\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})/ig;\r\n\t\t\t\tif(fractionPointPosition !== (-1))\r\n\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\"); // Here we should not have a \"fraction point\"\r\n\t\t\t\tbreak;\r\n\t\t\tcase (dateTimeString.length === 10): // \"YYYYMMDDHH\"\r\n\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n\r\n\t\t\t\tif(fractionPointPosition !== (-1))\r\n\t\t\t\t{\r\n\t\t\t\t\tlet fractionResult = 60 * fractionPart;\r\n\t\t\t\t\tthis.minute = Math.floor(fractionResult);\r\n\r\n\t\t\t\t\tfractionResult = 60 * (fractionResult - this.minute);\r\n\t\t\t\t\tthis.second = Math.floor(fractionResult);\r\n\r\n\t\t\t\t\tfractionResult = 1000 * (fractionResult - this.second);\r\n\t\t\t\t\tthis.millisecond = Math.floor(fractionResult);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase (dateTimeString.length === 12): // \"YYYYMMDDHHMM\"\r\n\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n\r\n\t\t\t\tif(fractionPointPosition !== (-1))\r\n\t\t\t\t{\r\n\t\t\t\t\tlet fractionResult = 60 * fractionPart;\r\n\t\t\t\t\tthis.second = Math.floor(fractionResult);\r\n\r\n\t\t\t\t\tfractionResult = 1000 * (fractionResult - this.second);\r\n\t\t\t\t\tthis.millisecond = Math.floor(fractionResult);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase (dateTimeString.length === 14): // \"YYYYMMDDHHMMSS\"\r\n\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n\r\n\t\t\t\tif(fractionPointPosition !== (-1))\r\n\t\t\t\t{\r\n\t\t\t\t\tconst fractionResult = 1000 * fractionPart;\r\n\t\t\t\t\tthis.millisecond = Math.floor(fractionResult);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Put parsed values at right places\r\n\t\tconst parserArray = parser.exec(dateTimeString);\r\n\t\tif(parserArray === null)\r\n\t\t\tthrow new Error(\"Wrong input string for convertion\");\r\n\r\n\t\tfor(let j = 1; j < parserArray.length; j++)\r\n\t\t{\r\n\t\t\tswitch(j)\r\n\t\t\t{\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tthis.year = parseInt(parserArray[j], 10);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tthis.month = parseInt(parserArray[j], 10);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tthis.day = parseInt(parserArray[j], 10);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 4:\r\n\t\t\t\t\tthis.hour = parseInt(parserArray[j], 10) + hourDifference;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 5:\r\n\t\t\t\t\tthis.minute = parseInt(parserArray[j], 10) + minuteDifference;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 6:\r\n\t\t\t\t\tthis.second = parseInt(parserArray[j], 10);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Get final date\r\n\t\tif(isUTC === false)\r\n\t\t{\r\n\t\t\tconst tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\r\n\r\n\t\t\tthis.year = tempDate.getUTCFullYear();\r\n\t\t\tthis.month = tempDate.getUTCMonth();\r\n\t\t\tthis.day = tempDate.getUTCDay();\r\n\t\t\tthis.hour = tempDate.getUTCHours();\r\n\t\t\tthis.minute = tempDate.getUTCMinutes();\r\n\t\t\tthis.second = tempDate.getUTCSeconds();\r\n\t\t\tthis.millisecond = tempDate.getUTCMilliseconds();\r\n\t\t}\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Function converting ASN.1 internal class into JavaScript string\r\n\t * @returns {string}\r\n\t */\r\n\ttoString()\r\n\t{\r\n\t\tconst outputArray = [];\r\n\r\n\t\toutputArray.push(padNumber(this.year, 4));\r\n\t\toutputArray.push(padNumber(this.month, 2));\r\n\t\toutputArray.push(padNumber(this.day, 2));\r\n\t\toutputArray.push(padNumber(this.hour, 2));\r\n\t\toutputArray.push(padNumber(this.minute, 2));\r\n\t\toutputArray.push(padNumber(this.second, 2));\r\n\t\tif(this.millisecond !== 0)\r\n\t\t{\r\n\t\t\toutputArray.push(\".\");\r\n\t\t\toutputArray.push(padNumber(this.millisecond, 3));\r\n\t\t}\r\n\t\toutputArray.push(\"Z\");\r\n\r\n\t\treturn outputArray.join(\"\");\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"GeneralizedTime\";\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convertion for the block to JSON object\r\n\t * @returns {Object}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tlet object = {};\r\n\t\t\r\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\r\n\t\ttry\r\n\t\t{\r\n\t\t\tobject = super.toJSON();\r\n\t\t}\r\n\t\tcatch(ex){}\r\n\t\t//endregion\r\n\r\n\t\tobject.year = this.year;\r\n\t\tobject.month = this.month;\r\n\t\tobject.day = this.day;\r\n\t\tobject.hour = this.hour;\r\n\t\tobject.minute = this.minute;\r\n\t\tobject.second = this.second;\r\n\t\tobject.millisecond = this.millisecond;\r\n\r\n\t\treturn object;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends Utf8String\r\n */\r\nexport class DATE extends Utf8String\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"DATE\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 31; // DATE\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"DATE\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends Utf8String\r\n */\r\nexport class TimeOfDay extends Utf8String\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"TimeOfDay\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 32; // TimeOfDay\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"TimeOfDay\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends Utf8String\r\n */\r\nexport class DateTime extends Utf8String\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"DateTime\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 33; // DateTime\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"DateTime\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends Utf8String\r\n */\r\nexport class Duration extends Utf8String\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"Duration\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 34; // Duration\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"Duration\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n/**\r\n * @extends Utf8String\r\n */\r\nexport class TIME extends Utf8String\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"Time\" class\r\n\t * @param {Object} [parameters={}]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tsuper(parameters);\r\n\r\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\r\n\t\tthis.idBlock.tagNumber = 14; // Time\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\r\n\t * @returns {string}\r\n\t */\r\n\tstatic blockName()\r\n\t{\r\n\t\treturn \"TIME\";\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of special ASN.1 schema type Choice\r\n//**************************************************************************************\r\nexport class Choice\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"Choice\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {Array} [value] Array of ASN.1 types for make a choice from\r\n\t * @property {boolean} [optional]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tthis.value = getParametersValue(parameters, \"value\", []);\r\n\t\tthis.optional = getParametersValue(parameters, \"optional\", false);\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of special ASN.1 schema type Any\r\n//**************************************************************************************\r\nexport class Any\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"Any\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {string} [name]\r\n\t * @property {boolean} [optional]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tthis.name = getParametersValue(parameters, \"name\", \"\");\r\n\t\tthis.optional = getParametersValue(parameters, \"optional\", false);\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of special ASN.1 schema type Repeated\r\n//**************************************************************************************\r\nexport class Repeated\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"Repeated\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {string} [name]\r\n\t * @property {boolean} [optional]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tthis.name = getParametersValue(parameters, \"name\", \"\");\r\n\t\tthis.optional = getParametersValue(parameters, \"optional\", false);\r\n\t\tthis.value = getParametersValue(parameters, \"value\", new Any());\r\n\t\tthis.local = getParametersValue(parameters, \"local\", false); // Could local or global array to store elements\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Declaration of special ASN.1 schema type RawData\r\n//**************************************************************************************\r\n/**\r\n * @description Special class providing ability to have \"toBER/fromBER\" for raw ArrayBuffer\r\n */\r\nexport class RawData\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"Repeated\" class\r\n\t * @param {Object} [parameters={}]\r\n\t * @property {string} [name]\r\n\t * @property {boolean} [optional]\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tthis.data = getParametersValue(parameters, \"data\", new ArrayBuffer(0));\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Base function for converting block from BER encoded array of bytes\r\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n\t * @returns {number} Offset after least decoded byte\r\n\t */\r\n\tfromBER(inputBuffer, inputOffset, inputLength)\r\n\t{\r\n\t\tthis.data = inputBuffer.slice(inputOffset, inputLength);\r\n\t\treturn (inputOffset + inputLength);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\ttoBER(sizeOnly = false)\r\n\t{\r\n\t\treturn this.data;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Major ASN.1 BER decoding function\r\n//**************************************************************************************\r\n/**\r\n * Internal library function for decoding ASN.1 BER\r\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n * @returns {{offset: number, result: Object}}\r\n */\r\nfunction LocalFromBER(inputBuffer, inputOffset, inputLength)\r\n{\r\n\tconst incomingOffset = inputOffset; // Need to store initial offset since \"inputOffset\" is changing in the function\r\n\r\n\t//region Local function changing a type for ASN.1 classes\r\n\tfunction localChangeType(inputObject, newType)\r\n\t{\r\n\t\tif(inputObject instanceof newType)\r\n\t\t\treturn inputObject;\r\n\r\n\t\tconst newObject = new newType();\r\n\t\tnewObject.idBlock = inputObject.idBlock;\r\n\t\tnewObject.lenBlock = inputObject.lenBlock;\r\n\t\tnewObject.warnings = inputObject.warnings;\r\n\t\t//noinspection JSCheckFunctionSignatures\r\n\t\tnewObject.valueBeforeDecode = inputObject.valueBeforeDecode.slice(0);\r\n\r\n\t\treturn newObject;\r\n\t}\r\n\t//endregion\r\n\r\n\t//region Create a basic ASN.1 type since we need to return errors and warnings from the function\r\n\tlet returnObject = new BaseBlock({}, Object);\r\n\t//endregion\r\n\r\n\t//region Basic check for parameters\r\n\tconst baseBlock = new LocalBaseBlock();\r\n\tif(checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) === false)\r\n\t{\r\n\t\treturnObject.error = baseBlock.error;\r\n\t\treturn {\r\n\t\t\toffset: (-1),\r\n\t\t\tresult: returnObject\r\n\t\t};\r\n\t}\r\n\t//endregion\r\n\r\n\t//region Getting Uint8Array from ArrayBuffer\r\n\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\r\n\t//endregion\r\n\r\n\t//region Initial checks\r\n\tif(intBuffer.length === 0)\r\n\t{\r\n\t\tthis.error = \"Zero buffer length\";\r\n\t\treturn {\r\n\t\t\toffset: (-1),\r\n\t\t\tresult: returnObject\r\n\t\t};\r\n\t}\r\n\t//endregion\r\n\r\n\t//region Decode indentifcation block of ASN.1 BER structure\r\n\tlet resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\r\n\treturnObject.warnings.concat(returnObject.idBlock.warnings);\r\n\tif(resultOffset === (-1))\r\n\t{\r\n\t\treturnObject.error = returnObject.idBlock.error;\r\n\t\treturn {\r\n\t\t\toffset: (-1),\r\n\t\t\tresult: returnObject\r\n\t\t};\r\n\t}\r\n\r\n\tinputOffset = resultOffset;\r\n\tinputLength -= returnObject.idBlock.blockLength;\r\n\t//endregion\r\n\r\n\t//region Decode length block of ASN.1 BER structure\r\n\tresultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\r\n\treturnObject.warnings.concat(returnObject.lenBlock.warnings);\r\n\tif(resultOffset === (-1))\r\n\t{\r\n\t\treturnObject.error = returnObject.lenBlock.error;\r\n\t\treturn {\r\n\t\t\toffset: (-1),\r\n\t\t\tresult: returnObject\r\n\t\t};\r\n\t}\r\n\r\n\tinputOffset = resultOffset;\r\n\tinputLength -= returnObject.lenBlock.blockLength;\r\n\t//endregion\r\n\r\n\t//region Check for usign indefinite length form in encoding for primitive types\r\n\tif((returnObject.idBlock.isConstructed === false) &&\r\n\t\t(returnObject.lenBlock.isIndefiniteForm === true))\r\n\t{\r\n\t\treturnObject.error = \"Indefinite length form used for primitive encoding form\";\r\n\t\treturn {\r\n\t\t\toffset: (-1),\r\n\t\t\tresult: returnObject\r\n\t\t};\r\n\t}\r\n\t//endregion\r\n\r\n\t//region Switch ASN.1 block type\r\n\tlet newASN1Type = BaseBlock;\r\n\r\n\tswitch(returnObject.idBlock.tagClass)\r\n\t{\r\n\t\t//region UNIVERSAL\r\n\t\tcase 1:\r\n\t\t\t//region Check for reserved tag numbers\r\n\t\t\tif((returnObject.idBlock.tagNumber >= 37) &&\r\n\t\t\t\t(returnObject.idBlock.isHexOnly === false))\r\n\t\t\t{\r\n\t\t\t\treturnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\r\n\t\t\t\treturn {\r\n\t\t\t\t\toffset: (-1),\r\n\t\t\t\t\tresult: returnObject\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\t//endregion\r\n\r\n\t\t\tswitch(returnObject.idBlock.tagNumber)\r\n\t\t\t{\r\n\t\t\t\t//region EndOfContent type\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\t//region Check for EndOfContent type\r\n\t\t\t\t\tif((returnObject.idBlock.isConstructed === true) &&\r\n\t\t\t\t\t\t(returnObject.lenBlock.length > 0))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturnObject.error = \"Type [UNIVERSAL 0] is reserved\";\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\toffset: (-1),\r\n\t\t\t\t\t\t\tresult: returnObject\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\tnewASN1Type = EndOfContent;\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region Boolean type\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tnewASN1Type = Boolean;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region Integer type\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tnewASN1Type = Integer;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region BitString type\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tnewASN1Type = BitString;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region OctetString type\r\n\t\t\t\tcase 4:\r\n\t\t\t\t\tnewASN1Type = OctetString;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region Null type\r\n\t\t\t\tcase 5:\r\n\t\t\t\t\tnewASN1Type = Null;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region OBJECT IDENTIFIER type\r\n\t\t\t\tcase 6:\r\n\t\t\t\t\tnewASN1Type = ObjectIdentifier;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region Enumerated type\r\n\t\t\t\tcase 10:\r\n\t\t\t\t\tnewASN1Type = Enumerated;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region Utf8String type\r\n\t\t\t\tcase 12:\r\n\t\t\t\t\tnewASN1Type = Utf8String;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region Time type\r\n\t\t\t\t//region RELATIVE OBJECT IDENTIFIER type\r\n\t\t\t\tcase 13:\r\n\t\t\t\t\tnewASN1Type = RelativeObjectIdentifier;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\tcase 14:\r\n\t\t\t\t\tnewASN1Type = TIME;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region ASN.1 reserved type\r\n\t\t\t\tcase 15:\r\n\t\t\t\t\treturnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\toffset: (-1),\r\n\t\t\t\t\t\tresult: returnObject\r\n\t\t\t\t\t};\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region Sequence type\r\n\t\t\t\tcase 16:\r\n\t\t\t\t\tnewASN1Type = Sequence;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region Set type\r\n\t\t\t\tcase 17:\r\n\t\t\t\t\tnewASN1Type = Set;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region NumericString type\r\n\t\t\t\tcase 18:\r\n\t\t\t\t\tnewASN1Type = NumericString;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region PrintableString type\r\n\t\t\t\tcase 19:\r\n\t\t\t\t\tnewASN1Type = PrintableString;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region TeletexString type\r\n\t\t\t\tcase 20:\r\n\t\t\t\t\tnewASN1Type = TeletexString;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region VideotexString type\r\n\t\t\t\tcase 21:\r\n\t\t\t\t\tnewASN1Type = VideotexString;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region IA5String type\r\n\t\t\t\tcase 22:\r\n\t\t\t\t\tnewASN1Type = IA5String;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region UTCTime type\r\n\t\t\t\tcase 23:\r\n\t\t\t\t\tnewASN1Type = UTCTime;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region GeneralizedTime type\r\n\t\t\t\tcase 24:\r\n\t\t\t\t\tnewASN1Type = GeneralizedTime;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region GraphicString type\r\n\t\t\t\tcase 25:\r\n\t\t\t\t\tnewASN1Type = GraphicString;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region VisibleString type\r\n\t\t\t\tcase 26:\r\n\t\t\t\t\tnewASN1Type = VisibleString;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region GeneralString type\r\n\t\t\t\tcase 27:\r\n\t\t\t\t\tnewASN1Type = GeneralString;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region UniversalString type\r\n\t\t\t\tcase 28:\r\n\t\t\t\t\tnewASN1Type = UniversalString;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region CharacterString type\r\n\t\t\t\tcase 29:\r\n\t\t\t\t\tnewASN1Type = CharacterString;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region BmpString type\r\n\t\t\t\tcase 30:\r\n\t\t\t\t\tnewASN1Type = BmpString;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region DATE type\r\n\t\t\t\tcase 31:\r\n\t\t\t\t\tnewASN1Type = DATE;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region TimeOfDay type\r\n\t\t\t\tcase 32:\r\n\t\t\t\t\tnewASN1Type = TimeOfDay;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region Date-Time type\r\n\t\t\t\tcase 33:\r\n\t\t\t\t\tnewASN1Type = DateTime;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region Duration type\r\n\t\t\t\tcase 34:\r\n\t\t\t\t\tnewASN1Type = Duration;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//endregion\r\n\t\t\t\t//region default\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet newObject;\r\n\r\n\t\t\t\t\t\tif(returnObject.idBlock.isConstructed === true)\r\n\t\t\t\t\t\t\tnewObject = new Constructed();\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tnewObject = new Primitive();\r\n\r\n\t\t\t\t\t\tnewObject.idBlock = returnObject.idBlock;\r\n\t\t\t\t\t\tnewObject.lenBlock = returnObject.lenBlock;\r\n\t\t\t\t\t\tnewObject.warnings = returnObject.warnings;\r\n\r\n\t\t\t\t\t\treturnObject = newObject;\r\n\r\n\t\t\t\t\t\tresultOffset = returnObject.fromBER(inputBuffer, inputOffset, inputLength);\r\n\t\t\t\t\t}\r\n\t\t\t\t//endregion\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t//endregion\r\n\t\t//region All other tag classes\r\n\t\tcase 2: // APPLICATION\r\n\t\tcase 3: // CONTEXT-SPECIFIC\r\n\t\tcase 4: // PRIVATE\r\n\t\tdefault:\r\n\t\t\t{\r\n\t\t\t\tif(returnObject.idBlock.isConstructed === true)\r\n\t\t\t\t\tnewASN1Type = Constructed;\r\n\t\t\t\telse\r\n\t\t\t\t\tnewASN1Type = Primitive;\r\n\t\t\t}\r\n\t\t//endregion\r\n\t}\r\n\t//endregion\r\n\r\n\t//region Change type and perform BER decoding\r\n\treturnObject = localChangeType(returnObject, newASN1Type);\r\n\tresultOffset = returnObject.fromBER(inputBuffer, inputOffset, (returnObject.lenBlock.isIndefiniteForm === true) ? inputLength : returnObject.lenBlock.length);\r\n\t//endregion\r\n\r\n\t//region Coping incoming buffer for entire ASN.1 block\r\n\treturnObject.valueBeforeDecode = inputBuffer.slice(incomingOffset, incomingOffset + returnObject.blockLength);\r\n\t//endregion\r\n\r\n\treturn {\r\n\t\toffset: resultOffset,\r\n\t\tresult: returnObject\r\n\t};\r\n}\r\n//**************************************************************************************\r\n/**\r\n * Major function for decoding ASN.1 BER array into internal library structuries\r\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array of bytes\r\n */\r\nexport function fromBER(inputBuffer)\r\n{\r\n\tif(inputBuffer.byteLength === 0)\r\n\t{\r\n\t\tconst result = new BaseBlock({}, Object);\r\n\t\tresult.error = \"Input buffer has zero length\";\r\n\r\n\t\treturn {\r\n\t\t\toffset: (-1),\r\n\t\t\tresult\r\n\t\t};\r\n\t}\r\n\r\n\treturn LocalFromBER(inputBuffer, 0, inputBuffer.byteLength);\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Major scheme verification function\r\n//**************************************************************************************\r\n/**\r\n * Compare of two ASN.1 object trees\r\n * @param {!Object} root Root of input ASN.1 object tree\r\n * @param {!Object} inputData Input ASN.1 object tree\r\n * @param {!Object} inputSchema Input ASN.1 schema to compare with\r\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\r\n */\r\nexport function compareSchema(root, inputData, inputSchema)\r\n{\r\n\t//region Special case for Choice schema element type\r\n\tif(inputSchema instanceof Choice)\r\n\t{\r\n\t\tconst choiceResult = false;\r\n\r\n\t\tfor(let j = 0; j < inputSchema.value.length; j++)\r\n\t\t{\r\n\t\t\tconst result = compareSchema(root, inputData, inputSchema.value[j]);\r\n\t\t\tif(result.verified === true)\r\n\t\t\t{\r\n\t\t\t\treturn {\r\n\t\t\t\t\tverified: true,\r\n\t\t\t\t\tresult: root\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(choiceResult === false)\r\n\t\t{\r\n\t\t\tconst _result = {\r\n\t\t\t\tverified: false,\r\n\t\t\t\tresult: {\r\n\t\t\t\t\terror: \"Wrong values for Choice type\"\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\r\n\t\t\t\t_result.name = inputSchema.name;\r\n\r\n\t\t\treturn _result;\r\n\t\t}\r\n\t}\r\n\t//endregion\r\n\r\n\t//region Special case for Any schema element type\r\n\tif(inputSchema instanceof Any)\r\n\t{\r\n\t\t//region Add named component of ASN.1 schema\r\n\t\tif(inputSchema.hasOwnProperty(\"name\"))\r\n\t\t\troot[inputSchema.name] = inputData;\r\n\t\t//endregion\r\n\r\n\t\treturn {\r\n\t\t\tverified: true,\r\n\t\t\tresult: root\r\n\t\t};\r\n\t}\r\n\t//endregion\r\n\r\n\t//region Initial check\r\n\tif((root instanceof Object) === false)\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: { error: \"Wrong root object\" }\r\n\t\t};\r\n\t}\r\n\r\n\tif((inputData instanceof Object) === false)\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: { error: \"Wrong ASN.1 data\" }\r\n\t\t};\r\n\t}\r\n\r\n\tif((inputSchema instanceof Object) === false)\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\r\n\t\t};\r\n\t}\r\n\r\n\tif((\"idBlock\" in inputSchema) === false)\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\r\n\t\t};\r\n\t}\r\n\t//endregion\r\n\r\n\t//region Comparing idBlock properties in ASN.1 data and ASN.1 schema\r\n\t//region Encode and decode ASN.1 schema idBlock\r\n\t/// <remarks>This encoding/decoding is neccessary because could be an errors in schema definition</remarks>\r\n\tif((\"fromBER\" in inputSchema.idBlock) === false)\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\r\n\t\t};\r\n\t}\r\n\r\n\tif((\"toBER\" in inputSchema.idBlock) === false)\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\r\n\t\t};\r\n\t}\r\n\r\n\tconst encodedId = inputSchema.idBlock.toBER(false);\r\n\tif(encodedId.byteLength === 0)\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: { error: \"Error encoding idBlock for ASN.1 schema\" }\r\n\t\t};\r\n\t}\r\n\r\n\tconst decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\r\n\tif(decodedOffset === (-1))\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: { error: \"Error decoding idBlock for ASN.1 schema\" }\r\n\t\t};\r\n\t}\r\n\t//endregion\r\n\r\n\t//region tagClass\r\n\tif(inputSchema.idBlock.hasOwnProperty(\"tagClass\") === false)\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\r\n\t\t};\r\n\t}\r\n\r\n\tif(inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass)\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: root\r\n\t\t};\r\n\t}\r\n\t//endregion\r\n\t//region tagNumber\r\n\tif(inputSchema.idBlock.hasOwnProperty(\"tagNumber\") === false)\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\r\n\t\t};\r\n\t}\r\n\r\n\tif(inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber)\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: root\r\n\t\t};\r\n\t}\r\n\t//endregion\r\n\t//region isConstructed\r\n\tif(inputSchema.idBlock.hasOwnProperty(\"isConstructed\") === false)\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\r\n\t\t};\r\n\t}\r\n\r\n\tif(inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed)\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: root\r\n\t\t};\r\n\t}\r\n\t//endregion\r\n\t//region isHexOnly\r\n\tif((\"isHexOnly\" in inputSchema.idBlock) === false) // Since 'isHexOnly' is an inhirited property\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\r\n\t\t};\r\n\t}\r\n\r\n\tif(inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly)\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: root\r\n\t\t};\r\n\t}\r\n\t//endregion\r\n\t//region valueHex\r\n\tif(inputSchema.idBlock.isHexOnly === true)\r\n\t{\r\n\t\tif((\"valueHex\" in inputSchema.idBlock) === false) // Since 'valueHex' is an inhirited property\r\n\t\t{\r\n\t\t\treturn {\r\n\t\t\t\tverified: false,\r\n\t\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tconst schemaView = new Uint8Array(inputSchema.idBlock.valueHex);\r\n\t\tconst asn1View = new Uint8Array(inputData.idBlock.valueHex);\r\n\r\n\t\tif(schemaView.length !== asn1View.length)\r\n\t\t{\r\n\t\t\treturn {\r\n\t\t\t\tverified: false,\r\n\t\t\t\tresult: root\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tfor(let i = 0; i < schemaView.length; i++)\r\n\t\t{\r\n\t\t\tif(schemaView[i] !== asn1View[1])\r\n\t\t\t{\r\n\t\t\t\treturn {\r\n\t\t\t\t\tverified: false,\r\n\t\t\t\t\tresult: root\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t//endregion\r\n\t//endregion\r\n\r\n\t//region Add named component of ASN.1 schema\r\n\tif(inputSchema.hasOwnProperty(\"name\"))\r\n\t{\r\n\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\r\n\t\tif(inputSchema.name !== \"\")\r\n\t\t\troot[inputSchema.name] = inputData;\r\n\t}\r\n\t//endregion\r\n\r\n\t//region Getting next ASN.1 block for comparition\r\n\tif(inputSchema.idBlock.isConstructed === true)\r\n\t{\r\n\t\tlet admission = 0;\r\n\t\tlet result = { verified: false };\r\n\r\n\t\tlet maxLength = inputSchema.valueBlock.value.length;\r\n\r\n\t\tif(maxLength > 0)\r\n\t\t{\r\n\t\t\tif(inputSchema.valueBlock.value[0] instanceof Repeated)\r\n\t\t\t\tmaxLength = inputData.valueBlock.value.length;\r\n\t\t}\r\n\r\n\t\t//region Special case when constructive value has no elements\r\n\t\tif(maxLength === 0)\r\n\t\t{\r\n\t\t\treturn {\r\n\t\t\t\tverified: true,\r\n\t\t\t\tresult: root\r\n\t\t\t};\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Special case when \"inputData\" has no values and \"inputSchema\" has all optional values\r\n\t\tif((inputData.valueBlock.value.length === 0) &&\r\n\t\t\t(inputSchema.valueBlock.value.length !== 0))\r\n\t\t{\r\n\t\t\tlet _optional = true;\r\n\r\n\t\t\tfor(let i = 0; i < inputSchema.valueBlock.value.length; i++)\r\n\t\t\t\t_optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\r\n\r\n\t\t\tif(_optional === true)\r\n\t\t\t{\r\n\t\t\t\treturn {\r\n\t\t\t\t\tverified: true,\r\n\t\t\t\t\tresult: root\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\t//region Delete early added name of block\r\n\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\r\n\t\t\t{\r\n\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\r\n\t\t\t\tif(inputSchema.name !== \"\")\r\n\t\t\t\t\tdelete root[inputSchema.name];\r\n\t\t\t}\r\n\t\t\t//endregion\r\n\r\n\t\t\troot.error = \"Inconsistent object length\";\r\n\r\n\t\t\treturn {\r\n\t\t\t\tverified: false,\r\n\t\t\t\tresult: root\r\n\t\t\t};\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\tfor(let i = 0; i < maxLength; i++)\r\n\t\t{\r\n\t\t\t//region Special case when there is an \"optional\" element of ASN.1 schema at the end\r\n\t\t\tif((i - admission) >= inputData.valueBlock.value.length)\r\n\t\t\t{\r\n\t\t\t\tif(inputSchema.valueBlock.value[i].optional === false)\r\n\t\t\t\t{\r\n\t\t\t\t\tconst _result = {\r\n\t\t\t\t\t\tverified: false,\r\n\t\t\t\t\t\tresult: root\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\troot.error = \"Inconsistent length between ASN.1 data and schema\";\r\n\r\n\t\t\t\t\t//region Delete early added name of block\r\n\t\t\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\r\n\t\t\t\t\t\tif(inputSchema.name !== \"\")\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tdelete root[inputSchema.name];\r\n\t\t\t\t\t\t\t_result.name = inputSchema.name;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\treturn _result;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//endregion\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t//region Special case for Repeated type of ASN.1 schema element\r\n\t\t\t\tif(inputSchema.valueBlock.value[0] instanceof Repeated)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\r\n\t\t\t\t\tif(result.verified === false)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(inputSchema.valueBlock.value[0].optional === true)\r\n\t\t\t\t\t\t\tadmission++;\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t//region Delete early added name of block\r\n\t\t\t\t\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\r\n\t\t\t\t\t\t\t\tif(inputSchema.name !== \"\")\r\n\t\t\t\t\t\t\t\t\tdelete root[inputSchema.name];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif((\"name\" in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].name.length > 0))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet arrayRoot = {};\r\n\r\n\t\t\t\t\t\tif((\"local\" in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].local === true))\r\n\t\t\t\t\t\t\tarrayRoot = inputData;\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tarrayRoot = root;\r\n\r\n\t\t\t\t\t\tif(typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\")\r\n\t\t\t\t\t\t\tarrayRoot[inputSchema.valueBlock.value[0].name] = [];\r\n\r\n\t\t\t\t\t\tarrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t//endregion\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\r\n\t\t\t\t\tif(result.verified === false)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(inputSchema.valueBlock.value[i].optional === true)\r\n\t\t\t\t\t\t\tadmission++;\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t//region Delete early added name of block\r\n\t\t\t\t\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\r\n\t\t\t\t\t\t\t\tif(inputSchema.name !== \"\")\r\n\t\t\t\t\t\t\t\t\tdelete root[inputSchema.name];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(result.verified === false) // The situation may take place if last element is \"optional\" and verification failed\r\n\t\t{\r\n\t\t\tconst _result = {\r\n\t\t\t\tverified: false,\r\n\t\t\t\tresult: root\r\n\t\t\t};\r\n\r\n\t\t\t//region Delete early added name of block\r\n\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\r\n\t\t\t{\r\n\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\r\n\t\t\t\tif(inputSchema.name !== \"\")\r\n\t\t\t\t{\r\n\t\t\t\t\tdelete root[inputSchema.name];\r\n\t\t\t\t\t_result.name = inputSchema.name;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn _result;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tverified: true,\r\n\t\t\tresult: root\r\n\t\t};\r\n\t}\r\n\t//endregion\r\n\t//region Ability to parse internal value for primitive-encoded value (value of OctetString, for example)\r\n\tif((\"primitiveSchema\" in inputSchema) &&\r\n\t\t(\"valueHex\" in inputData.valueBlock))\r\n\t{\r\n\t\t//region Decoding of raw ASN.1 data\r\n\t\tconst asn1 = fromBER(inputData.valueBlock.valueHex);\r\n\t\tif(asn1.offset === (-1))\r\n\t\t{\r\n\t\t\tconst _result = {\r\n\t\t\t\tverified: false,\r\n\t\t\t\tresult: asn1.result\r\n\t\t\t};\r\n\r\n\t\t\t//region Delete early added name of block\r\n\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\r\n\t\t\t{\r\n\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\r\n\t\t\t\tif(inputSchema.name !== \"\")\r\n\t\t\t\t{\r\n\t\t\t\t\tdelete root[inputSchema.name];\r\n\t\t\t\t\t_result.name = inputSchema.name;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn _result;\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\treturn compareSchema(root, asn1.result, inputSchema.primitiveSchema);\r\n\t}\r\n\r\n\treturn {\r\n\t\tverified: true,\r\n\t\tresult: root\r\n\t};\r\n\t//endregion\r\n}\r\n//**************************************************************************************\r\n//noinspection JSUnusedGlobalSymbols\r\n/**\r\n * ASN.1 schema verification for ArrayBuffer data\r\n * @param {!ArrayBuffer} inputBuffer Input BER-encoded ASN.1 data\r\n * @param {!Object} inputSchema Input ASN.1 schema to verify against to\r\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\r\n */\r\nexport function verifySchema(inputBuffer, inputSchema)\r\n{\r\n\t//region Initial check\r\n\tif((inputSchema instanceof Object) === false)\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: { error: \"Wrong ASN.1 schema type\" }\r\n\t\t};\r\n\t}\r\n\t//endregion\r\n\r\n\t//region Decoding of raw ASN.1 data\r\n\tconst asn1 = fromBER(inputBuffer);\r\n\tif(asn1.offset === (-1))\r\n\t{\r\n\t\treturn {\r\n\t\t\tverified: false,\r\n\t\t\tresult: asn1.result\r\n\t\t};\r\n\t}\r\n\t//endregion\r\n\r\n\t//region Compare ASN.1 struct with input schema\r\n\treturn compareSchema(asn1.result, asn1.result, inputSchema);\r\n\t//endregion\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n//region Major function converting JSON to ASN.1 objects\r\n//**************************************************************************************\r\n//noinspection JSUnusedGlobalSymbols\r\n/**\r\n * Converting from JSON to ASN.1 objects\r\n * @param {string|Object} json JSON string or object to convert to ASN.1 objects\r\n */\r\nexport function fromJSON(json)\r\n{\r\n\t// TODO Implement\r\n}\r\n//**************************************************************************************\r\n//endregion\r\n//**************************************************************************************\r\n"]},"metadata":{},"sourceType":"script"}