{"ast":null,"code":"/**\n * Copyright (c) 2019-2020, Peculiar Ventures, All rights reserved.\n */\nimport { CryptoKey as CryptoKey$1, AlgorithmError, OperationError, AesCbcProvider as AesCbcProvider$1, AesCmacProvider as AesCmacProvider$1, AesCtrProvider as AesCtrProvider$1, AesGcmProvider as AesGcmProvider$1, AesKwProvider as AesKwProvider$1, AesEcbProvider as AesEcbProvider$1, DesProvider, asn1, RsaSsaProvider as RsaSsaProvider$1, RsaPssProvider as RsaPssProvider$1, RsaOaepProvider as RsaOaepProvider$1, BufferSourceConverter, ProviderCrypto, EcdsaProvider as EcdsaProvider$1, EcdhProvider as EcdhProvider$1, Pbkdf2Provider as Pbkdf2Provider$1, HmacProvider as HmacProvider$1, HkdfProvider as HkdfProvider$1, SubtleCrypto as SubtleCrypto$1 } from 'webcrypto-core';\nexport { CryptoKey } from 'webcrypto-core';\nimport crypto__default, { createCipheriv, publicEncrypt, privateDecrypt, constants } from 'crypto';\nimport { __decorate } from 'tslib';\nimport { JsonProp, JsonPropTypes, JsonSerializer, JsonParser } from '@peculiar/json-schema';\nimport { Convert } from 'pvtsutils';\nimport { AsnParser, AsnSerializer } from '@peculiar/asn1-schema';\nconst JsonBase64UrlConverter = {\n  fromJSON: value => Buffer.from(Convert.FromBase64Url(value)),\n  toJSON: value => Convert.ToBase64Url(value)\n};\n\nclass CryptoKey extends CryptoKey$1 {\n  constructor() {\n    super(...arguments);\n    this.data = Buffer.alloc(0);\n    this.algorithm = {\n      name: \"\"\n    };\n    this.extractable = false;\n    this.type = \"secret\";\n    this.usages = [];\n    this.kty = \"oct\";\n    this.alg = \"\";\n  }\n\n}\n\n__decorate([JsonProp({\n  name: \"ext\",\n  type: JsonPropTypes.Boolean,\n  optional: true\n})], CryptoKey.prototype, \"extractable\", void 0);\n\n__decorate([JsonProp({\n  name: \"key_ops\",\n  type: JsonPropTypes.String,\n  repeated: true,\n  optional: true\n})], CryptoKey.prototype, \"usages\", void 0);\n\n__decorate([JsonProp({\n  type: JsonPropTypes.String\n})], CryptoKey.prototype, \"kty\", void 0);\n\n__decorate([JsonProp({\n  type: JsonPropTypes.String\n})], CryptoKey.prototype, \"alg\", void 0);\n\nclass SymmetricKey extends CryptoKey {\n  constructor() {\n    super(...arguments);\n    this.kty = \"oct\";\n    this.type = \"secret\";\n  }\n\n}\n\nclass AsymmetricKey extends CryptoKey {}\n\nclass AesCryptoKey extends SymmetricKey {\n  get alg() {\n    switch (this.algorithm.name.toUpperCase()) {\n      case \"AES-CBC\":\n        return `A${this.algorithm.length}CBC`;\n\n      case \"AES-CTR\":\n        return `A${this.algorithm.length}CTR`;\n\n      case \"AES-GCM\":\n        return `A${this.algorithm.length}GCM`;\n\n      case \"AES-KW\":\n        return `A${this.algorithm.length}KW`;\n\n      case \"AES-CMAC\":\n        return `A${this.algorithm.length}CMAC`;\n\n      case \"AES-ECB\":\n        return `A${this.algorithm.length}ECB`;\n\n      default:\n        throw new AlgorithmError(\"Unsupported algorithm name\");\n    }\n  }\n\n  set alg(value) {}\n\n}\n\n__decorate([JsonProp({\n  name: \"k\",\n  converter: JsonBase64UrlConverter\n})], AesCryptoKey.prototype, \"data\", void 0);\n\nconst keyStorage = new WeakMap();\n\nfunction getCryptoKey(key) {\n  const res = keyStorage.get(key);\n\n  if (!res) {\n    throw new OperationError(\"Cannot get CryptoKey from secure storage\");\n  }\n\n  return res;\n}\n\nfunction setCryptoKey(value) {\n  const key = CryptoKey$1.create(value.algorithm, value.type, value.extractable, value.usages);\n  Object.freeze(key);\n  keyStorage.set(key, value);\n  return key;\n}\n\nclass AesCrypto {\n  static async generateKey(algorithm, extractable, keyUsages) {\n    const key = new AesCryptoKey();\n    key.algorithm = algorithm;\n    key.extractable = extractable;\n    key.usages = keyUsages;\n    key.data = crypto__default.randomBytes(algorithm.length >> 3);\n    return key;\n  }\n\n  static async exportKey(format, key) {\n    if (!(key instanceof AesCryptoKey)) {\n      throw new Error(\"key: Is not AesCryptoKey\");\n    }\n\n    switch (format.toLowerCase()) {\n      case \"jwk\":\n        return JsonSerializer.toJSON(key);\n\n      case \"raw\":\n        return new Uint8Array(key.data).buffer;\n\n      default:\n        throw new OperationError(\"format: Must be 'jwk' or 'raw'\");\n    }\n  }\n\n  static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n    let key;\n\n    switch (format.toLowerCase()) {\n      case \"jwk\":\n        key = JsonParser.fromJSON(keyData, {\n          targetSchema: AesCryptoKey\n        });\n        break;\n\n      case \"raw\":\n        key = new AesCryptoKey();\n        key.data = Buffer.from(keyData);\n        break;\n\n      default:\n        throw new OperationError(\"format: Must be 'jwk' or 'raw'\");\n    }\n\n    key.algorithm = algorithm;\n    key.algorithm.length = key.data.length << 3;\n    key.extractable = extractable;\n    key.usages = keyUsages;\n\n    switch (key.algorithm.length) {\n      case 128:\n      case 192:\n      case 256:\n        break;\n\n      default:\n        throw new OperationError(\"keyData: Is wrong key length\");\n    }\n\n    return key;\n  }\n\n  static async encrypt(algorithm, key, data) {\n    switch (algorithm.name.toUpperCase()) {\n      case \"AES-CBC\":\n        return this.encryptAesCBC(algorithm, key, Buffer.from(data));\n\n      case \"AES-CTR\":\n        return this.encryptAesCTR(algorithm, key, Buffer.from(data));\n\n      case \"AES-GCM\":\n        return this.encryptAesGCM(algorithm, key, Buffer.from(data));\n\n      case \"AES-KW\":\n        return this.encryptAesKW(algorithm, key, Buffer.from(data));\n\n      case \"AES-ECB\":\n        return this.encryptAesECB(algorithm, key, Buffer.from(data));\n\n      default:\n        throw new OperationError(\"algorithm: Is not recognized\");\n    }\n  }\n\n  static async decrypt(algorithm, key, data) {\n    if (!(key instanceof AesCryptoKey)) {\n      throw new Error(\"key: Is not AesCryptoKey\");\n    }\n\n    switch (algorithm.name.toUpperCase()) {\n      case \"AES-CBC\":\n        return this.decryptAesCBC(algorithm, key, Buffer.from(data));\n\n      case \"AES-CTR\":\n        return this.decryptAesCTR(algorithm, key, Buffer.from(data));\n\n      case \"AES-GCM\":\n        return this.decryptAesGCM(algorithm, key, Buffer.from(data));\n\n      case \"AES-KW\":\n        return this.decryptAesKW(algorithm, key, Buffer.from(data));\n\n      case \"AES-ECB\":\n        return this.decryptAesECB(algorithm, key, Buffer.from(data));\n\n      default:\n        throw new OperationError(\"algorithm: Is not recognized\");\n    }\n  }\n\n  static async encryptAesCBC(algorithm, key, data) {\n    const cipher = crypto__default.createCipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\n    let enc = cipher.update(data);\n    enc = Buffer.concat([enc, cipher.final()]);\n    const res = new Uint8Array(enc).buffer;\n    return res;\n  }\n\n  static async decryptAesCBC(algorithm, key, data) {\n    const decipher = crypto__default.createDecipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\n    let dec = decipher.update(data);\n    dec = Buffer.concat([dec, decipher.final()]);\n    return new Uint8Array(dec).buffer;\n  }\n\n  static async encryptAesCTR(algorithm, key, data) {\n    const cipher = crypto__default.createCipheriv(`aes-${key.algorithm.length}-ctr`, key.data, Buffer.from(algorithm.counter));\n    let enc = cipher.update(data);\n    enc = Buffer.concat([enc, cipher.final()]);\n    const res = new Uint8Array(enc).buffer;\n    return res;\n  }\n\n  static async decryptAesCTR(algorithm, key, data) {\n    const decipher = crypto__default.createDecipheriv(`aes-${key.algorithm.length}-ctr`, key.data, new Uint8Array(algorithm.counter));\n    let dec = decipher.update(data);\n    dec = Buffer.concat([dec, decipher.final()]);\n    return new Uint8Array(dec).buffer;\n  }\n\n  static async encryptAesGCM(algorithm, key, data) {\n    const cipher = crypto__default.createCipheriv(`aes-${key.algorithm.length}-gcm`, key.data, Buffer.from(algorithm.iv), {\n      authTagLength: (algorithm.tagLength || 128) >> 3\n    });\n\n    if (algorithm.additionalData) {\n      cipher.setAAD(Buffer.from(algorithm.additionalData));\n    }\n\n    let enc = cipher.update(data);\n    enc = Buffer.concat([enc, cipher.final(), cipher.getAuthTag()]);\n    const res = new Uint8Array(enc).buffer;\n    return res;\n  }\n\n  static async decryptAesGCM(algorithm, key, data) {\n    const decipher = crypto__default.createDecipheriv(`aes-${key.algorithm.length}-gcm`, key.data, new Uint8Array(algorithm.iv));\n    const tagLength = (algorithm.tagLength || 128) >> 3;\n    const enc = data.slice(0, data.length - tagLength);\n    const tag = data.slice(data.length - tagLength);\n\n    if (algorithm.additionalData) {\n      decipher.setAAD(Buffer.from(algorithm.additionalData));\n    }\n\n    decipher.setAuthTag(tag);\n    let dec = decipher.update(enc);\n    dec = Buffer.concat([dec, decipher.final()]);\n    return new Uint8Array(dec).buffer;\n  }\n\n  static async encryptAesKW(algorithm, key, data) {\n    const cipher = crypto__default.createCipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\n    let enc = cipher.update(data);\n    enc = Buffer.concat([enc, cipher.final()]);\n    return new Uint8Array(enc).buffer;\n  }\n\n  static async decryptAesKW(algorithm, key, data) {\n    const decipher = crypto__default.createDecipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\n    let dec = decipher.update(data);\n    dec = Buffer.concat([dec, decipher.final()]);\n    return new Uint8Array(dec).buffer;\n  }\n\n  static async encryptAesECB(algorithm, key, data) {\n    const cipher = crypto__default.createCipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\n    let enc = cipher.update(data);\n    enc = Buffer.concat([enc, cipher.final()]);\n    const res = new Uint8Array(enc).buffer;\n    return res;\n  }\n\n  static async decryptAesECB(algorithm, key, data) {\n    const decipher = crypto__default.createDecipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\n    let dec = decipher.update(data);\n    dec = Buffer.concat([dec, decipher.final()]);\n    return new Uint8Array(dec).buffer;\n  }\n\n}\n\nAesCrypto.AES_KW_IV = Buffer.from(\"A6A6A6A6A6A6A6A6\", \"hex\");\n\nclass AesCbcProvider extends AesCbcProvider$1 {\n  async onGenerateKey(algorithm, extractable, keyUsages) {\n    const key = await AesCrypto.generateKey({\n      name: this.name,\n      length: algorithm.length\n    }, extractable, keyUsages);\n    return setCryptoKey(key);\n  }\n\n  async onEncrypt(algorithm, key, data) {\n    return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n  }\n\n  async onDecrypt(algorithm, key, data) {\n    return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n  }\n\n  async onExportKey(format, key) {\n    return AesCrypto.exportKey(format, getCryptoKey(key));\n  }\n\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n    const key = await AesCrypto.importKey(format, keyData, {\n      name: algorithm.name\n    }, extractable, keyUsages);\n    return setCryptoKey(key);\n  }\n\n  checkCryptoKey(key, keyUsage) {\n    super.checkCryptoKey(key, keyUsage);\n\n    if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n      throw new TypeError(\"key: Is not a AesCryptoKey\");\n    }\n  }\n\n}\n\nconst zero = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\nconst rb = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135]);\nconst blockSize = 16;\n\nfunction bitShiftLeft(buffer) {\n  const shifted = Buffer.alloc(buffer.length);\n  const last = buffer.length - 1;\n\n  for (let index = 0; index < last; index++) {\n    shifted[index] = buffer[index] << 1;\n\n    if (buffer[index + 1] & 0x80) {\n      shifted[index] += 0x01;\n    }\n  }\n\n  shifted[last] = buffer[last] << 1;\n  return shifted;\n}\n\nfunction xor(a, b) {\n  const length = Math.min(a.length, b.length);\n  const output = Buffer.alloc(length);\n\n  for (let index = 0; index < length; index++) {\n    output[index] = a[index] ^ b[index];\n  }\n\n  return output;\n}\n\nfunction aes(key, message) {\n  const cipher = createCipheriv(`aes${key.length << 3}`, key, zero);\n  const result = cipher.update(message);\n  cipher.final();\n  return result;\n}\n\nfunction getMessageBlock(message, blockIndex) {\n  const block = Buffer.alloc(blockSize);\n  const start = blockIndex * blockSize;\n  const end = start + blockSize;\n  message.copy(block, 0, start, end);\n  return block;\n}\n\nfunction getPaddedMessageBlock(message, blockIndex) {\n  const block = Buffer.alloc(blockSize);\n  const start = blockIndex * blockSize;\n  const end = message.length;\n  block.fill(0);\n  message.copy(block, 0, start, end);\n  block[end - start] = 0x80;\n  return block;\n}\n\nfunction generateSubkeys(key) {\n  const l = aes(key, zero);\n  let subkey1 = bitShiftLeft(l);\n\n  if (l[0] & 0x80) {\n    subkey1 = xor(subkey1, rb);\n  }\n\n  let subkey2 = bitShiftLeft(subkey1);\n\n  if (subkey1[0] & 0x80) {\n    subkey2 = xor(subkey2, rb);\n  }\n\n  return {\n    subkey1,\n    subkey2\n  };\n}\n\nfunction aesCmac(key, message) {\n  const subkeys = generateSubkeys(key);\n  let blockCount = Math.ceil(message.length / blockSize);\n  let lastBlockCompleteFlag;\n  let lastBlock;\n\n  if (blockCount === 0) {\n    blockCount = 1;\n    lastBlockCompleteFlag = false;\n  } else {\n    lastBlockCompleteFlag = message.length % blockSize === 0;\n  }\n\n  const lastBlockIndex = blockCount - 1;\n\n  if (lastBlockCompleteFlag) {\n    lastBlock = xor(getMessageBlock(message, lastBlockIndex), subkeys.subkey1);\n  } else {\n    lastBlock = xor(getPaddedMessageBlock(message, lastBlockIndex), subkeys.subkey2);\n  }\n\n  let x = zero;\n  let y;\n\n  for (let index = 0; index < lastBlockIndex; index++) {\n    y = xor(x, getMessageBlock(message, index));\n    x = aes(key, y);\n  }\n\n  y = xor(lastBlock, x);\n  return aes(key, y);\n}\n\nclass AesCmacProvider extends AesCmacProvider$1 {\n  async onGenerateKey(algorithm, extractable, keyUsages) {\n    const key = await AesCrypto.generateKey({\n      name: this.name,\n      length: algorithm.length\n    }, extractable, keyUsages);\n    return setCryptoKey(key);\n  }\n\n  async onSign(algorithm, key, data) {\n    const result = aesCmac(getCryptoKey(key).data, Buffer.from(data));\n    return new Uint8Array(result).buffer;\n  }\n\n  async onVerify(algorithm, key, signature, data) {\n    const signature2 = await this.sign(algorithm, key, data);\n    return Buffer.from(signature).compare(Buffer.from(signature2)) === 0;\n  }\n\n  async onExportKey(format, key) {\n    return AesCrypto.exportKey(format, getCryptoKey(key));\n  }\n\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n    const res = await AesCrypto.importKey(format, keyData, {\n      name: algorithm.name\n    }, extractable, keyUsages);\n    return setCryptoKey(res);\n  }\n\n  checkCryptoKey(key, keyUsage) {\n    super.checkCryptoKey(key, keyUsage);\n\n    if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n      throw new TypeError(\"key: Is not a AesCryptoKey\");\n    }\n  }\n\n}\n\nclass AesCtrProvider extends AesCtrProvider$1 {\n  async onGenerateKey(algorithm, extractable, keyUsages) {\n    const key = await AesCrypto.generateKey({\n      name: this.name,\n      length: algorithm.length\n    }, extractable, keyUsages);\n    return setCryptoKey(key);\n  }\n\n  async onEncrypt(algorithm, key, data) {\n    return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n  }\n\n  async onDecrypt(algorithm, key, data) {\n    return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n  }\n\n  async onExportKey(format, key) {\n    return AesCrypto.exportKey(format, getCryptoKey(key));\n  }\n\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n    const res = await AesCrypto.importKey(format, keyData, {\n      name: algorithm.name\n    }, extractable, keyUsages);\n    return setCryptoKey(res);\n  }\n\n  checkCryptoKey(key, keyUsage) {\n    super.checkCryptoKey(key, keyUsage);\n\n    if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n      throw new TypeError(\"key: Is not a AesCryptoKey\");\n    }\n  }\n\n}\n\nclass AesGcmProvider extends AesGcmProvider$1 {\n  async onGenerateKey(algorithm, extractable, keyUsages) {\n    const key = await AesCrypto.generateKey({\n      name: this.name,\n      length: algorithm.length\n    }, extractable, keyUsages);\n    return setCryptoKey(key);\n  }\n\n  async onEncrypt(algorithm, key, data) {\n    return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n  }\n\n  async onDecrypt(algorithm, key, data) {\n    return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n  }\n\n  async onExportKey(format, key) {\n    return AesCrypto.exportKey(format, getCryptoKey(key));\n  }\n\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n    const res = await AesCrypto.importKey(format, keyData, {\n      name: algorithm.name\n    }, extractable, keyUsages);\n    return setCryptoKey(res);\n  }\n\n  checkCryptoKey(key, keyUsage) {\n    super.checkCryptoKey(key, keyUsage);\n\n    if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n      throw new TypeError(\"key: Is not a AesCryptoKey\");\n    }\n  }\n\n}\n\nclass AesKwProvider extends AesKwProvider$1 {\n  async onGenerateKey(algorithm, extractable, keyUsages) {\n    const res = await AesCrypto.generateKey({\n      name: this.name,\n      length: algorithm.length\n    }, extractable, keyUsages);\n    return setCryptoKey(res);\n  }\n\n  async onExportKey(format, key) {\n    return AesCrypto.exportKey(format, getCryptoKey(key));\n  }\n\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n    const res = await AesCrypto.importKey(format, keyData, {\n      name: algorithm.name\n    }, extractable, keyUsages);\n    return setCryptoKey(res);\n  }\n\n  async onEncrypt(algorithm, key, data) {\n    return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n  }\n\n  async onDecrypt(algorithm, key, data) {\n    return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n  }\n\n  checkCryptoKey(key, keyUsage) {\n    super.checkCryptoKey(key, keyUsage);\n\n    if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n      throw new TypeError(\"key: Is not a AesCryptoKey\");\n    }\n  }\n\n}\n\nclass AesEcbProvider extends AesEcbProvider$1 {\n  async onGenerateKey(algorithm, extractable, keyUsages) {\n    const key = await AesCrypto.generateKey({\n      name: this.name,\n      length: algorithm.length\n    }, extractable, keyUsages);\n    return setCryptoKey(key);\n  }\n\n  async onEncrypt(algorithm, key, data) {\n    return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n  }\n\n  async onDecrypt(algorithm, key, data) {\n    return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n  }\n\n  async onExportKey(format, key) {\n    return AesCrypto.exportKey(format, getCryptoKey(key));\n  }\n\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n    const res = await AesCrypto.importKey(format, keyData, {\n      name: algorithm.name\n    }, extractable, keyUsages);\n    return setCryptoKey(res);\n  }\n\n  checkCryptoKey(key, keyUsage) {\n    super.checkCryptoKey(key, keyUsage);\n\n    if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n      throw new TypeError(\"key: Is not a AesCryptoKey\");\n    }\n  }\n\n}\n\nclass DesCryptoKey extends SymmetricKey {\n  get alg() {\n    switch (this.algorithm.name.toUpperCase()) {\n      case \"DES-CBC\":\n        return `DES-CBC`;\n\n      case \"DES-EDE3-CBC\":\n        return `3DES-CBC`;\n\n      default:\n        throw new AlgorithmError(\"Unsupported algorithm name\");\n    }\n  }\n\n  set alg(value) {}\n\n}\n\n__decorate([JsonProp({\n  name: \"k\",\n  converter: JsonBase64UrlConverter\n})], DesCryptoKey.prototype, \"data\", void 0);\n\nclass DesCrypto {\n  static async generateKey(algorithm, extractable, keyUsages) {\n    const key = new DesCryptoKey();\n    key.algorithm = algorithm;\n    key.extractable = extractable;\n    key.usages = keyUsages;\n    key.data = crypto__default.randomBytes(algorithm.length >> 3);\n    return key;\n  }\n\n  static async exportKey(format, key) {\n    switch (format.toLowerCase()) {\n      case \"jwk\":\n        return JsonSerializer.toJSON(key);\n\n      case \"raw\":\n        return new Uint8Array(key.data).buffer;\n\n      default:\n        throw new OperationError(\"format: Must be 'jwk' or 'raw'\");\n    }\n  }\n\n  static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n    let key;\n\n    switch (format.toLowerCase()) {\n      case \"jwk\":\n        key = JsonParser.fromJSON(keyData, {\n          targetSchema: DesCryptoKey\n        });\n        break;\n\n      case \"raw\":\n        key = new DesCryptoKey();\n        key.data = Buffer.from(keyData);\n        break;\n\n      default:\n        throw new OperationError(\"format: Must be 'jwk' or 'raw'\");\n    }\n\n    key.algorithm = algorithm;\n    key.extractable = extractable;\n    key.usages = keyUsages;\n    return key;\n  }\n\n  static async encrypt(algorithm, key, data) {\n    switch (algorithm.name.toUpperCase()) {\n      case \"DES-CBC\":\n        return this.encryptDesCBC(algorithm, key, Buffer.from(data));\n\n      case \"DES-EDE3-CBC\":\n        return this.encryptDesEDE3CBC(algorithm, key, Buffer.from(data));\n\n      default:\n        throw new OperationError(\"algorithm: Is not recognized\");\n    }\n  }\n\n  static async decrypt(algorithm, key, data) {\n    if (!(key instanceof DesCryptoKey)) {\n      throw new Error(\"key: Is not DesCryptoKey\");\n    }\n\n    switch (algorithm.name.toUpperCase()) {\n      case \"DES-CBC\":\n        return this.decryptDesCBC(algorithm, key, Buffer.from(data));\n\n      case \"DES-EDE3-CBC\":\n        return this.decryptDesEDE3CBC(algorithm, key, Buffer.from(data));\n\n      default:\n        throw new OperationError(\"algorithm: Is not recognized\");\n    }\n  }\n\n  static async encryptDesCBC(algorithm, key, data) {\n    const cipher = crypto__default.createCipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\n    let enc = cipher.update(data);\n    enc = Buffer.concat([enc, cipher.final()]);\n    const res = new Uint8Array(enc).buffer;\n    return res;\n  }\n\n  static async decryptDesCBC(algorithm, key, data) {\n    const decipher = crypto__default.createDecipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\n    let dec = decipher.update(data);\n    dec = Buffer.concat([dec, decipher.final()]);\n    return new Uint8Array(dec).buffer;\n  }\n\n  static async encryptDesEDE3CBC(algorithm, key, data) {\n    const cipher = crypto__default.createCipheriv(`des-ede3-cbc`, key.data, Buffer.from(algorithm.iv));\n    let enc = cipher.update(data);\n    enc = Buffer.concat([enc, cipher.final()]);\n    const res = new Uint8Array(enc).buffer;\n    return res;\n  }\n\n  static async decryptDesEDE3CBC(algorithm, key, data) {\n    const decipher = crypto__default.createDecipheriv(`des-ede3-cbc`, key.data, new Uint8Array(algorithm.iv));\n    let dec = decipher.update(data);\n    dec = Buffer.concat([dec, decipher.final()]);\n    return new Uint8Array(dec).buffer;\n  }\n\n}\n\nclass DesCbcProvider extends DesProvider {\n  constructor() {\n    super(...arguments);\n    this.keySizeBits = 64;\n    this.ivSize = 8;\n    this.name = \"DES-CBC\";\n  }\n\n  async onGenerateKey(algorithm, extractable, keyUsages) {\n    const key = await DesCrypto.generateKey({\n      name: this.name,\n      length: this.keySizeBits\n    }, extractable, keyUsages);\n    return setCryptoKey(key);\n  }\n\n  async onEncrypt(algorithm, key, data) {\n    return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n  }\n\n  async onDecrypt(algorithm, key, data) {\n    return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n  }\n\n  async onExportKey(format, key) {\n    return DesCrypto.exportKey(format, getCryptoKey(key));\n  }\n\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n    const key = await DesCrypto.importKey(format, keyData, {\n      name: this.name,\n      length: this.keySizeBits\n    }, extractable, keyUsages);\n\n    if (key.data.length !== this.keySizeBits >> 3) {\n      throw new OperationError(\"keyData: Wrong key size\");\n    }\n\n    return setCryptoKey(key);\n  }\n\n  checkCryptoKey(key, keyUsage) {\n    super.checkCryptoKey(key, keyUsage);\n\n    if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\n      throw new TypeError(\"key: Is not a DesCryptoKey\");\n    }\n  }\n\n}\n\nclass DesEde3CbcProvider extends DesProvider {\n  constructor() {\n    super(...arguments);\n    this.keySizeBits = 192;\n    this.ivSize = 8;\n    this.name = \"DES-EDE3-CBC\";\n  }\n\n  async onGenerateKey(algorithm, extractable, keyUsages) {\n    const key = await DesCrypto.generateKey({\n      name: this.name,\n      length: this.keySizeBits\n    }, extractable, keyUsages);\n    return setCryptoKey(key);\n  }\n\n  async onEncrypt(algorithm, key, data) {\n    return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n  }\n\n  async onDecrypt(algorithm, key, data) {\n    return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n  }\n\n  async onExportKey(format, key) {\n    return DesCrypto.exportKey(format, getCryptoKey(key));\n  }\n\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n    const key = await DesCrypto.importKey(format, keyData, {\n      name: this.name,\n      length: this.keySizeBits\n    }, extractable, keyUsages);\n\n    if (key.data.length !== this.keySizeBits >> 3) {\n      throw new OperationError(\"keyData: Wrong key size\");\n    }\n\n    return setCryptoKey(key);\n  }\n\n  checkCryptoKey(key, keyUsage) {\n    super.checkCryptoKey(key, keyUsage);\n\n    if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\n      throw new TypeError(\"key: Is not a DesCryptoKey\");\n    }\n  }\n\n}\n\nfunction getJwkAlgorithm(algorithm) {\n  switch (algorithm.name.toUpperCase()) {\n    case \"RSA-OAEP\":\n      {\n        const mdSize = /(\\d+)$/.exec(algorithm.hash.name)[1];\n        return `RSA-OAEP${mdSize !== \"1\" ? `-${mdSize}` : \"\"}`;\n      }\n\n    case \"RSASSA-PKCS1-V1_5\":\n      return `RS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\n\n    case \"RSA-PSS\":\n      return `PS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\n\n    case \"RSA-PKCS1\":\n      return `RS1`;\n\n    default:\n      throw new OperationError(\"algorithm: Is not recognized\");\n  }\n}\n\nclass RsaPrivateKey extends AsymmetricKey {\n  constructor() {\n    super(...arguments);\n    this.type = \"private\";\n  }\n\n  getKey() {\n    const keyInfo = AsnParser.parse(this.data, asn1.PrivateKeyInfo);\n    return AsnParser.parse(keyInfo.privateKey, asn1.RsaPrivateKey);\n  }\n\n  toJSON() {\n    const key = this.getKey();\n    const json = {\n      kty: \"RSA\",\n      alg: getJwkAlgorithm(this.algorithm),\n      key_ops: this.usages,\n      ext: this.extractable\n    };\n    return Object.assign(json, JsonSerializer.toJSON(key));\n  }\n\n  fromJSON(json) {\n    const key = JsonParser.fromJSON(json, {\n      targetSchema: asn1.RsaPrivateKey\n    });\n    const keyInfo = new asn1.PrivateKeyInfo();\n    keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n    keyInfo.privateKeyAlgorithm.parameters = null;\n    keyInfo.privateKey = AsnSerializer.serialize(key);\n    this.data = Buffer.from(AsnSerializer.serialize(keyInfo));\n  }\n\n}\n\nclass RsaPublicKey extends AsymmetricKey {\n  constructor() {\n    super(...arguments);\n    this.type = \"public\";\n  }\n\n  getKey() {\n    const keyInfo = AsnParser.parse(this.data, asn1.PublicKeyInfo);\n    return AsnParser.parse(keyInfo.publicKey, asn1.RsaPublicKey);\n  }\n\n  toJSON() {\n    const key = this.getKey();\n    const json = {\n      kty: \"RSA\",\n      alg: getJwkAlgorithm(this.algorithm),\n      key_ops: this.usages,\n      ext: this.extractable\n    };\n    return Object.assign(json, JsonSerializer.toJSON(key));\n  }\n\n  fromJSON(json) {\n    const key = JsonParser.fromJSON(json, {\n      targetSchema: asn1.RsaPublicKey\n    });\n    const keyInfo = new asn1.PublicKeyInfo();\n    keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n    keyInfo.publicKeyAlgorithm.parameters = null;\n    keyInfo.publicKey = AsnSerializer.serialize(key);\n    this.data = Buffer.from(AsnSerializer.serialize(keyInfo));\n  }\n\n}\n\nclass RsaCrypto {\n  static async generateKey(algorithm, extractable, keyUsages) {\n    const privateKey = new RsaPrivateKey();\n    privateKey.algorithm = algorithm;\n    privateKey.extractable = extractable;\n    privateKey.usages = keyUsages.filter(usage => this.privateKeyUsages.indexOf(usage) !== -1);\n    const publicKey = new RsaPublicKey();\n    publicKey.algorithm = algorithm;\n    publicKey.extractable = true;\n    publicKey.usages = keyUsages.filter(usage => this.publicKeyUsages.indexOf(usage) !== -1);\n    const publicExponent = Buffer.concat([Buffer.alloc(4 - algorithm.publicExponent.byteLength, 0), Buffer.from(algorithm.publicExponent)]).readInt32BE(0);\n    const keys = crypto__default.generateKeyPairSync(\"rsa\", {\n      modulusLength: algorithm.modulusLength,\n      publicExponent,\n      publicKeyEncoding: {\n        format: \"der\",\n        type: \"spki\"\n      },\n      privateKeyEncoding: {\n        format: \"der\",\n        type: \"pkcs8\"\n      }\n    });\n    privateKey.data = keys.privateKey;\n    publicKey.data = keys.publicKey;\n    const res = {\n      privateKey,\n      publicKey\n    };\n    return res;\n  }\n\n  static async exportKey(format, key) {\n    switch (format.toLowerCase()) {\n      case \"jwk\":\n        return JsonSerializer.toJSON(key);\n\n      case \"pkcs8\":\n      case \"spki\":\n        return new Uint8Array(key.data).buffer;\n\n      default:\n        throw new OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\n    }\n  }\n\n  static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n    switch (format.toLowerCase()) {\n      case \"jwk\":\n        {\n          const jwk = keyData;\n\n          if (jwk.d) {\n            const asnKey = JsonParser.fromJSON(keyData, {\n              targetSchema: asn1.RsaPrivateKey\n            });\n            return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n          } else {\n            const asnKey = JsonParser.fromJSON(keyData, {\n              targetSchema: asn1.RsaPublicKey\n            });\n            return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n          }\n        }\n\n      case \"spki\":\n        {\n          const keyInfo = AsnParser.parse(new Uint8Array(keyData), asn1.PublicKeyInfo);\n          const asnKey = AsnParser.parse(keyInfo.publicKey, asn1.RsaPublicKey);\n          return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n        }\n\n      case \"pkcs8\":\n        {\n          const keyInfo = AsnParser.parse(new Uint8Array(keyData), asn1.PrivateKeyInfo);\n          const asnKey = AsnParser.parse(keyInfo.privateKey, asn1.RsaPrivateKey);\n          return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n        }\n\n      default:\n        throw new OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\n    }\n  }\n\n  static async sign(algorithm, key, data) {\n    switch (algorithm.name.toUpperCase()) {\n      case \"RSA-PSS\":\n      case \"RSASSA-PKCS1-V1_5\":\n        return this.signRsa(algorithm, key, data);\n\n      default:\n        throw new OperationError(\"algorithm: Is not recognized\");\n    }\n  }\n\n  static async verify(algorithm, key, signature, data) {\n    switch (algorithm.name.toUpperCase()) {\n      case \"RSA-PSS\":\n      case \"RSASSA-PKCS1-V1_5\":\n        return this.verifySSA(algorithm, key, data, signature);\n\n      default:\n        throw new OperationError(\"algorithm: Is not recognized\");\n    }\n  }\n\n  static async encrypt(algorithm, key, data) {\n    switch (algorithm.name.toUpperCase()) {\n      case \"RSA-OAEP\":\n        return this.encryptOAEP(algorithm, key, data);\n\n      default:\n        throw new OperationError(\"algorithm: Is not recognized\");\n    }\n  }\n\n  static async decrypt(algorithm, key, data) {\n    switch (algorithm.name.toUpperCase()) {\n      case \"RSA-OAEP\":\n        return this.decryptOAEP(algorithm, key, data);\n\n      default:\n        throw new OperationError(\"algorithm: Is not recognized\");\n    }\n  }\n\n  static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\n    const keyInfo = new asn1.PrivateKeyInfo();\n    keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n    keyInfo.privateKeyAlgorithm.parameters = null;\n    keyInfo.privateKey = AsnSerializer.serialize(asnKey);\n    const key = new RsaPrivateKey();\n    key.data = Buffer.from(AsnSerializer.serialize(keyInfo));\n    key.algorithm = Object.assign({}, algorithm);\n    key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\n    key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\n    key.extractable = extractable;\n    key.usages = keyUsages;\n    return key;\n  }\n\n  static importPublicKey(asnKey, algorithm, extractable, keyUsages) {\n    const keyInfo = new asn1.PublicKeyInfo();\n    keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n    keyInfo.publicKeyAlgorithm.parameters = null;\n    keyInfo.publicKey = AsnSerializer.serialize(asnKey);\n    const key = new RsaPublicKey();\n    key.data = Buffer.from(AsnSerializer.serialize(keyInfo));\n    key.algorithm = Object.assign({}, algorithm);\n    key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\n    key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\n    key.extractable = extractable;\n    key.usages = keyUsages;\n    return key;\n  }\n\n  static getCryptoAlgorithm(alg) {\n    switch (alg.hash.name.toUpperCase()) {\n      case \"SHA-1\":\n        return \"RSA-SHA1\";\n\n      case \"SHA-256\":\n        return \"RSA-SHA256\";\n\n      case \"SHA-384\":\n        return \"RSA-SHA384\";\n\n      case \"SHA-512\":\n        return \"RSA-SHA512\";\n\n      default:\n        throw new OperationError(\"algorithm.hash: Is not recognized\");\n    }\n  }\n\n  static signRsa(algorithm, key, data) {\n    const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\n    const signer = crypto__default.createSign(cryptoAlg);\n    signer.update(Buffer.from(data));\n\n    if (!key.pem) {\n      key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n    }\n\n    const options = {\n      key: key.pem\n    };\n\n    if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\n      options.padding = crypto__default.constants.RSA_PKCS1_PSS_PADDING;\n      options.saltLength = algorithm.saltLength;\n    }\n\n    const signature = signer.sign(options);\n    return new Uint8Array(signature).buffer;\n  }\n\n  static verifySSA(algorithm, key, data, signature) {\n    const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\n    const signer = crypto__default.createVerify(cryptoAlg);\n    signer.update(Buffer.from(data));\n\n    if (!key.pem) {\n      key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n    }\n\n    const options = {\n      key: key.pem\n    };\n\n    if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\n      options.padding = crypto__default.constants.RSA_PKCS1_PSS_PADDING;\n      options.saltLength = algorithm.saltLength;\n    }\n\n    const ok = signer.verify(options, signature);\n    return ok;\n  }\n\n  static encryptOAEP(algorithm, key, data) {\n    const options = {\n      key: `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`,\n      padding: crypto__default.constants.RSA_PKCS1_OAEP_PADDING\n    };\n    if (algorithm.label) ;\n    return new Uint8Array(crypto__default.publicEncrypt(options, data)).buffer;\n  }\n\n  static decryptOAEP(algorithm, key, data) {\n    const options = {\n      key: `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`,\n      padding: crypto__default.constants.RSA_PKCS1_OAEP_PADDING\n    };\n    if (algorithm.label) ;\n    return new Uint8Array(crypto__default.privateDecrypt(options, data)).buffer;\n  }\n\n}\n\nRsaCrypto.publicKeyUsages = [\"verify\", \"encrypt\", \"wrapKey\"];\nRsaCrypto.privateKeyUsages = [\"sign\", \"decrypt\", \"unwrapKey\"];\n\nclass RsaSsaProvider extends RsaSsaProvider$1 {\n  async onGenerateKey(algorithm, extractable, keyUsages) {\n    const keys = await RsaCrypto.generateKey({ ...algorithm,\n      name: this.name\n    }, extractable, keyUsages);\n    return {\n      privateKey: setCryptoKey(keys.privateKey),\n      publicKey: setCryptoKey(keys.publicKey)\n    };\n  }\n\n  async onSign(algorithm, key, data) {\n    return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n  }\n\n  async onVerify(algorithm, key, signature, data) {\n    return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n  }\n\n  async onExportKey(format, key) {\n    return RsaCrypto.exportKey(format, getCryptoKey(key));\n  }\n\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n    const key = await RsaCrypto.importKey(format, keyData, { ...algorithm,\n      name: this.name\n    }, extractable, keyUsages);\n    return setCryptoKey(key);\n  }\n\n  checkCryptoKey(key, keyUsage) {\n    super.checkCryptoKey(key, keyUsage);\n    const internalKey = getCryptoKey(key);\n\n    if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n      throw new TypeError(\"key: Is not RSA CryptoKey\");\n    }\n  }\n\n}\n\nclass RsaPssProvider extends RsaPssProvider$1 {\n  async onGenerateKey(algorithm, extractable, keyUsages) {\n    const keys = await RsaCrypto.generateKey({ ...algorithm,\n      name: this.name\n    }, extractable, keyUsages);\n    return {\n      privateKey: setCryptoKey(keys.privateKey),\n      publicKey: setCryptoKey(keys.publicKey)\n    };\n  }\n\n  async onSign(algorithm, key, data) {\n    return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n  }\n\n  async onVerify(algorithm, key, signature, data) {\n    return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n  }\n\n  async onExportKey(format, key) {\n    return RsaCrypto.exportKey(format, getCryptoKey(key));\n  }\n\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n    const key = await RsaCrypto.importKey(format, keyData, { ...algorithm,\n      name: this.name\n    }, extractable, keyUsages);\n    return setCryptoKey(key);\n  }\n\n  checkCryptoKey(key, keyUsage) {\n    super.checkCryptoKey(key, keyUsage);\n    const internalKey = getCryptoKey(key);\n\n    if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n      throw new TypeError(\"key: Is not RSA CryptoKey\");\n    }\n  }\n\n}\n\nclass ShaCrypto {\n  static size(algorithm) {\n    switch (algorithm.name.toUpperCase()) {\n      case \"SHA-1\":\n        return 160;\n\n      case \"SHA-256\":\n        return 256;\n\n      case \"SHA-384\":\n        return 384;\n\n      case \"SHA-512\":\n        return 512;\n\n      default:\n        throw new Error(\"Unrecognized name\");\n    }\n  }\n\n  static digest(algorithm, data) {\n    const hash = crypto__default.createHash(algorithm.name.replace(\"-\", \"\")).update(Buffer.from(data)).digest();\n    return new Uint8Array(hash).buffer;\n  }\n\n}\n\nclass RsaOaepProvider extends RsaOaepProvider$1 {\n  async onGenerateKey(algorithm, extractable, keyUsages) {\n    const keys = await RsaCrypto.generateKey({ ...algorithm,\n      name: this.name\n    }, extractable, keyUsages);\n    return {\n      privateKey: setCryptoKey(keys.privateKey),\n      publicKey: setCryptoKey(keys.publicKey)\n    };\n  }\n\n  async onEncrypt(algorithm, key, data) {\n    const internalKey = getCryptoKey(key);\n    const dataView = new Uint8Array(data);\n    const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\n    const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\n    const dataLength = dataView.byteLength;\n    const psLength = keySize - dataLength - 2 * hashSize - 2;\n\n    if (dataLength > keySize - 2 * hashSize - 2) {\n      throw new Error(\"Data too large\");\n    }\n\n    const message = new Uint8Array(keySize);\n    const seed = message.subarray(1, hashSize + 1);\n    const dataBlock = message.subarray(hashSize + 1);\n    dataBlock.set(dataView, hashSize + psLength + 1);\n    const labelHash = crypto__default.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\")).update(BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0))).digest();\n    dataBlock.set(labelHash, 0);\n    dataBlock[hashSize + psLength] = 1;\n    crypto__default.randomFillSync(seed);\n    const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\n\n    for (let i = 0; i < dataBlock.length; i++) {\n      dataBlock[i] ^= dataBlockMask[i];\n    }\n\n    const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\n\n    for (let i = 0; i < seed.length; i++) {\n      seed[i] ^= seedMask[i];\n    }\n\n    if (!internalKey.pem) {\n      internalKey.pem = `-----BEGIN PUBLIC KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n    }\n\n    const pkcs0 = crypto__default.publicEncrypt({\n      key: internalKey.pem,\n      padding: crypto__default.constants.RSA_NO_PADDING\n    }, Buffer.from(message));\n    return new Uint8Array(pkcs0).buffer;\n  }\n\n  async onDecrypt(algorithm, key, data) {\n    const internalKey = getCryptoKey(key);\n    const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\n    const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\n    const dataLength = data.byteLength;\n\n    if (dataLength !== keySize) {\n      throw new Error(\"Bad data\");\n    }\n\n    if (!internalKey.pem) {\n      internalKey.pem = `-----BEGIN PRIVATE KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n    }\n\n    let pkcs0 = crypto__default.privateDecrypt({\n      key: internalKey.pem,\n      padding: crypto__default.constants.RSA_NO_PADDING\n    }, Buffer.from(data));\n    const z = pkcs0[0];\n    const seed = pkcs0.subarray(1, hashSize + 1);\n    const dataBlock = pkcs0.subarray(hashSize + 1);\n\n    if (z !== 0) {\n      throw new Error(\"Decryption failed\");\n    }\n\n    const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\n\n    for (let i = 0; i < seed.length; i++) {\n      seed[i] ^= seedMask[i];\n    }\n\n    const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\n\n    for (let i = 0; i < dataBlock.length; i++) {\n      dataBlock[i] ^= dataBlockMask[i];\n    }\n\n    const labelHash = crypto__default.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\")).update(BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0))).digest();\n\n    for (let i = 0; i < hashSize; i++) {\n      if (labelHash[i] !== dataBlock[i]) {\n        throw new Error(\"Decryption failed\");\n      }\n    }\n\n    let psEnd = hashSize;\n\n    for (; psEnd < dataBlock.length; psEnd++) {\n      const psz = dataBlock[psEnd];\n\n      if (psz === 1) {\n        break;\n      }\n\n      if (psz !== 0) {\n        throw new Error(\"Decryption failed\");\n      }\n    }\n\n    if (psEnd === dataBlock.length) {\n      throw new Error(\"Decryption failed\");\n    }\n\n    pkcs0 = dataBlock.subarray(psEnd + 1);\n    return new Uint8Array(pkcs0).buffer;\n  }\n\n  async onExportKey(format, key) {\n    return RsaCrypto.exportKey(format, getCryptoKey(key));\n  }\n\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n    const key = await RsaCrypto.importKey(format, keyData, { ...algorithm,\n      name: this.name\n    }, extractable, keyUsages);\n    return setCryptoKey(key);\n  }\n\n  checkCryptoKey(key, keyUsage) {\n    super.checkCryptoKey(key, keyUsage);\n    const internalKey = getCryptoKey(key);\n\n    if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n      throw new TypeError(\"key: Is not RSA CryptoKey\");\n    }\n  }\n\n  mgf1(algorithm, seed, length = 0) {\n    const hashSize = ShaCrypto.size(algorithm) >> 3;\n    const mask = new Uint8Array(length);\n    const counter = new Uint8Array(4);\n    const chunks = Math.ceil(length / hashSize);\n\n    for (let i = 0; i < chunks; i++) {\n      counter[0] = i >>> 24;\n      counter[1] = i >>> 16 & 255;\n      counter[2] = i >>> 8 & 255;\n      counter[3] = i & 255;\n      const submask = mask.subarray(i * hashSize);\n      let chunk = crypto__default.createHash(algorithm.name.replace(\"-\", \"\")).update(seed).update(counter).digest();\n\n      if (chunk.length > submask.length) {\n        chunk = chunk.subarray(0, submask.length);\n      }\n\n      submask.set(chunk);\n    }\n\n    return mask;\n  }\n\n}\n\nclass RsaEsProvider extends ProviderCrypto {\n  constructor() {\n    super(...arguments);\n    this.name = \"RSAES-PKCS1-v1_5\";\n    this.usages = {\n      publicKey: [\"encrypt\", \"wrapKey\"],\n      privateKey: [\"decrypt\", \"unwrapKey\"]\n    };\n  }\n\n  async onGenerateKey(algorithm, extractable, keyUsages) {\n    const keys = await RsaCrypto.generateKey({ ...algorithm,\n      name: this.name\n    }, extractable, keyUsages);\n    return {\n      privateKey: setCryptoKey(keys.privateKey),\n      publicKey: setCryptoKey(keys.publicKey)\n    };\n  }\n\n  checkGenerateKeyParams(algorithm) {\n    this.checkRequiredProperty(algorithm, \"publicExponent\");\n\n    if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {\n      throw new TypeError(\"publicExponent: Missing or not a Uint8Array\");\n    }\n\n    const publicExponent = Convert.ToBase64(algorithm.publicExponent);\n\n    if (!(publicExponent === \"Aw==\" || publicExponent === \"AQAB\")) {\n      throw new TypeError(\"publicExponent: Must be [3] or [1,0,1]\");\n    }\n\n    this.checkRequiredProperty(algorithm, \"modulusLength\");\n\n    switch (algorithm.modulusLength) {\n      case 1024:\n      case 2048:\n      case 4096:\n        break;\n\n      default:\n        throw new TypeError(\"modulusLength: Must be 1024, 2048, or 4096\");\n    }\n  }\n\n  async onEncrypt(algorithm, key, data) {\n    const options = this.toCryptoOptions(key);\n    const enc = publicEncrypt(options, new Uint8Array(data));\n    return new Uint8Array(enc).buffer;\n  }\n\n  async onDecrypt(algorithm, key, data) {\n    const options = this.toCryptoOptions(key);\n    const dec = privateDecrypt(options, new Uint8Array(data));\n    return new Uint8Array(dec).buffer;\n  }\n\n  async onExportKey(format, key) {\n    return RsaCrypto.exportKey(format, getCryptoKey(key));\n  }\n\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n    const key = await RsaCrypto.importKey(format, keyData, { ...algorithm,\n      name: this.name\n    }, extractable, keyUsages);\n    return setCryptoKey(key);\n  }\n\n  checkCryptoKey(key, keyUsage) {\n    super.checkCryptoKey(key, keyUsage);\n    const internalKey = getCryptoKey(key);\n\n    if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n      throw new TypeError(\"key: Is not RSA CryptoKey\");\n    }\n  }\n\n  toCryptoOptions(key) {\n    const type = key.type.toUpperCase();\n    return {\n      key: `-----BEGIN ${type} KEY-----\\n${getCryptoKey(key).data.toString(\"base64\")}\\n-----END ${type} KEY-----`,\n      padding: constants.RSA_PKCS1_PADDING\n    };\n  }\n\n}\n\nconst namedOIDs = {\n  \"1.2.840.10045.3.1.7\": \"P-256\",\n  \"P-256\": \"1.2.840.10045.3.1.7\",\n  \"1.3.132.0.34\": \"P-384\",\n  \"P-384\": \"1.3.132.0.34\",\n  \"1.3.132.0.35\": \"P-521\",\n  \"P-521\": \"1.3.132.0.35\",\n  \"1.3.132.0.10\": \"K-256\",\n  \"K-256\": \"1.3.132.0.10\"\n};\n\nfunction getOidByNamedCurve(namedCurve) {\n  const oid = namedOIDs[namedCurve];\n\n  if (!oid) {\n    throw new OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\n  }\n\n  return oid;\n}\n\nclass EcPrivateKey extends AsymmetricKey {\n  constructor() {\n    super(...arguments);\n    this.type = \"private\";\n  }\n\n  getKey() {\n    const keyInfo = AsnParser.parse(this.data, asn1.PrivateKeyInfo);\n    return AsnParser.parse(keyInfo.privateKey, asn1.EcPrivateKey);\n  }\n\n  toJSON() {\n    const key = this.getKey();\n    const json = {\n      kty: \"EC\",\n      crv: this.algorithm.namedCurve,\n      key_ops: this.usages,\n      ext: this.extractable\n    };\n    return Object.assign(json, JsonSerializer.toJSON(key));\n  }\n\n  fromJSON(json) {\n    if (!json.crv) {\n      throw new OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n    }\n\n    const keyInfo = new asn1.PrivateKeyInfo();\n    keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n    keyInfo.privateKeyAlgorithm.parameters = AsnSerializer.serialize(new asn1.ObjectIdentifier(getOidByNamedCurve(json.crv)));\n    const key = JsonParser.fromJSON(json, {\n      targetSchema: asn1.EcPrivateKey\n    });\n    keyInfo.privateKey = AsnSerializer.serialize(key);\n    this.data = Buffer.from(AsnSerializer.serialize(keyInfo));\n    return this;\n  }\n\n}\n\nclass EcPublicKey extends AsymmetricKey {\n  constructor() {\n    super(...arguments);\n    this.type = \"public\";\n  }\n\n  getKey() {\n    const keyInfo = AsnParser.parse(this.data, asn1.PublicKeyInfo);\n    return new asn1.EcPublicKey(keyInfo.publicKey);\n  }\n\n  toJSON() {\n    const key = this.getKey();\n    const json = {\n      kty: \"EC\",\n      crv: this.algorithm.namedCurve,\n      key_ops: this.usages,\n      ext: this.extractable\n    };\n    return Object.assign(json, JsonSerializer.toJSON(key));\n  }\n\n  fromJSON(json) {\n    if (!json.crv) {\n      throw new OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n    }\n\n    const key = JsonParser.fromJSON(json, {\n      targetSchema: asn1.EcPublicKey\n    });\n    const keyInfo = new asn1.PublicKeyInfo();\n    keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n    keyInfo.publicKeyAlgorithm.parameters = AsnSerializer.serialize(new asn1.ObjectIdentifier(getOidByNamedCurve(json.crv)));\n    keyInfo.publicKey = AsnSerializer.toASN(key).valueHex;\n    this.data = Buffer.from(AsnSerializer.serialize(keyInfo));\n    return this;\n  }\n\n}\n\nclass EcCrypto {\n  static async generateKey(algorithm, extractable, keyUsages) {\n    const privateKey = new EcPrivateKey();\n    privateKey.algorithm = algorithm;\n    privateKey.extractable = extractable;\n    privateKey.usages = keyUsages.filter(usage => this.privateKeyUsages.indexOf(usage) !== -1);\n    const publicKey = new EcPublicKey();\n    publicKey.algorithm = algorithm;\n    publicKey.extractable = true;\n    publicKey.usages = keyUsages.filter(usage => this.publicKeyUsages.indexOf(usage) !== -1);\n    const keys = crypto__default.generateKeyPairSync(\"ec\", {\n      namedCurve: this.getOpenSSLNamedCurve(algorithm.namedCurve),\n      publicKeyEncoding: {\n        format: \"der\",\n        type: \"spki\"\n      },\n      privateKeyEncoding: {\n        format: \"der\",\n        type: \"pkcs8\"\n      }\n    });\n    privateKey.data = keys.privateKey;\n    publicKey.data = keys.publicKey;\n    const res = {\n      privateKey,\n      publicKey\n    };\n    return res;\n  }\n\n  static async sign(algorithm, key, data) {\n    const cryptoAlg = algorithm.hash.name.replace(\"-\", \"\");\n    const signer = crypto__default.createSign(cryptoAlg);\n    signer.update(Buffer.from(data));\n\n    if (!key.pem) {\n      key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n    }\n\n    const options = {\n      key: key.pem\n    };\n    const signature = signer.sign(options);\n    const ecSignature = AsnParser.parse(signature, asn1.EcDsaSignature);\n    const pointSize = this.getPointSize(key.algorithm.namedCurve);\n    const r = this.addPadding(pointSize, Buffer.from(ecSignature.r));\n    const s = this.addPadding(pointSize, Buffer.from(ecSignature.s));\n    const signatureRaw = new Uint8Array(Buffer.concat([r, s])).buffer;\n    return signatureRaw;\n  }\n\n  static async verify(algorithm, key, signature, data) {\n    const cryptoAlg = algorithm.hash.name.replace(\"-\", \"\");\n    const signer = crypto__default.createVerify(cryptoAlg);\n    signer.update(Buffer.from(data));\n\n    if (!key.pem) {\n      key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n    }\n\n    const options = {\n      key: key.pem\n    };\n    const ecSignature = new asn1.EcDsaSignature();\n    const pointSize = this.getPointSize(key.algorithm.namedCurve);\n    ecSignature.r = this.removePadding(signature.slice(0, pointSize));\n    ecSignature.s = this.removePadding(signature.slice(pointSize, pointSize + pointSize));\n    const ecSignatureRaw = Buffer.from(AsnSerializer.serialize(ecSignature));\n    const ok = signer.verify(options, ecSignatureRaw);\n    return ok;\n  }\n\n  static async deriveBits(algorithm, baseKey, length) {\n    const cryptoAlg = this.getOpenSSLNamedCurve(baseKey.algorithm.namedCurve);\n    const ecdh = crypto__default.createECDH(cryptoAlg);\n    const asnPrivateKey = AsnParser.parse(baseKey.data, asn1.PrivateKeyInfo);\n    const asnEcPrivateKey = AsnParser.parse(asnPrivateKey.privateKey, asn1.EcPrivateKey);\n    ecdh.setPrivateKey(Buffer.from(asnEcPrivateKey.privateKey));\n    const asnPublicKey = AsnParser.parse(algorithm.public.data, asn1.PublicKeyInfo);\n    const bits = ecdh.computeSecret(Buffer.from(asnPublicKey.publicKey));\n    return new Uint8Array(bits).buffer.slice(0, length >> 3);\n  }\n\n  static async exportKey(format, key) {\n    switch (format.toLowerCase()) {\n      case \"jwk\":\n        return JsonSerializer.toJSON(key);\n\n      case \"pkcs8\":\n      case \"spki\":\n        return new Uint8Array(key.data).buffer;\n\n      case \"raw\":\n        {\n          const publicKeyInfo = AsnParser.parse(key.data, asn1.PublicKeyInfo);\n          return publicKeyInfo.publicKey;\n        }\n\n      default:\n        throw new OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\n    }\n  }\n\n  static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n    switch (format.toLowerCase()) {\n      case \"jwk\":\n        {\n          const jwk = keyData;\n\n          if (jwk.d) {\n            const asnKey = JsonParser.fromJSON(keyData, {\n              targetSchema: asn1.EcPrivateKey\n            });\n            return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n          } else {\n            const asnKey = JsonParser.fromJSON(keyData, {\n              targetSchema: asn1.EcPublicKey\n            });\n            return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n          }\n        }\n\n      case \"raw\":\n        {\n          const asnKey = new asn1.EcPublicKey(keyData);\n          return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n        }\n\n      case \"spki\":\n        {\n          const keyInfo = AsnParser.parse(new Uint8Array(keyData), asn1.PublicKeyInfo);\n          const asnKey = new asn1.EcPublicKey(keyInfo.publicKey);\n          return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n        }\n\n      case \"pkcs8\":\n        {\n          const keyInfo = AsnParser.parse(new Uint8Array(keyData), asn1.PrivateKeyInfo);\n          const asnKey = AsnParser.parse(keyInfo.privateKey, asn1.EcPrivateKey);\n          return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n        }\n\n      default:\n        throw new OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\n    }\n  }\n\n  static async importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\n    const keyInfo = new asn1.PrivateKeyInfo();\n    keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n    keyInfo.privateKeyAlgorithm.parameters = AsnSerializer.serialize(new asn1.ObjectIdentifier(getOidByNamedCurve(algorithm.namedCurve)));\n    keyInfo.privateKey = AsnSerializer.serialize(asnKey);\n    const key = new EcPrivateKey();\n    key.data = Buffer.from(AsnSerializer.serialize(keyInfo));\n    key.algorithm = Object.assign({}, algorithm);\n    key.extractable = extractable;\n    key.usages = keyUsages;\n    return key;\n  }\n\n  static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\n    const keyInfo = new asn1.PublicKeyInfo();\n    keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n    keyInfo.publicKeyAlgorithm.parameters = AsnSerializer.serialize(new asn1.ObjectIdentifier(getOidByNamedCurve(algorithm.namedCurve)));\n    keyInfo.publicKey = asnKey.value;\n    const key = new EcPublicKey();\n    key.data = Buffer.from(AsnSerializer.serialize(keyInfo));\n    key.algorithm = Object.assign({}, algorithm);\n    key.extractable = extractable;\n    key.usages = keyUsages;\n    return key;\n  }\n\n  static getOpenSSLNamedCurve(curve) {\n    switch (curve.toUpperCase()) {\n      case \"P-256\":\n        return \"prime256v1\";\n\n      case \"K-256\":\n        return \"secp256k1\";\n\n      case \"P-384\":\n        return \"secp384r1\";\n\n      case \"P-521\":\n        return \"secp521r1\";\n\n      default:\n        throw new OperationError(`Cannot convert WebCrypto named curve to NodeJs. Unknown name '${curve}'`);\n    }\n  }\n\n  static getPointSize(namedCurve) {\n    switch (namedCurve) {\n      case \"P-256\":\n      case \"K-256\":\n        return 32;\n\n      case \"P-384\":\n        return 48;\n\n      case \"P-521\":\n        return 66;\n\n      default:\n        throw new Error(`Cannot get size for the named curve '${namedCurve}'`);\n    }\n  }\n\n  static addPadding(pointSize, bytes) {\n    const res = Buffer.alloc(pointSize);\n    res.set(Buffer.from(bytes), pointSize - bytes.length);\n    return res;\n  }\n\n  static removePadding(bytes) {\n    for (let i = 0; i < bytes.length; i++) {\n      if (!bytes[i]) {\n        continue;\n      }\n\n      return bytes.slice(i).buffer;\n    }\n\n    return new ArrayBuffer(0);\n  }\n\n}\n\nEcCrypto.publicKeyUsages = [\"verify\"];\nEcCrypto.privateKeyUsages = [\"sign\", \"deriveKey\", \"deriveBits\"];\n\nclass EcdsaProvider extends EcdsaProvider$1 {\n  constructor() {\n    super(...arguments);\n    this.namedCurves = [\"P-256\", \"P-384\", \"P-521\", \"K-256\"];\n  }\n\n  async onGenerateKey(algorithm, extractable, keyUsages) {\n    const keys = await EcCrypto.generateKey({ ...algorithm,\n      name: this.name\n    }, extractable, keyUsages);\n    return {\n      privateKey: setCryptoKey(keys.privateKey),\n      publicKey: setCryptoKey(keys.publicKey)\n    };\n  }\n\n  async onSign(algorithm, key, data) {\n    return EcCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n  }\n\n  async onVerify(algorithm, key, signature, data) {\n    return EcCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n  }\n\n  async onExportKey(format, key) {\n    return EcCrypto.exportKey(format, getCryptoKey(key));\n  }\n\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n    const key = await EcCrypto.importKey(format, keyData, { ...algorithm,\n      name: this.name\n    }, extractable, keyUsages);\n    return setCryptoKey(key);\n  }\n\n  checkCryptoKey(key, keyUsage) {\n    super.checkCryptoKey(key, keyUsage);\n    const internalKey = getCryptoKey(key);\n\n    if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\n      throw new TypeError(\"key: Is not EC CryptoKey\");\n    }\n  }\n\n}\n\nclass EcdhProvider extends EcdhProvider$1 {\n  async onGenerateKey(algorithm, extractable, keyUsages) {\n    const keys = await EcCrypto.generateKey({ ...algorithm,\n      name: this.name\n    }, extractable, keyUsages);\n    return {\n      privateKey: setCryptoKey(keys.privateKey),\n      publicKey: setCryptoKey(keys.publicKey)\n    };\n  }\n\n  async onExportKey(format, key) {\n    return EcCrypto.exportKey(format, getCryptoKey(key));\n  }\n\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n    const key = await EcCrypto.importKey(format, keyData, { ...algorithm,\n      name: this.name\n    }, extractable, keyUsages);\n    return setCryptoKey(key);\n  }\n\n  checkCryptoKey(key, keyUsage) {\n    super.checkCryptoKey(key, keyUsage);\n    const internalKey = getCryptoKey(key);\n\n    if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\n      throw new TypeError(\"key: Is not EC CryptoKey\");\n    }\n  }\n\n  async onDeriveBits(algorithm, baseKey, length) {\n    const bits = await EcCrypto.deriveBits({ ...algorithm,\n      public: getCryptoKey(algorithm.public)\n    }, getCryptoKey(baseKey), length);\n    return bits;\n  }\n\n}\n\nclass Sha1Provider extends ProviderCrypto {\n  constructor() {\n    super(...arguments);\n    this.name = \"SHA-1\";\n    this.usages = [];\n  }\n\n  async onDigest(algorithm, data) {\n    return ShaCrypto.digest(algorithm, data);\n  }\n\n}\n\nclass Sha256Provider extends ProviderCrypto {\n  constructor() {\n    super(...arguments);\n    this.name = \"SHA-256\";\n    this.usages = [];\n  }\n\n  async onDigest(algorithm, data) {\n    return ShaCrypto.digest(algorithm, data);\n  }\n\n}\n\nclass Sha384Provider extends ProviderCrypto {\n  constructor() {\n    super(...arguments);\n    this.name = \"SHA-384\";\n    this.usages = [];\n  }\n\n  async onDigest(algorithm, data) {\n    return ShaCrypto.digest(algorithm, data);\n  }\n\n}\n\nclass Sha512Provider extends ProviderCrypto {\n  constructor() {\n    super(...arguments);\n    this.name = \"SHA-512\";\n    this.usages = [];\n  }\n\n  async onDigest(algorithm, data) {\n    return ShaCrypto.digest(algorithm, data);\n  }\n\n}\n\nclass PbkdfCryptoKey extends CryptoKey {}\n\nclass Pbkdf2Provider extends Pbkdf2Provider$1 {\n  async onDeriveBits(algorithm, baseKey, length) {\n    return new Promise((resolve, reject) => {\n      const salt = BufferSourceConverter.toArrayBuffer(algorithm.salt);\n      const hash = algorithm.hash.name.replace(\"-\", \"\");\n      crypto__default.pbkdf2(getCryptoKey(baseKey).data, Buffer.from(salt), algorithm.iterations, length >> 3, hash, (err, derivedBits) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(new Uint8Array(derivedBits).buffer);\n        }\n      });\n    });\n  }\n\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n    if (format === \"raw\") {\n      const key = new PbkdfCryptoKey();\n      key.data = Buffer.from(keyData);\n      key.algorithm = {\n        name: this.name\n      };\n      key.extractable = false;\n      key.usages = keyUsages;\n      return setCryptoKey(key);\n    }\n\n    throw new OperationError(\"format: Must be 'raw'\");\n  }\n\n  checkCryptoKey(key, keyUsage) {\n    super.checkCryptoKey(key, keyUsage);\n\n    if (!(getCryptoKey(key) instanceof PbkdfCryptoKey)) {\n      throw new TypeError(\"key: Is not PBKDF CryptoKey\");\n    }\n  }\n\n}\n\nclass HmacCryptoKey extends CryptoKey {\n  get alg() {\n    const hash = this.algorithm.hash.name.toUpperCase();\n    return `HS${hash.replace(\"SHA-\", \"\")}`;\n  }\n\n  set alg(value) {}\n\n}\n\n__decorate([JsonProp({\n  name: \"k\",\n  converter: JsonBase64UrlConverter\n})], HmacCryptoKey.prototype, \"data\", void 0);\n\nclass HmacProvider extends HmacProvider$1 {\n  async onGenerateKey(algorithm, extractable, keyUsages) {\n    const length = algorithm.length || this.getDefaultLength(algorithm.hash.name);\n    const key = new HmacCryptoKey();\n    key.algorithm = { ...algorithm,\n      name: this.name\n    };\n    key.extractable = extractable;\n    key.usages = keyUsages;\n    key.data = crypto__default.randomBytes(length >> 3);\n    return setCryptoKey(key);\n  }\n\n  async onSign(algorithm, key, data) {\n    const hash = key.algorithm.hash.name.replace(\"-\", \"\");\n    const hmac = crypto__default.createHmac(hash, getCryptoKey(key).data).update(Buffer.from(data)).digest();\n    return new Uint8Array(hmac).buffer;\n  }\n\n  async onVerify(algorithm, key, signature, data) {\n    const hash = key.algorithm.hash.name.replace(\"-\", \"\");\n    const hmac = crypto__default.createHmac(hash, getCryptoKey(key).data).update(Buffer.from(data)).digest();\n    return hmac.compare(Buffer.from(signature)) === 0;\n  }\n\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n    let key;\n\n    switch (format.toLowerCase()) {\n      case \"jwk\":\n        key = JsonParser.fromJSON(keyData, {\n          targetSchema: HmacCryptoKey\n        });\n        break;\n\n      case \"raw\":\n        key = new HmacCryptoKey();\n        key.data = Buffer.from(keyData);\n        break;\n\n      default:\n        throw new OperationError(\"format: Must be 'jwk' or 'raw'\");\n    }\n\n    key.algorithm = {\n      hash: {\n        name: algorithm.hash.name\n      },\n      name: this.name,\n      length: key.data.length << 3\n    };\n    key.extractable = extractable;\n    key.usages = keyUsages;\n    return setCryptoKey(key);\n  }\n\n  async onExportKey(format, key) {\n    switch (format.toLowerCase()) {\n      case \"jwk\":\n        return JsonSerializer.toJSON(getCryptoKey(key));\n\n      case \"raw\":\n        return new Uint8Array(getCryptoKey(key).data).buffer;\n\n      default:\n        throw new OperationError(\"format: Must be 'jwk' or 'raw'\");\n    }\n  }\n\n  checkCryptoKey(key, keyUsage) {\n    super.checkCryptoKey(key, keyUsage);\n\n    if (!(getCryptoKey(key) instanceof HmacCryptoKey)) {\n      throw new TypeError(\"key: Is not HMAC CryptoKey\");\n    }\n  }\n\n}\n\nclass HkdfCryptoKey extends CryptoKey {}\n\nclass HkdfProvider extends HkdfProvider$1 {\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n    if (format.toLowerCase() !== \"raw\") {\n      throw new OperationError(\"Operation not supported\");\n    }\n\n    const key = new HkdfCryptoKey();\n    key.data = Buffer.from(keyData);\n    key.algorithm = {\n      name: this.name\n    };\n    key.extractable = extractable;\n    key.usages = keyUsages;\n    return setCryptoKey(key);\n  }\n\n  async onDeriveBits(params, baseKey, length) {\n    const hash = params.hash.name.replace(\"-\", \"\");\n    const hashLength = crypto__default.createHash(hash).digest().length;\n    const byteLength = length / 8;\n    const info = BufferSourceConverter.toUint8Array(params.info);\n    const PRK = crypto__default.createHmac(hash, BufferSourceConverter.toUint8Array(params.salt)).update(BufferSourceConverter.toUint8Array(getCryptoKey(baseKey).data)).digest();\n    const blocks = [Buffer.alloc(0)];\n    const blockCount = Math.ceil(byteLength / hashLength) + 1;\n\n    for (let i = 1; i < blockCount; ++i) {\n      blocks.push(crypto__default.createHmac(hash, PRK).update(Buffer.concat([blocks[i - 1], info, Buffer.from([i])])).digest());\n    }\n\n    return Buffer.concat(blocks).slice(0, byteLength);\n  }\n\n  checkCryptoKey(key, keyUsage) {\n    super.checkCryptoKey(key, keyUsage);\n\n    if (!(getCryptoKey(key) instanceof HkdfCryptoKey)) {\n      throw new TypeError(\"key: Is not HKDF CryptoKey\");\n    }\n  }\n\n}\n\nclass SubtleCrypto extends SubtleCrypto$1 {\n  constructor() {\n    super();\n    this.providers.set(new AesCbcProvider());\n    this.providers.set(new AesCtrProvider());\n    this.providers.set(new AesGcmProvider());\n    this.providers.set(new AesCmacProvider());\n    this.providers.set(new AesKwProvider());\n    this.providers.set(new AesEcbProvider());\n    this.providers.set(new DesCbcProvider());\n    this.providers.set(new DesEde3CbcProvider());\n    this.providers.set(new RsaSsaProvider());\n    this.providers.set(new RsaPssProvider());\n    this.providers.set(new RsaOaepProvider());\n    this.providers.set(new RsaEsProvider());\n    this.providers.set(new EcdsaProvider());\n    this.providers.set(new EcdhProvider());\n    this.providers.set(new Sha1Provider());\n    this.providers.set(new Sha256Provider());\n    this.providers.set(new Sha384Provider());\n    this.providers.set(new Sha512Provider());\n    this.providers.set(new Pbkdf2Provider());\n    this.providers.set(new HmacProvider());\n    this.providers.set(new HkdfProvider());\n  }\n\n}\n\nclass Crypto {\n  constructor() {\n    this.subtle = new SubtleCrypto();\n  }\n\n  getRandomValues(array) {\n    const buffer = Buffer.from(array.buffer);\n    crypto__default.randomFillSync(buffer);\n    return array;\n  }\n\n}\n\nexport { Crypto };","map":{"version":3,"sources":["/Users/pratison/Work/Cisco/Education/React/education-webex/node_modules/@peculiar/webcrypto/build/webcrypto.es.js"],"names":["CryptoKey","CryptoKey$1","AlgorithmError","OperationError","AesCbcProvider","AesCbcProvider$1","AesCmacProvider","AesCmacProvider$1","AesCtrProvider","AesCtrProvider$1","AesGcmProvider","AesGcmProvider$1","AesKwProvider","AesKwProvider$1","AesEcbProvider","AesEcbProvider$1","DesProvider","asn1","RsaSsaProvider","RsaSsaProvider$1","RsaPssProvider","RsaPssProvider$1","RsaOaepProvider","RsaOaepProvider$1","BufferSourceConverter","ProviderCrypto","EcdsaProvider","EcdsaProvider$1","EcdhProvider","EcdhProvider$1","Pbkdf2Provider","Pbkdf2Provider$1","HmacProvider","HmacProvider$1","HkdfProvider","HkdfProvider$1","SubtleCrypto","SubtleCrypto$1","crypto__default","createCipheriv","publicEncrypt","privateDecrypt","constants","__decorate","JsonProp","JsonPropTypes","JsonSerializer","JsonParser","Convert","AsnParser","AsnSerializer","JsonBase64UrlConverter","fromJSON","value","Buffer","from","FromBase64Url","toJSON","ToBase64Url","constructor","arguments","data","alloc","algorithm","name","extractable","type","usages","kty","alg","Boolean","optional","prototype","String","repeated","SymmetricKey","AsymmetricKey","AesCryptoKey","toUpperCase","length","converter","keyStorage","WeakMap","getCryptoKey","key","res","get","setCryptoKey","create","Object","freeze","set","AesCrypto","generateKey","keyUsages","randomBytes","exportKey","format","Error","toLowerCase","Uint8Array","buffer","importKey","keyData","targetSchema","encrypt","encryptAesCBC","encryptAesCTR","encryptAesGCM","encryptAesKW","encryptAesECB","decrypt","decryptAesCBC","decryptAesCTR","decryptAesGCM","decryptAesKW","decryptAesECB","cipher","iv","enc","update","concat","final","decipher","createDecipheriv","dec","counter","authTagLength","tagLength","additionalData","setAAD","getAuthTag","slice","tag","setAuthTag","AES_KW_IV","onGenerateKey","onEncrypt","onDecrypt","onExportKey","onImportKey","checkCryptoKey","keyUsage","TypeError","zero","rb","blockSize","bitShiftLeft","shifted","last","index","xor","a","b","Math","min","output","aes","message","result","getMessageBlock","blockIndex","block","start","end","copy","getPaddedMessageBlock","fill","generateSubkeys","l","subkey1","subkey2","aesCmac","subkeys","blockCount","ceil","lastBlockCompleteFlag","lastBlock","lastBlockIndex","x","y","onSign","onVerify","signature","signature2","sign","compare","DesCryptoKey","DesCrypto","encryptDesCBC","encryptDesEDE3CBC","decryptDesCBC","decryptDesEDE3CBC","DesCbcProvider","keySizeBits","ivSize","DesEde3CbcProvider","getJwkAlgorithm","mdSize","exec","hash","RsaPrivateKey","getKey","keyInfo","parse","PrivateKeyInfo","privateKey","json","key_ops","ext","assign","privateKeyAlgorithm","parameters","serialize","RsaPublicKey","PublicKeyInfo","publicKey","publicKeyAlgorithm","RsaCrypto","filter","usage","privateKeyUsages","indexOf","publicKeyUsages","publicExponent","byteLength","readInt32BE","keys","generateKeyPairSync","modulusLength","publicKeyEncoding","privateKeyEncoding","jwk","d","asnKey","importPrivateKey","importPublicKey","signRsa","verify","verifySSA","encryptOAEP","decryptOAEP","modulus","getCryptoAlgorithm","cryptoAlg","signer","createSign","pem","toString","options","padding","RSA_PKCS1_PSS_PADDING","saltLength","createVerify","ok","RSA_PKCS1_OAEP_PADDING","label","internalKey","ShaCrypto","size","digest","createHash","replace","dataView","keySize","hashSize","dataLength","psLength","seed","subarray","dataBlock","labelHash","toUint8Array","randomFillSync","dataBlockMask","mgf1","i","seedMask","pkcs0","RSA_NO_PADDING","z","psEnd","psz","mask","chunks","submask","chunk","RsaEsProvider","checkGenerateKeyParams","checkRequiredProperty","ToBase64","toCryptoOptions","RSA_PKCS1_PADDING","namedOIDs","getOidByNamedCurve","namedCurve","oid","EcPrivateKey","crv","ObjectIdentifier","EcPublicKey","toASN","valueHex","EcCrypto","getOpenSSLNamedCurve","ecSignature","EcDsaSignature","pointSize","getPointSize","r","addPadding","s","signatureRaw","removePadding","ecSignatureRaw","deriveBits","baseKey","ecdh","createECDH","asnPrivateKey","asnEcPrivateKey","setPrivateKey","asnPublicKey","public","bits","computeSecret","publicKeyInfo","curve","bytes","ArrayBuffer","namedCurves","onDeriveBits","Sha1Provider","onDigest","Sha256Provider","Sha384Provider","Sha512Provider","PbkdfCryptoKey","Promise","resolve","reject","salt","toArrayBuffer","pbkdf2","iterations","err","derivedBits","HmacCryptoKey","getDefaultLength","hmac","createHmac","HkdfCryptoKey","params","hashLength","info","PRK","blocks","push","providers","Crypto","subtle","getRandomValues","array"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2019-2020, Peculiar Ventures, All rights reserved.\n */\n\nimport { CryptoKey as CryptoKey$1, AlgorithmError, OperationError, AesCbcProvider as AesCbcProvider$1, AesCmacProvider as AesCmacProvider$1, AesCtrProvider as AesCtrProvider$1, AesGcmProvider as AesGcmProvider$1, AesKwProvider as AesKwProvider$1, AesEcbProvider as AesEcbProvider$1, DesProvider, asn1, RsaSsaProvider as RsaSsaProvider$1, RsaPssProvider as RsaPssProvider$1, RsaOaepProvider as RsaOaepProvider$1, BufferSourceConverter, ProviderCrypto, EcdsaProvider as EcdsaProvider$1, EcdhProvider as EcdhProvider$1, Pbkdf2Provider as Pbkdf2Provider$1, HmacProvider as HmacProvider$1, HkdfProvider as HkdfProvider$1, SubtleCrypto as SubtleCrypto$1 } from 'webcrypto-core';\nexport { CryptoKey } from 'webcrypto-core';\nimport crypto__default, { createCipheriv, publicEncrypt, privateDecrypt, constants } from 'crypto';\nimport { __decorate } from 'tslib';\nimport { JsonProp, JsonPropTypes, JsonSerializer, JsonParser } from '@peculiar/json-schema';\nimport { Convert } from 'pvtsutils';\nimport { AsnParser, AsnSerializer } from '@peculiar/asn1-schema';\n\nconst JsonBase64UrlConverter = {\r\n    fromJSON: (value) => Buffer.from(Convert.FromBase64Url(value)),\r\n    toJSON: (value) => Convert.ToBase64Url(value),\r\n};\n\nclass CryptoKey extends CryptoKey$1 {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.data = Buffer.alloc(0);\r\n        this.algorithm = { name: \"\" };\r\n        this.extractable = false;\r\n        this.type = \"secret\";\r\n        this.usages = [];\r\n        this.kty = \"oct\";\r\n        this.alg = \"\";\r\n    }\r\n}\r\n__decorate([\r\n    JsonProp({ name: \"ext\", type: JsonPropTypes.Boolean, optional: true })\r\n], CryptoKey.prototype, \"extractable\", void 0);\r\n__decorate([\r\n    JsonProp({ name: \"key_ops\", type: JsonPropTypes.String, repeated: true, optional: true })\r\n], CryptoKey.prototype, \"usages\", void 0);\r\n__decorate([\r\n    JsonProp({ type: JsonPropTypes.String })\r\n], CryptoKey.prototype, \"kty\", void 0);\r\n__decorate([\r\n    JsonProp({ type: JsonPropTypes.String })\r\n], CryptoKey.prototype, \"alg\", void 0);\n\nclass SymmetricKey extends CryptoKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.kty = \"oct\";\r\n        this.type = \"secret\";\r\n    }\r\n}\n\nclass AsymmetricKey extends CryptoKey {\r\n}\n\nclass AesCryptoKey extends SymmetricKey {\r\n    get alg() {\r\n        switch (this.algorithm.name.toUpperCase()) {\r\n            case \"AES-CBC\":\r\n                return `A${this.algorithm.length}CBC`;\r\n            case \"AES-CTR\":\r\n                return `A${this.algorithm.length}CTR`;\r\n            case \"AES-GCM\":\r\n                return `A${this.algorithm.length}GCM`;\r\n            case \"AES-KW\":\r\n                return `A${this.algorithm.length}KW`;\r\n            case \"AES-CMAC\":\r\n                return `A${this.algorithm.length}CMAC`;\r\n            case \"AES-ECB\":\r\n                return `A${this.algorithm.length}ECB`;\r\n            default:\r\n                throw new AlgorithmError(\"Unsupported algorithm name\");\r\n        }\r\n    }\r\n    set alg(value) {\r\n    }\r\n}\r\n__decorate([\r\n    JsonProp({ name: \"k\", converter: JsonBase64UrlConverter })\r\n], AesCryptoKey.prototype, \"data\", void 0);\n\nconst keyStorage = new WeakMap();\r\nfunction getCryptoKey(key) {\r\n    const res = keyStorage.get(key);\r\n    if (!res) {\r\n        throw new OperationError(\"Cannot get CryptoKey from secure storage\");\r\n    }\r\n    return res;\r\n}\r\nfunction setCryptoKey(value) {\r\n    const key = CryptoKey$1.create(value.algorithm, value.type, value.extractable, value.usages);\r\n    Object.freeze(key);\r\n    keyStorage.set(key, value);\r\n    return key;\r\n}\n\nclass AesCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const key = new AesCryptoKey();\r\n        key.algorithm = algorithm;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        key.data = crypto__default.randomBytes(algorithm.length >> 3);\r\n        return key;\r\n    }\r\n    static async exportKey(format, key) {\r\n        if (!(key instanceof AesCryptoKey)) {\r\n            throw new Error(\"key: Is not AesCryptoKey\");\r\n        }\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return JsonSerializer.toJSON(key);\r\n            case \"raw\":\r\n                return new Uint8Array(key.data).buffer;\r\n            default:\r\n                throw new OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        let key;\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                key = JsonParser.fromJSON(keyData, { targetSchema: AesCryptoKey });\r\n                break;\r\n            case \"raw\":\r\n                key = new AesCryptoKey();\r\n                key.data = Buffer.from(keyData);\r\n                break;\r\n            default:\r\n                throw new OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n        key.algorithm = algorithm;\r\n        key.algorithm.length = key.data.length << 3;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        switch (key.algorithm.length) {\r\n            case 128:\r\n            case 192:\r\n            case 256:\r\n                break;\r\n            default:\r\n                throw new OperationError(\"keyData: Is wrong key length\");\r\n        }\r\n        return key;\r\n    }\r\n    static async encrypt(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"AES-CBC\":\r\n                return this.encryptAesCBC(algorithm, key, Buffer.from(data));\r\n            case \"AES-CTR\":\r\n                return this.encryptAesCTR(algorithm, key, Buffer.from(data));\r\n            case \"AES-GCM\":\r\n                return this.encryptAesGCM(algorithm, key, Buffer.from(data));\r\n            case \"AES-KW\":\r\n                return this.encryptAesKW(algorithm, key, Buffer.from(data));\r\n            case \"AES-ECB\":\r\n                return this.encryptAesECB(algorithm, key, Buffer.from(data));\r\n            default:\r\n                throw new OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async decrypt(algorithm, key, data) {\r\n        if (!(key instanceof AesCryptoKey)) {\r\n            throw new Error(\"key: Is not AesCryptoKey\");\r\n        }\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"AES-CBC\":\r\n                return this.decryptAesCBC(algorithm, key, Buffer.from(data));\r\n            case \"AES-CTR\":\r\n                return this.decryptAesCTR(algorithm, key, Buffer.from(data));\r\n            case \"AES-GCM\":\r\n                return this.decryptAesGCM(algorithm, key, Buffer.from(data));\r\n            case \"AES-KW\":\r\n                return this.decryptAesKW(algorithm, key, Buffer.from(data));\r\n            case \"AES-ECB\":\r\n                return this.decryptAesECB(algorithm, key, Buffer.from(data));\r\n            default:\r\n                throw new OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async encryptAesCBC(algorithm, key, data) {\r\n        const cipher = crypto__default.createCipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptAesCBC(algorithm, key, data) {\r\n        const decipher = crypto__default.createDecipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptAesCTR(algorithm, key, data) {\r\n        const cipher = crypto__default.createCipheriv(`aes-${key.algorithm.length}-ctr`, key.data, Buffer.from(algorithm.counter));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptAesCTR(algorithm, key, data) {\r\n        const decipher = crypto__default.createDecipheriv(`aes-${key.algorithm.length}-ctr`, key.data, new Uint8Array(algorithm.counter));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptAesGCM(algorithm, key, data) {\r\n        const cipher = crypto__default.createCipheriv(`aes-${key.algorithm.length}-gcm`, key.data, Buffer.from(algorithm.iv), {\r\n            authTagLength: (algorithm.tagLength || 128) >> 3,\r\n        });\r\n        if (algorithm.additionalData) {\r\n            cipher.setAAD(Buffer.from(algorithm.additionalData));\r\n        }\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final(), cipher.getAuthTag()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptAesGCM(algorithm, key, data) {\r\n        const decipher = crypto__default.createDecipheriv(`aes-${key.algorithm.length}-gcm`, key.data, new Uint8Array(algorithm.iv));\r\n        const tagLength = (algorithm.tagLength || 128) >> 3;\r\n        const enc = data.slice(0, data.length - tagLength);\r\n        const tag = data.slice(data.length - tagLength);\r\n        if (algorithm.additionalData) {\r\n            decipher.setAAD(Buffer.from(algorithm.additionalData));\r\n        }\r\n        decipher.setAuthTag(tag);\r\n        let dec = decipher.update(enc);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptAesKW(algorithm, key, data) {\r\n        const cipher = crypto__default.createCipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        return new Uint8Array(enc).buffer;\r\n    }\r\n    static async decryptAesKW(algorithm, key, data) {\r\n        const decipher = crypto__default.createDecipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptAesECB(algorithm, key, data) {\r\n        const cipher = crypto__default.createCipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptAesECB(algorithm, key, data) {\r\n        const decipher = crypto__default.createDecipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n}\r\nAesCrypto.AES_KW_IV = Buffer.from(\"A6A6A6A6A6A6A6A6\", \"hex\");\n\nclass AesCbcProvider extends AesCbcProvider$1 {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nconst zero = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\r\nconst rb = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135]);\r\nconst blockSize = 16;\r\nfunction bitShiftLeft(buffer) {\r\n    const shifted = Buffer.alloc(buffer.length);\r\n    const last = buffer.length - 1;\r\n    for (let index = 0; index < last; index++) {\r\n        shifted[index] = buffer[index] << 1;\r\n        if (buffer[index + 1] & 0x80) {\r\n            shifted[index] += 0x01;\r\n        }\r\n    }\r\n    shifted[last] = buffer[last] << 1;\r\n    return shifted;\r\n}\r\nfunction xor(a, b) {\r\n    const length = Math.min(a.length, b.length);\r\n    const output = Buffer.alloc(length);\r\n    for (let index = 0; index < length; index++) {\r\n        output[index] = a[index] ^ b[index];\r\n    }\r\n    return output;\r\n}\r\nfunction aes(key, message) {\r\n    const cipher = createCipheriv(`aes${key.length << 3}`, key, zero);\r\n    const result = cipher.update(message);\r\n    cipher.final();\r\n    return result;\r\n}\r\nfunction getMessageBlock(message, blockIndex) {\r\n    const block = Buffer.alloc(blockSize);\r\n    const start = blockIndex * blockSize;\r\n    const end = start + blockSize;\r\n    message.copy(block, 0, start, end);\r\n    return block;\r\n}\r\nfunction getPaddedMessageBlock(message, blockIndex) {\r\n    const block = Buffer.alloc(blockSize);\r\n    const start = blockIndex * blockSize;\r\n    const end = message.length;\r\n    block.fill(0);\r\n    message.copy(block, 0, start, end);\r\n    block[end - start] = 0x80;\r\n    return block;\r\n}\r\nfunction generateSubkeys(key) {\r\n    const l = aes(key, zero);\r\n    let subkey1 = bitShiftLeft(l);\r\n    if (l[0] & 0x80) {\r\n        subkey1 = xor(subkey1, rb);\r\n    }\r\n    let subkey2 = bitShiftLeft(subkey1);\r\n    if (subkey1[0] & 0x80) {\r\n        subkey2 = xor(subkey2, rb);\r\n    }\r\n    return { subkey1, subkey2 };\r\n}\r\nfunction aesCmac(key, message) {\r\n    const subkeys = generateSubkeys(key);\r\n    let blockCount = Math.ceil(message.length / blockSize);\r\n    let lastBlockCompleteFlag;\r\n    let lastBlock;\r\n    if (blockCount === 0) {\r\n        blockCount = 1;\r\n        lastBlockCompleteFlag = false;\r\n    }\r\n    else {\r\n        lastBlockCompleteFlag = (message.length % blockSize === 0);\r\n    }\r\n    const lastBlockIndex = blockCount - 1;\r\n    if (lastBlockCompleteFlag) {\r\n        lastBlock = xor(getMessageBlock(message, lastBlockIndex), subkeys.subkey1);\r\n    }\r\n    else {\r\n        lastBlock = xor(getPaddedMessageBlock(message, lastBlockIndex), subkeys.subkey2);\r\n    }\r\n    let x = zero;\r\n    let y;\r\n    for (let index = 0; index < lastBlockIndex; index++) {\r\n        y = xor(x, getMessageBlock(message, index));\r\n        x = aes(key, y);\r\n    }\r\n    y = xor(lastBlock, x);\r\n    return aes(key, y);\r\n}\r\nclass AesCmacProvider extends AesCmacProvider$1 {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        const result = aesCmac(getCryptoKey(key).data, Buffer.from(data));\r\n        return new Uint8Array(result).buffer;\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        const signature2 = await this.sign(algorithm, key, data);\r\n        return Buffer.from(signature).compare(Buffer.from(signature2)) === 0;\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass AesCtrProvider extends AesCtrProvider$1 {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass AesGcmProvider extends AesGcmProvider$1 {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass AesKwProvider extends AesKwProvider$1 {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass AesEcbProvider extends AesEcbProvider$1 {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass DesCryptoKey extends SymmetricKey {\r\n    get alg() {\r\n        switch (this.algorithm.name.toUpperCase()) {\r\n            case \"DES-CBC\":\r\n                return `DES-CBC`;\r\n            case \"DES-EDE3-CBC\":\r\n                return `3DES-CBC`;\r\n            default:\r\n                throw new AlgorithmError(\"Unsupported algorithm name\");\r\n        }\r\n    }\r\n    set alg(value) {\r\n    }\r\n}\r\n__decorate([\r\n    JsonProp({ name: \"k\", converter: JsonBase64UrlConverter })\r\n], DesCryptoKey.prototype, \"data\", void 0);\n\nclass DesCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const key = new DesCryptoKey();\r\n        key.algorithm = algorithm;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        key.data = crypto__default.randomBytes(algorithm.length >> 3);\r\n        return key;\r\n    }\r\n    static async exportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return JsonSerializer.toJSON(key);\r\n            case \"raw\":\r\n                return new Uint8Array(key.data).buffer;\r\n            default:\r\n                throw new OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        let key;\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                key = JsonParser.fromJSON(keyData, { targetSchema: DesCryptoKey });\r\n                break;\r\n            case \"raw\":\r\n                key = new DesCryptoKey();\r\n                key.data = Buffer.from(keyData);\r\n                break;\r\n            default:\r\n                throw new OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n        key.algorithm = algorithm;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static async encrypt(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"DES-CBC\":\r\n                return this.encryptDesCBC(algorithm, key, Buffer.from(data));\r\n            case \"DES-EDE3-CBC\":\r\n                return this.encryptDesEDE3CBC(algorithm, key, Buffer.from(data));\r\n            default:\r\n                throw new OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async decrypt(algorithm, key, data) {\r\n        if (!(key instanceof DesCryptoKey)) {\r\n            throw new Error(\"key: Is not DesCryptoKey\");\r\n        }\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"DES-CBC\":\r\n                return this.decryptDesCBC(algorithm, key, Buffer.from(data));\r\n            case \"DES-EDE3-CBC\":\r\n                return this.decryptDesEDE3CBC(algorithm, key, Buffer.from(data));\r\n            default:\r\n                throw new OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async encryptDesCBC(algorithm, key, data) {\r\n        const cipher = crypto__default.createCipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptDesCBC(algorithm, key, data) {\r\n        const decipher = crypto__default.createDecipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptDesEDE3CBC(algorithm, key, data) {\r\n        const cipher = crypto__default.createCipheriv(`des-ede3-cbc`, key.data, Buffer.from(algorithm.iv));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptDesEDE3CBC(algorithm, key, data) {\r\n        const decipher = crypto__default.createDecipheriv(`des-ede3-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n}\n\nclass DesCbcProvider extends DesProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.keySizeBits = 64;\r\n        this.ivSize = 8;\r\n        this.name = \"DES-CBC\";\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await DesCrypto.generateKey({\r\n            name: this.name,\r\n            length: this.keySizeBits,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return DesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);\r\n        if (key.data.length !== (this.keySizeBits >> 3)) {\r\n            throw new OperationError(\"keyData: Wrong key size\");\r\n        }\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass DesEde3CbcProvider extends DesProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.keySizeBits = 192;\r\n        this.ivSize = 8;\r\n        this.name = \"DES-EDE3-CBC\";\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await DesCrypto.generateKey({\r\n            name: this.name,\r\n            length: this.keySizeBits,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return DesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);\r\n        if (key.data.length !== (this.keySizeBits >> 3)) {\r\n            throw new OperationError(\"keyData: Wrong key size\");\r\n        }\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nfunction getJwkAlgorithm(algorithm) {\r\n    switch (algorithm.name.toUpperCase()) {\r\n        case \"RSA-OAEP\": {\r\n            const mdSize = /(\\d+)$/.exec(algorithm.hash.name)[1];\r\n            return `RSA-OAEP${mdSize !== \"1\" ? `-${mdSize}` : \"\"}`;\r\n        }\r\n        case \"RSASSA-PKCS1-V1_5\":\r\n            return `RS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\r\n        case \"RSA-PSS\":\r\n            return `PS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\r\n        case \"RSA-PKCS1\":\r\n            return `RS1`;\r\n        default:\r\n            throw new OperationError(\"algorithm: Is not recognized\");\r\n    }\r\n}\n\nclass RsaPrivateKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"private\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = AsnParser.parse(this.data, asn1.PrivateKeyInfo);\r\n        return AsnParser.parse(keyInfo.privateKey, asn1.RsaPrivateKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"RSA\",\r\n            alg: getJwkAlgorithm(this.algorithm),\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        const key = JsonParser.fromJSON(json, { targetSchema: asn1.RsaPrivateKey });\r\n        const keyInfo = new asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\r\n        keyInfo.privateKeyAlgorithm.parameters = null;\r\n        keyInfo.privateKey = AsnSerializer.serialize(key);\r\n        this.data = Buffer.from(AsnSerializer.serialize(keyInfo));\r\n    }\r\n}\n\nclass RsaPublicKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"public\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = AsnParser.parse(this.data, asn1.PublicKeyInfo);\r\n        return AsnParser.parse(keyInfo.publicKey, asn1.RsaPublicKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"RSA\",\r\n            alg: getJwkAlgorithm(this.algorithm),\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        const key = JsonParser.fromJSON(json, { targetSchema: asn1.RsaPublicKey });\r\n        const keyInfo = new asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\r\n        keyInfo.publicKeyAlgorithm.parameters = null;\r\n        keyInfo.publicKey = AsnSerializer.serialize(key);\r\n        this.data = Buffer.from(AsnSerializer.serialize(keyInfo));\r\n    }\r\n}\n\nclass RsaCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const privateKey = new RsaPrivateKey();\r\n        privateKey.algorithm = algorithm;\r\n        privateKey.extractable = extractable;\r\n        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);\r\n        const publicKey = new RsaPublicKey();\r\n        publicKey.algorithm = algorithm;\r\n        publicKey.extractable = true;\r\n        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);\r\n        const publicExponent = Buffer.concat([\r\n            Buffer.alloc(4 - algorithm.publicExponent.byteLength, 0),\r\n            Buffer.from(algorithm.publicExponent),\r\n        ]).readInt32BE(0);\r\n        const keys = crypto__default.generateKeyPairSync(\"rsa\", {\r\n            modulusLength: algorithm.modulusLength,\r\n            publicExponent,\r\n            publicKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"spki\",\r\n            },\r\n            privateKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"pkcs8\",\r\n            },\r\n        });\r\n        privateKey.data = keys.privateKey;\r\n        publicKey.data = keys.publicKey;\r\n        const res = {\r\n            privateKey,\r\n            publicKey,\r\n        };\r\n        return res;\r\n    }\r\n    static async exportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return JsonSerializer.toJSON(key);\r\n            case \"pkcs8\":\r\n            case \"spki\":\r\n                return new Uint8Array(key.data).buffer;\r\n            default:\r\n                throw new OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\": {\r\n                const jwk = keyData;\r\n                if (jwk.d) {\r\n                    const asnKey = JsonParser.fromJSON(keyData, { targetSchema: asn1.RsaPrivateKey });\r\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n                else {\r\n                    const asnKey = JsonParser.fromJSON(keyData, { targetSchema: asn1.RsaPublicKey });\r\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n            }\r\n            case \"spki\": {\r\n                const keyInfo = AsnParser.parse(new Uint8Array(keyData), asn1.PublicKeyInfo);\r\n                const asnKey = AsnParser.parse(keyInfo.publicKey, asn1.RsaPublicKey);\r\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"pkcs8\": {\r\n                const keyInfo = AsnParser.parse(new Uint8Array(keyData), asn1.PrivateKeyInfo);\r\n                const asnKey = AsnParser.parse(keyInfo.privateKey, asn1.RsaPrivateKey);\r\n                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            default:\r\n                throw new OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static async sign(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"RSA-PSS\":\r\n            case \"RSASSA-PKCS1-V1_5\":\r\n                return this.signRsa(algorithm, key, data);\r\n            default:\r\n                throw new OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async verify(algorithm, key, signature, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"RSA-PSS\":\r\n            case \"RSASSA-PKCS1-V1_5\":\r\n                return this.verifySSA(algorithm, key, data, signature);\r\n            default:\r\n                throw new OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async encrypt(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"RSA-OAEP\":\r\n                return this.encryptOAEP(algorithm, key, data);\r\n            default:\r\n                throw new OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async decrypt(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"RSA-OAEP\":\r\n                return this.decryptOAEP(algorithm, key, data);\r\n            default:\r\n                throw new OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const keyInfo = new asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\r\n        keyInfo.privateKeyAlgorithm.parameters = null;\r\n        keyInfo.privateKey = AsnSerializer.serialize(asnKey);\r\n        const key = new RsaPrivateKey();\r\n        key.data = Buffer.from(AsnSerializer.serialize(keyInfo));\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\r\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static importPublicKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const keyInfo = new asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\r\n        keyInfo.publicKeyAlgorithm.parameters = null;\r\n        keyInfo.publicKey = AsnSerializer.serialize(asnKey);\r\n        const key = new RsaPublicKey();\r\n        key.data = Buffer.from(AsnSerializer.serialize(keyInfo));\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\r\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static getCryptoAlgorithm(alg) {\r\n        switch (alg.hash.name.toUpperCase()) {\r\n            case \"SHA-1\":\r\n                return \"RSA-SHA1\";\r\n            case \"SHA-256\":\r\n                return \"RSA-SHA256\";\r\n            case \"SHA-384\":\r\n                return \"RSA-SHA384\";\r\n            case \"SHA-512\":\r\n                return \"RSA-SHA512\";\r\n            default:\r\n                throw new OperationError(\"algorithm.hash: Is not recognized\");\r\n        }\r\n    }\r\n    static signRsa(algorithm, key, data) {\r\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\r\n        const signer = crypto__default.createSign(cryptoAlg);\r\n        signer.update(Buffer.from(data));\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\r\n            options.padding = crypto__default.constants.RSA_PKCS1_PSS_PADDING;\r\n            options.saltLength = algorithm.saltLength;\r\n        }\r\n        const signature = signer.sign(options);\r\n        return new Uint8Array(signature).buffer;\r\n    }\r\n    static verifySSA(algorithm, key, data, signature) {\r\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\r\n        const signer = crypto__default.createVerify(cryptoAlg);\r\n        signer.update(Buffer.from(data));\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\r\n            options.padding = crypto__default.constants.RSA_PKCS1_PSS_PADDING;\r\n            options.saltLength = algorithm.saltLength;\r\n        }\r\n        const ok = signer.verify(options, signature);\r\n        return ok;\r\n    }\r\n    static encryptOAEP(algorithm, key, data) {\r\n        const options = {\r\n            key: `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`,\r\n            padding: crypto__default.constants.RSA_PKCS1_OAEP_PADDING,\r\n        };\r\n        if (algorithm.label) ;\r\n        return new Uint8Array(crypto__default.publicEncrypt(options, data)).buffer;\r\n    }\r\n    static decryptOAEP(algorithm, key, data) {\r\n        const options = {\r\n            key: `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`,\r\n            padding: crypto__default.constants.RSA_PKCS1_OAEP_PADDING,\r\n        };\r\n        if (algorithm.label) ;\r\n        return new Uint8Array(crypto__default.privateDecrypt(options, data)).buffer;\r\n    }\r\n}\r\nRsaCrypto.publicKeyUsages = [\"verify\", \"encrypt\", \"wrapKey\"];\r\nRsaCrypto.privateKeyUsages = [\"sign\", \"decrypt\", \"unwrapKey\"];\n\nclass RsaSsaProvider extends RsaSsaProvider$1 {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await RsaCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\r\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass RsaPssProvider extends RsaPssProvider$1 {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await RsaCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\r\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass ShaCrypto {\r\n    static size(algorithm) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"SHA-1\":\r\n                return 160;\r\n            case \"SHA-256\":\r\n                return 256;\r\n            case \"SHA-384\":\r\n                return 384;\r\n            case \"SHA-512\":\r\n                return 512;\r\n            default:\r\n                throw new Error(\"Unrecognized name\");\r\n        }\r\n    }\r\n    static digest(algorithm, data) {\r\n        const hash = crypto__default.createHash(algorithm.name.replace(\"-\", \"\"))\r\n            .update(Buffer.from(data)).digest();\r\n        return new Uint8Array(hash).buffer;\r\n    }\r\n}\n\nclass RsaOaepProvider extends RsaOaepProvider$1 {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await RsaCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        const internalKey = getCryptoKey(key);\r\n        const dataView = new Uint8Array(data);\r\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\r\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\r\n        const dataLength = dataView.byteLength;\r\n        const psLength = keySize - dataLength - 2 * hashSize - 2;\r\n        if (dataLength > keySize - 2 * hashSize - 2) {\r\n            throw new Error(\"Data too large\");\r\n        }\r\n        const message = new Uint8Array(keySize);\r\n        const seed = message.subarray(1, hashSize + 1);\r\n        const dataBlock = message.subarray(hashSize + 1);\r\n        dataBlock.set(dataView, hashSize + psLength + 1);\r\n        const labelHash = crypto__default.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\"))\r\n            .update(BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0)))\r\n            .digest();\r\n        dataBlock.set(labelHash, 0);\r\n        dataBlock[hashSize + psLength] = 1;\r\n        crypto__default.randomFillSync(seed);\r\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\r\n        for (let i = 0; i < dataBlock.length; i++) {\r\n            dataBlock[i] ^= dataBlockMask[i];\r\n        }\r\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\r\n        for (let i = 0; i < seed.length; i++) {\r\n            seed[i] ^= seedMask[i];\r\n        }\r\n        if (!internalKey.pem) {\r\n            internalKey.pem = `-----BEGIN PUBLIC KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\r\n        }\r\n        const pkcs0 = crypto__default.publicEncrypt({\r\n            key: internalKey.pem,\r\n            padding: crypto__default.constants.RSA_NO_PADDING,\r\n        }, Buffer.from(message));\r\n        return new Uint8Array(pkcs0).buffer;\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        const internalKey = getCryptoKey(key);\r\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\r\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\r\n        const dataLength = data.byteLength;\r\n        if (dataLength !== keySize) {\r\n            throw new Error(\"Bad data\");\r\n        }\r\n        if (!internalKey.pem) {\r\n            internalKey.pem = `-----BEGIN PRIVATE KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\r\n        }\r\n        let pkcs0 = crypto__default.privateDecrypt({\r\n            key: internalKey.pem,\r\n            padding: crypto__default.constants.RSA_NO_PADDING,\r\n        }, Buffer.from(data));\r\n        const z = pkcs0[0];\r\n        const seed = pkcs0.subarray(1, hashSize + 1);\r\n        const dataBlock = pkcs0.subarray(hashSize + 1);\r\n        if (z !== 0) {\r\n            throw new Error(\"Decryption failed\");\r\n        }\r\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\r\n        for (let i = 0; i < seed.length; i++) {\r\n            seed[i] ^= seedMask[i];\r\n        }\r\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\r\n        for (let i = 0; i < dataBlock.length; i++) {\r\n            dataBlock[i] ^= dataBlockMask[i];\r\n        }\r\n        const labelHash = crypto__default.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\"))\r\n            .update(BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0)))\r\n            .digest();\r\n        for (let i = 0; i < hashSize; i++) {\r\n            if (labelHash[i] !== dataBlock[i]) {\r\n                throw new Error(\"Decryption failed\");\r\n            }\r\n        }\r\n        let psEnd = hashSize;\r\n        for (; psEnd < dataBlock.length; psEnd++) {\r\n            const psz = dataBlock[psEnd];\r\n            if (psz === 1) {\r\n                break;\r\n            }\r\n            if (psz !== 0) {\r\n                throw new Error(\"Decryption failed\");\r\n            }\r\n        }\r\n        if (psEnd === dataBlock.length) {\r\n            throw new Error(\"Decryption failed\");\r\n        }\r\n        pkcs0 = dataBlock.subarray(psEnd + 1);\r\n        return new Uint8Array(pkcs0).buffer;\r\n    }\r\n    async onExportKey(format, key) {\r\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\r\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\r\n        }\r\n    }\r\n    mgf1(algorithm, seed, length = 0) {\r\n        const hashSize = ShaCrypto.size(algorithm) >> 3;\r\n        const mask = new Uint8Array(length);\r\n        const counter = new Uint8Array(4);\r\n        const chunks = Math.ceil(length / hashSize);\r\n        for (let i = 0; i < chunks; i++) {\r\n            counter[0] = i >>> 24;\r\n            counter[1] = (i >>> 16) & 255;\r\n            counter[2] = (i >>> 8) & 255;\r\n            counter[3] = i & 255;\r\n            const submask = mask.subarray(i * hashSize);\r\n            let chunk = crypto__default.createHash(algorithm.name.replace(\"-\", \"\"))\r\n                .update(seed)\r\n                .update(counter)\r\n                .digest();\r\n            if (chunk.length > submask.length) {\r\n                chunk = chunk.subarray(0, submask.length);\r\n            }\r\n            submask.set(chunk);\r\n        }\r\n        return mask;\r\n    }\r\n}\n\nclass RsaEsProvider extends ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"RSAES-PKCS1-v1_5\";\r\n        this.usages = {\r\n            publicKey: [\"encrypt\", \"wrapKey\"],\r\n            privateKey: [\"decrypt\", \"unwrapKey\"],\r\n        };\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await RsaCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    checkGenerateKeyParams(algorithm) {\r\n        this.checkRequiredProperty(algorithm, \"publicExponent\");\r\n        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {\r\n            throw new TypeError(\"publicExponent: Missing or not a Uint8Array\");\r\n        }\r\n        const publicExponent = Convert.ToBase64(algorithm.publicExponent);\r\n        if (!(publicExponent === \"Aw==\" || publicExponent === \"AQAB\")) {\r\n            throw new TypeError(\"publicExponent: Must be [3] or [1,0,1]\");\r\n        }\r\n        this.checkRequiredProperty(algorithm, \"modulusLength\");\r\n        switch (algorithm.modulusLength) {\r\n            case 1024:\r\n            case 2048:\r\n            case 4096:\r\n                break;\r\n            default:\r\n                throw new TypeError(\"modulusLength: Must be 1024, 2048, or 4096\");\r\n        }\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        const options = this.toCryptoOptions(key);\r\n        const enc = publicEncrypt(options, new Uint8Array(data));\r\n        return new Uint8Array(enc).buffer;\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        const options = this.toCryptoOptions(key);\r\n        const dec = privateDecrypt(options, new Uint8Array(data));\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    async onExportKey(format, key) {\r\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\r\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\r\n        }\r\n    }\r\n    toCryptoOptions(key) {\r\n        const type = key.type.toUpperCase();\r\n        return {\r\n            key: `-----BEGIN ${type} KEY-----\\n${getCryptoKey(key).data.toString(\"base64\")}\\n-----END ${type} KEY-----`,\r\n            padding: constants.RSA_PKCS1_PADDING,\r\n        };\r\n    }\r\n}\n\nconst namedOIDs = {\r\n    \"1.2.840.10045.3.1.7\": \"P-256\",\r\n    \"P-256\": \"1.2.840.10045.3.1.7\",\r\n    \"1.3.132.0.34\": \"P-384\",\r\n    \"P-384\": \"1.3.132.0.34\",\r\n    \"1.3.132.0.35\": \"P-521\",\r\n    \"P-521\": \"1.3.132.0.35\",\r\n    \"1.3.132.0.10\": \"K-256\",\r\n    \"K-256\": \"1.3.132.0.10\",\r\n};\r\nfunction getOidByNamedCurve(namedCurve) {\r\n    const oid = namedOIDs[namedCurve];\r\n    if (!oid) {\r\n        throw new OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\r\n    }\r\n    return oid;\r\n}\n\nclass EcPrivateKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"private\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = AsnParser.parse(this.data, asn1.PrivateKeyInfo);\r\n        return AsnParser.parse(keyInfo.privateKey, asn1.EcPrivateKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"EC\",\r\n            crv: this.algorithm.namedCurve,\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        if (!json.crv) {\r\n            throw new OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\r\n        }\r\n        const keyInfo = new asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\r\n        keyInfo.privateKeyAlgorithm.parameters = AsnSerializer.serialize(new asn1.ObjectIdentifier(getOidByNamedCurve(json.crv)));\r\n        const key = JsonParser.fromJSON(json, { targetSchema: asn1.EcPrivateKey });\r\n        keyInfo.privateKey = AsnSerializer.serialize(key);\r\n        this.data = Buffer.from(AsnSerializer.serialize(keyInfo));\r\n        return this;\r\n    }\r\n}\n\nclass EcPublicKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"public\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = AsnParser.parse(this.data, asn1.PublicKeyInfo);\r\n        return new asn1.EcPublicKey(keyInfo.publicKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"EC\",\r\n            crv: this.algorithm.namedCurve,\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        if (!json.crv) {\r\n            throw new OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\r\n        }\r\n        const key = JsonParser.fromJSON(json, { targetSchema: asn1.EcPublicKey });\r\n        const keyInfo = new asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\r\n        keyInfo.publicKeyAlgorithm.parameters = AsnSerializer.serialize(new asn1.ObjectIdentifier(getOidByNamedCurve(json.crv)));\r\n        keyInfo.publicKey = AsnSerializer.toASN(key).valueHex;\r\n        this.data = Buffer.from(AsnSerializer.serialize(keyInfo));\r\n        return this;\r\n    }\r\n}\n\nclass EcCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const privateKey = new EcPrivateKey();\r\n        privateKey.algorithm = algorithm;\r\n        privateKey.extractable = extractable;\r\n        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);\r\n        const publicKey = new EcPublicKey();\r\n        publicKey.algorithm = algorithm;\r\n        publicKey.extractable = true;\r\n        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);\r\n        const keys = crypto__default.generateKeyPairSync(\"ec\", {\r\n            namedCurve: this.getOpenSSLNamedCurve(algorithm.namedCurve),\r\n            publicKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"spki\",\r\n            },\r\n            privateKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"pkcs8\",\r\n            },\r\n        });\r\n        privateKey.data = keys.privateKey;\r\n        publicKey.data = keys.publicKey;\r\n        const res = {\r\n            privateKey,\r\n            publicKey,\r\n        };\r\n        return res;\r\n    }\r\n    static async sign(algorithm, key, data) {\r\n        const cryptoAlg = algorithm.hash.name.replace(\"-\", \"\");\r\n        const signer = crypto__default.createSign(cryptoAlg);\r\n        signer.update(Buffer.from(data));\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        const signature = signer.sign(options);\r\n        const ecSignature = AsnParser.parse(signature, asn1.EcDsaSignature);\r\n        const pointSize = this.getPointSize(key.algorithm.namedCurve);\r\n        const r = this.addPadding(pointSize, Buffer.from(ecSignature.r));\r\n        const s = this.addPadding(pointSize, Buffer.from(ecSignature.s));\r\n        const signatureRaw = new Uint8Array(Buffer.concat([r, s])).buffer;\r\n        return signatureRaw;\r\n    }\r\n    static async verify(algorithm, key, signature, data) {\r\n        const cryptoAlg = algorithm.hash.name.replace(\"-\", \"\");\r\n        const signer = crypto__default.createVerify(cryptoAlg);\r\n        signer.update(Buffer.from(data));\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        const ecSignature = new asn1.EcDsaSignature();\r\n        const pointSize = this.getPointSize(key.algorithm.namedCurve);\r\n        ecSignature.r = this.removePadding(signature.slice(0, pointSize));\r\n        ecSignature.s = this.removePadding(signature.slice(pointSize, pointSize + pointSize));\r\n        const ecSignatureRaw = Buffer.from(AsnSerializer.serialize(ecSignature));\r\n        const ok = signer.verify(options, ecSignatureRaw);\r\n        return ok;\r\n    }\r\n    static async deriveBits(algorithm, baseKey, length) {\r\n        const cryptoAlg = this.getOpenSSLNamedCurve(baseKey.algorithm.namedCurve);\r\n        const ecdh = crypto__default.createECDH(cryptoAlg);\r\n        const asnPrivateKey = AsnParser.parse(baseKey.data, asn1.PrivateKeyInfo);\r\n        const asnEcPrivateKey = AsnParser.parse(asnPrivateKey.privateKey, asn1.EcPrivateKey);\r\n        ecdh.setPrivateKey(Buffer.from(asnEcPrivateKey.privateKey));\r\n        const asnPublicKey = AsnParser.parse(algorithm.public.data, asn1.PublicKeyInfo);\r\n        const bits = ecdh.computeSecret(Buffer.from(asnPublicKey.publicKey));\r\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\r\n    }\r\n    static async exportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return JsonSerializer.toJSON(key);\r\n            case \"pkcs8\":\r\n            case \"spki\":\r\n                return new Uint8Array(key.data).buffer;\r\n            case \"raw\": {\r\n                const publicKeyInfo = AsnParser.parse(key.data, asn1.PublicKeyInfo);\r\n                return publicKeyInfo.publicKey;\r\n            }\r\n            default:\r\n                throw new OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\": {\r\n                const jwk = keyData;\r\n                if (jwk.d) {\r\n                    const asnKey = JsonParser.fromJSON(keyData, { targetSchema: asn1.EcPrivateKey });\r\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n                else {\r\n                    const asnKey = JsonParser.fromJSON(keyData, { targetSchema: asn1.EcPublicKey });\r\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n            }\r\n            case \"raw\": {\r\n                const asnKey = new asn1.EcPublicKey(keyData);\r\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"spki\": {\r\n                const keyInfo = AsnParser.parse(new Uint8Array(keyData), asn1.PublicKeyInfo);\r\n                const asnKey = new asn1.EcPublicKey(keyInfo.publicKey);\r\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"pkcs8\": {\r\n                const keyInfo = AsnParser.parse(new Uint8Array(keyData), asn1.PrivateKeyInfo);\r\n                const asnKey = AsnParser.parse(keyInfo.privateKey, asn1.EcPrivateKey);\r\n                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            default:\r\n                throw new OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static async importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const keyInfo = new asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\r\n        keyInfo.privateKeyAlgorithm.parameters = AsnSerializer.serialize(new asn1.ObjectIdentifier(getOidByNamedCurve(algorithm.namedCurve)));\r\n        keyInfo.privateKey = AsnSerializer.serialize(asnKey);\r\n        const key = new EcPrivateKey();\r\n        key.data = Buffer.from(AsnSerializer.serialize(keyInfo));\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const keyInfo = new asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\r\n        keyInfo.publicKeyAlgorithm.parameters = AsnSerializer.serialize(new asn1.ObjectIdentifier(getOidByNamedCurve(algorithm.namedCurve)));\r\n        keyInfo.publicKey = asnKey.value;\r\n        const key = new EcPublicKey();\r\n        key.data = Buffer.from(AsnSerializer.serialize(keyInfo));\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static getOpenSSLNamedCurve(curve) {\r\n        switch (curve.toUpperCase()) {\r\n            case \"P-256\":\r\n                return \"prime256v1\";\r\n            case \"K-256\":\r\n                return \"secp256k1\";\r\n            case \"P-384\":\r\n                return \"secp384r1\";\r\n            case \"P-521\":\r\n                return \"secp521r1\";\r\n            default:\r\n                throw new OperationError(`Cannot convert WebCrypto named curve to NodeJs. Unknown name '${curve}'`);\r\n        }\r\n    }\r\n    static getPointSize(namedCurve) {\r\n        switch (namedCurve) {\r\n            case \"P-256\":\r\n            case \"K-256\":\r\n                return 32;\r\n            case \"P-384\":\r\n                return 48;\r\n            case \"P-521\":\r\n                return 66;\r\n            default:\r\n                throw new Error(`Cannot get size for the named curve '${namedCurve}'`);\r\n        }\r\n    }\r\n    static addPadding(pointSize, bytes) {\r\n        const res = Buffer.alloc(pointSize);\r\n        res.set(Buffer.from(bytes), pointSize - bytes.length);\r\n        return res;\r\n    }\r\n    static removePadding(bytes) {\r\n        for (let i = 0; i < bytes.length; i++) {\r\n            if (!bytes[i]) {\r\n                continue;\r\n            }\r\n            return bytes.slice(i).buffer;\r\n        }\r\n        return new ArrayBuffer(0);\r\n    }\r\n}\r\nEcCrypto.publicKeyUsages = [\"verify\"];\r\nEcCrypto.privateKeyUsages = [\"sign\", \"deriveKey\", \"deriveBits\"];\n\nclass EcdsaProvider extends EcdsaProvider$1 {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.namedCurves = [\"P-256\", \"P-384\", \"P-521\", \"K-256\"];\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await EcCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        return EcCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        return EcCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return EcCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\r\n            throw new TypeError(\"key: Is not EC CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass EcdhProvider extends EcdhProvider$1 {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await EcCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onExportKey(format, key) {\r\n        return EcCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\r\n            throw new TypeError(\"key: Is not EC CryptoKey\");\r\n        }\r\n    }\r\n    async onDeriveBits(algorithm, baseKey, length) {\r\n        const bits = await EcCrypto.deriveBits({ ...algorithm, public: getCryptoKey(algorithm.public) }, getCryptoKey(baseKey), length);\r\n        return bits;\r\n    }\r\n}\n\nclass Sha1Provider extends ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA-1\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha256Provider extends ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA-256\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha384Provider extends ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA-384\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha512Provider extends ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA-512\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass PbkdfCryptoKey extends CryptoKey {\r\n}\n\nclass Pbkdf2Provider extends Pbkdf2Provider$1 {\r\n    async onDeriveBits(algorithm, baseKey, length) {\r\n        return new Promise((resolve, reject) => {\r\n            const salt = BufferSourceConverter.toArrayBuffer(algorithm.salt);\r\n            const hash = algorithm.hash.name.replace(\"-\", \"\");\r\n            crypto__default.pbkdf2(getCryptoKey(baseKey).data, Buffer.from(salt), algorithm.iterations, length >> 3, hash, (err, derivedBits) => {\r\n                if (err) {\r\n                    reject(err);\r\n                }\r\n                else {\r\n                    resolve(new Uint8Array(derivedBits).buffer);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        if (format === \"raw\") {\r\n            const key = new PbkdfCryptoKey();\r\n            key.data = Buffer.from(keyData);\r\n            key.algorithm = { name: this.name };\r\n            key.extractable = false;\r\n            key.usages = keyUsages;\r\n            return setCryptoKey(key);\r\n        }\r\n        throw new OperationError(\"format: Must be 'raw'\");\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof PbkdfCryptoKey)) {\r\n            throw new TypeError(\"key: Is not PBKDF CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass HmacCryptoKey extends CryptoKey {\r\n    get alg() {\r\n        const hash = this.algorithm.hash.name.toUpperCase();\r\n        return `HS${hash.replace(\"SHA-\", \"\")}`;\r\n    }\r\n    set alg(value) {\r\n    }\r\n}\r\n__decorate([\r\n    JsonProp({ name: \"k\", converter: JsonBase64UrlConverter })\r\n], HmacCryptoKey.prototype, \"data\", void 0);\n\nclass HmacProvider extends HmacProvider$1 {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const length = algorithm.length || this.getDefaultLength(algorithm.hash.name);\r\n        const key = new HmacCryptoKey();\r\n        key.algorithm = {\r\n            ...algorithm,\r\n            name: this.name,\r\n        };\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        key.data = crypto__default.randomBytes(length >> 3);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        const hash = key.algorithm.hash.name.replace(\"-\", \"\");\r\n        const hmac = crypto__default.createHmac(hash, getCryptoKey(key).data)\r\n            .update(Buffer.from(data)).digest();\r\n        return new Uint8Array(hmac).buffer;\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        const hash = key.algorithm.hash.name.replace(\"-\", \"\");\r\n        const hmac = crypto__default.createHmac(hash, getCryptoKey(key).data)\r\n            .update(Buffer.from(data)).digest();\r\n        return hmac.compare(Buffer.from(signature)) === 0;\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        let key;\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                key = JsonParser.fromJSON(keyData, { targetSchema: HmacCryptoKey });\r\n                break;\r\n            case \"raw\":\r\n                key = new HmacCryptoKey();\r\n                key.data = Buffer.from(keyData);\r\n                break;\r\n            default:\r\n                throw new OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n        key.algorithm = {\r\n            hash: { name: algorithm.hash.name },\r\n            name: this.name,\r\n            length: key.data.length << 3,\r\n        };\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return setCryptoKey(key);\r\n    }\r\n    async onExportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return JsonSerializer.toJSON(getCryptoKey(key));\r\n            case \"raw\":\r\n                return new Uint8Array(getCryptoKey(key).data).buffer;\r\n            default:\r\n                throw new OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof HmacCryptoKey)) {\r\n            throw new TypeError(\"key: Is not HMAC CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass HkdfCryptoKey extends CryptoKey {\r\n}\n\nclass HkdfProvider extends HkdfProvider$1 {\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        if (format.toLowerCase() !== \"raw\") {\r\n            throw new OperationError(\"Operation not supported\");\r\n        }\r\n        const key = new HkdfCryptoKey();\r\n        key.data = Buffer.from(keyData);\r\n        key.algorithm = { name: this.name };\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return setCryptoKey(key);\r\n    }\r\n    async onDeriveBits(params, baseKey, length) {\r\n        const hash = params.hash.name.replace(\"-\", \"\");\r\n        const hashLength = crypto__default.createHash(hash).digest().length;\r\n        const byteLength = length / 8;\r\n        const info = BufferSourceConverter.toUint8Array(params.info);\r\n        const PRK = crypto__default.createHmac(hash, BufferSourceConverter.toUint8Array(params.salt))\r\n            .update(BufferSourceConverter.toUint8Array(getCryptoKey(baseKey).data))\r\n            .digest();\r\n        const blocks = [Buffer.alloc(0)];\r\n        const blockCount = Math.ceil(byteLength / hashLength) + 1;\r\n        for (let i = 1; i < blockCount; ++i) {\r\n            blocks.push(crypto__default.createHmac(hash, PRK)\r\n                .update(Buffer.concat([blocks[i - 1], info, Buffer.from([i])]))\r\n                .digest());\r\n        }\r\n        return Buffer.concat(blocks).slice(0, byteLength);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof HkdfCryptoKey)) {\r\n            throw new TypeError(\"key: Is not HKDF CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass SubtleCrypto extends SubtleCrypto$1 {\r\n    constructor() {\r\n        super();\r\n        this.providers.set(new AesCbcProvider());\r\n        this.providers.set(new AesCtrProvider());\r\n        this.providers.set(new AesGcmProvider());\r\n        this.providers.set(new AesCmacProvider());\r\n        this.providers.set(new AesKwProvider());\r\n        this.providers.set(new AesEcbProvider());\r\n        this.providers.set(new DesCbcProvider());\r\n        this.providers.set(new DesEde3CbcProvider());\r\n        this.providers.set(new RsaSsaProvider());\r\n        this.providers.set(new RsaPssProvider());\r\n        this.providers.set(new RsaOaepProvider());\r\n        this.providers.set(new RsaEsProvider());\r\n        this.providers.set(new EcdsaProvider());\r\n        this.providers.set(new EcdhProvider());\r\n        this.providers.set(new Sha1Provider());\r\n        this.providers.set(new Sha256Provider());\r\n        this.providers.set(new Sha384Provider());\r\n        this.providers.set(new Sha512Provider());\r\n        this.providers.set(new Pbkdf2Provider());\r\n        this.providers.set(new HmacProvider());\r\n        this.providers.set(new HkdfProvider());\r\n    }\r\n}\n\nclass Crypto {\r\n    constructor() {\r\n        this.subtle = new SubtleCrypto();\r\n    }\r\n    getRandomValues(array) {\r\n        const buffer = Buffer.from(array.buffer);\r\n        crypto__default.randomFillSync(buffer);\r\n        return array;\r\n    }\r\n}\n\nexport { Crypto };\n"]},"metadata":{},"sourceType":"module"}