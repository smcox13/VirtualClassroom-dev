{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TIMEOUT_SYMBOL = undefined;\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _symbol = require('babel-runtime/core-js/symbol');\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _commonTimers = require('@webex/common-timers');\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _kmsErrors = require('./kms-errors');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar TIMEOUT_SYMBOL = exports.TIMEOUT_SYMBOL = (0, _symbol2.default)('TIMEOUT_SYMBOL');\n/**\n * @class\n */\n\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nvar KmsBatcher = _webexCore.Batcher.extend({\n  namespace: 'Encryption',\n\n  /**\n   * Accepts a kmsMessage event and passes its contents to acceptItem\n   * @param {Object} event\n   * @returns {Promise}\n   */\n  processKmsMessageEvent: function processKmsMessageEvent(event) {\n    var _this = this;\n\n    this.logger.info('kms-batcher: received kms message');\n    return _promise2.default.all(event.encryption.kmsMessages.map(function (kmsMessage) {\n      return new _promise2.default(function (resolve) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n          _this.logger.info('kms-batcher:', kmsMessage.body);\n        }\n\n        resolve(_this.acceptItem(kmsMessage));\n      });\n    }));\n  },\n\n  /**\n   * Attaches a timeout to the given KMS message\n   * @param {Object} item\n   * @returns {Promise<Object>}\n   */\n  prepareItem: function prepareItem(item) {\n    var _this2 = this;\n\n    return this.getDeferredForRequest(item).then(function (defer) {\n      var timeout = item[TIMEOUT_SYMBOL];\n      /* istanbul ignore if */\n\n      if (!timeout) {\n        throw new Error('timeout is required');\n      }\n\n      var timer = (0, _commonTimers.safeSetTimeout)(function () {\n        _this2.logger.warn('kms: request timed out; request id: ' + item.requestId + '; timeout: ' + timeout);\n\n        _this2.handleItemFailure(item, new _kmsErrors.KmsTimeoutError({\n          timeout: timeout,\n          request: item\n        }));\n      }, timeout); // Reminder: reassign `promise` is not a viable means of inserting into\n      // the Promise chain\n\n      defer.promise.then(function () {\n        return clearTimeout(timer);\n      });\n      defer.promise.catch(function () {\n        return clearTimeout(timer);\n      });\n      return item;\n    });\n  },\n\n  /**\n   * Attaches the final bits of cluster info to the payload\n   * @param {Array} queue\n   * @returns {Promise<Array>}\n   */\n  prepareRequest: function prepareRequest(queue) {\n    return this.webex.internal.encryption.kms._getKMSCluster().then(function (cluster) {\n      return {\n        destination: cluster,\n        kmsMessages: queue.map(function (req) {\n          return req.wrapped;\n        })\n      };\n    });\n  },\n\n  /**\n   * @param {Object} payload\n   * @returns {Promise<HttpResponseObject>}\n   */\n  submitHttpRequest: function submitHttpRequest(payload) {\n    this.logger.info('kms: batched-request-length', payload.kmsMessages.length);\n    return this.webex.request({\n      method: 'POST',\n      service: 'encryption',\n      resource: '/kms/messages',\n      body: payload\n    });\n  },\n\n  /**\n   * Does nothing; the http response doesn't carry our response data\n   * @returns {Promise}\n   */\n  handleHttpSuccess: function handleHttpSuccess() {\n    return _promise2.default.resolve();\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise<boolean>}\n   */\n  didItemFail: function didItemFail(item) {\n    return _promise2.default.resolve(item.status >= 400);\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise}\n   */\n  handleItemSuccess: function handleItemSuccess(item) {\n    return this.getDeferredForResponse(item).then(function (defer) {\n      defer.resolve(item.body);\n    });\n  },\n\n  /**\n   * @param {Object} item\n   * @param {KmsError} [reason]\n   * @returns {Promise}\n   */\n  handleItemFailure: function handleItemFailure(item, reason) {\n    return this.getDeferredForResponse(item).then(function (defer) {\n      defer.reject(reason || new _kmsErrors.KmsError(item.body));\n    });\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise}\n   */\n  fingerprintRequest: function fingerprintRequest(item) {\n    return _promise2.default.resolve(item.requestId);\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise}\n   */\n  fingerprintResponse: function fingerprintResponse(item) {\n    return _promise2.default.resolve(item.requestId);\n  }\n});\n\nexports.default = KmsBatcher;","map":{"version":3,"sources":["kms-batcher.js"],"names":["TIMEOUT_SYMBOL","KmsBatcher","namespace","processKmsMessageEvent","process","kmsMessage","resolve","prepareItem","timeout","item","timer","KmsTimeoutError","request","defer","clearTimeout","prepareRequest","destination","kmsMessages","req","submitHttpRequest","payload","method","service","resource","body","handleHttpSuccess","didItemFail","handleItemSuccess","handleItemFailure","reason","KmsError","fingerprintRequest","fingerprintResponse"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {safeSetTimeout} from '@webex/common-timers';\nimport {Batcher} from '@webex/webex-core';\nimport {KmsError, KmsTimeoutError} from './kms-errors';\n\nexport const TIMEOUT_SYMBOL = Symbol('TIMEOUT_SYMBOL');\n\n/**\n * @class\n */\nconst KmsBatcher = Batcher.extend({\n  namespace: 'Encryption',\n\n  /**\n   * Accepts a kmsMessage event and passes its contents to acceptItem\n   * @param {Object} event\n   * @returns {Promise}\n   */\n  processKmsMessageEvent(event) {\n    this.logger.info('kms-batcher: received kms message');\n\n    return Promise.all(event.encryption.kmsMessages.map((kmsMessage) => new Promise((resolve) => {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.info('kms-batcher:', kmsMessage.body);\n      }\n\n      resolve(this.acceptItem(kmsMessage));\n    })));\n  },\n\n  /**\n   * Attaches a timeout to the given KMS message\n   * @param {Object} item\n   * @returns {Promise<Object>}\n   */\n  prepareItem(item) {\n    return this.getDeferredForRequest(item)\n      .then((defer) => {\n        const timeout = item[TIMEOUT_SYMBOL];\n\n        /* istanbul ignore if */\n        if (!timeout) {\n          throw new Error('timeout is required');\n        }\n\n        const timer = safeSetTimeout(() => {\n          this.logger.warn(`kms: request timed out; request id: ${item.requestId}; timeout: ${timeout}`);\n          this.handleItemFailure(item, new KmsTimeoutError({\n            timeout,\n            request: item\n          }));\n        }, timeout);\n\n        // Reminder: reassign `promise` is not a viable means of inserting into\n        // the Promise chain\n        defer.promise.then(() => clearTimeout(timer));\n        defer.promise.catch(() => clearTimeout(timer));\n\n        return item;\n      });\n  },\n\n  /**\n   * Attaches the final bits of cluster info to the payload\n   * @param {Array} queue\n   * @returns {Promise<Array>}\n   */\n  prepareRequest(queue) {\n    return this.webex.internal.encryption.kms._getKMSCluster()\n      .then((cluster) => ({\n        destination: cluster,\n        kmsMessages: queue.map((req) => req.wrapped)\n      }));\n  },\n\n  /**\n   * @param {Object} payload\n   * @returns {Promise<HttpResponseObject>}\n   */\n  submitHttpRequest(payload) {\n    this.logger.info('kms: batched-request-length', payload.kmsMessages.length);\n\n    return this.webex.request({\n      method: 'POST',\n      service: 'encryption',\n      resource: '/kms/messages',\n      body: payload\n    });\n  },\n\n  /**\n   * Does nothing; the http response doesn't carry our response data\n   * @returns {Promise}\n   */\n  handleHttpSuccess() {\n    return Promise.resolve();\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise<boolean>}\n   */\n  didItemFail(item) {\n    return Promise.resolve(item.status >= 400);\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise}\n   */\n  handleItemSuccess(item) {\n    return this.getDeferredForResponse(item)\n      .then((defer) => {\n        defer.resolve(item.body);\n      });\n  },\n\n  /**\n   * @param {Object} item\n   * @param {KmsError} [reason]\n   * @returns {Promise}\n   */\n  handleItemFailure(item, reason) {\n    return this.getDeferredForResponse(item)\n      .then((defer) => {\n        defer.reject(reason || new KmsError(item.body));\n      });\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise}\n   */\n  fingerprintRequest(item) {\n    return Promise.resolve(item.requestId);\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise}\n   */\n  fingerprintResponse(item) {\n    return Promise.resolve(item.requestId);\n  }\n});\n\nexport default KmsBatcher;\n"]},"metadata":{},"sourceType":"script"}