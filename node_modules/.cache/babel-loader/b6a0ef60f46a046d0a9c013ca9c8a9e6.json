{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');\n\nvar _deleteProperty2 = _interopRequireDefault(_deleteProperty);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _httpCore = require('@webex/http-core');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * @class\n */\n\n\nvar AuthInterceptor = function (_Interceptor) {\n  (0, _inherits3.default)(AuthInterceptor, _Interceptor);\n\n  function AuthInterceptor() {\n    (0, _classCallCheck3.default)(this, AuthInterceptor);\n    return (0, _possibleConstructorReturn3.default)(this, (AuthInterceptor.__proto__ || (0, _getPrototypeOf2.default)(AuthInterceptor)).apply(this, arguments));\n  }\n\n  (0, _createClass3.default)(AuthInterceptor, [{\n    key: 'onRequest',\n\n    /**\n     * @see {@link Interceptor#onRequest}\n     * @param {Object} options\n     * @returns {Object}\n     */\n    value: function onRequest(options) {\n      var _this2 = this;\n\n      options.headers = options.headers || {}; // If Authorizations is already set, don't overwrite it\n\n      if ('authorization' in options.headers || 'auth' in options) {\n        // If Authorization is set to null, false, or undefined, delete it to\n        // prevent a CORS preflight.\n        if (!options.headers.authorization) {\n          (0, _deleteProperty2.default)(options.headers, 'authorization');\n        }\n\n        return _promise2.default.resolve(options);\n      }\n\n      return this.requiresCredentials(options).then(function (requires) {\n        if (!requires) {\n          return options;\n        }\n\n        return _this2.webex.credentials.getUserToken().then(function (token) {\n          options.headers.authorization = token.toString();\n          return options;\n        });\n      });\n    }\n    /**\n     * Determines if the provided options object needs an authorization header.\n     *\n     * @param {Object} options\n     * @returns {Promise<boolean>}\n     */\n\n  }, {\n    key: 'requiresCredentials',\n    value: function requiresCredentials(options) {\n      var _this3 = this; // Validate that authorization is necessary.\n\n\n      if (options.addAuthHeader === false) {\n        return _promise2.default.resolve(false);\n      } // Validate that the services plugin has been loaded before proceeding.\n\n\n      if (!this.webex.internal.services) {\n        return _promise2.default.resolve(false);\n      } // Destructure webex instance to isolate services plugin.\n\n\n      var services = this.webex.internal.services; // Store the current service details if available and destructure details.\n\n      var details = services.getServiceFromUrl(options.uri || '');\n\n      var _ref = details || {},\n          name = _ref.name;\n\n      var resource = options.resource,\n          uri = options.uri;\n      var service = options.service || options.api;\n\n      if (service && service === 'web-authentication' || name && name === 'web-authentication') {\n        return _promise2.default.resolve(false);\n      } // Unique validation for the u2c service.\n\n\n      if (service && service === 'u2c' || name && name === 'u2c') {\n        if (resource && resource.includes('limited') || uri && uri.includes('limited')) {\n          return _promise2.default.resolve(false);\n        }\n\n        return _promise2.default.resolve(true);\n      } // Validate that the allowed domains can be utilized.\n\n\n      if (services.validateDomains && services.hasAllowedDomains() && uri && services.isAllowedDomainUrl(uri)) {\n        return _promise2.default.resolve(true);\n      } // Perform an additional validation in case the service does not exist yet.\n\n\n      return services.waitForService({\n        name: service,\n        url: uri\n      }).then(function (detectedUrl) {\n        // Validate that the url exists in the catalog.\n        if (services.getServiceFromUrl(detectedUrl)) {\n          return true;\n        } // Return false to indicate authentication is not required.\n\n\n        return false;\n      }).catch(function (error) {\n        _this3.webex.logger.warn('auth-interceptor: failed to validate service exists in catalog', error);\n\n        return false;\n      });\n    }\n    /**\n     * @see {@link Interceptor#onResponseError}\n     * @param {Object} options\n     * @param {Error} reason\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'onResponseError',\n    value: function onResponseError(options, reason) {\n      var _this4 = this;\n\n      return this.shouldAttemptReauth(reason, options).then(function (shouldAttemptReauth) {\n        if (shouldAttemptReauth) {\n          _this4.webex.logger.info('auth: received 401, attempting to reauthenticate');\n\n          if (reason.options.headers) {\n            (0, _deleteProperty2.default)(reason.options.headers, 'authorization');\n          }\n\n          if (_this4.webex.credentials.canRefresh) {\n            return _this4.webex.credentials.refresh().then(function () {\n              return _this4.replay(options);\n            });\n          }\n        }\n\n        return _promise2.default.reject(reason);\n      });\n    }\n    /**\n     * Replays the request\n     * @param {Object} options\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'replay',\n    value: function replay(options) {\n      if (options.replayCount) {\n        options.replayCount += 1;\n      } else {\n        options.replayCount = 1;\n      }\n\n      if (options.replayCount > this.webex.config.maxAuthenticationReplays) {\n        this.webex.logger.error('auth: failed after ' + this.webex.config.maxAuthenticationReplays + ' replay attempts');\n        return _promise2.default.reject(new Error('Failed after ' + this.webex.config.maxAuthenticationReplays + ' replay attempts'));\n      }\n\n      this.webex.logger.info('auth: replaying request ' + options.replayCount + ' time');\n      return this.webex.request(options);\n    }\n    /**\n     * Indicates whether or not the current request should refresh its access\n     * token in event of a 401\n     * @param {Error} reason\n     * @param {Object} options\n     * @returns {Promise<boolean>}\n     */\n\n  }, {\n    key: 'shouldAttemptReauth',\n    value: function shouldAttemptReauth(reason, options) {\n      if (options && options.shouldRefreshAccessToken === false) {\n        return _promise2.default.resolve(false);\n      }\n\n      if (reason.statusCode === 401) {\n        return _promise2.default.resolve(true);\n      }\n\n      return _promise2.default.resolve(false);\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * @returns {AuthInterceptor}\n     */\n    value: function create() {\n      return new AuthInterceptor({\n        webex: this\n      });\n    }\n  }]);\n  return AuthInterceptor;\n}(_httpCore.Interceptor);\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nexports.default = AuthInterceptor;","map":{"version":3,"sources":["auth.js"],"names":["AuthInterceptor","Interceptor","webex","options","token","services","details","name","resource","uri","service","url","reason"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {Interceptor} from '@webex/http-core';\n\n/**\n * @class\n */\nexport default class AuthInterceptor extends Interceptor {\n  /**\n   * @returns {AuthInterceptor}\n   */\n  static create() {\n    return new AuthInterceptor({webex: this});\n  }\n\n  /**\n   * @see {@link Interceptor#onRequest}\n   * @param {Object} options\n   * @returns {Object}\n   */\n  onRequest(options) {\n    options.headers = options.headers || {};\n\n    // If Authorizations is already set, don't overwrite it\n    if ('authorization' in options.headers || 'auth' in options) {\n      // If Authorization is set to null, false, or undefined, delete it to\n      // prevent a CORS preflight.\n      if (!options.headers.authorization) {\n        Reflect.deleteProperty(options.headers, 'authorization');\n      }\n\n      return Promise.resolve(options);\n    }\n\n    return this.requiresCredentials(options)\n      .then((requires) => {\n        if (!requires) {\n          return options;\n        }\n\n        return this.webex.credentials.getUserToken()\n          .then((token) => {\n            options.headers.authorization = token.toString();\n\n            return options;\n          });\n      });\n  }\n\n  /**\n   * Determines if the provided options object needs an authorization header.\n   *\n   * @param {Object} options\n   * @returns {Promise<boolean>}\n   */\n  requiresCredentials(options) {\n    // Validate that authorization is necessary.\n    if (options.addAuthHeader === false) {\n      return Promise.resolve(false);\n    }\n\n    // Validate that the services plugin has been loaded before proceeding.\n    if (!this.webex.internal.services) {\n      return Promise.resolve(false);\n    }\n\n    // Destructure webex instance to isolate services plugin.\n    const {services} = this.webex.internal;\n\n    // Store the current service details if available and destructure details.\n    const details = services.getServiceFromUrl(options.uri || '');\n    const {name} = details || {};\n    const {resource, uri} = options;\n    const service = options.service || options.api;\n\n    if ((service && service === 'web-authentication') || (name && name === 'web-authentication')) {\n      return Promise.resolve(false);\n    }\n\n    // Unique validation for the u2c service.\n    if ((service && service === 'u2c') || (name && name === 'u2c')) {\n      if (\n        (resource && resource.includes('limited')) ||\n        (uri && uri.includes('limited'))\n      ) {\n        return Promise.resolve(false);\n      }\n\n      return Promise.resolve(true);\n    }\n\n\n    // Validate that the allowed domains can be utilized.\n    if (services.validateDomains &&\n      services.hasAllowedDomains() &&\n      (uri && services.isAllowedDomainUrl(uri))) {\n      return Promise.resolve(true);\n    }\n\n    // Perform an additional validation in case the service does not exist yet.\n    return services.waitForService({name: service, url: uri})\n      .then((detectedUrl) => {\n        // Validate that the url exists in the catalog.\n        if (services.getServiceFromUrl(detectedUrl)) {\n          return true;\n        }\n\n        // Return false to indicate authentication is not required.\n        return false;\n      })\n      .catch((error) => {\n        this.webex.logger.warn(\n          'auth-interceptor: failed to validate service exists in catalog',\n          error\n        );\n\n        return false;\n      });\n  }\n\n  /**\n   * @see {@link Interceptor#onResponseError}\n   * @param {Object} options\n   * @param {Error} reason\n   * @returns {Object}\n   */\n  onResponseError(options, reason) {\n    return this.shouldAttemptReauth(reason, options)\n      .then((shouldAttemptReauth) => {\n        if (shouldAttemptReauth) {\n          this.webex.logger.info('auth: received 401, attempting to reauthenticate');\n\n          if (reason.options.headers) {\n            Reflect.deleteProperty(reason.options.headers, 'authorization');\n          }\n\n          if (this.webex.credentials.canRefresh) {\n            return this.webex.credentials.refresh()\n              .then(() => this.replay(options));\n          }\n        }\n\n        return Promise.reject(reason);\n      });\n  }\n\n  /**\n   * Replays the request\n   * @param {Object} options\n   * @returns {Object}\n   */\n  replay(options) {\n    if (options.replayCount) {\n      options.replayCount += 1;\n    }\n    else {\n      options.replayCount = 1;\n    }\n\n    if (options.replayCount > this.webex.config.maxAuthenticationReplays) {\n      this.webex.logger.error(`auth: failed after ${this.webex.config.maxAuthenticationReplays} replay attempts`);\n\n      return Promise.reject(new Error(`Failed after ${this.webex.config.maxAuthenticationReplays} replay attempts`));\n    }\n\n    this.webex.logger.info(`auth: replaying request ${options.replayCount} time`);\n\n    return this.webex.request(options);\n  }\n\n  /**\n   * Indicates whether or not the current request should refresh its access\n   * token in event of a 401\n   * @param {Error} reason\n   * @param {Object} options\n   * @returns {Promise<boolean>}\n   */\n  shouldAttemptReauth(reason, options) {\n    if (options && options.shouldRefreshAccessToken === false) {\n      return Promise.resolve(false);\n    }\n\n    if (reason.statusCode === 401) {\n      return Promise.resolve(true);\n    }\n\n    return Promise.resolve(false);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}