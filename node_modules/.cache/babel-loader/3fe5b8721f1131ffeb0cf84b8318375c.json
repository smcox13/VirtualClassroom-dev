{"ast":null,"code":"/*!\n * jws/sign.js - Sign to JWS\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar clone = require(\"lodash.clone\"),\n    merge = require(\"../util/merge\"),\n    uniq = require(\"lodash.uniq\"),\n    util = require(\"../util\"),\n    JWK = require(\"../jwk\"),\n    slice = require(\"./helpers\").slice;\n\nvar DEFAULTS = require(\"./defaults\");\n/**\n * @class JWS.Signer\n * @classdesc Generator of signed content.\n *\n * @description\n * **NOTE:** this class cannot be instantiated directly. Instead call {@link\n * JWS.createSign}.\n */\n\n\nvar JWSSigner = function (cfg, signatories) {\n  var finalized = false,\n      format = cfg.format || \"general\",\n      content = new Buffer(0);\n  /**\n  * @member {Boolean} JWS.Signer#compact\n  * @description\n  * Indicates whether the outuput of this signature generator is using\n  * the Compact serialization (`true`) or the JSON serialization\n  * (`false`).\n  */\n\n  Object.defineProperty(this, \"compact\", {\n    get: function () {\n      return \"compact\" === format;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, \"format\", {\n    get: function () {\n      return format;\n    },\n    enumerable: true\n  });\n  /**\n  * @method JWS.Signer#update\n  * @description\n  * Updates the signing content for this signature content. The content\n  * is appended to the end of any other content already applied.\n  *\n  * If {data} is a Buffer, {encoding} is ignored. Otherwise, {data} is\n  * converted to a Buffer internally to {encoding}.\n  *\n  * @param {Buffer|String} data The data to sign.\n  * @param {String} [encoding=\"binary\"] The encoding of {data}.\n  * @returns {JWS.Signer} This signature generator.\n  * @throws {Error} If a signature has already been generated.\n  */\n\n  Object.defineProperty(this, \"update\", {\n    value: function (data, encoding) {\n      if (finalized) {\n        throw new Error(\"already final\");\n      }\n\n      if (data != null) {\n        data = util.asBuffer(data, encoding);\n\n        if (content.length) {\n          content = Buffer.concat([content, data], content.length + data.length);\n        } else {\n          content = data;\n        }\n      }\n\n      return this;\n    }\n  });\n  /**\n  * @method JWS.Signer#final\n  * @description\n  * Finishes the signature operation.\n  *\n  * The returned Promise, when fulfilled, is the JSON Web Signature (JWS)\n  * object, either in the Compact (if {@link JWS.Signer#format} is\n  * `\"compact\"`), the flattened JSON (if {@link JWS.Signer#format} is\n  * \"flattened\"), or the general JSON serialization.\n  *\n  * @param {Buffer|String} [data] The final content to apply.\n  * @param {String} [encoding=\"binary\"] The encoding of the final content\n  *        (if any).\n  * @returns {Promise} The promise for the signatures\n  * @throws {Error} If a signature has already been generated.\n  */\n\n  Object.defineProperty(this, \"final\", {\n    value: function (data, encoding) {\n      if (finalized) {\n        return Promise.reject(new Error(\"already final\"));\n      } // last-minute data\n\n\n      this.update(data, encoding); // mark as done...ish\n\n      finalized = true;\n      var promise; // map signatory promises to just signatories\n\n      promise = Promise.all(signatories);\n      promise = promise.then(function (sigs) {\n        // prepare content\n        content = util.base64url.encode(content);\n        sigs = sigs.map(function (s) {\n          // prepare protected\n          var protect = {},\n              lenProtect = 0,\n              unprotect = clone(s.header),\n              lenUnprotect = Object.keys(unprotect).length;\n          s.protected.forEach(function (h) {\n            if (!(h in unprotect)) {\n              return;\n            }\n\n            protect[h] = unprotect[h];\n            lenProtect++;\n            delete unprotect[h];\n            lenUnprotect--;\n          });\n\n          if (lenProtect > 0) {\n            protect = JSON.stringify(protect);\n            protect = util.base64url.encode(protect);\n          } else {\n            protect = \"\";\n          } // signit!\n\n\n          var data = new Buffer(protect + \".\" + content, \"ascii\");\n          s = s.key.sign(s.header.alg, data, s.header);\n          s = s.then(function (result) {\n            var sig = {};\n\n            if (0 < lenProtect) {\n              sig.protected = protect;\n            }\n\n            if (0 < lenUnprotect) {\n              sig.header = unprotect;\n            }\n\n            sig.signature = util.base64url.encode(result.mac);\n            return sig;\n          });\n          return s;\n        });\n        sigs = [Promise.resolve(content)].concat(sigs);\n        return Promise.all(sigs);\n      });\n      promise = promise.then(function (results) {\n        var content = results[0];\n        return {\n          payload: content,\n          signatures: results.slice(1)\n        };\n      });\n\n      switch (format) {\n        case \"compact\":\n          promise = promise.then(function (jws) {\n            var compact = [jws.signatures[0].protected, jws.payload, jws.signatures[0].signature];\n            compact = compact.join(\".\");\n            return compact;\n          });\n          break;\n\n        case \"flattened\":\n          promise = promise.then(function (jws) {\n            var flattened = {};\n            flattened.payload = jws.payload;\n            var sig = jws.signatures[0];\n\n            if (sig.protected) {\n              flattened.protected = sig.protected;\n            }\n\n            if (sig.header) {\n              flattened.header = sig.header;\n            }\n\n            flattened.signature = sig.signature;\n            return flattened;\n          });\n          break;\n      }\n\n      return promise;\n    }\n  });\n};\n/**\n * @description\n * Creates a new JWS.Signer with the given options and signatories.\n *\n * @param {Object} [opts] The signing options\n * @param {Boolean} [opts.compact] Use compact serialization?\n * @param {String} [opts.format] The serialization format to use (\"compact\",\n *                 \"flattened\", \"general\")\n * @param {Object} [opts.fields] Additional header fields\n * @param {JWK.Key[]|Object[]} [signs] Signatories, either as an array of\n *        JWK.Key instances; or an array of objects, each with the following\n *        properties\n * @param {JWK.Key} signs.key Key used to sign content\n * @param {Object} [signs.header] Per-signatory header fields\n * @param {String} [signs.reference] Reference field to identify the key\n * @param {String[]|String} [signs.protect] List of fields to integrity\n *        protect (\"*\" to protect all fields)\n * @returns {JWS.Signer} The signature generator.\n * @throws {Error} If Compact serialization is requested but there are\n *         multiple signatories\n */\n\n\nfunction createSign(opts, signs) {\n  // fixup signatories\n  var options = opts,\n      signStart = 1,\n      signList = signs;\n\n  if (arguments.length === 0) {\n    throw new Error(\"at least one signatory must be provided\");\n  }\n\n  if (arguments.length === 1) {\n    signList = opts;\n    signStart = 0;\n    options = {};\n  } else if (JWK.isKey(opts) || opts && \"kty\" in opts || opts && \"key\" in opts && (JWK.isKey(opts.key) || \"kty\" in opts.key)) {\n    signList = opts;\n    signStart = 0;\n    options = {};\n  } else {\n    options = clone(opts);\n  }\n\n  if (!Array.isArray(signList)) {\n    signList = slice(arguments, signStart);\n  } // fixup options\n\n\n  options = merge(clone(DEFAULTS), options); // setup header fields\n\n  var allFields = options.fields || {}; // setup serialization format\n\n  var format = options.format;\n\n  if (!format) {\n    format = options.compact ? \"compact\" : \"general\";\n  }\n\n  if ((\"compact\" === format || \"flattened\" === format) && 1 < signList.length) {\n    throw new Error(\"too many signatories for compact or flattened JSON serialization\");\n  } // note protected fields (globally)\n  // protected fields are per signature\n\n\n  var protectAll = \"*\" === options.protect;\n\n  if (options.compact) {\n    protectAll = true;\n  }\n\n  signList = signList.map(function (s, idx) {\n    var p; // resolve a key\n\n    if (s && \"kty\" in s) {\n      p = JWK.asKey(s);\n      p = p.then(function (k) {\n        return {\n          key: k\n        };\n      });\n    } else if (s) {\n      p = JWK.asKey(s.key);\n      p = p.then(function (k) {\n        return {\n          header: s.header,\n          reference: s.reference,\n          protect: s.protect,\n          key: k\n        };\n      });\n    } else {\n      p = Promise.reject(new Error(\"missing key for signatory \" + idx));\n    } // resolve the complete signatory\n\n\n    p = p.then(function (signatory) {\n      var key = signatory.key; // make sure there is a header\n\n      var header = signatory.header || {};\n      header = merge(merge({}, allFields), header);\n      signatory.header = header; // ensure an algorithm\n\n      if (!header.alg) {\n        header.alg = key.algorithms(JWK.MODE_SIGN)[0] || \"\";\n      } // determine the key reference\n\n\n      var ref = signatory.reference;\n      delete signatory.reference;\n\n      if (undefined === ref) {\n        // header already contains the key reference\n        ref = [\"kid\", \"jku\", \"x5c\", \"x5t\", \"x5u\"].some(function (k) {\n          return k in header;\n        });\n        ref = !ref ? \"kid\" : null;\n      } else if (\"boolean\" === typeof ref) {\n        // explicit (positive | negative) request for key reference\n        ref = ref ? \"kid\" : null;\n      }\n\n      var jwk;\n\n      if (ref) {\n        jwk = key.toJSON();\n\n        if (\"jwk\" === ref) {\n          if (\"oct\" === key.kty) {\n            return Promise.reject(new Error(\"cannot embed key\"));\n          }\n\n          header.jwk = jwk;\n        } else if (ref in jwk) {\n          header[ref] = jwk[ref];\n        }\n      } // determine protected fields\n\n\n      var protect = signatory.protect;\n\n      if (protectAll || \"*\" === protect) {\n        protect = Object.keys(header);\n      } else if (\"string\" === protect) {\n        protect = [protect];\n      } else if (Array.isArray(protect)) {\n        protect = protect.concat();\n      } else if (!protect) {\n        protect = [];\n      } else {\n        return Promise.reject(new Error(\"protect must be a list of fields\"));\n      }\n\n      protect = uniq(protect);\n      signatory.protected = protect; // freeze signatory\n\n      signatory = Object.freeze(signatory);\n      return signatory;\n    });\n    return p;\n  });\n  var cfg = {\n    format: format\n  };\n  return new JWSSigner(cfg, signList);\n}\n\nmodule.exports = {\n  signer: JWSSigner,\n  createSign: createSign\n};","map":{"version":3,"sources":["/Users/pratison/Work/Cisco/Education/React/education-webex/node_modules/node-jose/lib/jws/sign.js"],"names":["clone","require","merge","uniq","util","JWK","slice","DEFAULTS","JWSSigner","cfg","signatories","finalized","format","content","Buffer","Object","defineProperty","get","enumerable","value","data","encoding","Error","asBuffer","length","concat","Promise","reject","update","promise","all","then","sigs","base64url","encode","map","s","protect","lenProtect","unprotect","header","lenUnprotect","keys","protected","forEach","h","JSON","stringify","key","sign","alg","result","sig","signature","mac","resolve","results","payload","signatures","jws","compact","join","flattened","createSign","opts","signs","options","signStart","signList","arguments","isKey","Array","isArray","allFields","fields","protectAll","idx","p","asKey","k","reference","signatory","algorithms","MODE_SIGN","ref","undefined","some","jwk","toJSON","kty","freeze","module","exports","signer"],"mappings":"AAAA;;;;;AAKA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,cAAD,CAAnB;AAAA,IACIC,KAAK,GAAGD,OAAO,CAAC,eAAD,CADnB;AAAA,IAEIE,IAAI,GAAGF,OAAO,CAAC,aAAD,CAFlB;AAAA,IAGIG,IAAI,GAAGH,OAAO,CAAC,SAAD,CAHlB;AAAA,IAIII,GAAG,GAAGJ,OAAO,CAAC,QAAD,CAJjB;AAAA,IAKIK,KAAK,GAAGL,OAAO,CAAC,WAAD,CAAP,CAAqBK,KALjC;;AAOA,IAAIC,QAAQ,GAAGN,OAAO,CAAC,YAAD,CAAtB;AAEA;;;;;;;;;;AAQA,IAAIO,SAAS,GAAG,UAASC,GAAT,EAAcC,WAAd,EAA2B;AACzC,MAAIC,SAAS,GAAG,KAAhB;AAAA,MACIC,MAAM,GAAGH,GAAG,CAACG,MAAJ,IAAc,SAD3B;AAAA,MAEIC,OAAO,GAAG,IAAIC,MAAJ,CAAW,CAAX,CAFd;AAIA;;;;;;;;AAOAC,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC;AACrCC,IAAAA,GAAG,EAAE,YAAW;AACd,aAAO,cAAcL,MAArB;AACD,KAHoC;AAIrCM,IAAAA,UAAU,EAAE;AAJyB,GAAvC;AAMAH,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,QAA5B,EAAsC;AACpCC,IAAAA,GAAG,EAAE,YAAW;AACd,aAAOL,MAAP;AACD,KAHmC;AAIpCM,IAAAA,UAAU,EAAE;AAJwB,GAAtC;AAOA;;;;;;;;;;;;;;;AAcAH,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,QAA5B,EAAsC;AACpCG,IAAAA,KAAK,EAAE,UAASC,IAAT,EAAeC,QAAf,EAAyB;AAC9B,UAAIV,SAAJ,EAAe;AACb,cAAM,IAAIW,KAAJ,CAAU,eAAV,CAAN;AACD;;AACD,UAAIF,IAAI,IAAI,IAAZ,EAAkB;AAChBA,QAAAA,IAAI,GAAGhB,IAAI,CAACmB,QAAL,CAAcH,IAAd,EAAoBC,QAApB,CAAP;;AACA,YAAIR,OAAO,CAACW,MAAZ,EAAoB;AAClBX,UAAAA,OAAO,GAAGC,MAAM,CAACW,MAAP,CAAc,CAACZ,OAAD,EAAUO,IAAV,CAAd,EACEP,OAAO,CAACW,MAAR,GAAiBJ,IAAI,CAACI,MADxB,CAAV;AAED,SAHD,MAGO;AACLX,UAAAA,OAAO,GAAGO,IAAV;AACD;AACF;;AAED,aAAO,IAAP;AACD;AAhBmC,GAAtC;AAkBA;;;;;;;;;;;;;;;;;AAgBAL,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,OAA5B,EAAqC;AACnCG,IAAAA,KAAK,EAAE,UAASC,IAAT,EAAeC,QAAf,EAAyB;AAC9B,UAAIV,SAAJ,EAAe;AACb,eAAOe,OAAO,CAACC,MAAR,CAAe,IAAIL,KAAJ,CAAU,eAAV,CAAf,CAAP;AACD,OAH6B,CAK9B;;;AACA,WAAKM,MAAL,CAAYR,IAAZ,EAAkBC,QAAlB,EAN8B,CAQ9B;;AACAV,MAAAA,SAAS,GAAG,IAAZ;AACA,UAAIkB,OAAJ,CAV8B,CAY9B;;AACAA,MAAAA,OAAO,GAAGH,OAAO,CAACI,GAAR,CAAYpB,WAAZ,CAAV;AACAmB,MAAAA,OAAO,GAAGA,OAAO,CAACE,IAAR,CAAa,UAASC,IAAT,EAAe;AACpC;AACAnB,QAAAA,OAAO,GAAGT,IAAI,CAAC6B,SAAL,CAAeC,MAAf,CAAsBrB,OAAtB,CAAV;AAEAmB,QAAAA,IAAI,GAAGA,IAAI,CAACG,GAAL,CAAS,UAASC,CAAT,EAAY;AAC1B;AACA,cAAIC,OAAO,GAAG,EAAd;AAAA,cACIC,UAAU,GAAG,CADjB;AAAA,cAEIC,SAAS,GAAGvC,KAAK,CAACoC,CAAC,CAACI,MAAH,CAFrB;AAAA,cAGIC,YAAY,GAAG1B,MAAM,CAAC2B,IAAP,CAAYH,SAAZ,EAAuBf,MAH1C;AAIAY,UAAAA,CAAC,CAACO,SAAF,CAAYC,OAAZ,CAAoB,UAASC,CAAT,EAAY;AAC9B,gBAAI,EAAEA,CAAC,IAAIN,SAAP,CAAJ,EAAuB;AACrB;AACD;;AACDF,YAAAA,OAAO,CAACQ,CAAD,CAAP,GAAaN,SAAS,CAACM,CAAD,CAAtB;AACAP,YAAAA,UAAU;AACV,mBAAOC,SAAS,CAACM,CAAD,CAAhB;AACAJ,YAAAA,YAAY;AACb,WARD;;AASA,cAAIH,UAAU,GAAG,CAAjB,EAAoB;AAClBD,YAAAA,OAAO,GAAGS,IAAI,CAACC,SAAL,CAAeV,OAAf,CAAV;AACAA,YAAAA,OAAO,GAAGjC,IAAI,CAAC6B,SAAL,CAAeC,MAAf,CAAsBG,OAAtB,CAAV;AACD,WAHD,MAGO;AACLA,YAAAA,OAAO,GAAG,EAAV;AACD,WApByB,CAsB1B;;;AACA,cAAIjB,IAAI,GAAG,IAAIN,MAAJ,CAAWuB,OAAO,GAAG,GAAV,GAAgBxB,OAA3B,EAAoC,OAApC,CAAX;AACAuB,UAAAA,CAAC,GAAGA,CAAC,CAACY,GAAF,CAAMC,IAAN,CAAWb,CAAC,CAACI,MAAF,CAASU,GAApB,EAAyB9B,IAAzB,EAA+BgB,CAAC,CAACI,MAAjC,CAAJ;AACAJ,UAAAA,CAAC,GAAGA,CAAC,CAACL,IAAF,CAAO,UAASoB,MAAT,EAAiB;AAC1B,gBAAIC,GAAG,GAAG,EAAV;;AACA,gBAAI,IAAId,UAAR,EAAoB;AAClBc,cAAAA,GAAG,CAACT,SAAJ,GAAgBN,OAAhB;AACD;;AACD,gBAAI,IAAII,YAAR,EAAsB;AACpBW,cAAAA,GAAG,CAACZ,MAAJ,GAAaD,SAAb;AACD;;AACDa,YAAAA,GAAG,CAACC,SAAJ,GAAgBjD,IAAI,CAAC6B,SAAL,CAAeC,MAAf,CAAsBiB,MAAM,CAACG,GAA7B,CAAhB;AACA,mBAAOF,GAAP;AACD,WAVG,CAAJ;AAWA,iBAAOhB,CAAP;AACD,SArCM,CAAP;AAsCAJ,QAAAA,IAAI,GAAG,CAACN,OAAO,CAAC6B,OAAR,CAAgB1C,OAAhB,CAAD,EAA2BY,MAA3B,CAAkCO,IAAlC,CAAP;AACA,eAAON,OAAO,CAACI,GAAR,CAAYE,IAAZ,CAAP;AACD,OA5CS,CAAV;AA6CAH,MAAAA,OAAO,GAAGA,OAAO,CAACE,IAAR,CAAa,UAASyB,OAAT,EAAkB;AACvC,YAAI3C,OAAO,GAAG2C,OAAO,CAAC,CAAD,CAArB;AACA,eAAO;AACLC,UAAAA,OAAO,EAAE5C,OADJ;AAEL6C,UAAAA,UAAU,EAAEF,OAAO,CAAClD,KAAR,CAAc,CAAd;AAFP,SAAP;AAID,OANS,CAAV;;AAOA,cAAQM,MAAR;AACE,aAAK,SAAL;AACEiB,UAAAA,OAAO,GAAGA,OAAO,CAACE,IAAR,CAAa,UAAS4B,GAAT,EAAc;AACnC,gBAAIC,OAAO,GAAG,CACZD,GAAG,CAACD,UAAJ,CAAe,CAAf,EAAkBf,SADN,EAEZgB,GAAG,CAACF,OAFQ,EAGZE,GAAG,CAACD,UAAJ,CAAe,CAAf,EAAkBL,SAHN,CAAd;AAKAO,YAAAA,OAAO,GAAGA,OAAO,CAACC,IAAR,CAAa,GAAb,CAAV;AACA,mBAAOD,OAAP;AACD,WARS,CAAV;AASA;;AACF,aAAK,WAAL;AACE/B,UAAAA,OAAO,GAAGA,OAAO,CAACE,IAAR,CAAa,UAAS4B,GAAT,EAAc;AACnC,gBAAIG,SAAS,GAAG,EAAhB;AACAA,YAAAA,SAAS,CAACL,OAAV,GAAoBE,GAAG,CAACF,OAAxB;AAEA,gBAAIL,GAAG,GAAGO,GAAG,CAACD,UAAJ,CAAe,CAAf,CAAV;;AACA,gBAAIN,GAAG,CAACT,SAAR,EAAmB;AACjBmB,cAAAA,SAAS,CAACnB,SAAV,GAAsBS,GAAG,CAACT,SAA1B;AACD;;AACD,gBAAIS,GAAG,CAACZ,MAAR,EAAgB;AACdsB,cAAAA,SAAS,CAACtB,MAAV,GAAmBY,GAAG,CAACZ,MAAvB;AACD;;AACDsB,YAAAA,SAAS,CAACT,SAAV,GAAsBD,GAAG,CAACC,SAA1B;AAEA,mBAAOS,SAAP;AACD,WAdS,CAAV;AAeA;AA5BJ;;AA+BA,aAAOjC,OAAP;AACD;AAnGkC,GAArC;AAqGD,CA9KD;AAiLA;;;;;;;;;;;;;;;;;;;;;;;AAqBA,SAASkC,UAAT,CAAoBC,IAApB,EAA0BC,KAA1B,EAAiC;AAC/B;AACA,MAAIC,OAAO,GAAGF,IAAd;AAAA,MACIG,SAAS,GAAG,CADhB;AAAA,MAEIC,QAAQ,GAAGH,KAFf;;AAIA,MAAII,SAAS,CAAC7C,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,UAAM,IAAIF,KAAJ,CAAU,yCAAV,CAAN;AACD;;AACD,MAAI+C,SAAS,CAAC7C,MAAV,KAAqB,CAAzB,EAA4B;AAC1B4C,IAAAA,QAAQ,GAAGJ,IAAX;AACAG,IAAAA,SAAS,GAAG,CAAZ;AACAD,IAAAA,OAAO,GAAG,EAAV;AACD,GAJD,MAIO,IAAI7D,GAAG,CAACiE,KAAJ,CAAUN,IAAV,KACAA,IAAI,IAAI,SAASA,IADjB,IAEAA,IAAI,IAAI,SAASA,IAAjB,KACA3D,GAAG,CAACiE,KAAJ,CAAUN,IAAI,CAAChB,GAAf,KAAuB,SAASgB,IAAI,CAAChB,GADrC,CAFJ,EAGgD;AACrDoB,IAAAA,QAAQ,GAAGJ,IAAX;AACAG,IAAAA,SAAS,GAAG,CAAZ;AACAD,IAAAA,OAAO,GAAG,EAAV;AACD,GAPM,MAOA;AACLA,IAAAA,OAAO,GAAGlE,KAAK,CAACgE,IAAD,CAAf;AACD;;AACD,MAAI,CAACO,KAAK,CAACC,OAAN,CAAcJ,QAAd,CAAL,EAA8B;AAC5BA,IAAAA,QAAQ,GAAG9D,KAAK,CAAC+D,SAAD,EAAYF,SAAZ,CAAhB;AACD,GAzB8B,CA2B/B;;;AACAD,EAAAA,OAAO,GAAGhE,KAAK,CAACF,KAAK,CAACO,QAAD,CAAN,EAAkB2D,OAAlB,CAAf,CA5B+B,CA8B/B;;AACA,MAAIO,SAAS,GAAGP,OAAO,CAACQ,MAAR,IAAkB,EAAlC,CA/B+B,CAgC/B;;AACA,MAAI9D,MAAM,GAAGsD,OAAO,CAACtD,MAArB;;AACA,MAAI,CAACA,MAAL,EAAa;AACXA,IAAAA,MAAM,GAAGsD,OAAO,CAACN,OAAR,GAAkB,SAAlB,GAA8B,SAAvC;AACD;;AACD,MAAI,CAAC,cAAchD,MAAd,IAAwB,gBAAgBA,MAAzC,KAAoD,IAAIwD,QAAQ,CAAC5C,MAArE,EAA6E;AAC3E,UAAM,IAAIF,KAAJ,CAAU,kEAAV,CAAN;AACD,GAvC8B,CAyC/B;AACA;;;AACA,MAAIqD,UAAU,GAAI,QAAQT,OAAO,CAAC7B,OAAlC;;AACA,MAAI6B,OAAO,CAACN,OAAZ,EAAqB;AACnBe,IAAAA,UAAU,GAAG,IAAb;AACD;;AAEDP,EAAAA,QAAQ,GAAGA,QAAQ,CAACjC,GAAT,CAAa,UAASC,CAAT,EAAYwC,GAAZ,EAAiB;AACvC,QAAIC,CAAJ,CADuC,CAGvC;;AACA,QAAIzC,CAAC,IAAI,SAASA,CAAlB,EAAqB;AACnByC,MAAAA,CAAC,GAAGxE,GAAG,CAACyE,KAAJ,CAAU1C,CAAV,CAAJ;AACAyC,MAAAA,CAAC,GAAGA,CAAC,CAAC9C,IAAF,CAAO,UAASgD,CAAT,EAAY;AACrB,eAAO;AACL/B,UAAAA,GAAG,EAAE+B;AADA,SAAP;AAGD,OAJG,CAAJ;AAKD,KAPD,MAOO,IAAI3C,CAAJ,EAAO;AACZyC,MAAAA,CAAC,GAAGxE,GAAG,CAACyE,KAAJ,CAAU1C,CAAC,CAACY,GAAZ,CAAJ;AACA6B,MAAAA,CAAC,GAAGA,CAAC,CAAC9C,IAAF,CAAO,UAASgD,CAAT,EAAY;AACrB,eAAO;AACLvC,UAAAA,MAAM,EAAEJ,CAAC,CAACI,MADL;AAELwC,UAAAA,SAAS,EAAE5C,CAAC,CAAC4C,SAFR;AAGL3C,UAAAA,OAAO,EAAED,CAAC,CAACC,OAHN;AAILW,UAAAA,GAAG,EAAE+B;AAJA,SAAP;AAMD,OAPG,CAAJ;AAQD,KAVM,MAUA;AACLF,MAAAA,CAAC,GAAGnD,OAAO,CAACC,MAAR,CAAe,IAAIL,KAAJ,CAAU,+BAA+BsD,GAAzC,CAAf,CAAJ;AACD,KAvBsC,CAyBvC;;;AACAC,IAAAA,CAAC,GAAGA,CAAC,CAAC9C,IAAF,CAAO,UAASkD,SAAT,EAAoB;AAC7B,UAAIjC,GAAG,GAAGiC,SAAS,CAACjC,GAApB,CAD6B,CAG7B;;AACA,UAAIR,MAAM,GAAGyC,SAAS,CAACzC,MAAV,IAAoB,EAAjC;AACAA,MAAAA,MAAM,GAAGtC,KAAK,CAACA,KAAK,CAAC,EAAD,EAAKuE,SAAL,CAAN,EAAuBjC,MAAvB,CAAd;AACAyC,MAAAA,SAAS,CAACzC,MAAV,GAAmBA,MAAnB,CAN6B,CAQ7B;;AACA,UAAI,CAACA,MAAM,CAACU,GAAZ,EAAiB;AACfV,QAAAA,MAAM,CAACU,GAAP,GAAaF,GAAG,CAACkC,UAAJ,CAAe7E,GAAG,CAAC8E,SAAnB,EAA8B,CAA9B,KAAoC,EAAjD;AACD,OAX4B,CAa7B;;;AACA,UAAIC,GAAG,GAAGH,SAAS,CAACD,SAApB;AACA,aAAOC,SAAS,CAACD,SAAjB;;AACA,UAAIK,SAAS,KAAKD,GAAlB,EAAuB;AACrB;AACAA,QAAAA,GAAG,GAAG,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,EAAsB,KAAtB,EAA6B,KAA7B,EAAoCE,IAApC,CAAyC,UAASP,CAAT,EAAY;AACzD,iBAAQA,CAAC,IAAIvC,MAAb;AACD,SAFK,CAAN;AAGA4C,QAAAA,GAAG,GAAG,CAACA,GAAD,GAAO,KAAP,GAAe,IAArB;AACD,OAND,MAMO,IAAI,cAAc,OAAOA,GAAzB,EAA8B;AACnC;AACAA,QAAAA,GAAG,GAAGA,GAAG,GAAG,KAAH,GAAW,IAApB;AACD;;AACD,UAAIG,GAAJ;;AACA,UAAIH,GAAJ,EAAS;AACPG,QAAAA,GAAG,GAAGvC,GAAG,CAACwC,MAAJ,EAAN;;AACA,YAAI,UAAUJ,GAAd,EAAmB;AACjB,cAAI,UAAUpC,GAAG,CAACyC,GAAlB,EAAuB;AACrB,mBAAO/D,OAAO,CAACC,MAAR,CAAe,IAAIL,KAAJ,CAAU,kBAAV,CAAf,CAAP;AACD;;AACDkB,UAAAA,MAAM,CAAC+C,GAAP,GAAaA,GAAb;AACD,SALD,MAKO,IAAIH,GAAG,IAAIG,GAAX,EAAgB;AACrB/C,UAAAA,MAAM,CAAC4C,GAAD,CAAN,GAAcG,GAAG,CAACH,GAAD,CAAjB;AACD;AACF,OArC4B,CAuC7B;;;AACA,UAAI/C,OAAO,GAAG4C,SAAS,CAAC5C,OAAxB;;AACA,UAAIsC,UAAU,IAAI,QAAQtC,OAA1B,EAAmC;AACjCA,QAAAA,OAAO,GAAGtB,MAAM,CAAC2B,IAAP,CAAYF,MAAZ,CAAV;AACD,OAFD,MAEO,IAAI,aAAaH,OAAjB,EAA0B;AAC/BA,QAAAA,OAAO,GAAG,CAACA,OAAD,CAAV;AACD,OAFM,MAEA,IAAIkC,KAAK,CAACC,OAAN,CAAcnC,OAAd,CAAJ,EAA4B;AACjCA,QAAAA,OAAO,GAAGA,OAAO,CAACZ,MAAR,EAAV;AACD,OAFM,MAEA,IAAI,CAACY,OAAL,EAAc;AACnBA,QAAAA,OAAO,GAAG,EAAV;AACD,OAFM,MAEA;AACL,eAAOX,OAAO,CAACC,MAAR,CAAe,IAAIL,KAAJ,CAAU,kCAAV,CAAf,CAAP;AACD;;AACDe,MAAAA,OAAO,GAAGlC,IAAI,CAACkC,OAAD,CAAd;AACA4C,MAAAA,SAAS,CAACtC,SAAV,GAAsBN,OAAtB,CArD6B,CAuD7B;;AACA4C,MAAAA,SAAS,GAAGlE,MAAM,CAAC2E,MAAP,CAAcT,SAAd,CAAZ;AACA,aAAOA,SAAP;AACD,KA1DG,CAAJ;AA4DA,WAAOJ,CAAP;AACD,GAvFU,CAAX;AAyFA,MAAIpE,GAAG,GAAG;AACRG,IAAAA,MAAM,EAAEA;AADA,GAAV;AAGA,SAAO,IAAIJ,SAAJ,CAAcC,GAAd,EACc2D,QADd,CAAP;AAED;;AAEDuB,MAAM,CAACC,OAAP,GAAiB;AACfC,EAAAA,MAAM,EAAErF,SADO;AAEfuD,EAAAA,UAAU,EAAEA;AAFG,CAAjB","sourcesContent":["/*!\n * jws/sign.js - Sign to JWS\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar clone = require(\"lodash.clone\"),\n    merge = require(\"../util/merge\"),\n    uniq = require(\"lodash.uniq\"),\n    util = require(\"../util\"),\n    JWK = require(\"../jwk\"),\n    slice = require(\"./helpers\").slice;\n\nvar DEFAULTS = require(\"./defaults\");\n\n/**\n * @class JWS.Signer\n * @classdesc Generator of signed content.\n *\n * @description\n * **NOTE:** this class cannot be instantiated directly. Instead call {@link\n * JWS.createSign}.\n */\nvar JWSSigner = function(cfg, signatories) {\n  var finalized = false,\n      format = cfg.format || \"general\",\n      content = new Buffer(0);\n\n  /**\n  * @member {Boolean} JWS.Signer#compact\n  * @description\n  * Indicates whether the outuput of this signature generator is using\n  * the Compact serialization (`true`) or the JSON serialization\n  * (`false`).\n  */\n  Object.defineProperty(this, \"compact\", {\n    get: function() {\n      return \"compact\" === format;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, \"format\", {\n    get: function() {\n      return format;\n    },\n    enumerable: true\n  });\n\n  /**\n  * @method JWS.Signer#update\n  * @description\n  * Updates the signing content for this signature content. The content\n  * is appended to the end of any other content already applied.\n  *\n  * If {data} is a Buffer, {encoding} is ignored. Otherwise, {data} is\n  * converted to a Buffer internally to {encoding}.\n  *\n  * @param {Buffer|String} data The data to sign.\n  * @param {String} [encoding=\"binary\"] The encoding of {data}.\n  * @returns {JWS.Signer} This signature generator.\n  * @throws {Error} If a signature has already been generated.\n  */\n  Object.defineProperty(this, \"update\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        throw new Error(\"already final\");\n      }\n      if (data != null) {\n        data = util.asBuffer(data, encoding);\n        if (content.length) {\n          content = Buffer.concat([content, data],\n                      content.length + data.length);\n        } else {\n          content = data;\n        }\n      }\n\n      return this;\n    }\n  });\n  /**\n  * @method JWS.Signer#final\n  * @description\n  * Finishes the signature operation.\n  *\n  * The returned Promise, when fulfilled, is the JSON Web Signature (JWS)\n  * object, either in the Compact (if {@link JWS.Signer#format} is\n  * `\"compact\"`), the flattened JSON (if {@link JWS.Signer#format} is\n  * \"flattened\"), or the general JSON serialization.\n  *\n  * @param {Buffer|String} [data] The final content to apply.\n  * @param {String} [encoding=\"binary\"] The encoding of the final content\n  *        (if any).\n  * @returns {Promise} The promise for the signatures\n  * @throws {Error} If a signature has already been generated.\n  */\n  Object.defineProperty(this, \"final\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        return Promise.reject(new Error(\"already final\"));\n      }\n\n      // last-minute data\n      this.update(data, encoding);\n\n      // mark as done...ish\n      finalized = true;\n      var promise;\n\n      // map signatory promises to just signatories\n      promise = Promise.all(signatories);\n      promise = promise.then(function(sigs) {\n        // prepare content\n        content = util.base64url.encode(content);\n\n        sigs = sigs.map(function(s) {\n          // prepare protected\n          var protect = {},\n              lenProtect = 0,\n              unprotect = clone(s.header),\n              lenUnprotect = Object.keys(unprotect).length;\n          s.protected.forEach(function(h) {\n            if (!(h in unprotect)) {\n              return;\n            }\n            protect[h] = unprotect[h];\n            lenProtect++;\n            delete unprotect[h];\n            lenUnprotect--;\n          });\n          if (lenProtect > 0) {\n            protect = JSON.stringify(protect);\n            protect = util.base64url.encode(protect);\n          } else {\n            protect = \"\";\n          }\n\n          // signit!\n          var data = new Buffer(protect + \".\" + content, \"ascii\");\n          s = s.key.sign(s.header.alg, data, s.header);\n          s = s.then(function(result) {\n            var sig = {};\n            if (0 < lenProtect) {\n              sig.protected = protect;\n            }\n            if (0 < lenUnprotect) {\n              sig.header = unprotect;\n            }\n            sig.signature = util.base64url.encode(result.mac);\n            return sig;\n          });\n          return s;\n        });\n        sigs = [Promise.resolve(content)].concat(sigs);\n        return Promise.all(sigs);\n      });\n      promise = promise.then(function(results) {\n        var content = results[0];\n        return {\n          payload: content,\n          signatures: results.slice(1)\n        };\n      });\n      switch (format) {\n        case \"compact\":\n          promise = promise.then(function(jws) {\n            var compact = [\n              jws.signatures[0].protected,\n              jws.payload,\n              jws.signatures[0].signature\n            ];\n            compact = compact.join(\".\");\n            return compact;\n          });\n          break;\n        case \"flattened\":\n          promise = promise.then(function(jws) {\n            var flattened = {};\n            flattened.payload = jws.payload;\n\n            var sig = jws.signatures[0];\n            if (sig.protected) {\n              flattened.protected = sig.protected;\n            }\n            if (sig.header) {\n              flattened.header = sig.header;\n            }\n            flattened.signature = sig.signature;\n\n            return flattened;\n          });\n          break;\n      }\n\n      return promise;\n    }\n  });\n};\n\n\n/**\n * @description\n * Creates a new JWS.Signer with the given options and signatories.\n *\n * @param {Object} [opts] The signing options\n * @param {Boolean} [opts.compact] Use compact serialization?\n * @param {String} [opts.format] The serialization format to use (\"compact\",\n *                 \"flattened\", \"general\")\n * @param {Object} [opts.fields] Additional header fields\n * @param {JWK.Key[]|Object[]} [signs] Signatories, either as an array of\n *        JWK.Key instances; or an array of objects, each with the following\n *        properties\n * @param {JWK.Key} signs.key Key used to sign content\n * @param {Object} [signs.header] Per-signatory header fields\n * @param {String} [signs.reference] Reference field to identify the key\n * @param {String[]|String} [signs.protect] List of fields to integrity\n *        protect (\"*\" to protect all fields)\n * @returns {JWS.Signer} The signature generator.\n * @throws {Error} If Compact serialization is requested but there are\n *         multiple signatories\n */\nfunction createSign(opts, signs) {\n  // fixup signatories\n  var options = opts,\n      signStart = 1,\n      signList = signs;\n\n  if (arguments.length === 0) {\n    throw new Error(\"at least one signatory must be provided\");\n  }\n  if (arguments.length === 1) {\n    signList = opts;\n    signStart = 0;\n    options = {};\n  } else if (JWK.isKey(opts) ||\n            (opts && \"kty\" in opts) ||\n            (opts && \"key\" in opts &&\n            (JWK.isKey(opts.key) || \"kty\" in opts.key))) {\n    signList = opts;\n    signStart = 0;\n    options = {};\n  } else {\n    options = clone(opts);\n  }\n  if (!Array.isArray(signList)) {\n    signList = slice(arguments, signStart);\n  }\n\n  // fixup options\n  options = merge(clone(DEFAULTS), options);\n\n  // setup header fields\n  var allFields = options.fields || {};\n  // setup serialization format\n  var format = options.format;\n  if (!format) {\n    format = options.compact ? \"compact\" : \"general\";\n  }\n  if ((\"compact\" === format || \"flattened\" === format) && 1 < signList.length) {\n    throw new Error(\"too many signatories for compact or flattened JSON serialization\");\n  }\n\n  // note protected fields (globally)\n  // protected fields are per signature\n  var protectAll = (\"*\" === options.protect);\n  if (options.compact) {\n    protectAll = true;\n  }\n\n  signList = signList.map(function(s, idx) {\n    var p;\n\n    // resolve a key\n    if (s && \"kty\" in s) {\n      p = JWK.asKey(s);\n      p = p.then(function(k) {\n        return {\n          key: k\n        };\n      });\n    } else if (s) {\n      p = JWK.asKey(s.key);\n      p = p.then(function(k) {\n        return {\n          header: s.header,\n          reference: s.reference,\n          protect: s.protect,\n          key: k\n        };\n      });\n    } else {\n      p = Promise.reject(new Error(\"missing key for signatory \" + idx));\n    }\n\n    // resolve the complete signatory\n    p = p.then(function(signatory) {\n      var key = signatory.key;\n\n      // make sure there is a header\n      var header = signatory.header || {};\n      header = merge(merge({}, allFields), header);\n      signatory.header = header;\n\n      // ensure an algorithm\n      if (!header.alg) {\n        header.alg = key.algorithms(JWK.MODE_SIGN)[0] || \"\";\n      }\n\n      // determine the key reference\n      var ref = signatory.reference;\n      delete signatory.reference;\n      if (undefined === ref) {\n        // header already contains the key reference\n        ref = [\"kid\", \"jku\", \"x5c\", \"x5t\", \"x5u\"].some(function(k) {\n          return (k in header);\n        });\n        ref = !ref ? \"kid\" : null;\n      } else if (\"boolean\" === typeof ref) {\n        // explicit (positive | negative) request for key reference\n        ref = ref ? \"kid\" : null;\n      }\n      var jwk;\n      if (ref) {\n        jwk = key.toJSON();\n        if (\"jwk\" === ref) {\n          if (\"oct\" === key.kty) {\n            return Promise.reject(new Error(\"cannot embed key\"));\n          }\n          header.jwk = jwk;\n        } else if (ref in jwk) {\n          header[ref] = jwk[ref];\n        }\n      }\n\n      // determine protected fields\n      var protect = signatory.protect;\n      if (protectAll || \"*\" === protect) {\n        protect = Object.keys(header);\n      } else if (\"string\" === protect) {\n        protect = [protect];\n      } else if (Array.isArray(protect)) {\n        protect = protect.concat();\n      } else if (!protect) {\n        protect = [];\n      } else {\n        return Promise.reject(new Error(\"protect must be a list of fields\"));\n      }\n      protect = uniq(protect);\n      signatory.protected = protect;\n\n      // freeze signatory\n      signatory = Object.freeze(signatory);\n      return signatory;\n    });\n\n    return p;\n  });\n\n  var cfg = {\n    format: format\n  };\n  return new JWSSigner(cfg,\n                       signList);\n}\n\nmodule.exports = {\n  signer: JWSSigner,\n  createSign: createSign\n};\n"]},"metadata":{},"sourceType":"script"}