{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _cloneDeep2 = require('lodash/cloneDeep');\n\nvar _cloneDeep3 = _interopRequireDefault(_cloneDeep2);\n\nrequire('@webex/internal-plugin-lyra');\n\nrequire('@webex/internal-plugin-search');\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _uuid = require('uuid');\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nvar _constants = require('./constants');\n\nvar _collection = require('./collection');\n\nvar _collection2 = _interopRequireDefault(_collection);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar DeviceManager = _webexCore.WebexPlugin.extend({\n  namespace: 'DeviceManager',\n  _devicePendingPinChallenge: null,\n  _pairedDevice: null,\n  _boundSpace: null,\n  initialize: function initialize() {\n    var _this = this; // Lyra mercury events listener\n\n\n    this.webex.internal.mercury.on('event:lyra.space_updated', function (_ref) {\n      var data = _ref.data;\n\n      _this._receiveDeviceUpdates(data);\n    });\n  },\n\n  /**\n  * Gets a list of all recent devices associated with the user\n  * the device list gets populated from Redis\n  * @returns {Promise<Device>}\n  */\n  getAll: function getAll() {\n    return _collection2.default.getAll();\n  },\n\n  /**\n  * Gets a list of all recent devices associated with the user\n  * the device list gets populated from Redis\n  * @returns {Promise<Device>}\n  */\n  refresh: function refresh() {\n    var _this2 = this;\n\n    _collection2.default.reset();\n\n    return this.webex.request({\n      api: 'wdm',\n      resource: 'devices/auxiliary'\n    }).then(function (res) {\n      if (!res.body) {\n        return _promise2.default.reject();\n      }\n\n      return _this2._updateDeviceMetadata(res.body.items).then(function (devices) {\n        /* eslint-disable consistent-return */\n        devices.forEach(function (device) {\n          if (device.deviceInfo && device.deviceInfo.machineType === _constants.LYRA_SPACE) {\n            return _this2.webex.internal.lyra.space.get(device.deviceInfo).catch(function (err) {\n              _this2.logger.error('DeviceManager#refresh: failed to receive device info', err);\n            });\n          }\n        });\n        /* eslint-enable consistent-return */\n\n        res.body.items.forEach(function (device) {\n          _collection2.default.set(device);\n        });\n        return _this2.getAll();\n      });\n    }).catch(function (err) {\n      _this2.logger.error('DeviceManager#refresh: failed to fetch recent devices', err);\n    });\n  },\n\n  /**\n  * Search for a device by name\n  * @param {Object} options\n  * @param {string} options.searchQuery\n  * @returns {Promise<Device>}\n  */\n  search: function search(options) {\n    var _this3 = this;\n\n    if (!options || !options.searchQuery) {\n      this.logger.error('DeviceManager#search: options.searchQuery is required');\n      return _promise2.default.reject(new Error('DeviceManager#search: options.searchQuery is required'));\n    }\n\n    return this.webex.internal.search.people({\n      searchId: _uuid2.default.v4(),\n      searchType: 'DEVICE_SEARCH',\n      searchEntity: 'device',\n      includePeople: false,\n      includeRooms: true,\n      queryString: options.searchQuery\n    }).catch(function (err) {\n      _this3.logger.error('DeviceManager#search: failed to search a device', err);\n    });\n  },\n\n  /**\n  * Caches the device info and also registers to Redis for subsequent fetches\n  * @param {Object} device\n  * @param {string} device.id\n  * @returns {deviceInfo}\n  */\n  upsert: function upsert(device) {\n    var _this4 = this;\n\n    var deviceId = device.id || device.identity && device.identity.id;\n\n    if (!deviceId) {\n      this.logger.error('DeviceManager#upsert: device.id is required');\n      return _promise2.default.reject(new Error('DeviceManager#upsert: device.id is required'));\n    }\n\n    this._pairedDevice = this._devicePendingPinChallenge;\n    this._devicePendingPinChallenge = null; // check if the device is already existing, if so then merge else add\n\n    var existingDevice = _collection2.default.get(deviceId);\n\n    if (existingDevice) {\n      _collection2.default.set(device);\n\n      return _promise2.default.resolve(_collection2.default.get(deviceId));\n    } // new device requested, add to wdm for subsequent retreivals\n\n\n    return this.webex.request({\n      api: 'wdm',\n      method: 'PUT',\n      resource: 'devices/auxiliary/Room/' + deviceId\n    }).then(function (res) {\n      var auxDevice = res.body;\n      return _this4._decryptDeviceName(auxDevice);\n    }).then(function (device) {\n      _collection2.default.set(device);\n\n      return _promise2.default.resolve(_collection2.default.get(deviceId));\n    }).catch(function (err) {\n      _this4.logger.error('DeviceManager#upsert: failed to add/update a device', err);\n\n      return _promise2.default.reject(err);\n    });\n  },\n\n  /**\n  * Retreives device info of a particular device\n  * @param {string} token\n  * @returns {Promise<deviceInfo>}\n  */\n  get: function get(token) {\n    var _this5 = this;\n\n    if (!token) {\n      this.logger.error('DeviceManager#get: token is required');\n      return _promise2.default.reject(new Error('DeviceManager#get: token is required'));\n    }\n\n    var deviceInfo = void 0;\n    return this.webex.internal.lyra.getAdvertisedEndpoint(token).then(function (res) {\n      deviceInfo = res;\n      return _this5.webex.internal.lyra.space.get({\n        id: res.advertiser.id\n      });\n    }).then(function (result) {\n      // the deviceInfo doesn't have proper displayName, hence update\n      // displayName on deviceInfo for search to work\n      if (result && result.identity && result.identity.displayName) {\n        deviceInfo.advertiser.displayName = result.identity.displayName;\n      }\n\n      return deviceInfo;\n    }).catch(function (err) {\n      _this5.logger.error('DeviceManager#get: failed to get device info', err);\n\n      return _promise2.default.reject(err);\n    });\n  },\n\n  /**\n  * Unregisters the device from Redis, will not fetch in subsequent loads,\n  * similar to space.deleteBinding()\n  * @param {string} deviceId\n  * @returns {Promise<deviceInfo>}\n  */\n  remove: function remove(deviceId) {\n    var _this6 = this;\n\n    if (!deviceId) {\n      this.logger.error('DeviceManager#remove: deviceId is required');\n      return _promise2.default.reject(new Error('DeviceManager#remove: deviceId is required'));\n    }\n\n    return this.webex.request({\n      method: 'delete',\n      api: 'wdm',\n      resource: 'devices/auxiliary/' + deviceId\n    }).catch(function (error) {\n      _this6.logger.error('DeviceManager#remove: failed to remove the device', error);\n\n      return _promise2.default.reject(error);\n    });\n  },\n\n  /**\n  * Requests to display PIN on the device\n  * @param {object} device\n  * @param {object} options\n  * @param {object} options.data\n  * @returns {Promise<deviceInfo>}\n  */\n  requestPin: function requestPin(device) {\n    var _this7 = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var deviceId = device.id || device.identity && device.identity.id;\n\n    if (!deviceId) {\n      this.logger.error('DeviceManager#requestPin: device.id is required');\n      return _promise2.default.reject(new Error('DeviceManager#requestPin: device.id is required'));\n    }\n\n    var space = {\n      id: deviceId,\n      url: '/spaces/' + deviceId\n    };\n    return this.webex.internal.lyra.space.get(space).then(function (dev) {\n      // check if the space is pinChallenge capable\n      if (dev && dev.occupants && dev.occupants.pinChallenge) {\n        _this7.logger.info('DeviceManager#requestPin: space is PIN challenge capable');\n\n        return _this7.webex.internal.lyra.space.join(space, {\n          passType: 'MANUAL',\n          verificationInitiation: 'PIN',\n          data: options.data\n        }).then(function () {\n          _this7._devicePendingPinChallenge = dev; // return the actual device so that it can be upserted on successful\n          // PIN exchange\n\n          return dev;\n        });\n      } // pairs with the space if it's not PIN challenge capable\n\n\n      _this7.logger.info('DeviceManager#requestPin: space is not PIN challenge capable, probably already occupied, will still return device info');\n\n      return _this7.webex.internal.lyra.space.get(space).then(function () {\n        return _promise2.default.resolve(dev);\n      });\n    }).catch(function (err) {\n      _this7.logger.error('DeviceManager#requestPin: device failed PIN challenge request', err);\n\n      return _promise2.default.reject(err);\n    });\n  },\n\n  /**\n  * pairs the device with the user (manual pairing), also adds it to\n  * user's recents list for subsequent fetches.\n  * similar to space.join()\n  * @param {object} options\n  * @param {number} options.pin\n  * @returns {Promise<deviceInfo>}\n  */\n  pair: function pair() {\n    var _this8 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!options.pin) {\n      this.logger.error('DeviceManager#pair: options.pin is required');\n      return _promise2.default.reject(new Error('DeviceManager#pair: options.pin is required'));\n    }\n\n    if (this._devicePendingPinChallenge) {\n      var space = {\n        id: this._devicePendingPinChallenge.identity.id,\n        url: '/spaces/' + this._devicePendingPinChallenge.identity.id\n      };\n      return this.webex.internal.lyra.space.join(space, {\n        passType: 'PIN_ANSWER',\n        data: options.pin\n      }).catch(function (err) {\n        _this8.logger.error('DeviceManager#pair: incorrect PIN, unable to pair ', err);\n\n        return _promise2.default.reject(err);\n      }).then(function () {\n        return _this8.upsert(_this8._devicePendingPinChallenge);\n      });\n    }\n\n    this.logger.error('DeviceManager#pair: no device to pair');\n    return _promise2.default.reject(new Error('DeviceManager#pair: no device to pair'));\n  },\n\n  /**\n  * unpairs the device with the user (manual/ultrasonic pairing), but still\n  * keeps in the recents list/does not remove from Redis\n  * options.removeAllDevices will remove all associated devices to user\n  * similar to space.leave()\n  * @param {object} options\n  * @param {boolean} options.removeAllDevices\n  * @returns {Promise<deviceInfo>}\n  */\n  unpair: function unpair() {\n    var _this9 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#unpair: no device to unpair');\n      return _promise2.default.reject(new Error('DeviceManager#unpair: no device to unpair'));\n    }\n\n    var space = {\n      url: '/spaces/' + this._pairedDevice.identity.id\n    };\n    return this.webex.internal.lyra.space.leave(space, options).catch(function (err) {\n      _this9.logger.error('DeviceManager#unpair: failed to remove device from Lyra', err);\n\n      return _promise2.default.reject(err);\n    });\n  },\n\n  /**\n  * binds the space to the paired device (if supported)\n  * similar to space.bindConversation()\n  * @param {object} options\n  * @param {boolean} options.url, conversation url\n  * @param {boolean} options.kmsResourceObjectUrl of the convo\n  * @returns {Promise<deviceInfo>}\n  */\n  bindSpace: function bindSpace() {\n    var _this10 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!options.url) {\n      this.logger.error('DeviceManager#pair: options.url is required');\n      return _promise2.default.reject(new Error('DeviceManager#bindSpace: options.url is required'));\n    }\n\n    if (!options.kmsResourceObjectUrl) {\n      this.logger.error('DeviceManager#bindSpace: options.kmsResourceObjectUrl is required');\n      return _promise2.default.reject(new Error('DeviceManager#bindSpace: options.kmsResourceObjectUrl is required'));\n    }\n\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#bindSpace: No device paired currently');\n      return _promise2.default.reject(new Error('DeviceManager#bindSpace: No device paired currently'));\n    }\n\n    var space = {\n      url: '/spaces/' + this._pairedDevice.identity.id,\n      id: this._pairedDevice.identity.id\n    };\n    this._boundSpace = {\n      kmsResourceObjectUrl: options.kmsResourceObjectUrl,\n      url: options.url\n    };\n    return this.webex.internal.lyra.space.bindConversation(space, this._boundSpace).catch(function (err) {\n      _this10.logger.error('DeviceManager#bindSpace: failed to bind device to Space');\n\n      return _promise2.default.reject(err);\n    });\n  },\n\n  /**\n  * unbinds the space to the paired device (if supported)\n  * similar to space.unbindConversation()\n  * @returns {Promise<deviceInfo>}\n  */\n  unbindSpace: function unbindSpace() {\n    var _this11 = this;\n\n    if (!this._pairedDevice || !this._boundSpace) {\n      this.logger.error('DeviceManager#unbindSpace: No space currently bound to the device');\n      return _promise2.default.reject(new Error('DeviceManager#unbindSpace: No space currently bound to the device'));\n    }\n\n    var space = {\n      url: '/spaces/' + this._pairedDevice.identity.id,\n      id: this._pairedDevice.identity.id\n    };\n    return this.webex.internal.lyra.space.unbindConversation(space, this._boundSpace).then(function (res) {\n      _this11._boundSpace = null;\n      return _promise2.default.resolve(res);\n    }).catch(function (err) {\n      _this11.logger.error('DeviceManager#unbindSpace: failed to unbind Space to device');\n\n      return _promise2.default.reject(err);\n    });\n  },\n\n  /**\n  * Gets the audio state of the paired device\n  * similar to device.getAudioState()\n  * @returns {Promise<audioState>}\n  */\n  getAudioState: function getAudioState() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#getAudioState: Currently no device is paired');\n      return _promise2.default.reject(new Error('DeviceManager#getAudioState: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.getAudioState(this._pairedDevice);\n  },\n\n  /**\n  * Updates audio state of the paired device, should be called every 10 minutes\n  * or when mic or volume state is changed\n  * similar to device.putAudioState()\n  * @param {object} space\n  * @param {object} audioState\n  * @returns {Promise<audioState>}\n  */\n  putAudioState: function putAudioState(space) {\n    var audioState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.webex.internal.lyra.device.putAudioState(space, audioState);\n  },\n\n  /**\n  * Mutes paired device\n  * similar to device.mute()\n  * @returns {Promise<audioState>}\n  */\n  mute: function mute() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#mute: Currently no device is paired');\n      return _promise2.default.reject(new Error('DeviceManager#mute: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.mute(this._pairedDevice);\n  },\n\n  /**\n  * Unmutes paired device\n  * similar to device.unmute()\n  * @returns {Promise<audioState>}\n  */\n  unmute: function unmute() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#unmute: Currently no device is paired');\n      return _promise2.default.reject(new Error('DeviceManager#unmute: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.unmute(this._pairedDevice);\n  },\n\n  /**\n  * Increases paired device's volume\n  * similar to device.increaseVolume()\n  * @returns {Promise<audioState>}\n  */\n  increaseVolume: function increaseVolume() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#increaseVolume: Currently no device is paired');\n      return _promise2.default.reject(new Error('DeviceManager#increaseVolume: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.increaseVolume(this._pairedDevice);\n  },\n\n  /**\n  * Decreases paired device's volume\n  * similar to device.decreaseVolume()\n  * @returns {Promise<audioState>}\n  */\n  decreaseVolume: function decreaseVolume() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#decreaseVolume: Currently no device is paired');\n      return _promise2.default.reject(new Error('DeviceManager#decreaseVolume: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.decreaseVolume(this._pairedDevice);\n  },\n\n  /**\n  * Sets paired device's volume but should use increase and decrease api instead\n  * similar to device.setVolume()\n  * @param {number} level\n  * @returns {Promise<audioState>}\n  */\n  setVolume: function setVolume() {\n    var level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#setVolume: Currently no device is paired');\n      return _promise2.default.reject(new Error('DeviceManager#setVolume: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.setVolume(this._pairedDevice, level);\n  },\n\n  /**\n  * Utility function to update decrypted device name on device object\n  * @param {Array} deviceArray\n  * @returns {device}\n  */\n  _updateDeviceMetadata: function _updateDeviceMetadata() {\n    var _this12 = this;\n\n    var deviceArray = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    if (!deviceArray.length) {\n      return _promise2.default.resolve(deviceArray);\n    }\n\n    var devices = (0, _cloneDeep3.default)(deviceArray);\n    return _promise2.default.all(devices.map(function (device, index) {\n      return _this12.webex.internal.services.waitForCatalog('postauth').then(function () {\n        if (device.deviceClass === _constants.UC_CLOUD) {\n          device.id = _this12.webex.internal.services.get('wdm') + '/' + device.id;\n        }\n\n        return _this12._decryptDeviceName(device);\n      }).then(function (updatedDevice) {\n        devices[index] = updatedDevice;\n        return _promise2.default.resolve();\n      });\n    })).then(function () {\n      return _promise2.default.resolve(devices);\n    });\n  },\n\n  /**\n  * Utility function to update decrypted device name on device object\n  * @param {object} inDevice\n  * @returns {device}\n  */\n  _decryptDeviceName: function _decryptDeviceName() {\n    var _this13 = this;\n\n    var inDevice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var device = (0, _cloneDeep3.default)(inDevice);\n\n    if (device.metadata && device.metadata.encryptedUserAssignedName && device.metadata.encryptionKeyUrl) {\n      return this.webex.internal.encryption.decryptText(device.metadata.encryptionKeyUrl, device.metadata.encryptedUserAssignedName).then(function (decryptedDeviceName) {\n        // set userAssignedName as the decypted value, unset encryptedUserAssignedName since it's not needed\n        device.metadata.encryptedUserAssignedName = undefined;\n        device.metadata.userAssignedName = decryptedDeviceName;\n        return _promise2.default.resolve(device);\n      }).catch(function (err) {\n        // unset encryptedUserAssignedName if failed to decrypt\n        device.metadata.encryptedUserAssignedName = undefined;\n\n        _this13.logger.error('DeviceCollection#_decryptDeviceName: failed to decrypt device name', err);\n      });\n    }\n\n    return _promise2.default.resolve(device);\n  },\n\n  /**\n  * Utility function to update device info on mercury updates\n  * @param {object} device\n  * @returns {device}\n  */\n  _receiveDeviceUpdates: function _receiveDeviceUpdates(device) {\n    var _this14 = this; // we care only the updates are for the registered devices\n\n\n    if (device && device.spaceUrl) {\n      var deviceId = device.spaceUrl.substring(device.spaceUrl.lastIndexOf('/') + 1);\n\n      var existingDevice = _collection2.default.get(deviceId);\n\n      if (existingDevice) {\n        return this.webex.internal.lyra.space.get({\n          id: deviceId\n        }).then(function (space) {\n          var device = _collection2.default.get(deviceId);\n\n          if (device && space.occupants && (!space.occupants.self || !space.occupants.self.verified)) {\n            device.productName = space.devices && space.devices[0] && space.devices[0].productName || _constants.DEFAULT_PRODUCT_NAME; // pin challenge is not verified reset _pairedDevice if ids\n            // match\n\n            var pairedDeviceId = _this14._pairedDevice && (_this14._pairedDevice.id || _this14._pairedDevice.identity.id);\n\n            if (pairedDeviceId === deviceId) {\n              _this14._pairedDevice = null;\n\n              _this14.logger.info('DeviceManager#_receiveDeviceUpdates: device ' + deviceId + ' lost pairing');\n\n              return _promise2.default.resolve();\n            } // we do not want to reset the device pending PIN challenge\n\n\n            if (_this14._devicePendingPinChallenge.identity.id !== deviceId) {\n              return _this14.upsert(device);\n            }\n\n            return _promise2.default.resolve();\n          }\n\n          return _promise2.default.resolve();\n        }).catch(function (err) {\n          _this14.logger.error('DeviceManager#_receiveDeviceUpdates: failed to receive updates for Lyra space', err);\n        });\n      }\n    }\n\n    return _promise2.default.resolve();\n  },\n  version: '1.80.172'\n});\n\nexports.default = DeviceManager;","map":{"version":3,"sources":["device-manager.js"],"names":["DeviceManager","namespace","_devicePendingPinChallenge","_pairedDevice","_boundSpace","initialize","data","getAll","DeviceCollection","refresh","api","resource","res","devices","device","LYRA_SPACE","search","options","searchId","uuid","searchType","searchEntity","includePeople","includeRooms","queryString","searchQuery","upsert","deviceId","existingDevice","method","auxDevice","get","deviceInfo","id","result","remove","requestPin","space","url","dev","passType","verificationInitiation","pair","pin","unpair","bindSpace","kmsResourceObjectUrl","unbindSpace","getAudioState","putAudioState","audioState","mute","unmute","increaseVolume","decreaseVolume","setVolume","level","_updateDeviceMetadata","deviceArray","UC_CLOUD","_decryptDeviceName","inDevice","_receiveDeviceUpdates","DEFAULT_PRODUCT_NAME","pairedDeviceId"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\nimport {cloneDeep} from 'lodash';\nimport '@webex/internal-plugin-lyra';\nimport '@webex/internal-plugin-search';\nimport {WebexPlugin} from '@webex/webex-core';\nimport uuid from 'uuid';\n\nimport {LYRA_SPACE, UC_CLOUD, DEFAULT_PRODUCT_NAME} from './constants';\nimport DeviceCollection from './collection';\n\nconst DeviceManager = WebexPlugin.extend({\n  namespace: 'DeviceManager',\n  _devicePendingPinChallenge: null,\n  _pairedDevice: null,\n  _boundSpace: null,\n\n  initialize() {\n    // Lyra mercury events listener\n    this.webex.internal.mercury.on('event:lyra.space_updated', ({data}) => {\n      this._receiveDeviceUpdates(data);\n    });\n  },\n\n  /**\n  * Gets a list of all recent devices associated with the user\n  * the device list gets populated from Redis\n  * @returns {Promise<Device>}\n  */\n  getAll() {\n    return DeviceCollection.getAll();\n  },\n\n  /**\n  * Gets a list of all recent devices associated with the user\n  * the device list gets populated from Redis\n  * @returns {Promise<Device>}\n  */\n  refresh() {\n    DeviceCollection.reset();\n\n    return this.webex.request({\n      api: 'wdm',\n      resource: 'devices/auxiliary'\n    })\n      .then((res) => {\n        if (!res.body) {\n          return Promise.reject();\n        }\n\n        return this._updateDeviceMetadata(res.body.items)\n          .then((devices) => {\n            /* eslint-disable consistent-return */\n            devices.forEach((device) => {\n              if (device.deviceInfo &&\n                device.deviceInfo.machineType === LYRA_SPACE) {\n                return this.webex.internal.lyra.space.get(device.deviceInfo)\n                  .catch((err) => {\n                    this.logger.error('DeviceManager#refresh: failed to receive device info', err);\n                  });\n              }\n            });\n            /* eslint-enable consistent-return */\n            res.body.items.forEach((device) => {\n              DeviceCollection.set(device);\n            });\n\n            return this.getAll();\n          });\n      })\n      .catch((err) => {\n        this.logger.error('DeviceManager#refresh: failed to fetch recent devices', err);\n      });\n  },\n\n  /**\n  * Search for a device by name\n  * @param {Object} options\n  * @param {string} options.searchQuery\n  * @returns {Promise<Device>}\n  */\n  search(options) {\n    if (!options || !options.searchQuery) {\n      this.logger.error('DeviceManager#search: options.searchQuery is required');\n\n      return Promise.reject(new Error('DeviceManager#search: options.searchQuery is required'));\n    }\n\n    return this.webex.internal.search.people({\n      searchId: uuid.v4(),\n      searchType: 'DEVICE_SEARCH',\n      searchEntity: 'device',\n      includePeople: false,\n      includeRooms: true,\n      queryString: options.searchQuery\n    })\n      .catch((err) => {\n        this.logger.error('DeviceManager#search: failed to search a device', err);\n      });\n  },\n\n  /**\n  * Caches the device info and also registers to Redis for subsequent fetches\n  * @param {Object} device\n  * @param {string} device.id\n  * @returns {deviceInfo}\n  */\n  upsert(device) {\n    const deviceId = device.id || device.identity && device.identity.id;\n\n    if (!deviceId) {\n      this.logger.error('DeviceManager#upsert: device.id is required');\n\n      return Promise.reject(new Error('DeviceManager#upsert: device.id is required'));\n    }\n    this._pairedDevice = this._devicePendingPinChallenge;\n    this._devicePendingPinChallenge = null;\n    // check if the device is already existing, if so then merge else add\n    const existingDevice = DeviceCollection.get(deviceId);\n\n    if (existingDevice) {\n      DeviceCollection.set(device);\n\n      return Promise.resolve(DeviceCollection.get(deviceId));\n    }\n\n    // new device requested, add to wdm for subsequent retreivals\n    return this.webex.request({\n      api: 'wdm',\n      method: 'PUT',\n      resource: `devices/auxiliary/Room/${deviceId}`\n    })\n      .then((res) => {\n        const auxDevice = res.body;\n\n        return this._decryptDeviceName(auxDevice);\n      })\n      .then((device) => {\n        DeviceCollection.set(device);\n\n        return Promise.resolve(DeviceCollection.get(deviceId));\n      })\n      .catch((err) => {\n        this.logger.error('DeviceManager#upsert: failed to add/update a device', err);\n\n        return Promise.reject(err);\n      });\n  },\n\n  /**\n  * Retreives device info of a particular device\n  * @param {string} token\n  * @returns {Promise<deviceInfo>}\n  */\n  get(token) {\n    if (!token) {\n      this.logger.error('DeviceManager#get: token is required');\n\n      return Promise.reject(new Error('DeviceManager#get: token is required'));\n    }\n    let deviceInfo;\n\n    return this.webex.internal.lyra.getAdvertisedEndpoint(token)\n      .then((res) => {\n        deviceInfo = res;\n\n        return this.webex.internal.lyra.space.get({id: res.advertiser.id});\n      })\n      .then((result) => {\n        // the deviceInfo doesn't have proper displayName, hence update\n        // displayName on deviceInfo for search to work\n        if (result && result.identity && result.identity.displayName) {\n          deviceInfo.advertiser.displayName = result.identity.displayName;\n        }\n\n        return deviceInfo;\n      })\n      .catch((err) => {\n        this.logger.error('DeviceManager#get: failed to get device info', err);\n\n        return Promise.reject(err);\n      });\n  },\n\n  /**\n  * Unregisters the device from Redis, will not fetch in subsequent loads,\n  * similar to space.deleteBinding()\n  * @param {string} deviceId\n  * @returns {Promise<deviceInfo>}\n  */\n  remove(deviceId) {\n    if (!deviceId) {\n      this.logger.error('DeviceManager#remove: deviceId is required');\n\n      return Promise.reject(new Error('DeviceManager#remove: deviceId is required'));\n    }\n\n    return this.webex.request({\n      method: 'delete',\n      api: 'wdm',\n      resource: `devices/auxiliary/${deviceId}`\n    })\n      .catch((error) => {\n        this.logger.error('DeviceManager#remove: failed to remove the device', error);\n\n        return Promise.reject(error);\n      });\n  },\n\n  /**\n  * Requests to display PIN on the device\n  * @param {object} device\n  * @param {object} options\n  * @param {object} options.data\n  * @returns {Promise<deviceInfo>}\n  */\n  requestPin(device, options = {}) {\n    const deviceId = device.id || device.identity && device.identity.id;\n\n    if (!deviceId) {\n      this.logger.error('DeviceManager#requestPin: device.id is required');\n\n      return Promise.reject(new Error('DeviceManager#requestPin: device.id is required'));\n    }\n    const space = {id: deviceId, url: `/spaces/${deviceId}`};\n\n    return this.webex.internal.lyra.space.get(space)\n      .then((dev) => { // check if the space is pinChallenge capable\n        if (dev && dev.occupants && dev.occupants.pinChallenge) {\n          this.logger.info('DeviceManager#requestPin: space is PIN challenge capable');\n\n          return this.webex.internal.lyra.space.join(space, {\n            passType: 'MANUAL',\n            verificationInitiation: 'PIN',\n            data: options.data\n          })\n            .then(() => {\n              this._devicePendingPinChallenge = dev;\n\n              // return the actual device so that it can be upserted on successful\n              // PIN exchange\n              return dev;\n            });\n        }\n        // pairs with the space if it's not PIN challenge capable\n        this.logger.info('DeviceManager#requestPin: space is not PIN challenge capable, probably already occupied, will still return device info');\n\n        return this.webex.internal.lyra.space.get(space)\n          .then(() => Promise.resolve(dev));\n      })\n      .catch((err) => {\n        this.logger.error('DeviceManager#requestPin: device failed PIN challenge request', err);\n\n        return Promise.reject(err);\n      });\n  },\n\n  /**\n  * pairs the device with the user (manual pairing), also adds it to\n  * user's recents list for subsequent fetches.\n  * similar to space.join()\n  * @param {object} options\n  * @param {number} options.pin\n  * @returns {Promise<deviceInfo>}\n  */\n  pair(options = {}) {\n    if (!options.pin) {\n      this.logger.error('DeviceManager#pair: options.pin is required');\n\n      return Promise.reject(new Error('DeviceManager#pair: options.pin is required'));\n    }\n    if (this._devicePendingPinChallenge) {\n      const space = {id: this._devicePendingPinChallenge.identity.id, url: `/spaces/${this._devicePendingPinChallenge.identity.id}`};\n\n      return this.webex.internal.lyra.space.join(space, {\n        passType: 'PIN_ANSWER',\n        data: options.pin\n      })\n        .catch((err) => {\n          this.logger.error('DeviceManager#pair: incorrect PIN, unable to pair ', err);\n\n          return Promise.reject(err);\n        })\n        .then(() => this.upsert(this._devicePendingPinChallenge));\n    }\n    this.logger.error('DeviceManager#pair: no device to pair');\n\n    return Promise.reject(new Error('DeviceManager#pair: no device to pair'));\n  },\n\n  /**\n  * unpairs the device with the user (manual/ultrasonic pairing), but still\n  * keeps in the recents list/does not remove from Redis\n  * options.removeAllDevices will remove all associated devices to user\n  * similar to space.leave()\n  * @param {object} options\n  * @param {boolean} options.removeAllDevices\n  * @returns {Promise<deviceInfo>}\n  */\n  unpair(options = {}) {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#unpair: no device to unpair');\n\n      return Promise.reject(new Error('DeviceManager#unpair: no device to unpair'));\n    }\n    const space = {url: `/spaces/${this._pairedDevice.identity.id}`};\n\n    return this.webex.internal.lyra.space.leave(space, options)\n      .catch((err) => {\n        this.logger.error('DeviceManager#unpair: failed to remove device from Lyra', err);\n\n        return Promise.reject(err);\n      });\n  },\n\n  /**\n  * binds the space to the paired device (if supported)\n  * similar to space.bindConversation()\n  * @param {object} options\n  * @param {boolean} options.url, conversation url\n  * @param {boolean} options.kmsResourceObjectUrl of the convo\n  * @returns {Promise<deviceInfo>}\n  */\n  bindSpace(options = {}) {\n    if (!options.url) {\n      this.logger.error('DeviceManager#pair: options.url is required');\n\n      return Promise.reject(new Error('DeviceManager#bindSpace: options.url is required'));\n    }\n    if (!options.kmsResourceObjectUrl) {\n      this.logger.error('DeviceManager#bindSpace: options.kmsResourceObjectUrl is required');\n\n      return Promise.reject(new Error('DeviceManager#bindSpace: options.kmsResourceObjectUrl is required'));\n    }\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#bindSpace: No device paired currently');\n\n      return Promise.reject(new Error('DeviceManager#bindSpace: No device paired currently'));\n    }\n    const space = {url: `/spaces/${this._pairedDevice.identity.id}`, id: this._pairedDevice.identity.id};\n\n    this._boundSpace = {\n      kmsResourceObjectUrl: options.kmsResourceObjectUrl,\n      url: options.url\n    };\n\n    return this.webex.internal.lyra.space.bindConversation(space, this._boundSpace)\n      .catch((err) => {\n        this.logger.error('DeviceManager#bindSpace: failed to bind device to Space');\n\n        return Promise.reject(err);\n      });\n  },\n\n  /**\n  * unbinds the space to the paired device (if supported)\n  * similar to space.unbindConversation()\n  * @returns {Promise<deviceInfo>}\n  */\n  unbindSpace() {\n    if (!this._pairedDevice || !this._boundSpace) {\n      this.logger.error('DeviceManager#unbindSpace: No space currently bound to the device');\n\n      return Promise.reject(new Error('DeviceManager#unbindSpace: No space currently bound to the device'));\n    }\n    const space = {url: `/spaces/${this._pairedDevice.identity.id}`, id: this._pairedDevice.identity.id};\n\n    return this.webex.internal.lyra.space.unbindConversation(space, this._boundSpace)\n      .then((res) => {\n        this._boundSpace = null;\n\n        return Promise.resolve(res);\n      })\n      .catch((err) => {\n        this.logger.error('DeviceManager#unbindSpace: failed to unbind Space to device');\n\n        return Promise.reject(err);\n      });\n  },\n\n  /**\n  * Gets the audio state of the paired device\n  * similar to device.getAudioState()\n  * @returns {Promise<audioState>}\n  */\n  getAudioState() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#getAudioState: Currently no device is paired');\n\n      return Promise.reject(new Error('DeviceManager#getAudioState: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.getAudioState(this._pairedDevice);\n  },\n\n  /**\n  * Updates audio state of the paired device, should be called every 10 minutes\n  * or when mic or volume state is changed\n  * similar to device.putAudioState()\n  * @param {object} space\n  * @param {object} audioState\n  * @returns {Promise<audioState>}\n  */\n  putAudioState(space, audioState = {}) {\n    return this.webex.internal.lyra.device.putAudioState(space, audioState);\n  },\n\n  /**\n  * Mutes paired device\n  * similar to device.mute()\n  * @returns {Promise<audioState>}\n  */\n  mute() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#mute: Currently no device is paired');\n\n      return Promise.reject(new Error('DeviceManager#mute: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.mute(this._pairedDevice);\n  },\n\n  /**\n  * Unmutes paired device\n  * similar to device.unmute()\n  * @returns {Promise<audioState>}\n  */\n  unmute() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#unmute: Currently no device is paired');\n\n      return Promise.reject(new Error('DeviceManager#unmute: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.unmute(this._pairedDevice);\n  },\n\n  /**\n  * Increases paired device's volume\n  * similar to device.increaseVolume()\n  * @returns {Promise<audioState>}\n  */\n  increaseVolume() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#increaseVolume: Currently no device is paired');\n\n      return Promise.reject(new Error('DeviceManager#increaseVolume: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.increaseVolume(this._pairedDevice);\n  },\n\n  /**\n  * Decreases paired device's volume\n  * similar to device.decreaseVolume()\n  * @returns {Promise<audioState>}\n  */\n  decreaseVolume() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#decreaseVolume: Currently no device is paired');\n\n      return Promise.reject(new Error('DeviceManager#decreaseVolume: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.decreaseVolume(this._pairedDevice);\n  },\n\n  /**\n  * Sets paired device's volume but should use increase and decrease api instead\n  * similar to device.setVolume()\n  * @param {number} level\n  * @returns {Promise<audioState>}\n  */\n  setVolume(level = 0) {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#setVolume: Currently no device is paired');\n\n      return Promise.reject(new Error('DeviceManager#setVolume: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.setVolume(this._pairedDevice, level);\n  },\n\n  /**\n  * Utility function to update decrypted device name on device object\n  * @param {Array} deviceArray\n  * @returns {device}\n  */\n  _updateDeviceMetadata(deviceArray = []) {\n    if (!deviceArray.length) {\n      return Promise.resolve(deviceArray);\n    }\n    const devices = cloneDeep(deviceArray);\n\n    return Promise.all(devices.map(\n      (device, index) => this.webex.internal.services.waitForCatalog('postauth')\n        .then(() => {\n          if (device.deviceClass === UC_CLOUD) {\n            device.id = `${this.webex.internal.services.get('wdm')}/${device.id}`;\n          }\n\n          return this._decryptDeviceName(device);\n        })\n        .then((updatedDevice) => {\n          devices[index] = updatedDevice;\n\n          return Promise.resolve();\n        })\n    ))\n      .then(() => Promise.resolve(devices));\n  },\n\n  /**\n  * Utility function to update decrypted device name on device object\n  * @param {object} inDevice\n  * @returns {device}\n  */\n  _decryptDeviceName(inDevice = {}) {\n    const device = cloneDeep(inDevice);\n\n    if (device.metadata &&\n      device.metadata.encryptedUserAssignedName &&\n      device.metadata.encryptionKeyUrl) {\n      return this.webex.internal.encryption.decryptText(\n        device.metadata.encryptionKeyUrl, device.metadata.encryptedUserAssignedName\n      )\n        .then((decryptedDeviceName) => {\n          // set userAssignedName as the decypted value, unset encryptedUserAssignedName since it's not needed\n          device.metadata.encryptedUserAssignedName = undefined;\n          device.metadata.userAssignedName = decryptedDeviceName;\n\n          return Promise.resolve(device);\n        })\n        .catch((err) => {\n          // unset encryptedUserAssignedName if failed to decrypt\n          device.metadata.encryptedUserAssignedName = undefined;\n          this.logger.error('DeviceCollection#_decryptDeviceName: failed to decrypt device name', err);\n        });\n    }\n\n    return Promise.resolve(device);\n  },\n\n  /**\n  * Utility function to update device info on mercury updates\n  * @param {object} device\n  * @returns {device}\n  */\n  _receiveDeviceUpdates(device) {\n    // we care only the updates are for the registered devices\n    if (device && device.spaceUrl) {\n      const deviceId = device.spaceUrl.substring(device.spaceUrl.lastIndexOf('/') + 1);\n      const existingDevice = DeviceCollection.get(deviceId);\n\n      if (existingDevice) {\n        return this.webex.internal.lyra.space.get({id: deviceId})\n          .then((space) => {\n            const device = DeviceCollection.get(deviceId);\n\n            if (device &&\n              space.occupants &&\n              (!space.occupants.self || !space.occupants.self.verified)) {\n              device.productName = space.devices && space.devices[0] && space.devices[0].productName ||\n              DEFAULT_PRODUCT_NAME;\n              // pin challenge is not verified reset _pairedDevice if ids\n              // match\n              const pairedDeviceId = this._pairedDevice && (this._pairedDevice.id || this._pairedDevice.identity.id);\n\n              if (pairedDeviceId === deviceId) {\n                this._pairedDevice = null;\n                this.logger.info(`DeviceManager#_receiveDeviceUpdates: device ${deviceId} lost pairing`);\n\n                return Promise.resolve();\n              }\n              // we do not want to reset the device pending PIN challenge\n              if (this._devicePendingPinChallenge.identity.id !== deviceId) {\n                return this.upsert(device);\n              }\n\n              return Promise.resolve();\n            }\n\n            return Promise.resolve();\n          })\n          .catch((err) => {\n            this.logger.error('DeviceManager#_receiveDeviceUpdates: failed to receive updates for Lyra space', err);\n          });\n      }\n    }\n\n    return Promise.resolve();\n  }\n\n\n});\n\nexport default DeviceManager;\n"]},"metadata":{},"sourceType":"script"}