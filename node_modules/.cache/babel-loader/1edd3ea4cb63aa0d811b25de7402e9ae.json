{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _ampersandState = require('ampersand-state');\n\nvar _ampersandState2 = _interopRequireDefault(_ampersandState);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* eslint-disable no-underscore-dangle */\n\n/**\n * @class\n */\n\n\nvar ServiceUrl = _ampersandState2.default.extend({\n  namespace: 'ServiceUrl',\n  props: {\n    defaultUrl: ['string', true, undefined],\n    hosts: ['array', false, function () {\n      return [];\n    }],\n    name: ['string', true, undefined]\n  },\n\n  /**\n   * Generate a host url based on the host\n   * uri provided.\n   * @param {string} hostUri\n   * @returns {string}\n   */\n  _generateHostUrl: function _generateHostUrl(hostUri) {\n    var url = _url2.default.parse(this.defaultUrl); // setting url.hostname will not apply during Url.format(), set host via\n    // a string literal instead.\n\n\n    url.host = '' + hostUri + (url.port ? ':' + url.port : '');\n    return _url2.default.format(url);\n  },\n\n  /**\n   * Generate a list of urls based on this\n   * `ServiceUrl`'s known hosts.\n   * @returns {string[]}\n   */\n  _getHostUrls: function _getHostUrls() {\n    var _this = this;\n\n    return this.hosts.map(function (host) {\n      return {\n        url: _this._generateHostUrl(host.host),\n        priority: host.priority\n      };\n    });\n  },\n\n  /**\n   * Get the current host url with the highest priority. If a clusterId is not\n   * provided, this will only return a URL with a filtered host that has the\n   * `homeCluster` value set to `true`.\n   *\n   * @param {string} [clusterId] - The clusterId to filter for a priority host.\n   * @returns {string} - The priority host url.\n   */\n  _getPriorityHostUrl: function _getPriorityHostUrl(clusterId) {\n    if (this.hosts.length === 0) {\n      return this.defaultUrl;\n    }\n\n    var filteredHosts = clusterId ? this.hosts.filter(function (host) {\n      return host.id === clusterId;\n    }) : this.hosts.filter(function (host) {\n      return host.homeCluster;\n    });\n    var aliveHosts = filteredHosts.filter(function (host) {\n      return !host.failed;\n    });\n    filteredHosts = aliveHosts.length === 0 ? filteredHosts.map(function (host) {\n      /* eslint-disable-next-line no-param-reassign */\n      host.failed = false;\n      return host;\n    }) : aliveHosts;\n    return this._generateHostUrl(filteredHosts.reduce(function (previous, current) {\n      return previous.priority > current.priority || !previous.homeCluster ? current : previous;\n    }, {}).host);\n  },\n\n  /**\n   * Attempt to mark a host from this `ServiceUrl` as failed and return true\n   * if the provided url has a host that could be successfully marked as failed.\n   *\n   * @param {string} url\n   * @returns {boolean}\n   */\n  failHost: function failHost(url) {\n    if (url === this.defaultUrl) {\n      return true;\n    }\n\n    var _Url$parse = _url2.default.parse(url),\n        hostname = _Url$parse.hostname;\n\n    var foundHost = this.hosts.find(function (hostObj) {\n      return hostObj.host === hostname;\n    });\n\n    if (foundHost) {\n      foundHost.failed = true;\n    }\n\n    return foundHost !== undefined;\n  },\n\n  /**\n   * Get the current `defaultUrl` or generate a url using the host with the\n   * highest priority via host rendering.\n   *\n   * @param {boolean} [priorityHost] - Retrieve the priority host.\n   * @param {string} [clusterId] - Cluster to match a host against.\n   * @returns {string} - The full service url.\n   */\n  get: function get(priorityHost, clusterId) {\n    if (!priorityHost) {\n      return this.defaultUrl;\n    }\n\n    return this._getPriorityHostUrl(clusterId);\n  }\n});\n/* eslint-enable no-underscore-dangle */\n\n\nexports.default = ServiceUrl;","map":{"version":3,"sources":["service-url.js"],"names":["ServiceUrl","namespace","props","defaultUrl","hosts","name","_generateHostUrl","url","Url","_getHostUrls","host","priority","_getPriorityHostUrl","filteredHosts","aliveHosts","previous","current","failHost","hostname","foundHost","hostObj","get"],"mappings":"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","sourcesContent":["import Url from 'url';\n\nimport AmpState from 'ampersand-state';\n\n/* eslint-disable no-underscore-dangle */\n/**\n * @class\n */\nconst ServiceUrl = AmpState.extend({\n  namespace: 'ServiceUrl',\n\n  props: {\n    defaultUrl: ['string', true, undefined],\n    hosts: ['array', false, () => ([])],\n    name: ['string', true, undefined]\n  },\n\n  /**\n   * Generate a host url based on the host\n   * uri provided.\n   * @param {string} hostUri\n   * @returns {string}\n   */\n  _generateHostUrl(hostUri) {\n    const url = Url.parse(this.defaultUrl);\n\n    // setting url.hostname will not apply during Url.format(), set host via\n    // a string literal instead.\n    url.host = `${hostUri}${url.port ? `:${url.port}` : ''}`;\n\n    return Url.format(url);\n  },\n\n  /**\n   * Generate a list of urls based on this\n   * `ServiceUrl`'s known hosts.\n   * @returns {string[]}\n   */\n  _getHostUrls() {\n    return this.hosts.map((host) => ({\n      url: this._generateHostUrl(host.host),\n      priority: host.priority\n    }));\n  },\n\n  /**\n   * Get the current host url with the highest priority. If a clusterId is not\n   * provided, this will only return a URL with a filtered host that has the\n   * `homeCluster` value set to `true`.\n   *\n   * @param {string} [clusterId] - The clusterId to filter for a priority host.\n   * @returns {string} - The priority host url.\n   */\n  _getPriorityHostUrl(clusterId) {\n    if (this.hosts.length === 0) {\n      return this.defaultUrl;\n    }\n\n    let filteredHosts = clusterId ?\n      this.hosts.filter((host) => host.id === clusterId) :\n      this.hosts.filter((host) => host.homeCluster);\n\n    const aliveHosts = filteredHosts.filter(\n      (host) => !host.failed\n    );\n\n    filteredHosts = (aliveHosts.length === 0) ?\n      filteredHosts.map(\n        (host) => {\n          /* eslint-disable-next-line no-param-reassign */\n          host.failed = false;\n\n          return host;\n        }\n      ) : aliveHosts;\n\n    return this._generateHostUrl(filteredHosts.reduce((previous, current) => (\n      (previous.priority > current.priority || !previous.homeCluster) ?\n        current : previous\n    ), {}).host);\n  },\n\n  /**\n   * Attempt to mark a host from this `ServiceUrl` as failed and return true\n   * if the provided url has a host that could be successfully marked as failed.\n   *\n   * @param {string} url\n   * @returns {boolean}\n   */\n  failHost(url) {\n    if (url === this.defaultUrl) {\n      return true;\n    }\n\n    const {hostname} = Url.parse(url);\n    const foundHost = this.hosts.find((hostObj) => hostObj.host === hostname);\n\n    if (foundHost) {\n      foundHost.failed = true;\n    }\n\n    return (foundHost !== undefined);\n  },\n\n  /**\n   * Get the current `defaultUrl` or generate a url using the host with the\n   * highest priority via host rendering.\n   *\n   * @param {boolean} [priorityHost] - Retrieve the priority host.\n   * @param {string} [clusterId] - Cluster to match a host against.\n   * @returns {string} - The full service url.\n   */\n  get(priorityHost, clusterId) {\n    if (!priorityHost) {\n      return this.defaultUrl;\n    }\n\n    return this._getPriorityHostUrl(clusterId);\n  }\n});\n/* eslint-enable no-underscore-dangle */\n\nexport default ServiceUrl;\n"]},"metadata":{},"sourceType":"script"}