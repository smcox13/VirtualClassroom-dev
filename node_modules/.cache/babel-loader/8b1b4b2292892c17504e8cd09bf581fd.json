{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * stores the last x filtered stream datas\n */\n\n/**\n * @export\n * @class StatsHistory\n */\n\n\nvar StatsHistory = function () {\n  /**\n   * instantiate our wrapped history array\n   * @param {Number} max\n   */\n  function StatsHistory(max) {\n    (0, _classCallCheck3.default)(this, StatsHistory);\n    /**\n     * @instance\n     * @type {Array}\n     * @public\n     * @memberof StatsHistory\n     */\n\n    this.history = [];\n    /**\n     * @instance\n     * @type {Number}\n     * @public\n     * @memberof StatsHistory\n     */\n\n    this.max = max;\n  }\n  /**\n   * @returns {Array} the array of stats reports, read from [0] = most recent to [length - 1] = least recent\n   * @public\n   * @memberof StatsHistory\n   */\n\n\n  (0, _createClass3.default)(StatsHistory, [{\n    key: \"get\",\n    value: function get() {\n      return this.history;\n    }\n    /**\n     * deletes the history array and resets it\n     * @returns {undefined}\n     * @public\n     * @memberof StatsHistory\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.history = [];\n    }\n    /**\n     * gets the stored stat\n     * @param {Number} index the location\n     * @returns {Object} the stat at location index\n     * @public\n     * @memberof StatsHistory\n     */\n\n  }, {\n    key: \"getAt\",\n    value: function getAt(index) {\n      return this.history[index];\n    }\n    /**\n     * gets the most recently stored stat\n     * @returns {Object} the most recently added stat to the history recorder\n     * @public\n     * @memberof StatsHistory\n     */\n\n  }, {\n    key: \"getMostRecent\",\n    value: function getMostRecent() {\n      return this.history.length > 1 ? this.getAt(0) : null;\n    }\n    /**\n     * gets the last two values, that can be used to compare\n     * @returns {Object} {previous: WebRTCData, current: WebRTCData}\n     */\n\n  }, {\n    key: \"getComparable\",\n    value: function getComparable() {\n      return {\n        previous: this.getMostRecent(),\n        current: this.history.length > 2 ? this.getAt(1) : null\n      };\n    }\n    /**\n     * gets a cut of the n most recent WebRTC datas stored\n     * @param {Number} exclusiveEnd\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getSlice\",\n    value: function getSlice(exclusiveEnd) {\n      return this.history.slice(0, exclusiveEnd);\n    }\n    /**\n     * adds a history entry into tshe array at the head, removes from the tail\n     * if too large, returns the old tail if removed\n     * @param {WebRTCData} data filtered stats report to add to the history array\n     * @returns {Object} the removed stats report at the end if that had to be removed\n     * to make space for the new stats data report to be added to the front\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(data) {\n      var removed = null;\n\n      if (this.history.length >= this.max) {\n        removed = this.history.pop();\n      }\n\n      this.history.unshift(data);\n      return removed;\n    }\n  }]);\n  return StatsHistory;\n}();\n\nexports.default = StatsHistory;","map":{"version":3,"sources":["history.js"],"names":["StatsHistory","index","previous","current","exclusiveEnd","data","removed"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;;;;AAGA;;;;;;IAIqBA,Y;AACnB;;;;AAIA,WAAA,YAAA,CAAA,GAAA,EAAiB;AAAA,KAAA,GAAA,gBAAA,CAAA,OAAA,EAAA,IAAA,EAAA,YAAA;AACf;;;;;;;AAMA,SAAA,OAAA,GAAA,EAAA;AACA;;;;;;;AAMA,SAAA,GAAA,GAAA,GAAA;AACD;AAED;;;;;;;;;0BAKM;AACJ,aAAO,KAAP,OAAA;AACD;AAED;;;;;;;;;4BAMQ;AACN,WAAA,OAAA,GAAA,EAAA;AACD;AAED;;;;;;;;;;0BAOMC,K,EAAO;AACX,aAAO,KAAA,OAAA,CAAP,KAAO,CAAP;AACD;AAED;;;;;;;;;oCAMgB;AACd,aAAO,KAAA,OAAA,CAAA,MAAA,GAAA,CAAA,GAA0B,KAAA,KAAA,CAA1B,CAA0B,CAA1B,GAAP,IAAA;AACD;AAED;;;;;;;oCAIgB;AACd,aAAO;AACLC,QAAAA,QAAAA,EAAU,KADL,aACK,EADL;AAELC,QAAAA,OAAAA,EAAS,KAAA,OAAA,CAAA,MAAA,GAAA,CAAA,GAA0B,KAAA,KAAA,CAA1B,CAA0B,CAA1B,GAA0C;AAF9C,OAAP;AAID;AAED;;;;;;;;6BAKSC,Y,EAAc;AACrB,aAAO,KAAA,OAAA,CAAA,KAAA,CAAA,CAAA,EAAP,YAAO,CAAP;AACD;AAED;;;;;;;;;;wBAOIC,I,EAAM;AACR,UAAIC,OAAAA,GAAJ,IAAA;;AAEA,UAAI,KAAA,OAAA,CAAA,MAAA,IAAuB,KAA3B,GAAA,EAAqC;AACnCA,QAAAA,OAAAA,GAAU,KAAA,OAAA,CAAVA,GAAU,EAAVA;AACD;;AACD,WAAA,OAAA,CAAA,OAAA,CAAA,IAAA;AAEA,aAAA,OAAA;AACD;;;;;kBAlGkBN,Y","sourcesContent":["/**\n * stores the last x filtered stream datas\n */\n/**\n * @export\n * @class StatsHistory\n */\nexport default class StatsHistory {\n  /**\n   * instantiate our wrapped history array\n   * @param {Number} max\n   */\n  constructor(max) {\n    /**\n     * @instance\n     * @type {Array}\n     * @public\n     * @memberof StatsHistory\n     */\n    this.history = [];\n    /**\n     * @instance\n     * @type {Number}\n     * @public\n     * @memberof StatsHistory\n     */\n    this.max = max;\n  }\n\n  /**\n   * @returns {Array} the array of stats reports, read from [0] = most recent to [length - 1] = least recent\n   * @public\n   * @memberof StatsHistory\n   */\n  get() {\n    return this.history;\n  }\n\n  /**\n   * deletes the history array and resets it\n   * @returns {undefined}\n   * @public\n   * @memberof StatsHistory\n   */\n  clear() {\n    this.history = [];\n  }\n\n  /**\n   * gets the stored stat\n   * @param {Number} index the location\n   * @returns {Object} the stat at location index\n   * @public\n   * @memberof StatsHistory\n   */\n  getAt(index) {\n    return this.history[index];\n  }\n\n  /**\n   * gets the most recently stored stat\n   * @returns {Object} the most recently added stat to the history recorder\n   * @public\n   * @memberof StatsHistory\n   */\n  getMostRecent() {\n    return this.history.length > 1 ? this.getAt(0) : null;\n  }\n\n  /**\n   * gets the last two values, that can be used to compare\n   * @returns {Object} {previous: WebRTCData, current: WebRTCData}\n   */\n  getComparable() {\n    return {\n      previous: this.getMostRecent(),\n      current: this.history.length > 2 ? this.getAt(1) : null\n    };\n  }\n\n  /**\n   * gets a cut of the n most recent WebRTC datas stored\n   * @param {Number} exclusiveEnd\n   * @returns {Array}\n   */\n  getSlice(exclusiveEnd) {\n    return this.history.slice(0, exclusiveEnd);\n  }\n\n  /**\n   * adds a history entry into tshe array at the head, removes from the tail\n   * if too large, returns the old tail if removed\n   * @param {WebRTCData} data filtered stats report to add to the history array\n   * @returns {Object} the removed stats report at the end if that had to be removed\n   * to make space for the new stats data report to be added to the front\n   */\n  add(data) {\n    let removed = null;\n\n    if (this.history.length >= this.max) {\n      removed = this.history.pop();\n    }\n    this.history.unshift(data);\n\n    return removed;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}