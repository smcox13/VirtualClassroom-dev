{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nvar _map = require('babel-runtime/core-js/map');\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _weakMap = require('babel-runtime/core-js/weak-map');\n\nvar _weakMap2 = _interopRequireDefault(_weakMap);\n\nvar _result2 = require('lodash/result');\n\nvar _result3 = _interopRequireDefault(_result2);\n\nvar _isObject2 = require('lodash/isObject');\n\nvar _isObject3 = _interopRequireDefault(_isObject2);\n\nvar _isArray2 = require('lodash/isArray');\n\nvar _isArray3 = _interopRequireDefault(_isArray2);\n\nexports.default = makeWebexPluginStorage;\n\nvar _common = require('@webex/common');\n\nvar _errors = require('./errors');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar defers = new _weakMap2.default();\n/**\n * Walks an object before writing it to the store and omits empty arrays\n * @private\n * @param {Object} value\n * @returns {Object}\n */\n\nfunction serialize(value) {\n  if (!(0, _isObject3.default)(value)) {\n    return value;\n  }\n\n  var serialized = value.serialize ? value.serialize() : value;\n  (0, _keys2.default)(serialized).forEach(function (key) {\n    var val = serialized[key];\n\n    if ((0, _isArray3.default)(val)) {\n      if (val.length === 0) {\n        serialized[key] = undefined;\n      } else {\n        serialized[key] = val.map(serialize);\n      }\n    } else if ((0, _isObject3.default)(val)) {\n      (0, _keys2.default)(val).forEach(function (k) {\n        val[k] = serialize(val[k]);\n      });\n    }\n  });\n  var empty = (0, _keys2.default)(serialized).reduce(function (acc, key) {\n    return acc && !serialized[key];\n  }, true);\n\n  if (empty) {\n    return undefined;\n  }\n\n  return serialized;\n}\n/**\n * [makeWebexPluginStorage description]\n * @param {[type]} type\n * @param {[type]} context\n * @private\n * @returns {[type]}\n */\n\n\nfunction makeWebexPluginStorage(type, context) {\n  var _dec, _desc, _value, _class;\n  /**\n   * Interface between WebexPlugin and Webex#boundeStorage or\n   * Webex#unboundedStorage\n   */\n\n\n  var WebexPluginStorage = (_dec = (0, _common.oneFlight)({\n    keyFactory: function keyFactory(key) {\n      return 'initValue-' + key;\n    }\n  }), (_class = function () {\n    /**\n     * @param {Object} attrs\n     * @param {Object} options\n     * @returns {WebexPluginStorage}\n     */\n    function WebexPluginStorage() {\n      (0, _classCallCheck3.default)(this, WebexPluginStorage);\n      defers.set(this, new _map2.default());\n    }\n    /**\n     * Clears an entire namespace\n     * @returns {Promise}\n     */\n\n\n    (0, _createClass3.default)(WebexPluginStorage, [{\n      key: 'clear',\n      value: function clear() {\n        return context.webex[type + 'Storage'].del(context.getNamespace());\n      }\n      /**\n       * Deletes the specified key from the store\n       * @param {string} key\n       * @returns {[type]}\n       */\n\n    }, {\n      key: 'del',\n      value: function del() {\n        var _context$webex$;\n\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return (_context$webex$ = context.webex[type + 'Storage']).del.apply(_context$webex$, [context.getNamespace()].concat(args));\n      }\n      /**\n       * Retrieves the value specified by key from the store. Rejects with\n       * NotFoundError if no value can be found\n       * @param {string} key\n       * @returns {Promise}\n       */\n\n    }, {\n      key: 'get',\n      value: function get(key) {\n        var defer = defers.get(this).get(key);\n\n        if (!defer) {\n          defer = new _common.Defer();\n          defers.get(this).set(key, defer);\n        }\n\n        return context.webex[type + 'Storage'].get(context.getNamespace(), key).then(function (res) {\n          defer.resolve();\n          return res;\n        });\n      }\n      /**\n       * Writes a value to the store\n       * @param {string} key\n       * @param {any} value\n       * @returns {Promise}\n       */\n\n    }, {\n      key: 'put',\n      value: function put(key, value) {\n        return context.webex[type + 'Storage'].put(context.getNamespace(), key, serialize(value));\n      }\n      /**\n       * Returns a Promise that won't resolve until the value specified by key has\n       * been attempted to be loaded from the store. This allows us to lazily\n       * prevent certain method from executing until the specified keys have been\n       * retrieved from the store.\n       * @param {string} key\n       * @returns {Promise}\n       */\n\n    }, {\n      key: 'waitFor',\n      value: function waitFor(key) {\n        context.logger.debug('plugin-storage(' + context.getNamespace() + '): waiting to init key `' + key + '`');\n        var defer = defers.get(this).get(key);\n\n        if (defer) {\n          context.logger.debug('plugin-storage(' + context.getNamespace() + '): already inited `' + key + '`');\n          return defer.promise;\n        }\n\n        context.logger.debug('plugin-storage(' + context.getNamespace() + '): initing `' + key + '`');\n        return this.initValue(key);\n      }\n    }, {\n      key: 'initValue',\n\n      /**\n       * Attempts to load the specified key from the store and set it on the parent\n       * object.\n       * @param {string} key\n       * @returns {Promise} Resolves (but not with the retrieved value) when\n       * the value retrieval complete\n       */\n      // suppress doc warning because decorators confuse eslint\n      // eslint-disable-next-line require-jsdoc\n      value: function initValue(key) {\n        var defer = new _common.Defer();\n        defers.get(this).set(key, defer); // Intentionally bypasses this.get so we don't resolve the promise until\n        // after the parent value is set.\n\n        context.webex[type + 'Storage'].get(context.getNamespace(), key).then(function (value) {\n          context.logger.debug('plugin-storage(' + context.getNamespace() + '): got `' + key + '` for first time');\n\n          if (key === '@') {\n            context.parent.set(value);\n          } else if ((0, _result3.default)(context[key], 'isState')) {\n            context[key].set(value);\n          } else {\n            context.set(key, value);\n          }\n\n          context.logger.debug('plugin-storage(' + context.getNamespace() + '): set `' + key + '` for first time');\n          defer.resolve();\n          context.logger.debug('plugin-storage(' + context.getNamespace() + '): inited `' + key + '`');\n        }).catch(function (reason) {\n          // The  next conditional is a bit of an unfortunate solution to deal\n          // with circular dependencies in unit tests. It should not effect\n          // integration tests or production code.\n          if (reason instanceof _errors.NotFoundError || process.env.NODE_ENV !== 'production' && reason.toString().includes('MockNotFoundError')) {\n            context.logger.debug('plugin-storage(' + context.getNamespace() + '): no data for `' + key + '`, continuing');\n            return defer.resolve();\n          }\n\n          context.logger.warn('plugin-storage(' + context.getNamespace() + '): failed to init `' + key + '`', reason);\n          return defer.reject(reason);\n        });\n        return defer.promise;\n      }\n    }]);\n    return WebexPluginStorage;\n  }(), _applyDecoratedDescriptor(_class.prototype, 'initValue', [_dec], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'initValue'), _class.prototype), _class));\n  return new WebexPluginStorage();\n}","map":{"version":3,"sources":["make-webex-plugin-store.js"],"names":["defers","serialized","value","val","serialize","empty","acc","makeWebexPluginStorage","WebexPluginStorage","context","type","args","defer","Defer","keyFactory","key","reason","NotFoundError","process"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {Defer, oneFlight} from '@webex/common';\nimport {isArray, isObject, result} from 'lodash';\nimport {NotFoundError} from './errors';\n\nconst defers = new WeakMap();\n\n/**\n * Walks an object before writing it to the store and omits empty arrays\n * @private\n * @param {Object} value\n * @returns {Object}\n */\nfunction serialize(value) {\n  if (!isObject(value)) {\n    return value;\n  }\n\n  const serialized = value.serialize ? value.serialize() : value;\n\n  Object.keys(serialized).forEach((key) => {\n    const val = serialized[key];\n\n    if (isArray(val)) {\n      if (val.length === 0) {\n        serialized[key] = undefined;\n      }\n      else {\n        serialized[key] = val.map(serialize);\n      }\n    }\n    else if (isObject(val)) {\n      Object.keys(val).forEach((k) => {\n        val[k] = serialize(val[k]);\n      });\n    }\n  });\n\n  const empty = Object.keys(serialized).reduce((acc, key) => acc && !serialized[key], true);\n\n  if (empty) {\n    return undefined;\n  }\n\n  return serialized;\n}\n\n/**\n * [makeWebexPluginStorage description]\n * @param {[type]} type\n * @param {[type]} context\n * @private\n * @returns {[type]}\n */\nexport default function makeWebexPluginStorage(type, context) {\n  /**\n   * Interface between WebexPlugin and Webex#boundeStorage or\n   * Webex#unboundedStorage\n   */\n  class WebexPluginStorage {\n    /**\n     * @param {Object} attrs\n     * @param {Object} options\n     * @returns {WebexPluginStorage}\n     */\n    constructor() {\n      defers.set(this, new Map());\n    }\n\n    /**\n     * Clears an entire namespace\n     * @returns {Promise}\n     */\n    clear() {\n      return context.webex[`${type}Storage`].del(context.getNamespace());\n    }\n\n    /**\n     * Deletes the specified key from the store\n     * @param {string} key\n     * @returns {[type]}\n     */\n    del(...args) {\n      return context.webex[`${type}Storage`].del(context.getNamespace(), ...args);\n    }\n\n    /**\n     * Retrieves the value specified by key from the store. Rejects with\n     * NotFoundError if no value can be found\n     * @param {string} key\n     * @returns {Promise}\n     */\n    get(key) {\n      let defer = defers.get(this).get(key);\n\n      if (!defer) {\n        defer = new Defer();\n        defers.get(this).set(key, defer);\n      }\n\n      return context.webex[`${type}Storage`].get(context.getNamespace(), key)\n        .then((res) => {\n          defer.resolve();\n\n          return res;\n        });\n    }\n\n    /**\n     * Writes a value to the store\n     * @param {string} key\n     * @param {any} value\n     * @returns {Promise}\n     */\n    put(key, value) {\n      return context.webex[`${type}Storage`].put(context.getNamespace(), key, serialize(value));\n    }\n\n    /**\n     * Returns a Promise that won't resolve until the value specified by key has\n     * been attempted to be loaded from the store. This allows us to lazily\n     * prevent certain method from executing until the specified keys have been\n     * retrieved from the store.\n     * @param {string} key\n     * @returns {Promise}\n     */\n    waitFor(key) {\n      context.logger.debug(`plugin-storage(${context.getNamespace()}): waiting to init key \\`${key}\\``);\n      const defer = defers.get(this).get(key);\n\n      if (defer) {\n        context.logger.debug(`plugin-storage(${context.getNamespace()}): already inited \\`${key}\\``);\n\n        return defer.promise;\n      }\n\n      context.logger.debug(`plugin-storage(${context.getNamespace()}): initing \\`${key}\\``);\n\n      return this.initValue(key);\n    }\n\n    @oneFlight({keyFactory: (key) => `initValue-${key}`})\n    /**\n     * Attempts to load the specified key from the store and set it on the parent\n     * object.\n     * @param {string} key\n     * @returns {Promise} Resolves (but not with the retrieved value) when\n     * the value retrieval complete\n     */\n    // suppress doc warning because decorators confuse eslint\n    // eslint-disable-next-line require-jsdoc\n    initValue(key) {\n      const defer = new Defer();\n\n      defers.get(this).set(key, defer);\n\n      // Intentionally bypasses this.get so we don't resolve the promise until\n      // after the parent value is set.\n      context.webex[`${type}Storage`].get(context.getNamespace(), key)\n        .then((value) => {\n          context.logger.debug(`plugin-storage(${context.getNamespace()}): got \\`${key}\\` for first time`);\n          if (key === '@') {\n            context.parent.set(value);\n          }\n          else if (result(context[key], 'isState')) {\n            context[key].set(value);\n          }\n          else {\n            context.set(key, value);\n          }\n          context.logger.debug(`plugin-storage(${context.getNamespace()}): set \\`${key}\\` for first time`);\n          defer.resolve();\n          context.logger.debug(`plugin-storage(${context.getNamespace()}): inited \\`${key}\\``);\n        })\n        .catch((reason) => {\n          // The  next conditional is a bit of an unfortunate solution to deal\n          // with circular dependencies in unit tests. It should not effect\n          // integration tests or production code.\n          if (reason instanceof NotFoundError || process.env.NODE_ENV !== 'production' && reason.toString().includes('MockNotFoundError')) {\n            context.logger.debug(`plugin-storage(${context.getNamespace()}): no data for \\`${key}\\`, continuing`);\n\n            return defer.resolve();\n          }\n          context.logger.warn(`plugin-storage(${context.getNamespace()}): failed to init \\`${key}\\``, reason);\n\n          return defer.reject(reason);\n        });\n\n      return defer.promise;\n    }\n  }\n\n  return new WebexPluginStorage();\n}\n"]},"metadata":{},"sourceType":"script"}