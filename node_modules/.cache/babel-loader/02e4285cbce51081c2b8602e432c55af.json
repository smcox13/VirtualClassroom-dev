{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = makeStateDataType;\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n// Reminder: any class using this function must have something like the\n// following in its initialize method:\n//\n// // HACK to deal with the fact that AmpersandState#dataTypes#set is a pure\n// // function.\n// this._dataTypes = cloneDeep(this._dataTypes);\n// Object.keys(this._dataTypes).forEach((key) => {\n//   if (this._dataTypes[key].set) {\n//     this._dataTypes[key].set = this._dataTypes[key].set.bind(this);\n//   }\n// });\n// // END HACK\n\n/**\n * Creates an ampersand state object that wires its event handlers like a an\n * ampersand child\n * @param {Function} Constructor\n * @param {string} name\n * @returns {Object}\n */\n\nfunction makeStateDataType(Constructor, name) {\n  if (!Constructor || !name) {\n    throw new Error('missing parameter for makeStateDataType');\n  }\n\n  return {\n    dataType: {\n      set: function set(newVal) {\n        // newVal.parent = this;\n        if (newVal instanceof Constructor) {\n          newVal.parent = this;\n          return {\n            val: newVal,\n            type: name\n          };\n        } // We only want to construct the new instance if we have some set of\n        // attributes (even an empty object) to base it on. This is to deal with\n        // the unexpected side effect that AmpState#unset will create a new\n        // instance.\n\n\n        return {\n          val: newVal ? new Constructor(newVal, {\n            parent: this\n          }) : undefined,\n          type: name\n        };\n      },\n      compare: function compare(currentValue, newVal) {\n        return currentValue === newVal;\n      },\n      onChange: function onChange(newVal, previousVal, attributeName) {\n        // Copied from ampersand-state.js\n        // if this has changed we want to also handle\n        // event propagation\n        if (previousVal) {\n          this.stopListening(previousVal, 'all', this._getCachedEventBubblingHandler(attributeName));\n        }\n\n        if (newVal) {\n          this.listenTo(newVal, 'all', this._getCachedEventBubblingHandler(attributeName));\n        }\n      }\n    },\n    prop: {\n      /**\n       * This is a really unfortunate hack to deal with ampersand`s decision to\n       * make the dateType#set function pure. The only function called with the\n       * scope of the parent at set time seems to be test\n       * @param {AmpersandState} newVal\n       * @returns {boolean}\n       */\n      test: function test(newVal) {\n        if (!newVal) {\n          return false;\n        }\n\n        newVal.parent = this;\n        return false;\n      },\n      type: name\n    }\n  };\n}","map":{"version":3,"sources":["make-state-datatype.js"],"names":["makeStateDataType","dataType","set","newVal","val","type","name","parent","compare","currentValue","onChange","prop","test"],"mappings":";;;;;kBAwBwBA,iB;AAxBxB;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AAOe,SAAA,iBAAA,CAAA,WAAA,EAAA,IAAA,EAA8C;AAC3D,MAAI,CAAA,WAAA,IAAgB,CAApB,IAAA,EAA2B;AACzB,UAAM,IAAA,KAAA,CAAN,yCAAM,CAAN;AACD;;AAED,SAAO;AACLC,IAAAA,QAAAA,EAAU;AACRC,MAAAA,GAAAA,EAAK,SAAA,GAAA,CAAA,MAAA,EAAqB;AACxB;AACA,YAAIC,MAAAA,YAAJ,WAAA,EAAmC;AACjCA,UAAAA,MAAAA,CAAAA,MAAAA,GAAAA,IAAAA;AAEA,iBAAO;AACLC,YAAAA,GAAAA,EADK,MAAA;AAELC,YAAAA,IAAAA,EAAMC;AAFD,WAAP;AAID,SATuB,CAWxB;AACA;AACA;AACA;;;AACA,eAAO;AACLF,UAAAA,GAAAA,EAAKD,MAAAA,GAAS,IAAA,WAAA,CAAA,MAAA,EAAwB;AAACI,YAAAA,MAAAA,EAAlCJ;AAAiC,WAAxB,CAATA,GADA,SAAA;AAELE,UAAAA,IAAAA,EAAMC;AAFD,SAAP;AAhBM,OAAA;AAqBRE,MAAAA,OAAAA,EAAS,SAAA,OAAA,CAAA,YAAA,EAAA,MAAA,EAAuC;AAC9C,eAAOC,YAAAA,KAAP,MAAA;AAtBM,OAAA;AAwBRC,MAAAA,QAAAA,EAAU,SAAA,QAAA,CAAA,MAAA,EAAA,WAAA,EAAA,aAAA,EAAsD;AAC9D;AACA;AACA;AACA,YAAA,WAAA,EAAiB;AACf,eAAA,aAAA,CAAA,WAAA,EAAA,KAAA,EAAuC,KAAA,8BAAA,CAAvC,aAAuC,CAAvC;AACD;;AAED,YAAA,MAAA,EAAY;AACV,eAAA,QAAA,CAAA,MAAA,EAAA,KAAA,EAA6B,KAAA,8BAAA,CAA7B,aAA6B,CAA7B;AACD;AACF;AAnCO,KADL;AAsCLC,IAAAA,IAAAA,EAAM;AACJ;;;;;;;AAOAC,MAAAA,IAAAA,EAAM,SAAA,IAAA,CAAA,MAAA,EAAsB;AAC1B,YAAI,CAAJ,MAAA,EAAa;AACX,iBAAA,KAAA;AACD;;AACDT,QAAAA,MAAAA,CAAAA,MAAAA,GAAAA,IAAAA;AAEA,eAAA,KAAA;AAdE,OAAA;AAgBJE,MAAAA,IAAAA,EAAMC;AAhBF;AAtCD,GAAP;AAyDD","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n// Reminder: any class using this function must have something like the\n// following in its initialize method:\n//\n// // HACK to deal with the fact that AmpersandState#dataTypes#set is a pure\n// // function.\n// this._dataTypes = cloneDeep(this._dataTypes);\n// Object.keys(this._dataTypes).forEach((key) => {\n//   if (this._dataTypes[key].set) {\n//     this._dataTypes[key].set = this._dataTypes[key].set.bind(this);\n//   }\n// });\n// // END HACK\n\n/**\n * Creates an ampersand state object that wires its event handlers like a an\n * ampersand child\n * @param {Function} Constructor\n * @param {string} name\n * @returns {Object}\n */\nexport default function makeStateDataType(Constructor, name) {\n  if (!Constructor || !name) {\n    throw new Error('missing parameter for makeStateDataType');\n  }\n\n  return {\n    dataType: {\n      set: function set(newVal) {\n        // newVal.parent = this;\n        if (newVal instanceof Constructor) {\n          newVal.parent = this;\n\n          return {\n            val: newVal,\n            type: name\n          };\n        }\n\n        // We only want to construct the new instance if we have some set of\n        // attributes (even an empty object) to base it on. This is to deal with\n        // the unexpected side effect that AmpState#unset will create a new\n        // instance.\n        return {\n          val: newVal ? new Constructor(newVal, {parent: this}) : undefined,\n          type: name\n        };\n      },\n      compare: function compare(currentValue, newVal) {\n        return currentValue === newVal;\n      },\n      onChange: function onChange(newVal, previousVal, attributeName) {\n        // Copied from ampersand-state.js\n        // if this has changed we want to also handle\n        // event propagation\n        if (previousVal) {\n          this.stopListening(previousVal, 'all', this._getCachedEventBubblingHandler(attributeName));\n        }\n\n        if (newVal) {\n          this.listenTo(newVal, 'all', this._getCachedEventBubblingHandler(attributeName));\n        }\n      }\n    },\n    prop: {\n      /**\n       * This is a really unfortunate hack to deal with ampersand`s decision to\n       * make the dateType#set function pure. The only function called with the\n       * scope of the parent at set time seems to be test\n       * @param {AmpersandState} newVal\n       * @returns {boolean}\n       */\n      test: function test(newVal) {\n        if (!newVal) {\n          return false;\n        }\n        newVal.parent = this;\n\n        return false;\n      },\n      type: name\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"script"}