{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _javascriptStateMachine = require('javascript-state-machine');\n\nvar _javascriptStateMachine2 = _interopRequireDefault(_javascriptStateMachine);\n\nvar _loggerProxy = require('../common/logs/logger-proxy');\n\nvar _loggerProxy2 = _interopRequireDefault(_loggerProxy);\n\nvar _constants = require('../constants');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar shouldStep = function shouldStep(roap, meeting) {\n  var messageType = roap.msg.messageType;\n\n  if (meeting) {\n    if (messageType === _constants._OFFER_ && roap.remote && meeting.shareStatus === _constants._REQUESTED_) {\n      // The peer-connection is waiting for answer but got an offer Reset. Try to\n      // send the offer later after you accept the answer\n      return false;\n    } // Assuming the mercury event has come first before the response for the event\n    // we have to wait for the response and trigger the ROAP request later on\n\n\n    if (!meeting.mediaProperties.peerConnection && messageType === _constants._ANSWER_) {\n      return false;\n    }\n  }\n\n  _loggerProxy2.default.logger.log('RoapStateMachine->shouldStep-> PeerConnectionState, ', meeting.mediaProperties.peerConnection.signalingState);\n\n  _loggerProxy2.default.logger.log('RoapStateMachine->shouldStep-> success save proceeding with transition, ', roap.msg);\n\n  return true;\n};\n\nvar handleTransition = function handleTransition(value, signal, meeting) {\n  switch (value) {\n    case _constants.ROAP.ROAP_STATE.INIT:\n      if (signal === _constants.ROAP.ROAP_SIGNAL.RX_OFFER) {\n        return _constants.ROAP.ROAP_STATE.WAIT_TX_ANSWER;\n      }\n\n      if (signal === _constants.ROAP.ROAP_SIGNAL.TX_OFFER) {\n        return _constants.ROAP.ROAP_STATE.WAIT_RX_ANSWER;\n      }\n\n      return value;\n\n    case _constants.ROAP.ROAP_STATE.WAIT_RX_OFFER:\n      return value;\n\n    case _constants.ROAP.ROAP_STATE.WAIT_RX_ANSWER:\n      if (signal === _constants.ROAP.ROAP_SIGNAL.RX_ANSWER) {\n        // There is a race condition where the /call response comes after mercury event from the server\n        // As mercury sends roap event if it didnt get back a response. We can send the roap ok after that\n        if (meeting.mediaId) {\n          return _constants.ROAP.ROAP_STATE.WAIT_TX_OK;\n        }\n\n        _loggerProxy2.default.logger.error('RoapStateMachine->handleTransition#Race Condition no mediaId, continuing.');\n\n        return value;\n      }\n\n      if (signal === _constants.ROAP.ROAP_SIGNAL.RX_OFFER) {\n        return _constants.ROAP.ROAP_STATE.GLARE;\n      }\n\n      return value;\n\n    case _constants.ROAP.ROAP_STATE.WAIT_TX_OFFER:\n      return value;\n\n    case _constants.ROAP.ROAP_STATE.WAIT_TX_ANSWER:\n      if (signal === _constants.ROAP.ROAP_SIGNAL.TX_ANSWER) {\n        return _constants.ROAP.ROAP_STATE.WAIT_RX_OK;\n      }\n\n      return value;\n\n    case _constants.ROAP.ROAP_STATE.WAIT_TX_OK:\n      if (signal === _constants.ROAP.ROAP_SIGNAL.TX_OK) {\n        return _constants.ROAP.ROAP_STATE.INIT;\n      }\n\n      return value;\n\n    case _constants.ROAP.ROAP_STATE.WAIT_RX_OK:\n      if (signal === _constants.ROAP.ROAP_SIGNAL.RX_OK) {\n        return _constants.ROAP.ROAP_STATE.INIT;\n      }\n\n      return value;\n\n    case _constants.ROAP.ROAP_STATE.ERROR:\n      // eslint-disable-next-line no-warning-comments\n      // TODO: resolve error state. Add a signal constant and handle the cleanup\n      return _constants.ROAP.ROAP_STATE.INIT;\n\n    case _constants.ROAP.ROAP_STATE.GLARE:\n      return _constants.ROAP.ROAP_STATE.WAIT_RX_ANSWER;\n\n    default:\n      return value;\n  }\n};\n\nvar RoapStateMachine = {\n  /**\n   * @param {Roap} roapRef\n   * initializes the state machine\n   * @returns {StateMachine} an instance of a state machine\n   */\n  createState: function createState() {\n    var RoapState = _javascriptStateMachine2.default.factory({\n      init: _constants.ROAP.ROAP_STATE.INIT,\n      transitions: [{\n        name: _constants.ROAP.ROAP_TRANSITIONS.STEP,\n        from: '*',\n\n        /**\n         * Method to handle the transitions between states\n         * @param {String} signal\n         * @param {Meeting} meeting instance of a Meeting\n         * @param {Object} roap\n         * @returns {String} new state value\n         */\n        to: function to(signal, meeting, roap) {\n          var value = this.state;\n\n          if (!shouldStep(roap, meeting)) {\n            return value;\n          }\n\n          return handleTransition(value, signal, meeting);\n        }\n      }],\n      methods: {\n        /**\n         * Event that fires after we've transitioned to a new state\n         * @param {Object} transition\n         * @returns {null}\n         */\n        onAfterStep: function onAfterStep(transition) {\n          _loggerProxy2.default.logger.log('RoapStateMachine->onAfterStep#fired! State changed from \\'' + transition.from + '\\' to \\'' + transition.to + '\\' with transition \\'' + transition.transition + '\\'\\'.');\n        }\n      }\n    });\n\n    return new RoapState();\n  }\n};\nexports.default = RoapStateMachine;","map":{"version":3,"sources":["state.js"],"names":["shouldStep","messageType","roap","_OFFER_","meeting","_REQUESTED_","_ANSWER_","LoggerProxy","handleTransition","ROAP","signal","RoapStateMachine","createState","RoapState","init","transitions","name","from","to","value","methods","onAfterStep","transition"],"mappings":"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","sourcesContent":["import StateMachine from 'javascript-state-machine';\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport {ROAP, _OFFER_, _ANSWER_, _REQUESTED_} from '../constants';\n\nconst shouldStep = (roap, meeting) => {\n  const {messageType} = roap.msg;\n\n  if (meeting) {\n    if (messageType === _OFFER_ && roap.remote && meeting.shareStatus === _REQUESTED_) {\n      // The peer-connection is waiting for answer but got an offer Reset. Try to\n      // send the offer later after you accept the answer\n      return false;\n    }\n    // Assuming the mercury event has come first before the response for the event\n    // we have to wait for the response and trigger the ROAP request later on\n    if (!meeting.mediaProperties.peerConnection && messageType === _ANSWER_) {\n      return false;\n    }\n  }\n  LoggerProxy.logger.log('RoapStateMachine->shouldStep-> PeerConnectionState, ', meeting.mediaProperties.peerConnection.signalingState);\n  LoggerProxy.logger.log('RoapStateMachine->shouldStep-> success save proceeding with transition, ', roap.msg);\n\n  return true;\n};\n\nconst handleTransition = (value, signal, meeting) => {\n  switch (value) {\n    case ROAP.ROAP_STATE.INIT:\n      if (signal === ROAP.ROAP_SIGNAL.RX_OFFER) {\n        return ROAP.ROAP_STATE.WAIT_TX_ANSWER;\n      }\n      if (signal === ROAP.ROAP_SIGNAL.TX_OFFER) {\n        return ROAP.ROAP_STATE.WAIT_RX_ANSWER;\n      }\n\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_RX_OFFER:\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_RX_ANSWER:\n      if (signal === ROAP.ROAP_SIGNAL.RX_ANSWER) {\n        // There is a race condition where the /call response comes after mercury event from the server\n        // As mercury sends roap event if it didnt get back a response. We can send the roap ok after that\n        if (meeting.mediaId) {\n          return ROAP.ROAP_STATE.WAIT_TX_OK;\n        }\n        LoggerProxy.logger.error('RoapStateMachine->handleTransition#Race Condition no mediaId, continuing.');\n\n        return value;\n      }\n\n      if (signal === ROAP.ROAP_SIGNAL.RX_OFFER) {\n        return ROAP.ROAP_STATE.GLARE;\n      }\n\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_TX_OFFER:\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_TX_ANSWER:\n      if (signal === ROAP.ROAP_SIGNAL.TX_ANSWER) {\n        return ROAP.ROAP_STATE.WAIT_RX_OK;\n      }\n\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_TX_OK:\n      if (signal === ROAP.ROAP_SIGNAL.TX_OK) {\n        return ROAP.ROAP_STATE.INIT;\n      }\n\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_RX_OK:\n      if (signal === ROAP.ROAP_SIGNAL.RX_OK) {\n        return ROAP.ROAP_STATE.INIT;\n      }\n\n      return value;\n\n    case ROAP.ROAP_STATE.ERROR:\n      // eslint-disable-next-line no-warning-comments\n      // TODO: resolve error state. Add a signal constant and handle the cleanup\n      return ROAP.ROAP_STATE.INIT;\n\n    case ROAP.ROAP_STATE.GLARE:\n      return ROAP.ROAP_STATE.WAIT_RX_ANSWER;\n    default:\n      return value;\n  }\n};\n\nconst RoapStateMachine = {\n  /**\n   * @param {Roap} roapRef\n   * initializes the state machine\n   * @returns {StateMachine} an instance of a state machine\n   */\n  createState() {\n    const RoapState = StateMachine.factory({\n      init: ROAP.ROAP_STATE.INIT,\n      transitions: [\n        {\n          name: ROAP.ROAP_TRANSITIONS.STEP,\n          from: '*',\n          /**\n           * Method to handle the transitions between states\n           * @param {String} signal\n           * @param {Meeting} meeting instance of a Meeting\n           * @param {Object} roap\n           * @returns {String} new state value\n           */\n          to(signal, meeting, roap) {\n            const value = this.state;\n\n            if (!shouldStep(roap, meeting)) {\n              return value;\n            }\n\n            return handleTransition(value, signal, meeting);\n          }\n        }\n      ],\n      methods: {\n        /**\n         * Event that fires after we've transitioned to a new state\n         * @param {Object} transition\n         * @returns {null}\n         */\n        onAfterStep(transition) {\n          LoggerProxy.logger.log(\n            `RoapStateMachine->onAfterStep#fired! State changed from '${transition.from}' to '${\n              transition.to\n            }' with transition '${transition.transition}''.`\n          );\n        }\n      }\n    });\n\n    return new RoapState();\n  }\n};\n\nexport default RoapStateMachine;\n"]},"metadata":{},"sourceType":"script"}