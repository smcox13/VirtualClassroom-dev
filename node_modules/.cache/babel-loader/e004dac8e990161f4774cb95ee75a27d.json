{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _cloneDeep2 = require('lodash/cloneDeep');\n\nvar _cloneDeep3 = _interopRequireDefault(_cloneDeep2);\n/**\n * Helper method to build a roomInfo object from a conversation object\n * @param {Conversation~ConversationObject} conversation\n * @returns {Promise<RoomInfoObject>}\n */\n\n\nvar buildRoomInfo = function () {\n  var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(conversation) {\n    var type, title, lastActivityDate, roomInfo;\n    return _regenerator2.default.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            type = (0, _common.getHydraRoomType)(conversation.tags);\n            title = conversation.displayName ? conversation.displayName : conversation.computedTitle;\n            lastActivityDate = conversation.lastReadableActivityDate ? conversation.lastReadableActivityDate : conversation.lastRelevantActivityDate;\n            roomInfo = (0, _extends3.default)({\n              id: (0, _common.buildHydraRoomId)(conversation.id),\n              type: type\n            }, title && {\n              title: conversation.displayName\n            }, lastActivityDate && {\n              lastActivityDate: lastActivityDate\n            }, {\n              lastSeenActivityDate: conversation.lastSeenActivityDate ? conversation.lastSeenActivityDate : // If user has never been seen set the date to \"a long time ago\"\n              new Date(0).toISOString()\n            });\n            return _context2.abrupt('return', _promise2.default.resolve(roomInfo));\n\n          case 8:\n            _context2.prev = 8;\n            _context2.t0 = _context2['catch'](0);\n            return _context2.abrupt('return', _promise2.default.reject(_context2.t0));\n\n          case 11:\n          case 'end':\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this, [[0, 8]]);\n  }));\n\n  return function buildRoomInfo(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Helper method to build a list of roomInfo object from conversation list\n * @param {Conversation~ConversationObjectList} conversations\n * @returns {Promise<RoomInfoList>}\n */\n\n\nvar buildRoomInfoList = function () {\n  var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(conversations) {\n    var roomReadInfo, roomInfoPromises, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, conversation;\n\n    return _regenerator2.default.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            // Convert each Conversation into a roomInfo object\n            roomReadInfo = {\n              items: []\n            };\n            roomInfoPromises = [];\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _iteratorError = undefined;\n            _context3.prev = 5;\n\n            for (_iterator = (0, _getIterator3.default)(conversations); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              conversation = _step.value;\n              roomInfoPromises.push(buildRoomInfo(conversation));\n            }\n\n            _context3.next = 13;\n            break;\n\n          case 9:\n            _context3.prev = 9;\n            _context3.t0 = _context3['catch'](5);\n            _didIteratorError = true;\n            _iteratorError = _context3.t0;\n\n          case 13:\n            _context3.prev = 13;\n            _context3.prev = 14;\n\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n\n          case 16:\n            _context3.prev = 16;\n\n            if (!_didIteratorError) {\n              _context3.next = 19;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 19:\n            return _context3.finish(16);\n\n          case 20:\n            return _context3.finish(13);\n\n          case 21:\n            return _context3.abrupt('return', _promise2.default.all(roomInfoPromises).then(function (roomInfoList) {\n              roomReadInfo.items = roomInfoList;\n              roomReadInfo.items.sort(function (a, b) {\n                return a.lastActivityDate < b.lastActivityDate ? 1 : -1;\n              });\n              return roomReadInfo;\n            }));\n\n          case 22:\n          case 'end':\n            return _context3.stop();\n        }\n      }\n    }, _callee3, this, [[5, 9, 13, 21], [14,, 16, 20]]);\n  }));\n\n  return function buildRoomInfoList(_x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _common = require('@webex/common');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar debug = require('debug')('memberships');\n/**\n * @typedef {Object} RoomObject\n * @property {string} id - (server generated) Unique identifier for the room\n * @property {string} title - The display name for the room. All room members\n * will see the title so make it something good\n * @property {string} teamId - (optional) The ID of the team to which the room\n * belongs\n * @property {isoDate} created - (server generated) The date and time that the\n * room was created\n */\n\n/**\n * Rooms are virtual meeting places for getting stuff done. This resource\n * represents the room itself. Check out the {@link Memberships} API to learn\n * how to add and remove people from rooms and the {@link Messages} API for\n * posting and managing content.\n * @class\n * @name Rooms\n */\n\n\nvar Rooms = _webexCore.WebexPlugin.extend({\n  /**\n   * Register to listen for incoming rooms events\n   * This is an alternate approach to registering for rooms webhooks.\n   * The events passed to any registered handlers will be similar to the webhook JSON,\n   * but will omit webhook specific fields such as name, secret, url, etc.\n   * To utilize the `listen()` method, the authorization token used\n   * will need to have `spark:all` and `spark:kms` scopes enabled.\n   * Note that by configuring your application to enable or disable `spark:all`\n   * via its configuration page will also enable or disable `spark:kms`.\n   * See the <a href=\"https://js.samples.s4d.io/browser-socket/\">Sample App</a>\n   * for more details.\n   * @instance\n   * @memberof Rooms\n   * @returns {Promise}\n   * @example\n   * webex.rooms.listen()\n   *   .then(() => {\n   *     console.log('listening to room events');\n   *     webex.rooms.on('created', (event) => console.log(`Got a room:created event:\\n${event}`);\n   *     webex.rooms.on('updated', (event) => console.log(`Got a room:updated event:\\n${event}`);\n   *   })\n   *   .catch((e) => console.error(`Unable to register for room events: ${e}`));\n   * // Some app logic...\n   * // WHen it is time to cleanup\n   * webex.rooms.stopListening();\n   * webex.rooms.off('created');\n   * webex.rooms.off('updated');\n   */\n  listen: function listen() {\n    var _this = this;\n\n    return (0, _common.createEventEnvelope)(this.webex, _common.SDK_EVENT.EXTERNAL.RESOURCE.ROOMS).then(function (envelope) {\n      _this.eventEnvelope = envelope;\n      return _this.webex.internal.mercury.connect().then(function () {\n        _this.listenTo(_this.webex.internal.mercury, _common.SDK_EVENT.INTERNAL.TEAMS_ACTIVITY, function (event) {\n          return _this.onWebexApiEvent(event);\n        });\n      });\n    });\n  },\n\n  /**\n   * Creates a new room. The authenticated user is automatically added as a\n   * member of the room. See the {@link Memberships} API to learn how to add\n   * more people to the room.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject} room\n   * @returns {Promise<RoomObject>}\n   * @example\n   * webex.rooms.create({title: 'Create Room Example'})\n   *   .then(function(room) {\n   *     var assert = require('assert')\n   *     assert(typeof room.created === 'string');\n   *     assert(typeof room.id === 'string');\n   *     assert(room.title === 'Create Room Example');\n   *     console.log(room.title);\n   *     return 'success';\n   *   });\n   *   // => success\n   */\n  create: function create(room) {\n    return this.request({\n      method: 'POST',\n      service: 'hydra',\n      resource: 'rooms',\n      body: room\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n\n  /**\n   * Returns a single room.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject|string} room\n   * @param {Object} options\n   * @returns {Promise<RoomObject>}\n   * @example\n   * var room;\n   * webex.rooms.create({title: 'Get Room Example'})\n   *   .then(function(r) {\n   *     room = r\n   *     return webex.rooms.get(room.id)\n   *   })\n   *   .then(function(r) {\n   *     var assert = require('assert');\n   *     assert.deepEqual(r, room);\n   *     return 'success';\n   *   });\n   *   // => success\n   */\n  get: function get(room, options) {\n    var id = room.id || room;\n    return this.request({\n      service: 'hydra',\n      resource: 'rooms/' + id,\n      qs: options\n    }).then(function (res) {\n      return res.body.items || res.body;\n    });\n  },\n\n  /**\n   * Returns a list of rooms. In most cases the results will only contain rooms\n   * that the authentiated user is a member of.\n   * @instance\n   * @memberof Rooms\n   * @param {Object} options\n   * @param {Object} options.max Limit the maximum number of rooms in the\n   * response.\n   * @returns {Promise<Page<RoomObject>>}\n   * @example\n   * var createdRooms;\n   * Promise.all([\n   *   webex.rooms.create({title: 'List Rooms Example 1'}),\n   *   webex.rooms.create({title: 'List Rooms Example 2'}),\n   *   webex.rooms.create({title: 'List Rooms Example 3'})\n   * ])\n   *   .then(function(r) {\n   *     createdRooms = r;\n   *     return webex.rooms.list({max: 3})\n   *       .then(function(rooms) {\n   *         var assert = require('assert');\n   *         assert(rooms.length === 3);\n   *         for (var i = 0; i < rooms.items.length; i+= 1) {\n   *           assert(createdRooms.filter(function(room) {\n   *             return room.id === rooms.items[i].id;\n   *           }).length === 1);\n   *         }\n   *         return 'success';\n   *       });\n   *   });\n   *   // => success\n   */\n  list: function list(options) {\n    var _this2 = this;\n\n    return this.request({\n      service: 'hydra',\n      resource: 'rooms/',\n      qs: options\n    }).then(function (res) {\n      return new _webexCore.Page(res, _this2.webex);\n    });\n  },\n\n  /**\n   * Returns a list of rooms with details about the data of the last\n   * actvity in the room, and the date of the users last presences in\n   * the room. The list is sorted with this with most recent activity first\n   *\n   * For rooms where lastActivityDate > lastSeenDate the space\n   * can be considerd to be \"unread\"\n   *\n   * This differs from the rooms.list() function in the following ways:\n   *  -- when called with no parameters it returns an array of all\n   *     spaces, up to 1000, that the user is a member of\n   *  -- pagination is not supported. ALL rooms are returned which\n   *     can result in a large payload\n   *  -- For users with hundreds of spaces, this API can take some time to\n   *     to return, for this reason it supports an optional maxRecent parameter.\n   *     If set this will return only the specified number of spaces with activity\n   *     in the last two weeks.  Reccomended value is 30.  Max supported is 100.\n   *  -- only \"id\", \"type\", \"lastActivityDate\", and \"lastSeenDate\" are\n   *     guaranteed to be available for each room in the list\n   *  -- \"title\" is usually returned, but not guaranteed\n   *\n   * In general this function should be used only when the client needs to\n   * access read status info, for example on startup.\n   * After startup, clients should track message and membership:seen events\n   * to maintain read status client side.\n   *\n   * Since this API can take some time to return up to 1000 spaces, it is\n   * recommended that custom clients call this first with the maxRecent parameter\n   * set to 30, so that they can display some of the more recents spaces.  Calling\n   * this API a second time with no parameters will return all the spaces.\n   *\n   * Not all spaces may be returned, for example when users in more than 1000\n   * spaces, or when a new spaces is added after this function is called,\n   * but before it returns. Custom clients should be prepared to gracefully\n   * andle cases where an event occurs in a space not returned by this call,\n   * by querying rooms.getWithReadStatus() with the id of the room in question\n   *\n   * This function may be deprecated when this info is provided in the membership\n   * objects returned in the list function.\n   * @instance\n   * @param {int} maxRecent\n   * @memberof Rooms\n   * @returns {Promise<RoomInfoObjectList>}\n   */\n  listWithReadStatus: function () {\n    var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {\n      var _this3 = this;\n\n      var maxRecent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var now, options;\n      return _regenerator2.default.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              now = new Date();\n              options = {\n                activitiesLimit: 0,\n                computeTitleIfEmpty: true,\n                conversationsLimit: 1000,\n                isActive: true\n              };\n\n              if (!(maxRecent > 0)) {\n                _context.next = 7;\n                break;\n              }\n\n              options.conversationsLimit = maxRecent;\n              options.sinceDate = now.setDate(now.getDate() - 14);\n              _context.next = 9;\n              break;\n\n            case 7:\n              if (!(maxRecent < 0 || maxRecent > 100)) {\n                _context.next = 9;\n                break;\n              }\n\n              return _context.abrupt('return', _promise2.default.reject(new Error('rooms.listWithReadStatus: ' + 'optional maxRecent parameter must be an integer between 1 and 100')));\n\n            case 9:\n              return _context.abrupt('return', (0, _common.ensureConvoAvailability)(this.webex).then(function () {\n                return _this3.webex.internal.conversation.list(options);\n              }).then(function (conversations) {\n                return buildRoomInfoList(conversations);\n              }));\n\n            case 10:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function listWithReadStatus() {\n      return _ref.apply(this, arguments);\n    }\n\n    return listWithReadStatus;\n  }(),\n\n  /**\n   * Returns a single room object with details about the data of the last\n   * actvity in the room, and the date of the users last presence in\n   * the room.\n   *\n   * For rooms where lastActivityDate > lastSeenDate the room\n   * can be considerd to be \"unread\"\n   *\n   * This differs from the rooms.get() function in the following ways:\n   *  -- it takes a single roomId parameter to fetch\n   *  -- no other options are considered\n   *  -- only \"id\", \"type\", \"lastActivityDate\", and \"lastSeenDate\" are\n   *     guaranteed to be available in the return object\n   *  -- \"title\" is usually returned, but not guaranteed\n   *\n   * In general clients should use the listWithReadStatus() method on startup\n   * to get the initial roomStatus and then update their client side copy by\n   * responding to message, membership and room events.\n    * This function allows a custom client to be \"nimble\" if it is responding\n   * to an event with a roomId that was not in the original fetch.  The\n   * anticipated behavior is that getWithReadStats is called \"just in time\",\n   * with the resulting room object being added to the list of cached room\n   * objects on the client side.\n   *\n   * This function may be deprecated when this info is provided in the room\n   * object returned in the get function.\n   * @instance\n   * @memberof Rooms\n   * @param {string} roomId\n   * @returns {Promise<RoomInfoObject>}\n   */\n  getWithReadStatus: function getWithReadStatus(roomId) {\n    var _this4 = this;\n\n    var deconstructedId = (0, _common.deconstructHydraId)(roomId);\n    var conversation = {\n      id: deconstructedId.id,\n      cluster: deconstructedId.cluster\n    };\n    return (0, _common.ensureConvoAvailability)(this.webex).then(function () {\n      return _this4.webex.internal.conversation.get(conversation, {\n        computeTitleIfEmpty: true,\n        activitiesLimit: 0 // don't send the whole history of activity\n\n      }).then(function (convo) {\n        return buildRoomInfo(convo);\n      });\n    });\n  },\n\n  /**\n   * Deletes a single room.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject|string} room\n   * @returns {Promise}\n   * @example\n   * var room;\n   * webex.rooms.create({title: 'Remove Room Example'})\n   *  .then(function(r) {\n   *    room = r;\n   *    return webex.rooms.remove(room.id);\n   *  })\n   *  .then(function() {\n   *    return webex.rooms.get(room.id);\n   *  })\n   *  .then(function() {\n   *    var assert = require('assert');\n   *    assert(false, 'the previous get should have failed');\n   *  })\n   *  .catch(function(reason) {\n   *    var assert = require('assert');\n   *    assert.equal(reason.statusCode, 404);\n   *    return 'success'\n   *  });\n   *  // => success\n   */\n  remove: function remove(room) {\n    var id = room.id || room;\n    return this.request({\n      method: 'DELETE',\n      service: 'hydra',\n      resource: 'rooms/' + id\n    }).then(function (res) {\n      // Firefox has some issues with 204s and/or DELETE. This should move to\n      // http-core\n      if (res.statusCode === 204) {\n        return undefined;\n      }\n\n      return res.body;\n    });\n  },\n\n  /**\n   * Used to update a single room's properties.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject} room\n   * @returns {Promise<RoomObject>}\n   * @example\n   * var room;\n   * webex.rooms.update({title: 'Update Room Example'})\n   *   .then(function(r) {\n   *     room = r;\n   *     room.title = 'Update Room Example (Updated Title)';\n   *     return webex.rooms.update(room);\n   *   })\n   *   .then(function() {\n   *     return webex.rooms.get(room.id);\n   *   })\n   *   .then(function(room) {\n   *    var assert = require('assert');\n   *     assert.equal(room.title, 'Update Room Example (Updated Title)');\n   *     return 'success';\n   *   });\n   *   // => success\n   */\n  update: function update(room) {\n    var id = room.id;\n    return this.request({\n      method: 'PUT',\n      service: 'hydra',\n      resource: 'rooms/' + id,\n      body: room\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n\n  /**\n   * This function is called when an internal membership events fires,\n   * if the user registered for these events with the listen() function.\n   * External users of the SDK should not call this function\n   * @private\n   * @memberof Rooms\n   * @param {Object} event\n   * @returns {void}\n   */\n  onWebexApiEvent: function onWebexApiEvent(event) {\n    var activity = event.data.activity;\n    /* eslint-disable no-case-declarations */\n\n    switch (activity.verb) {\n      case _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.CREATE:\n        var roomCreatedEvent = this.getRoomEvent(activity, _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED);\n\n        if (roomCreatedEvent) {\n          debug('room \"created\" payload:             ' + (0, _stringify2.default)(roomCreatedEvent));\n          this.trigger(_common.SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED, roomCreatedEvent);\n        }\n\n        break;\n\n      case _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.UPDATE:\n        var roomUpdatedEvent = this.getRoomEvent(activity, _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED);\n\n        if (roomUpdatedEvent) {\n          debug('room \"updated\" payload:             ' + (0, _stringify2.default)(roomUpdatedEvent));\n          this.trigger(_common.SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED, roomUpdatedEvent);\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  },\n\n  /**\n   * Constructs the data object for an event on the rooms resource,\n   * adhering to Hydra's Webehook data structure.\n   * External users of the SDK should not call this function\n   * @private\n   * @memberof Rooms\n   * @param {Object} activity from mercury\n   * @param {Object} event type of \"webhook\" event\n   * @returns {Object} constructed event\n   */\n  getRoomEvent: function getRoomEvent(activity, event) {\n    try {\n      var sdkEvent = (0, _cloneDeep3.default)(this.eventEnvelope);\n      var room = void 0;\n      sdkEvent.event = event;\n      sdkEvent.data.created = activity.published;\n      sdkEvent.actorId = (0, _common.buildHydraPersonId)(activity.actor.entryUUID);\n\n      if (event === _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED) {\n        room = _common.SDK_EVENT.INTERNAL.ACTIVITY_FIELD.OBJECT;\n        sdkEvent.data.creatorId = (0, _common.buildHydraPersonId)(activity.actor.entryUUID);\n        sdkEvent.data.lastActivity = activity.published;\n      } else if (event === _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED) {\n        room = _common.SDK_EVENT.INTERNAL.ACTIVITY_FIELD.TARGET; // TODO - lastActivity is not in the mercury 'update' event\n        // would need to make an async call to get more conversation details\n        // or we can skip this for the SDK, since we will provide an\n        // SDK api to allow the app to query this directly if it needs\n        // sdkEvent.data.lastActivity = 'to do';\n      } else {\n        throw new Error('unexpected event type');\n      }\n\n      sdkEvent.data.id = (0, _common.buildHydraRoomId)(activity[room].id);\n      sdkEvent.data.type = (0, _common.getHydraRoomType)(activity[room].tags);\n      sdkEvent.data.isLocked = activity[room].tags.includes(_common.SDK_EVENT.INTERNAL.ACTIVITY_TAG.LOCKED);\n      return sdkEvent;\n    } catch (e) {\n      this.webex.logger.error('Unable to generate SDK event from mercury \\'socket activity for rooms:' + event + ' event: ' + e.message);\n      return null;\n    }\n  },\n  version: '1.80.172'\n});\n\nexports.default = Rooms;","map":{"version":3,"sources":["rooms.js"],"names":["debug","require","Rooms","listen","SDK_EVENT","create","method","service","resource","body","room","res","get","id","qs","options","list","Page","listWithReadStatus","maxRecent","now","activitiesLimit","computeTitleIfEmpty","conversationsLimit","isActive","buildRoomInfoList","getWithReadStatus","deconstructedId","conversation","cluster","buildRoomInfo","remove","update","onWebexApiEvent","activity","event","roomCreatedEvent","roomUpdatedEvent","getRoomEvent","sdkEvent","e","type","title","lastActivityDate","roomInfo","lastSeenActivityDate","roomReadInfo","items","roomInfoPromises","a","b"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {WebexPlugin, Page} from '@webex/webex-core';\nimport {cloneDeep} from 'lodash';\nimport {\n  ensureConvoAvailability,\n  SDK_EVENT,\n  createEventEnvelope,\n  buildHydraPersonId,\n  buildHydraRoomId,\n  getHydraRoomType,\n  deconstructHydraId\n} from '@webex/common';\n\nconst debug = require('debug')('memberships');\n\n/**\n * @typedef {Object} RoomObject\n * @property {string} id - (server generated) Unique identifier for the room\n * @property {string} title - The display name for the room. All room members\n * will see the title so make it something good\n * @property {string} teamId - (optional) The ID of the team to which the room\n * belongs\n * @property {isoDate} created - (server generated) The date and time that the\n * room was created\n */\n\n/**\n * Rooms are virtual meeting places for getting stuff done. This resource\n * represents the room itself. Check out the {@link Memberships} API to learn\n * how to add and remove people from rooms and the {@link Messages} API for\n * posting and managing content.\n * @class\n * @name Rooms\n */\nconst Rooms = WebexPlugin.extend({\n  /**\n   * Register to listen for incoming rooms events\n   * This is an alternate approach to registering for rooms webhooks.\n   * The events passed to any registered handlers will be similar to the webhook JSON,\n   * but will omit webhook specific fields such as name, secret, url, etc.\n   * To utilize the `listen()` method, the authorization token used\n   * will need to have `spark:all` and `spark:kms` scopes enabled.\n   * Note that by configuring your application to enable or disable `spark:all`\n   * via its configuration page will also enable or disable `spark:kms`.\n   * See the <a href=\"https://js.samples.s4d.io/browser-socket/\">Sample App</a>\n   * for more details.\n   * @instance\n   * @memberof Rooms\n   * @returns {Promise}\n   * @example\n   * webex.rooms.listen()\n   *   .then(() => {\n   *     console.log('listening to room events');\n   *     webex.rooms.on('created', (event) => console.log(`Got a room:created event:\\n${event}`);\n   *     webex.rooms.on('updated', (event) => console.log(`Got a room:updated event:\\n${event}`);\n   *   })\n   *   .catch((e) => console.error(`Unable to register for room events: ${e}`));\n   * // Some app logic...\n   * // WHen it is time to cleanup\n   * webex.rooms.stopListening();\n   * webex.rooms.off('created');\n   * webex.rooms.off('updated');\n   */\n  listen() {\n    return createEventEnvelope(this.webex, SDK_EVENT.EXTERNAL.RESOURCE.ROOMS)\n      .then((envelope) => {\n        this.eventEnvelope = envelope;\n\n        return this.webex.internal.mercury.connect().then(() => {\n          this.listenTo(this.webex.internal.mercury,\n            SDK_EVENT.INTERNAL.TEAMS_ACTIVITY,\n            (event) => this.onWebexApiEvent(event));\n        });\n      });\n  },\n\n  /**\n   * Creates a new room. The authenticated user is automatically added as a\n   * member of the room. See the {@link Memberships} API to learn how to add\n   * more people to the room.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject} room\n   * @returns {Promise<RoomObject>}\n   * @example\n   * webex.rooms.create({title: 'Create Room Example'})\n   *   .then(function(room) {\n   *     var assert = require('assert')\n   *     assert(typeof room.created === 'string');\n   *     assert(typeof room.id === 'string');\n   *     assert(room.title === 'Create Room Example');\n   *     console.log(room.title);\n   *     return 'success';\n   *   });\n   *   // => success\n   */\n  create(room) {\n    return this.request({\n      method: 'POST',\n      service: 'hydra',\n      resource: 'rooms',\n      body: room\n    })\n      .then((res) => res.body);\n  },\n\n  /**\n   * Returns a single room.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject|string} room\n   * @param {Object} options\n   * @returns {Promise<RoomObject>}\n   * @example\n   * var room;\n   * webex.rooms.create({title: 'Get Room Example'})\n   *   .then(function(r) {\n   *     room = r\n   *     return webex.rooms.get(room.id)\n   *   })\n   *   .then(function(r) {\n   *     var assert = require('assert');\n   *     assert.deepEqual(r, room);\n   *     return 'success';\n   *   });\n   *   // => success\n   */\n  get(room, options) {\n    const id = room.id || room;\n\n    return this.request({\n      service: 'hydra',\n      resource: `rooms/${id}`,\n      qs: options\n    })\n      .then((res) => res.body.items || res.body);\n  },\n\n  /**\n   * Returns a list of rooms. In most cases the results will only contain rooms\n   * that the authentiated user is a member of.\n   * @instance\n   * @memberof Rooms\n   * @param {Object} options\n   * @param {Object} options.max Limit the maximum number of rooms in the\n   * response.\n   * @returns {Promise<Page<RoomObject>>}\n   * @example\n   * var createdRooms;\n   * Promise.all([\n   *   webex.rooms.create({title: 'List Rooms Example 1'}),\n   *   webex.rooms.create({title: 'List Rooms Example 2'}),\n   *   webex.rooms.create({title: 'List Rooms Example 3'})\n   * ])\n   *   .then(function(r) {\n   *     createdRooms = r;\n   *     return webex.rooms.list({max: 3})\n   *       .then(function(rooms) {\n   *         var assert = require('assert');\n   *         assert(rooms.length === 3);\n   *         for (var i = 0; i < rooms.items.length; i+= 1) {\n   *           assert(createdRooms.filter(function(room) {\n   *             return room.id === rooms.items[i].id;\n   *           }).length === 1);\n   *         }\n   *         return 'success';\n   *       });\n   *   });\n   *   // => success\n   */\n  list(options) {\n    return this.request({\n      service: 'hydra',\n      resource: 'rooms/',\n      qs: options\n    })\n      .then((res) => new Page(res, this.webex));\n  },\n\n  /**\n   * Returns a list of rooms with details about the data of the last\n   * actvity in the room, and the date of the users last presences in\n   * the room. The list is sorted with this with most recent activity first\n   *\n   * For rooms where lastActivityDate > lastSeenDate the space\n   * can be considerd to be \"unread\"\n   *\n   * This differs from the rooms.list() function in the following ways:\n   *  -- when called with no parameters it returns an array of all\n   *     spaces, up to 1000, that the user is a member of\n   *  -- pagination is not supported. ALL rooms are returned which\n   *     can result in a large payload\n   *  -- For users with hundreds of spaces, this API can take some time to\n   *     to return, for this reason it supports an optional maxRecent parameter.\n   *     If set this will return only the specified number of spaces with activity\n   *     in the last two weeks.  Reccomended value is 30.  Max supported is 100.\n   *  -- only \"id\", \"type\", \"lastActivityDate\", and \"lastSeenDate\" are\n   *     guaranteed to be available for each room in the list\n   *  -- \"title\" is usually returned, but not guaranteed\n   *\n   * In general this function should be used only when the client needs to\n   * access read status info, for example on startup.\n   * After startup, clients should track message and membership:seen events\n   * to maintain read status client side.\n   *\n   * Since this API can take some time to return up to 1000 spaces, it is\n   * recommended that custom clients call this first with the maxRecent parameter\n   * set to 30, so that they can display some of the more recents spaces.  Calling\n   * this API a second time with no parameters will return all the spaces.\n   *\n   * Not all spaces may be returned, for example when users in more than 1000\n   * spaces, or when a new spaces is added after this function is called,\n   * but before it returns. Custom clients should be prepared to gracefully\n   * andle cases where an event occurs in a space not returned by this call,\n   * by querying rooms.getWithReadStatus() with the id of the room in question\n   *\n   * This function may be deprecated when this info is provided in the membership\n   * objects returned in the list function.\n   * @instance\n   * @param {int} maxRecent\n   * @memberof Rooms\n   * @returns {Promise<RoomInfoObjectList>}\n   */\n  async listWithReadStatus(maxRecent = 0) {\n    const now = new Date();\n    const options = {\n      activitiesLimit: 0,\n      computeTitleIfEmpty: true,\n      conversationsLimit: 1000,\n      isActive: true\n    };\n\n    if (maxRecent > 0) {\n      options.conversationsLimit = maxRecent;\n      options.sinceDate = now.setDate(now.getDate() - 14);\n    }\n    else if ((maxRecent < 0) || (maxRecent > 100)) {\n      return Promise.reject(new Error('rooms.listWithReadStatus: ' +\n        'optional maxRecent parameter must be an integer between 1 and 100'));\n    }\n\n    return ensureConvoAvailability(this.webex)\n      .then(() => this.webex.internal.conversation.list(options))\n      .then((conversations) => buildRoomInfoList(conversations));\n  },\n\n  /**\n   * Returns a single room object with details about the data of the last\n   * actvity in the room, and the date of the users last presence in\n   * the room.\n   *\n   * For rooms where lastActivityDate > lastSeenDate the room\n   * can be considerd to be \"unread\"\n   *\n   * This differs from the rooms.get() function in the following ways:\n   *  -- it takes a single roomId parameter to fetch\n   *  -- no other options are considered\n   *  -- only \"id\", \"type\", \"lastActivityDate\", and \"lastSeenDate\" are\n   *     guaranteed to be available in the return object\n   *  -- \"title\" is usually returned, but not guaranteed\n   *\n   * In general clients should use the listWithReadStatus() method on startup\n   * to get the initial roomStatus and then update their client side copy by\n   * responding to message, membership and room events.\n\n   * This function allows a custom client to be \"nimble\" if it is responding\n   * to an event with a roomId that was not in the original fetch.  The\n   * anticipated behavior is that getWithReadStats is called \"just in time\",\n   * with the resulting room object being added to the list of cached room\n   * objects on the client side.\n   *\n   * This function may be deprecated when this info is provided in the room\n   * object returned in the get function.\n   * @instance\n   * @memberof Rooms\n   * @param {string} roomId\n   * @returns {Promise<RoomInfoObject>}\n   */\n  getWithReadStatus(roomId) {\n    const deconstructedId = deconstructHydraId(roomId);\n    const conversation = {\n      id: deconstructedId.id,\n      cluster: deconstructedId.cluster\n    };\n\n    return ensureConvoAvailability(this.webex)\n      .then(() => this.webex.internal.conversation.get(conversation,\n        {\n          computeTitleIfEmpty: true,\n          activitiesLimit: 0 // don't send the whole history of activity\n        })\n        .then((convo) => buildRoomInfo(convo)));\n  },\n\n  /**\n   * Deletes a single room.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject|string} room\n   * @returns {Promise}\n   * @example\n   * var room;\n   * webex.rooms.create({title: 'Remove Room Example'})\n   *  .then(function(r) {\n   *    room = r;\n   *    return webex.rooms.remove(room.id);\n   *  })\n   *  .then(function() {\n   *    return webex.rooms.get(room.id);\n   *  })\n   *  .then(function() {\n   *    var assert = require('assert');\n   *    assert(false, 'the previous get should have failed');\n   *  })\n   *  .catch(function(reason) {\n   *    var assert = require('assert');\n   *    assert.equal(reason.statusCode, 404);\n   *    return 'success'\n   *  });\n   *  // => success\n   */\n  remove(room) {\n    const id = room.id || room;\n\n    return this.request({\n      method: 'DELETE',\n      service: 'hydra',\n      resource: `rooms/${id}`\n    })\n      .then((res) => {\n        // Firefox has some issues with 204s and/or DELETE. This should move to\n        // http-core\n        if (res.statusCode === 204) {\n          return undefined;\n        }\n\n        return res.body;\n      });\n  },\n\n  /**\n   * Used to update a single room's properties.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject} room\n   * @returns {Promise<RoomObject>}\n   * @example\n   * var room;\n   * webex.rooms.update({title: 'Update Room Example'})\n   *   .then(function(r) {\n   *     room = r;\n   *     room.title = 'Update Room Example (Updated Title)';\n   *     return webex.rooms.update(room);\n   *   })\n   *   .then(function() {\n   *     return webex.rooms.get(room.id);\n   *   })\n   *   .then(function(room) {\n   *    var assert = require('assert');\n   *     assert.equal(room.title, 'Update Room Example (Updated Title)');\n   *     return 'success';\n   *   });\n   *   // => success\n   */\n  update(room) {\n    const {id} = room;\n\n    return this.request({\n      method: 'PUT',\n      service: 'hydra',\n      resource: `rooms/${id}`,\n      body: room\n    })\n      .then((res) => res.body);\n  },\n\n  /**\n   * This function is called when an internal membership events fires,\n   * if the user registered for these events with the listen() function.\n   * External users of the SDK should not call this function\n   * @private\n   * @memberof Rooms\n   * @param {Object} event\n   * @returns {void}\n   */\n  onWebexApiEvent(event) {\n    const {activity} = event.data;\n\n    /* eslint-disable no-case-declarations */\n    switch (activity.verb) {\n      case SDK_EVENT.INTERNAL.ACTIVITY_VERB.CREATE:\n        const roomCreatedEvent =\n          this.getRoomEvent(activity, SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED);\n\n        if (roomCreatedEvent) {\n          debug(`room \"created\" payload: \\\n            ${JSON.stringify(roomCreatedEvent)}`);\n          this.trigger(SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED, roomCreatedEvent);\n        }\n        break;\n\n      case SDK_EVENT.INTERNAL.ACTIVITY_VERB.UPDATE:\n        const roomUpdatedEvent =\n          this.getRoomEvent(activity, SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED);\n\n        if (roomUpdatedEvent) {\n          debug(`room \"updated\" payload: \\\n            ${JSON.stringify(roomUpdatedEvent)}`);\n          this.trigger(SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED, roomUpdatedEvent);\n        }\n        break;\n\n      default:\n        break;\n    }\n  },\n\n  /**\n   * Constructs the data object for an event on the rooms resource,\n   * adhering to Hydra's Webehook data structure.\n   * External users of the SDK should not call this function\n   * @private\n   * @memberof Rooms\n   * @param {Object} activity from mercury\n   * @param {Object} event type of \"webhook\" event\n   * @returns {Object} constructed event\n   */\n  getRoomEvent(activity, event) {\n    try {\n      const sdkEvent = cloneDeep(this.eventEnvelope);\n      let room;\n\n      sdkEvent.event = event;\n      sdkEvent.data.created = activity.published;\n      sdkEvent.actorId = buildHydraPersonId(activity.actor.entryUUID);\n      if (event === SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED) {\n        room = SDK_EVENT.INTERNAL.ACTIVITY_FIELD.OBJECT;\n        sdkEvent.data.creatorId = buildHydraPersonId(activity.actor.entryUUID);\n        sdkEvent.data.lastActivity = activity.published;\n      }\n      else if (event === SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED) {\n        room = SDK_EVENT.INTERNAL.ACTIVITY_FIELD.TARGET;\n        // TODO - lastActivity is not in the mercury 'update' event\n        // would need to make an async call to get more conversation details\n        // or we can skip this for the SDK, since we will provide an\n        // SDK api to allow the app to query this directly if it needs\n        // sdkEvent.data.lastActivity = 'to do';\n      }\n      else {\n        throw new Error('unexpected event type');\n      }\n      sdkEvent.data.id =\n      buildHydraRoomId(activity[room].id);\n      sdkEvent.data.type = getHydraRoomType(activity[room].tags);\n      sdkEvent.data.isLocked =\n        activity[room].tags.includes(SDK_EVENT.INTERNAL.ACTIVITY_TAG.LOCKED);\n\n      return sdkEvent;\n    }\n    catch (e) {\n      this.webex.logger.error(`Unable to generate SDK event from mercury \\\n'socket activity for rooms:${event} event: ${e.message}`);\n\n      return null;\n    }\n  }\n\n});\n\nexport default Rooms;\n\n/**\n * Helper method to build a roomInfo object from a conversation object\n * @param {Conversation~ConversationObject} conversation\n * @returns {Promise<RoomInfoObject>}\n */\nasync function buildRoomInfo(conversation) {\n  try {\n    const type = getHydraRoomType(conversation.tags);\n    const title = conversation.displayName ?\n      conversation.displayName : conversation.computedTitle;\n    const lastActivityDate = conversation.lastReadableActivityDate ?\n      conversation.lastReadableActivityDate :\n      conversation.lastRelevantActivityDate;\n\n    const roomInfo = {\n      id: buildHydraRoomId(conversation.id),\n      type,\n      ...(title && {title: conversation.displayName}),\n      ...(lastActivityDate && {lastActivityDate}),\n      lastSeenActivityDate: conversation.lastSeenActivityDate ?\n        conversation.lastSeenActivityDate :\n        // If user has never been seen set the date to \"a long time ago\"\n        new Date(0).toISOString()\n    };\n\n    return Promise.resolve(roomInfo);\n  }\n  catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Helper method to build a list of roomInfo object from conversation list\n * @param {Conversation~ConversationObjectList} conversations\n * @returns {Promise<RoomInfoList>}\n */\nasync function buildRoomInfoList(conversations) {\n  // Convert each Conversation into a roomInfo object\n  const roomReadInfo = {items: []};\n  const roomInfoPromises = [];\n\n  for (const conversation of conversations) {\n    roomInfoPromises.push(buildRoomInfo(conversation));\n  }\n\n  return Promise.all(roomInfoPromises)\n    .then((roomInfoList) => {\n      roomReadInfo.items = roomInfoList;\n      roomReadInfo.items.sort((a, b) => (a.lastActivityDate < b.lastActivityDate ? 1 : -1));\n\n      return roomReadInfo;\n    });\n}\n"]},"metadata":{},"sourceType":"script"}