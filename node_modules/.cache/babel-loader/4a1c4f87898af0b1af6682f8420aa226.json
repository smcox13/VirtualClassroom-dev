{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nexports.default = detectFileType;\n\nvar _httpCore = require('@webex/http-core');\n\nvar _mimeTypes = require('mime-types');\n\nvar _mimeTypes2 = _interopRequireDefault(_mimeTypes);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Determines the file type of the specified file\n * @param {FileLike} file\n * @param {Object} logger\n * @returns {Promise<string>}\n */\n\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nfunction detectFileType(file, logger) {\n  if (file.type) {\n    logger.info('file already has type ' + file.type + '. using existing file.type.');\n    return _promise2.default.resolve(file.type);\n  }\n\n  if (file.mimeType) {\n    logger.info('file already has mimeType ' + file.type + '. using existing file.mimeType.');\n    return _promise2.default.resolve(file.mimeType);\n  } // This kinda belongs in http core, but since we have no guarantee that\n  // buffers are expected to have names there, it'll stay here for now.\n\n\n  return (0, _httpCore.detect)(file).then(function (type) {\n    if (type === 'application/x-msi' || type === 'application/octet-stream') {\n      logger.info('detected filetype to be ' + type + '. Falling back to mime.lookup');\n      return _mimeTypes2.default.lookup(file.name);\n    }\n\n    logger.info('detected filetype to be ' + type + '. returning it');\n    return type;\n  });\n}","map":{"version":3,"sources":["detect-filetype.js"],"names":["detectFileType","file","logger","type","mime"],"mappings":";;;;;;;;;;kBAawBA,c;;AATxB,IAAA,SAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,IAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;;;;;;;;AAEA;;;;;;;AAPA;;;;;AAae,SAAA,cAAA,CAAA,IAAA,EAAA,MAAA,EAAsC;AACnD,MAAIC,IAAAA,CAAJ,IAAA,EAAe;AACbC,IAAAA,MAAAA,CAAAA,IAAAA,CAAAA,2BAAqCD,IAAAA,CAArCC,IAAAA,GAAAA,6BAAAA;AAEA,WAAO,SAAA,CAAA,OAAA,CAAA,OAAA,CAAgBD,IAAAA,CAAvB,IAAO,CAAP;AACD;;AAED,MAAIA,IAAAA,CAAJ,QAAA,EAAmB;AACjBC,IAAAA,MAAAA,CAAAA,IAAAA,CAAAA,+BAAyCD,IAAAA,CAAzCC,IAAAA,GAAAA,iCAAAA;AAEA,WAAO,SAAA,CAAA,OAAA,CAAA,OAAA,CAAgBD,IAAAA,CAAvB,QAAO,CAAP;AACD,GAXkD,CAanD;AACA;;;AACA,SAAO,CAAA,GAAA,SAAA,CAAA,MAAA,EAAA,IAAA,EAAA,IAAA,CACC,UAAA,IAAA,EAAU;AACd,QAAIE,IAAAA,KAAAA,mBAAAA,IAAgCA,IAAAA,KAApC,0BAAA,EAAyE;AACvED,MAAAA,MAAAA,CAAAA,IAAAA,CAAAA,6BAAAA,IAAAA,GAAAA,+BAAAA;AAEA,aAAOE,WAAAA,CAAAA,OAAAA,CAAAA,MAAAA,CAAYH,IAAAA,CAAnB,IAAOG,CAAP;AACD;;AAEDF,IAAAA,MAAAA,CAAAA,IAAAA,CAAAA,6BAAAA,IAAAA,GAAAA,gBAAAA;AAEA,WAAA,IAAA;AAVJ,GAAO,CAAP;AAYD","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {detect} from '@webex/http-core';\nimport mime from 'mime-types';\n\n/**\n * Determines the file type of the specified file\n * @param {FileLike} file\n * @param {Object} logger\n * @returns {Promise<string>}\n */\nexport default function detectFileType(file, logger) {\n  if (file.type) {\n    logger.info(`file already has type ${file.type}. using existing file.type.`);\n\n    return Promise.resolve(file.type);\n  }\n\n  if (file.mimeType) {\n    logger.info(`file already has mimeType ${file.type}. using existing file.mimeType.`);\n\n    return Promise.resolve(file.mimeType);\n  }\n\n  // This kinda belongs in http core, but since we have no guarantee that\n  // buffers are expected to have names there, it'll stay here for now.\n  return detect(file)\n    .then((type) => {\n      if (type === 'application/x-msi' || type === 'application/octet-stream') {\n        logger.info(`detected filetype to be ${type}. Falling back to mime.lookup`);\n\n        return mime.lookup(file.name);\n      }\n\n      logger.info(`detected filetype to be ${type}. returning it`);\n\n      return type;\n    });\n}\n"]},"metadata":{},"sourceType":"script"}