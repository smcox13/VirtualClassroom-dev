{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _entries = require('babel-runtime/core-js/object/entries');\n\nvar _entries2 = _interopRequireDefault(_entries);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _debounce2 = require('lodash/debounce');\n\nvar _debounce3 = _interopRequireDefault(_debounce2);\n\nvar _constants = require('./constants');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Presence Worker\n * Manages fetches and subscriptions for presence\n * @class\n */\n\n\nvar PresenceWorker = function () {\n  /**\n   * Constructs a presence worker to execute and\n   * maintain tasks related to presence upkeep.\n   * @returns {undefined}\n   */\n  function PresenceWorker() {\n    (0, _classCallCheck3.default)(this, PresenceWorker);\n    this.debouncedFetch = (0, _debounce3.default)(this.checkFetchers, _constants.FETCH_DELAY);\n    this.presences = {}; // current presence objects; updated time\n\n    this.watchers = {}; // counter of visible presence-required objects\n\n    this.fetchers = {}; // waiting to get presence object\n\n    this.flights = {}; // in flight to get presence object\n\n    this.campers = {}; // waiting to subscribe; updated time\n\n    this.subscribers = {}; // current subscriptions; expiration time\n  }\n  /**\n   * Connect to the mercury for presence and starts worker.\n   * @param {object} webex\n   * @returns {undefined}\n   */\n\n\n  (0, _createClass3.default)(PresenceWorker, [{\n    key: 'initialize',\n    value: function initialize(webex) {\n      var _this = this;\n\n      if (!webex || !webex.internal) {\n        throw new Error('Must initialize Presence Worker with webex!');\n      }\n\n      this.webex = webex;\n      var mercury = this.webex.internal.mercury.connected ? _promise2.default.resolve() : this.webex.internal.mercury.connect();\n      mercury.then(function () {\n        _this.webex.internal.mercury.on(_constants.APHELEIA_SUBSCRIPTION_UPDATE, _this.subscriptionUpdate.bind(_this));\n      });\n      setInterval(this.groundskeeper.bind(this), _constants.GROUNDSKEEPER_INTERVAL);\n    }\n    /**\n     * Trigger a subscription update event.\n     * @param {string} event\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'subscriptionUpdate',\n    value: function subscriptionUpdate(event) {\n      this.presences[event.data.subject] = new Date().getTime();\n      this.webex.internal.presence.emitEvent(_constants.PRESENCE_UPDATE, {\n        type: _constants.ENVELOPE_TYPE.SUBSCRIPTION,\n        payload: event.data\n      });\n    }\n    /**\n     * Retrieves and subscribes to a user's presence.\n     * @param {string} id\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'enqueue',\n    value: function enqueue(id) {\n      var now = new Date().getTime();\n\n      if (this.watchers[id]) {\n        this.watchers[id] += 1;\n      } else {\n        this.watchers[id] = 1;\n      }\n\n      if (this.subscribers[id]) {\n        return;\n      }\n\n      if (!this.campers[id]) {\n        this.campers[id] = now;\n      } // Retrieve presence if:\n      // not in flight or\n      // don't already have the presence or\n      // presence has gone stale\n\n\n      if (!this.flights[id] && (!this.presences[id] || this.presences[id] < now - _constants.UPDATE_PRESENCE_DELAY)) {\n        this.fetchers[id] = id;\n        this.debouncedFetch();\n      }\n    }\n    /**\n     * Retract from subscribing to a user's presence.\n     * @param {string} id\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'dequeue',\n    value: function dequeue(id) {\n      if (this.watchers[id]) {\n        this.watchers[id] -= 1;\n\n        if (this.watchers[id] <= 0) {\n          delete this.watchers[id];\n          delete this.fetchers[id];\n          delete this.campers[id];\n        }\n      }\n    }\n    /**\n     * Retrieve users' presences.\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'checkFetchers',\n    value: function checkFetchers() {\n      var _this2 = this;\n\n      var boarding = this.fetchers;\n      (0, _assign2.default)(this.flights, boarding);\n      this.fetchers = {};\n      this.webex.internal.presence.list((0, _keys2.default)(boarding)).then(function (response) {\n        var now = new Date().getTime();\n        response.statusList.forEach(function (presence) {\n          var id = presence.subject;\n          delete _this2.flights[id];\n          _this2.presences[id] = now;\n        });\n\n        _this2.webex.internal.presence.emitEvent(_constants.PRESENCE_UPDATE, {\n          type: _constants.ENVELOPE_TYPE.PRESENCE,\n          payload: response\n        });\n      });\n    }\n  }, {\n    key: 'checkCampers',\n\n    /**\n     * Determine if we should subscribe to users' presences.\n     * @returns {Array}: User ids to subscribe.\n     */\n    value: function checkCampers() {\n      var _this3 = this;\n\n      var now = new Date().getTime();\n      var subscribers = [];\n      (0, _entries2.default)(this.campers).forEach(function (camper) {\n        var id = camper[0];\n        var time = camper[1]; // Subscribe if they've been camping for a minute\n\n        if (time < now - _constants.SUBSCRIPTION_DELAY) {\n          delete _this3.campers[id];\n          _this3.subscribers[id] = null;\n          subscribers.push(id);\n        }\n      });\n      return subscribers;\n    }\n    /**\n     * Determine if we should re-subscribe or remove users' subscriptions.\n     * @returns {Array}: User ids to re-subscribe.\n     */\n\n  }, {\n    key: 'checkSubscriptions',\n    value: function checkSubscriptions() {\n      var _this4 = this;\n\n      var now = new Date().getTime();\n      var renewIds = [];\n      (0, _entries2.default)(this.subscribers).forEach(function (subscription) {\n        var id = subscription[0];\n        var expiration = subscription[1];\n\n        if (expiration) {\n          // Renew subscription if they're about to expire\n          if (_this4.watchers[id] && now > expiration - _constants.PREMATURE_EXPIRATION_SUBSCRIPTION_TIME) {\n            renewIds.push(id);\n          } else if (now > expiration) {\n            delete _this4.subscribers[id];\n          }\n        }\n      });\n      return renewIds;\n    }\n    /**\n     * Remove expired presence objects.\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'cleanPresences',\n    value: function cleanPresences() {\n      var _this5 = this;\n\n      var trash = [];\n\n      var tenMinutesAgo = new Date().getTime() - _constants.EXPIRED_PRESENCE_TIME;\n\n      (0, _entries2.default)(this.presences).forEach(function (presence) {\n        var id = presence[0];\n        var lastUpdated = presence[1]; // Delete the object if it is stale\n\n        if (lastUpdated < tenMinutesAgo) {\n          delete _this5.presences[id];\n          trash.push(id);\n        }\n      }); // Tells client to delete it too\n\n      if (trash.length) {\n        this.webex.internal.presence.emitEvent(_constants.PRESENCE_UPDATE, {\n          type: _constants.ENVELOPE_TYPE.DELETE,\n          payload: trash\n        });\n      }\n    }\n    /**\n     * Execute chores on an interval.\n     * Checks if we should make new subscribe,\n     * checks if we should re-subscribe,\n     * removes expired subscriptions,\n     * removes expired presence objects.\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'groundskeeper',\n    value: function groundskeeper() {\n      var _this6 = this;\n\n      var campers = this.checkCampers();\n      var renewSubscriptions = this.checkSubscriptions();\n      var ids = [].concat((0, _toConsumableArray3.default)(campers), (0, _toConsumableArray3.default)(renewSubscriptions));\n\n      if (ids.length) {\n        this.webex.internal.presence.subscribe(ids).then(function (body) {\n          var now = new Date().getTime();\n          body.responses.forEach(function (response) {\n            if (response.responseCode === 200) {\n              var ttl = response.subscriptionTtl * 1000;\n              _this6.subscribers[response.subject] = now + ttl;\n              _this6.presences[response.status.subject] = now;\n            } else {\n              // If it errored for any reason, set the ttl so we clean it out eventually\n              _this6.subscribers[response.subject] = now + _constants.DEFAULT_SUBSCRIPTION_TTL;\n            }\n          });\n        });\n      }\n\n      this.cleanPresences();\n    }\n  }]);\n  return PresenceWorker;\n}();\n\nexports.default = PresenceWorker;","map":{"version":3,"sources":["presence-worker.js"],"names":["PresenceWorker","webex","mercury","APHELEIA_SUBSCRIPTION_UPDATE","setInterval","GROUNDSKEEPER_INTERVAL","event","PRESENCE_UPDATE","type","ENVELOPE_TYPE","payload","data","id","now","UPDATE_PRESENCE_DELAY","boarding","response","presence","FETCH_DELAY","subscribers","camper","time","SUBSCRIPTION_DELAY","renewIds","subscription","expiration","PREMATURE_EXPIRATION_SUBSCRIPTION_TIME","trash","tenMinutesAgo","EXPIRED_PRESENCE_TIME","lastUpdated","campers","renewSubscriptions","ids","body","ttl","DEFAULT_SUBSCRIPTION_TTL"],"mappings":"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","sourcesContent":["\nimport {debounce} from 'lodash';\n\nimport {\n  FETCH_DELAY,\n  GROUNDSKEEPER_INTERVAL,\n  SUBSCRIPTION_DELAY,\n  UPDATE_PRESENCE_DELAY,\n  EXPIRED_PRESENCE_TIME,\n  PREMATURE_EXPIRATION_SUBSCRIPTION_TIME,\n  DEFAULT_SUBSCRIPTION_TTL,\n  APHELEIA_SUBSCRIPTION_UPDATE,\n  PRESENCE_UPDATE,\n  ENVELOPE_TYPE\n} from './constants';\n\n/**\n * Presence Worker\n * Manages fetches and subscriptions for presence\n * @class\n */\nexport default class PresenceWorker {\n  /**\n   * Constructs a presence worker to execute and\n   * maintain tasks related to presence upkeep.\n   * @returns {undefined}\n   */\n  constructor() {\n    this.presences = {}; // current presence objects; updated time\n    this.watchers = {}; // counter of visible presence-required objects\n    this.fetchers = {}; // waiting to get presence object\n    this.flights = {}; // in flight to get presence object\n    this.campers = {}; // waiting to subscribe; updated time\n    this.subscribers = {}; // current subscriptions; expiration time\n  }\n\n  /**\n   * Connect to the mercury for presence and starts worker.\n   * @param {object} webex\n   * @returns {undefined}\n   */\n  initialize(webex) {\n    if (!webex || !webex.internal) {\n      throw new Error('Must initialize Presence Worker with webex!');\n    }\n\n    this.webex = webex;\n\n    const mercury = this.webex.internal.mercury.connected ?\n      Promise.resolve() : this.webex.internal.mercury.connect();\n\n    mercury.then(() => {\n      this.webex.internal.mercury.on(APHELEIA_SUBSCRIPTION_UPDATE,\n        this.subscriptionUpdate.bind(this));\n    });\n\n    setInterval(this.groundskeeper.bind(this), GROUNDSKEEPER_INTERVAL);\n  }\n\n  /**\n   * Trigger a subscription update event.\n   * @param {string} event\n   * @returns {undefined}\n   */\n  subscriptionUpdate(event) {\n    this.presences[event.data.subject] = new Date().getTime();\n\n    this.webex.internal.presence.emitEvent(PRESENCE_UPDATE, {\n      type: ENVELOPE_TYPE.SUBSCRIPTION,\n      payload: event.data\n    });\n  }\n\n  /**\n   * Retrieves and subscribes to a user's presence.\n   * @param {string} id\n   * @returns {undefined}\n   */\n  enqueue(id) {\n    const now = new Date().getTime();\n\n    if (this.watchers[id]) {\n      this.watchers[id] += 1;\n    }\n    else {\n      this.watchers[id] = 1;\n    }\n\n    if (this.subscribers[id]) {\n      return;\n    }\n\n    if (!this.campers[id]) {\n      this.campers[id] = now;\n    }\n\n    // Retrieve presence if:\n    // not in flight or\n    // don't already have the presence or\n    // presence has gone stale\n    if (!this.flights[id] &&\n        (!this.presences[id] ||\n        this.presences[id] < now - UPDATE_PRESENCE_DELAY)) {\n      this.fetchers[id] = id;\n      this.debouncedFetch();\n    }\n  }\n\n  /**\n   * Retract from subscribing to a user's presence.\n   * @param {string} id\n   * @returns {undefined}\n   */\n  dequeue(id) {\n    if (this.watchers[id]) {\n      this.watchers[id] -= 1;\n\n      if (this.watchers[id] <= 0) {\n        delete this.watchers[id];\n        delete this.fetchers[id];\n        delete this.campers[id];\n      }\n    }\n  }\n\n  /**\n   * Retrieve users' presences.\n   * @returns {undefined}\n   */\n  checkFetchers() {\n    const boarding = this.fetchers;\n\n    Object.assign(this.flights, boarding);\n    this.fetchers = {};\n\n\n    this.webex.internal.presence.list(Object.keys(boarding))\n      .then((response) => {\n        const now = new Date().getTime();\n\n        response.statusList.forEach((presence) => {\n          const id = presence.subject;\n\n          delete this.flights[id];\n          this.presences[id] = now;\n        });\n\n        this.webex.internal.presence.emitEvent(PRESENCE_UPDATE, {\n          type: ENVELOPE_TYPE.PRESENCE,\n          payload: response\n        });\n      });\n  }\n\n  debouncedFetch = debounce(this.checkFetchers, FETCH_DELAY)\n\n  /**\n   * Determine if we should subscribe to users' presences.\n   * @returns {Array}: User ids to subscribe.\n   */\n  checkCampers() {\n    const now = new Date().getTime();\n    const subscribers = [];\n\n    Object.entries(this.campers).forEach((camper) => {\n      const id = camper[0];\n      const time = camper[1];\n\n      // Subscribe if they've been camping for a minute\n      if (time < now - SUBSCRIPTION_DELAY) {\n        delete this.campers[id];\n        this.subscribers[id] = null;\n        subscribers.push(id);\n      }\n    });\n\n    return subscribers;\n  }\n\n  /**\n   * Determine if we should re-subscribe or remove users' subscriptions.\n   * @returns {Array}: User ids to re-subscribe.\n   */\n  checkSubscriptions() {\n    const now = new Date().getTime();\n\n    const renewIds = [];\n\n    Object.entries(this.subscribers).forEach((subscription) => {\n      const id = subscription[0];\n      const expiration = subscription[1];\n\n      if (expiration) {\n        // Renew subscription if they're about to expire\n        if (this.watchers[id] &&\n            now > expiration - PREMATURE_EXPIRATION_SUBSCRIPTION_TIME) {\n          renewIds.push(id);\n        }\n        else if (now > expiration) {\n          delete this.subscribers[id];\n        }\n      }\n    });\n\n    return renewIds;\n  }\n\n  /**\n   * Remove expired presence objects.\n   * @returns {undefined}\n   */\n  cleanPresences() {\n    const trash = [];\n    const tenMinutesAgo = new Date().getTime() - EXPIRED_PRESENCE_TIME;\n\n    Object.entries(this.presences).forEach((presence) => {\n      const id = presence[0];\n      const lastUpdated = presence[1];\n\n      // Delete the object if it is stale\n      if (lastUpdated < tenMinutesAgo) {\n        delete this.presences[id];\n        trash.push(id);\n      }\n    });\n\n    // Tells client to delete it too\n    if (trash.length) {\n      this.webex.internal.presence.emitEvent(PRESENCE_UPDATE, {\n        type: ENVELOPE_TYPE.DELETE,\n        payload: trash\n      });\n    }\n  }\n\n  /**\n   * Execute chores on an interval.\n   * Checks if we should make new subscribe,\n   * checks if we should re-subscribe,\n   * removes expired subscriptions,\n   * removes expired presence objects.\n   * @returns {undefined}\n   */\n  groundskeeper() {\n    const campers = this.checkCampers();\n    const renewSubscriptions = this.checkSubscriptions();\n\n    const ids = [\n      ...campers,\n      ...renewSubscriptions\n    ];\n\n    if (ids.length) {\n      this.webex.internal.presence.subscribe(ids)\n        .then((body) => {\n          const now = new Date().getTime();\n\n          body.responses.forEach((response) => {\n            if (response.responseCode === 200) {\n              const ttl = response.subscriptionTtl * 1000;\n\n              this.subscribers[response.subject] = now + ttl;\n              this.presences[response.status.subject] = now;\n            }\n            else {\n              // If it errored for any reason, set the ttl so we clean it out eventually\n              this.subscribers[response.subject] = now + DEFAULT_SUBSCRIPTION_TTL;\n            }\n          });\n        });\n    }\n\n    this.cleanPresences();\n  }\n}\n\n"]},"metadata":{},"sourceType":"script"}