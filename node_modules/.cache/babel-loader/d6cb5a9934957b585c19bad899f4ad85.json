{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _isEmpty2 = require('lodash/isEmpty');\n\nvar _isEmpty3 = _interopRequireDefault(_isEmpty2);\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _constants = require('../constants');\n\nvar _triggerProxy = require('../common/events/trigger-proxy');\n\nvar _triggerProxy2 = _interopRequireDefault(_triggerProxy);\n\nvar _member = require('../member');\n\nvar _member2 = _interopRequireDefault(_member);\n\nvar _loggerProxy = require('../common/logs/logger-proxy');\n\nvar _loggerProxy2 = _interopRequireDefault(_loggerProxy);\n\nvar _parameter = require('../common/errors/parameter');\n\nvar _parameter2 = _interopRequireDefault(_parameter);\n\nvar _collection = require('./collection');\n\nvar _collection2 = _interopRequireDefault(_collection);\n\nvar _request = require('./request');\n\nvar _request2 = _interopRequireDefault(_request);\n\nvar _util = require('./util');\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n   * Members Update Event\n   * Emitted when something in the roster list needs to be updated\n   * @event members:update\n   * @instance\n   * @property {Object} delta the changes to the members list\n   * @property {Array} delta.updated array only the updates, includes removals, as they will have updated status and member properties\n   * @property {Array} delta.added array added members to the meeting\n   * @property {Array} full array the full members collection\n   * @memberof Members\n   */\n\n/**\n   * Members Content Update Event\n   * Emitted when who is sharing changes\n   * @event members:content:update\n   * @instance\n   * @property {String} activeContentSharingId\n   * @property {String} endedContentSharingId\n   * @memberof Members\n   */\n\n/**\n   * Members Host Update Event\n   * Emitted when who is the host changes\n   * @event members:host:update\n   * @instance\n   * @property {String} activeHostId\n   * @property {String} endedHostId\n   * @memberof Members\n   */\n\n/**\n   * Members Self Update Event\n   * Emitted when who is the self changes\n   * @event members:self:update\n   * @instance\n   * @property {String} activeSelfId\n   * @property {String} endedSelfId\n   * @memberof Members\n   */\n\n/**\n * @class Members\n */\n\n\nvar Members = function (_StatelessWebexPlugin) {\n  (0, _inherits3.default)(Members, _StatelessWebexPlugin);\n  /**\n   *\n   * @param {Object} attrs\n   * @param {Object} options\n   * @memberof Members\n   */\n\n  function Members(attrs, options) {\n    (0, _classCallCheck3.default)(this, Members);\n    /**\n     * The Members Request object to interact with server\n     * @instance\n     * @type {MembersRequest}\n     * @private\n     * @memberof Members\n    */\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Members.__proto__ || (0, _getPrototypeOf2.default)(Members)).call(this, {}, options));\n\n    _this.namespace = _constants.MEETINGS;\n    _this.membersRequest = new _request2.default({}, options);\n    /**\n     * The Members Collection cache\n     * @instance\n     * @type {MembersCollection}\n     * @private\n     * @memberof Members\n    */\n\n    _this.membersCollection = new _collection2.default();\n    /**\n     * The current locus url for the active meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n\n    _this.locusUrl = attrs.locusUrl || null;\n    /**\n     * The current hostId for the meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n\n    _this.hostId = null;\n    /**\n     * The current type for the meeting, could be MEETING or CALL\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n\n    _this.type = null;\n    /**\n     * Locus has a self object, sent individually to the client\n     * i.e., each person in the call gets their own self object from locus.\n     * We need to maintain that self object, because we also get information about all the participants\n     * and differentiate those participants from self.\n     * The self id shouldnt ever change, but it does have properties that will change\n     * and we use values in locus-info, such as to determine if i am admitted to the meeting or not as guest.\n     * The current selfId for the meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n\n    _this.selfId = null;\n    /**\n     * The current mediaShareContentId for the meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n\n    _this.mediaShareContentId = null;\n    /**\n     * The current recordingId for the meeting, if it exists\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n\n    _this.recordingId = null;\n    return _this;\n  }\n  /**\n   * Internal update the self Id value\n   * @param {Object} payload\n   * @param {Object} payload.newSelf\n   * @param {Object} payload.oldSelf\n   * @returns {undefined}\n   * @private\n   * @memberof Members\n   */\n\n\n  (0, _createClass3.default)(Members, [{\n    key: 'locusSelfUpdate',\n    value: function locusSelfUpdate(payload) {\n      var newSelfId = null;\n      var oldSelfId = null;\n\n      if (payload) {\n        if (payload.newSelf) {\n          newSelfId = payload.newSelf.id;\n        }\n\n        if (payload.oldSelf) {\n          oldSelfId = payload.oldSelf.id;\n        }\n      }\n\n      if (newSelfId) {\n        var theSelf = this.membersCollection.get(newSelfId);\n\n        if (theSelf) {\n          theSelf.setIsSelf(true);\n        }\n      }\n\n      if (oldSelfId) {\n        var notSelf = this.membersCollection.get(oldSelfId);\n\n        if (notSelf) {\n          notSelf.setIsSelf(false);\n        }\n      }\n\n      this.selfId = newSelfId;\n\n      _triggerProxy2.default.trigger(this, {\n        file: 'members',\n        function: 'locusSelfUpdate'\n      }, _constants.EVENT_TRIGGERS.MEMBERS_SELF_UPDATE, {\n        activeSelfId: newSelfId,\n        endedSelfId: oldSelfId\n      });\n    }\n    /**\n     * Internal update the hostId value\n     * @param {Object} payload\n     * @param {Object} payload.newHost\n     * @param {Object} payload.oldHost\n     * @returns {undefined}\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: 'locusHostUpdate',\n    value: function locusHostUpdate(payload) {\n      var newHostId = null;\n      var oldHostId = null;\n\n      if (payload) {\n        if (payload.newHost) {\n          newHostId = payload.newHost.id;\n        }\n\n        if (payload.oldHost) {\n          oldHostId = payload.oldHost.id;\n        }\n      }\n\n      if (newHostId) {\n        var theHost = this.membersCollection.get(newHostId);\n\n        if (theHost) {\n          theHost.setIsHost(true);\n        }\n      }\n\n      if (oldHostId) {\n        var notHost = this.membersCollection.get(oldHostId);\n\n        if (notHost) {\n          notHost.setIsHost(false);\n        }\n      }\n\n      this.hostId = newHostId;\n\n      _triggerProxy2.default.trigger(this, {\n        file: 'members',\n        function: 'locusHostUpdate'\n      }, _constants.EVENT_TRIGGERS.MEMBERS_HOST_UPDATE, {\n        activeHostId: newHostId,\n        endedHostId: oldHostId\n      });\n    }\n    /**\n     * when new participant updates come in, both delta and full participants, update them in members collection\n     * delta object in the event will have {updated, added} and full will be the full membersCollection\n     * @param {Object} payload\n     * @param {Object} payload.participants\n     * @returns {undefined}\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: 'locusParticipantsUpdate',\n    value: function locusParticipantsUpdate(payload) {\n      if (payload) {\n        var delta = this.handleLocusInfoUpdatedParticipants(payload);\n        var full = this.handleMembersUpdate(delta); // SDK should propagate the full list for both delta and non delta updates\n\n        _triggerProxy2.default.trigger(this, {\n          file: 'members',\n          function: 'locusParticipantsUpdate'\n        }, _constants.EVENT_TRIGGERS.MEMBERS_UPDATE, {\n          delta: delta,\n          full: full\n        });\n      }\n    }\n    /**\n     * Internal update the content id\n     * @param {Object} payload\n     * @param {Object} payload.current\n     * @param {Object} payload.previous\n     * @returns {undefined}\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: 'locusMediaSharesUpdate',\n    value: function locusMediaSharesUpdate(payload) {\n      var currentContent = payload.current;\n      var previousContent = payload.previous;\n      var whoSharing = null;\n      var whoStopped = null;\n\n      if (currentContent && currentContent.contentId) {\n        if (currentContent.disposition === _constants.FLOOR_ACTION.GRANTED) {\n          whoSharing = currentContent.contentId;\n          whoStopped = previousContent && previousContent.contentId;\n        } else if (currentContent.disposition === _constants.FLOOR_ACTION.RELEASED) {\n          whoStopped = currentContent.contentId;\n        }\n      }\n\n      if (whoSharing) {\n        var shareMember = this.membersCollection.get(whoSharing);\n\n        if (shareMember) {\n          shareMember.setIsContentSharing(true);\n        }\n      }\n\n      if (whoStopped) {\n        var stopMember = this.membersCollection.get(whoStopped);\n\n        if (stopMember) {\n          stopMember.setIsContentSharing(false);\n        }\n      }\n\n      this.mediaShareContentId = whoSharing;\n\n      _triggerProxy2.default.trigger(this, {\n        file: 'members',\n        function: 'locusMediaSharesUpdate'\n      }, _constants.EVENT_TRIGGERS.MEMBERS_CONTENT_UPDATE, {\n        activeContentSharingId: whoSharing,\n        endedContentSharingId: whoStopped\n      });\n    }\n    /**\n     * Internal update the locus url value\n     * @param {Object} payload\n     * @param {String} payload.locusUrl\n     * @returns {undefined}\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: 'locusUrlUpdate',\n    value: function locusUrlUpdate(payload) {\n      if (payload) {\n        this.setLocusUrl(null, payload);\n      }\n    }\n    /**\n     * Internal update the type of meeting\n     * @param {Object} payload\n     * @param {String} payload.type\n     * @returns {undefined}\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: 'locusFullStateTypeUpdate',\n    value: function locusFullStateTypeUpdate(payload) {\n      // TODO: at some point there could be a timing issue here, for updating each member\n      // ie., if the type changes AND there is no locus update, then each member will not know the type of call\n      // which means they cannot determine isMutable && isRemovable\n      // for now this scenario is impossible to occur since we always get a locus update when the type changes\n      // except for in delta locus meetings, but in that case, the type will always have been set differently\n      // from the outset anyway\n      if (payload) {\n        this.setType(payload);\n      }\n    }\n    /**\n     * sets values in the members collection for updated and added properties from delta\n     * @param {Object} membersUpdate {updated: [], added: []}\n     * @returns {Object} membersCollection\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: 'handleMembersUpdate',\n    value: function handleMembersUpdate(membersUpdate) {\n      if (membersUpdate) {\n        if (membersUpdate.updated) {\n          this.constructMembers(membersUpdate.updated);\n        }\n\n        if (membersUpdate.added) {\n          this.constructMembers(membersUpdate.added);\n        }\n      }\n\n      return this.membersCollection.getAll();\n    }\n    /**\n     * set members to the member collection from each updated/added lists as passed in\n     * @param {Array} list\n     * @returns {undefined}\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: 'constructMembers',\n    value: function constructMembers(list) {\n      var _this2 = this;\n\n      list.forEach(function (member) {\n        _this2.membersCollection.set(member.id, member);\n      });\n    }\n    /**\n     * Internal update the participants value\n     * @param {Object} payload\n     * @returns {Object}\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: 'handleLocusInfoUpdatedParticipants',\n    value: function handleLocusInfoUpdatedParticipants(payload) {\n      this.hostId = payload.hostId || this.hostId;\n      this.selfId = payload.selfId || this.selfId;\n      this.recordingId = payload.recordingId;\n\n      if (!payload.participants) {\n        _loggerProxy2.default.logger.warn('members/index->handleLocusInfoUpdatedParticipants#participants payload is missing.');\n      }\n\n      var memberUpdate = this.update(payload.participants);\n      return memberUpdate;\n    }\n    /**\n     * Update the locus Url\n     * @param {Object} locus\n     * @param {String} [locusUrl] optional, takes precedence\n     * @throws {ParameterError}\n     * @returns {undefined}\n     * @public\n     * @memberof Members\n     */\n\n  }, {\n    key: 'setLocusUrl',\n    value: function setLocusUrl(locus) {\n      var locusUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (locusUrl) {\n        this.locusUrl = locusUrl;\n      } else if (locus && (locus.locusUrl || locus.url)) {\n        this.locusUrl = locus.locusUrl || locus.url;\n      } else {\n        throw new _parameter2.default('Setting locusUrl for the Members module should be done with a locus object or locusUrl');\n      }\n    }\n    /**\n     * Update the host id\n     * @param {Object} locus\n     * @param {String} [hostId] optional, takes precedence\n     * @throws {ParameterError}\n     * @returns {undefined}\n     * @public\n     * @memberof Members\n     */\n\n  }, {\n    key: 'setHostId',\n    value: function setHostId(locus) {\n      var hostId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (hostId) {\n        this.hostId = hostId;\n      } else if (locus) {\n        this.hostId = locus && locus.owner && locus.owner.info ? locus.owner.info : null;\n      } else {\n        throw new _parameter2.default('Setting hostid for the Members module should be done with a locus object or hostId');\n      }\n    }\n    /**\n     * Update the type\n     * @param {Object} fullState\n     * @param {String} [type] optional, takes precedence\n     * @throws {ParameterError}\n     * @returns {undefined}\n     * @public\n     * @memberof Members\n     */\n\n  }, {\n    key: 'setType',\n    value: function setType(fullState) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (type) {\n        this.type = type;\n      } else if (fullState) {\n        this.type = fullState && fullState.type || null;\n      } else {\n        throw new _parameter2.default('Setting type for the Members module should be done with a fullstate object or type string');\n      }\n    }\n    /**\n     * Update the self Id\n     * @param {Object} locus\n     * @param {String} [selfId] optional, takes precedence\n     * @throws {Error}\n     * @returns {undefined}\n     * @memberof Members\n     */\n\n  }, {\n    key: 'setSelfId',\n    value: function setSelfId(locus) {\n      var selfId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (selfId) {\n        this.selfId = selfId;\n      } else if (locus) {\n        this.selfId = locus && locus.self && locus.self.person && locus.self.person.id ? locus.self.person.id : null;\n      } else {\n        throw new _parameter2.default('Setting selfid for the Members module should be done with a locus object or selfId');\n      }\n    }\n    /**\n     * Update the media share content id\n     * @param {Object} locus\n     * @param {String} [contentId] optional, takes precedence\n     * @throws {Error}\n     * @returns {undefined}\n     * @memberof Members\n     */\n\n  }, {\n    key: 'setMediaShareContentId',\n    value: function setMediaShareContentId(locus, contentId) {\n      if (contentId) {\n        this.mediaShareContentId = contentId;\n      } else if (locus) {\n        var contentMediaShare = locus.mediaShares && locus.mediaShares.length && locus.mediaShares.find(function (mediaShare) {\n          return mediaShare.name === _constants.CONTENT;\n        });\n        this.mediaShareContentId = contentMediaShare && contentMediaShare.floor && contentMediaShare.floor.beneficiary && contentMediaShare.floor.beneficiary.id || null;\n      } else {\n        throw new _parameter2.default('Setting hostid for the Members module should be done with a locus object or hostId');\n      }\n    }\n    /**\n     * Find all the updates, and added members\n     * Removed/left members will end up in updates\n     * Each array contains only members\n     * @param {Array} participants the locus participants\n     * @returns {Object} {added: {Array}, updated: {Array}}\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: 'update',\n    value: function update(participants) {\n      var _this3 = this;\n\n      var membersUpdate = {\n        added: [],\n        updated: []\n      };\n\n      if (participants) {\n        participants.forEach(function (participant) {\n          if (participant.hideInRoster) {\n            return;\n          }\n\n          var existing = _this3.membersCollection.get(participant.id);\n\n          if (existing) {\n            // TODO: compare existing member to new participant coming in properties and determine if updated (this helps for non delta events)\n            // on client re renders, but we will have to determine what values to compare to determine difference, premature optimization\n            membersUpdate.updated.push(new _member2.default(participant, {\n              recordingId: _this3.recordingId,\n              selfId: _this3.selfId,\n              hostId: _this3.hostId,\n              contentSharingId: _this3.mediaShareContentId,\n              type: _this3.type\n            }));\n          } else {\n            membersUpdate.added.push(new _member2.default(participant, {\n              recordingId: _this3.recordingId,\n              selfId: _this3.selfId,\n              hostId: _this3.hostId,\n              contentSharingId: _this3.mediaShareContentId,\n              type: _this3.type\n            }));\n          }\n        });\n      }\n\n      return membersUpdate;\n    }\n    /**\n     * Adds a guest Member to the associated meeting\n     * @param {String} invitee\n     * @param {Boolean} [alertIfActive]\n     * @returns {Promise}\n     * @memberof Members\n     */\n\n  }, {\n    key: 'addMember',\n    value: function addMember(invitee, alertIfActive) {\n      if (!this.locusUrl) {\n        return _promise2.default.reject(new _parameter2.default('The associated locus url for this meeting object must be defined.'));\n      }\n\n      if (_util2.default.isInvalidInvitee(invitee)) {\n        return _promise2.default.reject(new _parameter2.default('The invitee must be defined with either a valid email, or emailAddress property.'));\n      }\n\n      var options = _util2.default.generateAddMemberOptions(invitee, this.locusUrl, alertIfActive);\n\n      return this.membersRequest.addMembers(options);\n    }\n    /**\n     * Admits waiting members (invited guests to meeting)\n     * @param {Array} memberIds\n     * @returns {Promise}\n     * @public\n     * @memberof Members\n     */\n\n  }, {\n    key: 'admitMembers',\n    value: function admitMembers(memberIds) {\n      if ((0, _isEmpty3.default)(memberIds)) {\n        return _promise2.default.reject(new _parameter2.default('No member ids provided to admit.'));\n      }\n\n      var options = _util2.default.generateAdmitMemberOptions(memberIds, this.locusUrl);\n\n      return this.membersRequest.admitMember(options);\n    }\n    /**\n     * Removes a member from the meeting\n     * @param {String} memberId\n     * @returns {Promise}\n     * @public\n     * @memberof Members\n     */\n\n  }, {\n    key: 'removeMember',\n    value: function removeMember(memberId) {\n      if (!this.locusUrl) {\n        return _promise2.default.reject(new _parameter2.default('The associated locus url for this meeting object must be defined.'));\n      }\n\n      if (!memberId) {\n        return _promise2.default.reject(new _parameter2.default('The member id must be defined to remove the member.'));\n      }\n\n      var options = _util2.default.generateRemoveMemberOptions(memberId, this.locusUrl);\n\n      return this.membersRequest.removeMember(options);\n    }\n    /**\n     * Audio mutes another member in a meeting\n     * @param {String} memberId\n     * @param {boolean} [mute] default true\n     * @returns {Promise}\n     * @public\n     * @memberof Members\n     */\n\n  }, {\n    key: 'muteMember',\n    value: function muteMember(memberId) {\n      var mute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (!this.locusUrl) {\n        return _promise2.default.reject(new _parameter2.default('The associated locus url for this meetings members object must be defined.'));\n      }\n\n      if (!memberId) {\n        return _promise2.default.reject(new _parameter2.default('The member id must be defined to mute the member.'));\n      }\n\n      var options = _util2.default.generateMuteMemberOptions(memberId, mute, this.locusUrl);\n\n      return this.membersRequest.muteMember(options);\n    }\n    /**\n     * Transfers the host to another member\n     * @param {String} memberId\n     * @param {boolean} [moderator] default true\n     * @returns {Promise}\n     * @public\n     * @memberof Members\n     */\n\n  }, {\n    key: 'transferHostToMember',\n    value: function transferHostToMember(memberId) {\n      var moderator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (!this.locusUrl) {\n        return _promise2.default.reject(new _parameter2.default('The associated locus url for this meetings members object must be defined.'));\n      }\n\n      if (!memberId) {\n        return _promise2.default.reject(new _parameter2.default('The member id must be defined to transfer host to the member.'));\n      }\n\n      var options = _util2.default.generateTransferHostMemberOptions(memberId, moderator, this.locusUrl);\n\n      return this.membersRequest.transferHostToMember(options);\n    }\n  }]);\n  return Members;\n}(_webexCore.StatelessWebexPlugin);\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nexports.default = Members;","map":{"version":3,"sources":["index.js"],"names":["Members","StatelessWebexPlugin","namespace","MEETINGS","MembersRequest","MembersCollection","attrs","payload","newSelfId","oldSelfId","theSelf","notSelf","Trigger","file","function","EVENT_TRIGGERS","activeSelfId","endedSelfId","newHostId","oldHostId","theHost","notHost","activeHostId","endedHostId","delta","full","currentContent","previousContent","whoSharing","whoStopped","FLOOR_ACTION","shareMember","stopMember","activeContentSharingId","endedContentSharingId","membersUpdate","list","member","LoggerProxy","memberUpdate","locus","locusUrl","ParameterError","hostId","fullState","type","selfId","contentId","contentMediaShare","mediaShare","CONTENT","participants","added","updated","participant","existing","Member","recordingId","contentSharingId","invitee","alertIfActive","MembersUtil","options","memberIds","memberId","mute","moderator"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\nimport {isEmpty} from 'lodash';\nimport {StatelessWebexPlugin} from '@webex/webex-core';\n\nimport {MEETINGS, EVENT_TRIGGERS, FLOOR_ACTION, CONTENT} from '../constants';\nimport Trigger from '../common/events/trigger-proxy';\nimport Member from '../member';\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport ParameterError from '../common/errors/parameter';\n\nimport MembersCollection from './collection';\nimport MembersRequest from './request';\nimport MembersUtil from './util';\n\n/**\n   * Members Update Event\n   * Emitted when something in the roster list needs to be updated\n   * @event members:update\n   * @instance\n   * @property {Object} delta the changes to the members list\n   * @property {Array} delta.updated array only the updates, includes removals, as they will have updated status and member properties\n   * @property {Array} delta.added array added members to the meeting\n   * @property {Array} full array the full members collection\n   * @memberof Members\n   */\n\n/**\n   * Members Content Update Event\n   * Emitted when who is sharing changes\n   * @event members:content:update\n   * @instance\n   * @property {String} activeContentSharingId\n   * @property {String} endedContentSharingId\n   * @memberof Members\n   */\n\n/**\n   * Members Host Update Event\n   * Emitted when who is the host changes\n   * @event members:host:update\n   * @instance\n   * @property {String} activeHostId\n   * @property {String} endedHostId\n   * @memberof Members\n   */\n\n/**\n   * Members Self Update Event\n   * Emitted when who is the self changes\n   * @event members:self:update\n   * @instance\n   * @property {String} activeSelfId\n   * @property {String} endedSelfId\n   * @memberof Members\n   */\n\n/**\n * @class Members\n */\nexport default class Members extends StatelessWebexPlugin {\n  namespace = MEETINGS;\n\n  /**\n   *\n   * @param {Object} attrs\n   * @param {Object} options\n   * @memberof Members\n   */\n  constructor(attrs, options) {\n    super({}, options);\n    /**\n     * The Members Request object to interact with server\n     * @instance\n     * @type {MembersRequest}\n     * @private\n     * @memberof Members\n    */\n    this.membersRequest = new MembersRequest({}, options);\n    /**\n     * The Members Collection cache\n     * @instance\n     * @type {MembersCollection}\n     * @private\n     * @memberof Members\n    */\n    this.membersCollection = new MembersCollection();\n    /**\n     * The current locus url for the active meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n    this.locusUrl = attrs.locusUrl || null;\n    /**\n     * The current hostId for the meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n    this.hostId = null;\n    /**\n     * The current type for the meeting, could be MEETING or CALL\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n    this.type = null;\n    /**\n     * Locus has a self object, sent individually to the client\n     * i.e., each person in the call gets their own self object from locus.\n     * We need to maintain that self object, because we also get information about all the participants\n     * and differentiate those participants from self.\n     * The self id shouldnt ever change, but it does have properties that will change\n     * and we use values in locus-info, such as to determine if i am admitted to the meeting or not as guest.\n     * The current selfId for the meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n    this.selfId = null;\n    /**\n     * The current mediaShareContentId for the meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n    this.mediaShareContentId = null;\n    /**\n     * The current recordingId for the meeting, if it exists\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n    this.recordingId = null;\n  }\n\n  /**\n   * Internal update the self Id value\n   * @param {Object} payload\n   * @param {Object} payload.newSelf\n   * @param {Object} payload.oldSelf\n   * @returns {undefined}\n   * @private\n   * @memberof Members\n   */\n  locusSelfUpdate(payload) {\n    let newSelfId = null;\n    let oldSelfId = null;\n\n    if (payload) {\n      if (payload.newSelf) {\n        newSelfId = payload.newSelf.id;\n      }\n      if (payload.oldSelf) {\n        oldSelfId = payload.oldSelf.id;\n      }\n    }\n    if (newSelfId) {\n      const theSelf = this.membersCollection.get(newSelfId);\n\n      if (theSelf) {\n        theSelf.setIsSelf(true);\n      }\n    }\n    if (oldSelfId) {\n      const notSelf = this.membersCollection.get(oldSelfId);\n\n      if (notSelf) {\n        notSelf.setIsSelf(false);\n      }\n    }\n    this.selfId = newSelfId;\n    Trigger.trigger(\n      this,\n      {\n        file: 'members',\n        function: 'locusSelfUpdate'\n      },\n      EVENT_TRIGGERS.MEMBERS_SELF_UPDATE,\n      {\n        activeSelfId: newSelfId,\n        endedSelfId: oldSelfId\n      }\n    );\n  }\n\n  /**\n   * Internal update the hostId value\n   * @param {Object} payload\n   * @param {Object} payload.newHost\n   * @param {Object} payload.oldHost\n   * @returns {undefined}\n   * @private\n   * @memberof Members\n   */\n  locusHostUpdate(payload) {\n    let newHostId = null;\n    let oldHostId = null;\n\n    if (payload) {\n      if (payload.newHost) {\n        newHostId = payload.newHost.id;\n      }\n      if (payload.oldHost) {\n        oldHostId = payload.oldHost.id;\n      }\n    }\n    if (newHostId) {\n      const theHost = this.membersCollection.get(newHostId);\n\n      if (theHost) {\n        theHost.setIsHost(true);\n      }\n    }\n    if (oldHostId) {\n      const notHost = this.membersCollection.get(oldHostId);\n\n      if (notHost) {\n        notHost.setIsHost(false);\n      }\n    }\n    this.hostId = newHostId;\n    Trigger.trigger(\n      this,\n      {\n        file: 'members',\n        function: 'locusHostUpdate'\n      },\n      EVENT_TRIGGERS.MEMBERS_HOST_UPDATE,\n      {\n        activeHostId: newHostId,\n        endedHostId: oldHostId\n      }\n    );\n  }\n\n  /**\n   * when new participant updates come in, both delta and full participants, update them in members collection\n   * delta object in the event will have {updated, added} and full will be the full membersCollection\n   * @param {Object} payload\n   * @param {Object} payload.participants\n   * @returns {undefined}\n   * @private\n   * @memberof Members\n   */\n  locusParticipantsUpdate(payload) {\n    if (payload) {\n      const delta = this.handleLocusInfoUpdatedParticipants(payload);\n      const full = this.handleMembersUpdate(delta); // SDK should propagate the full list for both delta and non delta updates\n\n      Trigger.trigger(\n        this,\n        {\n          file: 'members',\n          function: 'locusParticipantsUpdate'\n        },\n        EVENT_TRIGGERS.MEMBERS_UPDATE,\n        {\n          delta,\n          full\n        }\n      );\n    }\n  }\n\n  /**\n   * Internal update the content id\n   * @param {Object} payload\n   * @param {Object} payload.current\n   * @param {Object} payload.previous\n   * @returns {undefined}\n   * @private\n   * @memberof Members\n   */\n  locusMediaSharesUpdate(payload) {\n    const currentContent = payload.current;\n    const previousContent = payload.previous;\n    let whoSharing = null;\n    let whoStopped = null;\n\n    if (currentContent && currentContent.contentId) {\n      if (currentContent.disposition === FLOOR_ACTION.GRANTED) {\n        whoSharing = currentContent.contentId;\n        whoStopped = previousContent && previousContent.contentId;\n      }\n      else if (currentContent.disposition === FLOOR_ACTION.RELEASED) {\n        whoStopped = currentContent.contentId;\n      }\n    }\n    if (whoSharing) {\n      const shareMember = this.membersCollection.get(whoSharing);\n\n      if (shareMember) {\n        shareMember.setIsContentSharing(true);\n      }\n    }\n    if (whoStopped) {\n      const stopMember = this.membersCollection.get(whoStopped);\n\n      if (stopMember) {\n        stopMember.setIsContentSharing(false);\n      }\n    }\n    this.mediaShareContentId = whoSharing;\n    Trigger.trigger(\n      this,\n      {\n        file: 'members',\n        function: 'locusMediaSharesUpdate'\n      },\n      EVENT_TRIGGERS.MEMBERS_CONTENT_UPDATE,\n      {\n        activeContentSharingId: whoSharing,\n        endedContentSharingId: whoStopped\n      }\n    );\n  }\n\n\n  /**\n   * Internal update the locus url value\n   * @param {Object} payload\n   * @param {String} payload.locusUrl\n   * @returns {undefined}\n   * @private\n   * @memberof Members\n   */\n  locusUrlUpdate(payload) {\n    if (payload) {\n      this.setLocusUrl(null, payload);\n    }\n  }\n\n  /**\n   * Internal update the type of meeting\n   * @param {Object} payload\n   * @param {String} payload.type\n   * @returns {undefined}\n   * @private\n   * @memberof Members\n   */\n  locusFullStateTypeUpdate(payload) {\n    // TODO: at some point there could be a timing issue here, for updating each member\n    // ie., if the type changes AND there is no locus update, then each member will not know the type of call\n    // which means they cannot determine isMutable && isRemovable\n    // for now this scenario is impossible to occur since we always get a locus update when the type changes\n    // except for in delta locus meetings, but in that case, the type will always have been set differently\n    // from the outset anyway\n    if (payload) {\n      this.setType(payload);\n    }\n  }\n\n  /**\n   * sets values in the members collection for updated and added properties from delta\n   * @param {Object} membersUpdate {updated: [], added: []}\n   * @returns {Object} membersCollection\n   * @private\n   * @memberof Members\n   */\n  handleMembersUpdate(membersUpdate) {\n    if (membersUpdate) {\n      if (membersUpdate.updated) {\n        this.constructMembers(membersUpdate.updated);\n      }\n      if (membersUpdate.added) {\n        this.constructMembers(membersUpdate.added);\n      }\n    }\n\n    return this.membersCollection.getAll();\n  }\n\n  /**\n   * set members to the member collection from each updated/added lists as passed in\n   * @param {Array} list\n   * @returns {undefined}\n   * @private\n   * @memberof Members\n   */\n  constructMembers(list) {\n    list.forEach((member) => {\n      this.membersCollection.set(member.id, member);\n    });\n  }\n\n  /**\n   * Internal update the participants value\n   * @param {Object} payload\n   * @returns {Object}\n   * @private\n   * @memberof Members\n   */\n  handleLocusInfoUpdatedParticipants(payload) {\n    this.hostId = payload.hostId || this.hostId;\n    this.selfId = payload.selfId || this.selfId;\n    this.recordingId = payload.recordingId;\n    if (!payload.participants) {\n      LoggerProxy.logger.warn('members/index->handleLocusInfoUpdatedParticipants#participants payload is missing.');\n    }\n    const memberUpdate = this.update(payload.participants);\n\n    return memberUpdate;\n  }\n\n  /**\n   * Update the locus Url\n   * @param {Object} locus\n   * @param {String} [locusUrl] optional, takes precedence\n   * @throws {ParameterError}\n   * @returns {undefined}\n   * @public\n   * @memberof Members\n   */\n  setLocusUrl(locus, locusUrl = null) {\n    if (locusUrl) {\n      this.locusUrl = locusUrl;\n    }\n    else if (locus && (locus.locusUrl || locus.url)) {\n      this.locusUrl = locus.locusUrl || locus.url;\n    }\n    else {\n      throw new ParameterError('Setting locusUrl for the Members module should be done with a locus object or locusUrl');\n    }\n  }\n\n  /**\n   * Update the host id\n   * @param {Object} locus\n   * @param {String} [hostId] optional, takes precedence\n   * @throws {ParameterError}\n   * @returns {undefined}\n   * @public\n   * @memberof Members\n   */\n  setHostId(locus, hostId = null) {\n    if (hostId) {\n      this.hostId = hostId;\n    }\n    else if (locus) {\n      this.hostId = locus && locus.owner && locus.owner.info ? locus.owner.info : null;\n    }\n    else {\n      throw new ParameterError('Setting hostid for the Members module should be done with a locus object or hostId');\n    }\n  }\n\n  /**\n   * Update the type\n   * @param {Object} fullState\n   * @param {String} [type] optional, takes precedence\n   * @throws {ParameterError}\n   * @returns {undefined}\n   * @public\n   * @memberof Members\n   */\n  setType(fullState, type = null) {\n    if (type) {\n      this.type = type;\n    }\n    else if (fullState) {\n      this.type = (fullState && fullState.type) || null;\n    }\n    else {\n      throw new ParameterError('Setting type for the Members module should be done with a fullstate object or type string');\n    }\n  }\n\n  /**\n   * Update the self Id\n   * @param {Object} locus\n   * @param {String} [selfId] optional, takes precedence\n   * @throws {Error}\n   * @returns {undefined}\n   * @memberof Members\n   */\n  setSelfId(locus, selfId = null) {\n    if (selfId) {\n      this.selfId = selfId;\n    }\n    else if (locus) {\n      this.selfId = locus && locus.self && locus.self.person && locus.self.person.id ? locus.self.person.id : null;\n    }\n    else {\n      throw new ParameterError('Setting selfid for the Members module should be done with a locus object or selfId');\n    }\n  }\n\n  /**\n   * Update the media share content id\n   * @param {Object} locus\n   * @param {String} [contentId] optional, takes precedence\n   * @throws {Error}\n   * @returns {undefined}\n   * @memberof Members\n   */\n  setMediaShareContentId(locus, contentId) {\n    if (contentId) {\n      this.mediaShareContentId = contentId;\n    }\n    else if (locus) {\n      const contentMediaShare =\n        locus.mediaShares &&\n        locus.mediaShares.length &&\n        locus.mediaShares.find((mediaShare) => mediaShare.name === CONTENT);\n\n      this.mediaShareContentId =\n        (contentMediaShare &&\n          contentMediaShare.floor &&\n          contentMediaShare.floor.beneficiary &&\n          contentMediaShare.floor.beneficiary.id) ||\n        null;\n    }\n    else {\n      throw new ParameterError('Setting hostid for the Members module should be done with a locus object or hostId');\n    }\n  }\n\n  /**\n   * Find all the updates, and added members\n   * Removed/left members will end up in updates\n   * Each array contains only members\n   * @param {Array} participants the locus participants\n   * @returns {Object} {added: {Array}, updated: {Array}}\n   * @private\n   * @memberof Members\n   */\n  update(participants) {\n    const membersUpdate = {added: [], updated: []};\n\n    if (participants) {\n      participants.forEach((participant) => {\n        if (participant.hideInRoster) {\n          return;\n        }\n        const existing = this.membersCollection.get(participant.id);\n\n        if (existing) {\n          // TODO: compare existing member to new participant coming in properties and determine if updated (this helps for non delta events)\n          // on client re renders, but we will have to determine what values to compare to determine difference, premature optimization\n          membersUpdate.updated.push(\n            new Member(participant, {\n              recordingId: this.recordingId,\n              selfId: this.selfId,\n              hostId: this.hostId,\n              contentSharingId: this.mediaShareContentId,\n              type: this.type\n            })\n          );\n        }\n        else {\n          membersUpdate.added.push(\n            new Member(participant, {\n              recordingId: this.recordingId,\n              selfId: this.selfId,\n              hostId: this.hostId,\n              contentSharingId: this.mediaShareContentId,\n              type: this.type\n            })\n          );\n        }\n      });\n    }\n\n    return membersUpdate;\n  }\n\n  /**\n   * Adds a guest Member to the associated meeting\n   * @param {String} invitee\n   * @param {Boolean} [alertIfActive]\n   * @returns {Promise}\n   * @memberof Members\n   */\n  addMember(invitee, alertIfActive) {\n    if (!this.locusUrl) {\n      return Promise.reject(new ParameterError('The associated locus url for this meeting object must be defined.'));\n    }\n    if (MembersUtil.isInvalidInvitee(invitee)) {\n      return Promise.reject(\n        new ParameterError('The invitee must be defined with either a valid email, or emailAddress property.')\n      );\n    }\n    const options = MembersUtil.generateAddMemberOptions(invitee, this.locusUrl, alertIfActive);\n\n    return this.membersRequest.addMembers(options);\n  }\n\n  /**\n   * Admits waiting members (invited guests to meeting)\n   * @param {Array} memberIds\n   * @returns {Promise}\n   * @public\n   * @memberof Members\n   */\n  admitMembers(memberIds) {\n    if (isEmpty(memberIds)) {\n      return Promise.reject(new ParameterError('No member ids provided to admit.'));\n    }\n    const options = MembersUtil.generateAdmitMemberOptions(memberIds, this.locusUrl);\n\n    return this.membersRequest.admitMember(options);\n  }\n\n  /**\n   * Removes a member from the meeting\n   * @param {String} memberId\n   * @returns {Promise}\n   * @public\n   * @memberof Members\n   */\n  removeMember(memberId) {\n    if (!this.locusUrl) {\n      return Promise.reject(new ParameterError('The associated locus url for this meeting object must be defined.'));\n    }\n    if (!memberId) {\n      return Promise.reject(new ParameterError('The member id must be defined to remove the member.'));\n    }\n    const options = MembersUtil.generateRemoveMemberOptions(memberId, this.locusUrl);\n\n    return this.membersRequest.removeMember(options);\n  }\n\n  /**\n   * Audio mutes another member in a meeting\n   * @param {String} memberId\n   * @param {boolean} [mute] default true\n   * @returns {Promise}\n   * @public\n   * @memberof Members\n   */\n  muteMember(memberId, mute = true) {\n    if (!this.locusUrl) {\n      return Promise.reject(new ParameterError('The associated locus url for this meetings members object must be defined.'));\n    }\n    if (!memberId) {\n      return Promise.reject(new ParameterError('The member id must be defined to mute the member.'));\n    }\n    const options = MembersUtil.generateMuteMemberOptions(memberId, mute, this.locusUrl);\n\n    return this.membersRequest.muteMember(options);\n  }\n\n  /**\n   * Transfers the host to another member\n   * @param {String} memberId\n   * @param {boolean} [moderator] default true\n   * @returns {Promise}\n   * @public\n   * @memberof Members\n   */\n  transferHostToMember(memberId, moderator = true) {\n    if (!this.locusUrl) {\n      return Promise.reject(new ParameterError('The associated locus url for this meetings members object must be defined.'));\n    }\n    if (!memberId) {\n      return Promise.reject(new ParameterError('The member id must be defined to transfer host to the member.'));\n    }\n    const options = MembersUtil.generateTransferHostMemberOptions(memberId, moderator, this.locusUrl);\n\n    return this.membersRequest.transferHostToMember(options);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}