{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _map = require('babel-runtime/core-js/map');\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _has2 = require('lodash/has');\n\nvar _has3 = _interopRequireDefault(_has2);\n\nvar _webexPlugin = require('./webex-plugin');\n\nvar _webexPlugin2 = _interopRequireDefault(_webexPlugin);\n\nvar _common = require('@webex/common');\n\nvar _webexHttpError = require('./webex-http-error');\n\nvar _webexHttpError2 = _interopRequireDefault(_webexHttpError);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Base class for coalescing requests to batched APIs\n * @class Batcher\n */\n\n\nvar Batcher = _webexPlugin2.default.extend({\n  session: {\n    deferreds: {\n      type: 'object',\n      default: function _default() {\n        return new _map2.default();\n      }\n    },\n    queue: {\n      type: 'array',\n      default: function _default() {\n        return [];\n      }\n    }\n  },\n  derived: {\n    bounce: {\n      fn: function fn() {\n        var _this = this;\n\n        return (0, _common.cappedDebounce)(function () {\n          return _this.executeQueue.apply(_this, arguments);\n        }, this.config.batcherWait, {\n          maxCalls: this.config.batcherMaxCalls,\n          maxWait: this.config.batcherMaxWait\n        });\n      }\n    }\n  },\n\n  /**\n   * Requests an item from a batched API\n   * @param {Object} item\n   * @returns {Promise<mixed>}\n   */\n  request: function request(item) {\n    var _this2 = this; // So far, I can't find a way to avoid three layers of nesting here.\n\n    /* eslint max-nested-callbacks: [0] */\n\n\n    var defer = new _common.Defer();\n    this.fingerprintRequest(item).then(function (idx) {\n      if (_this2.deferreds.has(idx)) {\n        defer.resolve(_this2.deferreds.get(idx).promise);\n        return;\n      }\n\n      _this2.deferreds.set(idx, defer);\n\n      _this2.prepareItem(item).then(function (req) {\n        defer.promise = defer.promise.then((0, _common.tap)(function () {\n          return _this2.deferreds.delete(idx);\n        })).catch(function (reason) {\n          _this2.deferreds.delete(idx);\n\n          return _promise2.default.reject(reason);\n        });\n\n        _this2.enqueue(req).then(function () {\n          return _this2.bounce();\n        }).catch(function (reason) {\n          return defer.reject(reason);\n        });\n      }).catch(function (reason) {\n        return defer.reject(reason);\n      });\n    }).catch(function (reason) {\n      return defer.reject(reason);\n    });\n    return defer.promise;\n  },\n\n  /**\n   * Adds an item to the queue.\n   * Intended to be overridden\n   * @param {mixed} req\n   * @returns {Promise<undefined>}\n   */\n  enqueue: function enqueue(req) {\n    this.queue.push(req);\n    return _promise2.default.resolve();\n  },\n\n  /**\n   * Transform the item before adding it to the queue\n   * Intended to be overridden\n   * @param {mixed} item\n   * @returns {Promise<mixed>}\n   */\n  prepareItem: function prepareItem(item) {\n    return _promise2.default.resolve(item);\n  },\n\n  /**\n   * Detaches the current queue, does any appropriate transforms, and submits it\n   * to the API.\n   * @returns {Promise<undefined>}\n   */\n  executeQueue: function executeQueue() {\n    var _this3 = this;\n\n    var queue = this.queue.splice(0, this.config.batcherMaxCalls);\n    return new _promise2.default(function (resolve) {\n      resolve(_this3.prepareRequest(queue).then(function (payload) {\n        return _this3.submitHttpRequest(payload).then(function (res) {\n          return _this3.handleHttpSuccess(res);\n        });\n      }).catch(function (reason) {\n        if (reason instanceof _webexHttpError2.default) {\n          return _this3.handleHttpError(reason);\n        }\n\n        return _promise2.default.all(queue.map(function (item) {\n          return _this3.getDeferredForRequest(item).then(function (defer) {\n            defer.reject(reason);\n          });\n        }));\n      }));\n    }).catch(function (reason) {\n      _this3.logger.error(process.env.NODE_ENV === 'production' ? reason : reason.stack);\n\n      return _promise2.default.reject(reason);\n    });\n  },\n\n  /**\n   * Performs any final transforms on the queue before submitting it to the API\n   * Intended to be overridden\n   * @param {Object|Array} queue\n   * @returns {Promise<Object>}\n   */\n  prepareRequest: function prepareRequest(queue) {\n    return _promise2.default.resolve(queue);\n  },\n\n  /**\n   * Submits the prepared request body to the API.\n   * This method *must* be overridden\n   * @param {Object} payload\n   * @returns {Promise<HttpResponseObject>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  submitHttpRequest: function submitHttpRequest(payload) {\n    throw new Error('request() must be implemented');\n  },\n\n  /**\n   * Actions taken when the http request returns a success\n   * Intended to be overridden\n   * @param {Promise<HttpResponseObject>} res\n   * @returns {Promise<undefined>}\n   */\n  handleHttpSuccess: function handleHttpSuccess(res) {\n    var _this4 = this;\n\n    return _promise2.default.all((res.body && res.body.items || res.body).map(function (item) {\n      return _this4.acceptItem(item);\n    }));\n  },\n\n  /**\n   * Actions taken when the http request returns a failure. Typically, this\n   * means failing the entire queue, but could be overridden in some\n   * implementations to e.g. reenqueue.\n   * Intended to be overridden\n   * @param {WebexHttpError} reason\n   * @returns {Promise<undefined>}\n   */\n  handleHttpError: function handleHttpError(reason) {\n    var _this5 = this;\n\n    if (reason instanceof _webexHttpError2.default) {\n      if ((0, _has3.default)(reason, 'options.body.map')) {\n        return _promise2.default.all(reason.options.body.map(function (item) {\n          return _this5.getDeferredForRequest(item).then(function (defer) {\n            defer.reject(reason);\n          });\n        }));\n      }\n    }\n\n    this.logger.error('http error handler called without a WebexHttpError object', reason);\n    return _promise2.default.reject(reason);\n  },\n\n  /**\n   * Determines if the item succeeded or failed and delegates accordingly\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  acceptItem: function acceptItem(item) {\n    var _this6 = this;\n\n    return this.didItemFail(item).then(function (didFail) {\n      if (didFail) {\n        return _this6.handleItemFailure(item);\n      }\n\n      return _this6.handleItemSuccess(item);\n    });\n  },\n\n  /**\n   * Indicates if the specified response item implies a success or a failure\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<Boolean>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  didItemFail: function didItemFail(item) {\n    return _promise2.default.resolve(false);\n  },\n\n  /**\n   * Finds the Defer for the specified item and rejects its promise\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  handleItemFailure: function handleItemFailure(item) {\n    return this.getDeferredForResponse(item).then(function (defer) {\n      defer.reject(item);\n    });\n  },\n\n  /**\n   * Finds the Defer for the specified item and resolves its promise\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  handleItemSuccess: function handleItemSuccess(item) {\n    return this.getDeferredForResponse(item).then(function (defer) {\n      defer.resolve(item);\n    });\n  },\n\n  /**\n   * Returns the Deferred for the specified request item\n   * @param {Object} item\n   * @returns {Promise<Defer>}\n   */\n  getDeferredForRequest: function getDeferredForRequest(item) {\n    var _this7 = this;\n\n    return this.fingerprintRequest(item).then(function (idx) {\n      var defer = _this7.deferreds.get(idx);\n      /* istanbul ignore if */\n\n\n      if (!defer) {\n        throw new Error('Could not find pending request for received response');\n      }\n\n      return defer;\n    });\n  },\n\n  /**\n   * Returns the Deferred for the specified response item\n   * @param {Object} item\n   * @returns {Promise<Defer>}\n   */\n  getDeferredForResponse: function getDeferredForResponse(item) {\n    var _this8 = this;\n\n    return this.fingerprintResponse(item).then(function (idx) {\n      var defer = _this8.deferreds.get(idx);\n      /* istanbul ignore if */\n\n\n      if (!defer) {\n        throw new Error('Could not find pending request for received response');\n      }\n\n      return defer;\n    });\n  },\n\n  /**\n   * Generates a unique identifier for the item in a request payload\n   * Intended to be overridden\n   * Note that overrides must return a primitive.\n   * @param {Object} item\n   * @returns {Promise<primitive>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  fingerprintRequest: function fingerprintRequest(item) {\n    throw new Error('fingerprintRequest() must be implemented');\n  },\n\n  /**\n   * Generates a unique identifier for the item in a response payload\n   * Intended to be overridden\n   * Note that overrides must return a primitive.\n   * @param {Object} item\n   * @returns {Promise<primitive>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  fingerprintResponse: function fingerprintResponse(item) {\n    throw new Error('fingerprintResponse() must be implemented');\n  },\n  version: '1.80.172'\n});\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nexports.default = Batcher;","map":{"version":3,"sources":["batcher.js"],"names":["Batcher","session","deferreds","type","default","queue","derived","bounce","fn","maxCalls","maxWait","batcherMaxWait","request","defer","Defer","enqueue","prepareItem","executeQueue","resolve","reason","WebexHttpError","process","prepareRequest","submitHttpRequest","handleHttpSuccess","res","handleHttpError","acceptItem","didItemFail","handleItemFailure","handleItemSuccess","getDeferredForRequest","getDeferredForResponse","fingerprintRequest","fingerprintResponse"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {has} from 'lodash';\nimport WebexPlugin from './webex-plugin';\nimport {\n  cappedDebounce,\n  Defer,\n  tap\n} from '@webex/common';\nimport WebexHttpError from './webex-http-error';\n\n/**\n * Base class for coalescing requests to batched APIs\n * @class Batcher\n */\nconst Batcher = WebexPlugin.extend({\n  session: {\n    deferreds: {\n      type: 'object',\n      default() {\n        return new Map();\n      }\n    },\n    queue: {\n      type: 'array',\n      default() {\n        return [];\n      }\n    }\n  },\n\n  derived: {\n    bounce: {\n      fn() {\n        return cappedDebounce((...args) => this.executeQueue(...args), this.config.batcherWait, {\n          maxCalls: this.config.batcherMaxCalls,\n          maxWait: this.config.batcherMaxWait\n        });\n      }\n    }\n  },\n\n  /**\n   * Requests an item from a batched API\n   * @param {Object} item\n   * @returns {Promise<mixed>}\n   */\n  request(item) {\n    // So far, I can't find a way to avoid three layers of nesting here.\n    /* eslint max-nested-callbacks: [0] */\n    const defer = new Defer();\n\n    this.fingerprintRequest(item)\n      .then((idx) => {\n        if (this.deferreds.has(idx)) {\n          defer.resolve(this.deferreds.get(idx).promise);\n\n          return;\n        }\n        this.deferreds.set(idx, defer);\n        this.prepareItem(item)\n          .then((req) => {\n            defer.promise = defer.promise\n              .then(tap(() => this.deferreds.delete(idx)))\n              .catch((reason) => {\n                this.deferreds.delete(idx);\n\n                return Promise.reject(reason);\n              });\n\n            this.enqueue(req)\n              .then(() => this.bounce())\n              .catch((reason) => defer.reject(reason));\n          })\n          .catch((reason) => defer.reject(reason));\n      })\n      .catch((reason) => defer.reject(reason));\n\n    return defer.promise;\n  },\n\n  /**\n   * Adds an item to the queue.\n   * Intended to be overridden\n   * @param {mixed} req\n   * @returns {Promise<undefined>}\n   */\n  enqueue(req) {\n    this.queue.push(req);\n\n    return Promise.resolve();\n  },\n\n  /**\n   * Transform the item before adding it to the queue\n   * Intended to be overridden\n   * @param {mixed} item\n   * @returns {Promise<mixed>}\n   */\n  prepareItem(item) {\n    return Promise.resolve(item);\n  },\n\n  /**\n   * Detaches the current queue, does any appropriate transforms, and submits it\n   * to the API.\n   * @returns {Promise<undefined>}\n   */\n  executeQueue() {\n    const queue = this.queue.splice(0, this.config.batcherMaxCalls);\n\n    return new Promise((resolve) => {\n      resolve(this.prepareRequest(queue)\n        .then((payload) => this.submitHttpRequest(payload)\n          .then((res) => this.handleHttpSuccess(res)))\n        .catch((reason) => {\n          if (reason instanceof WebexHttpError) {\n            return this.handleHttpError(reason);\n          }\n\n          return Promise.all(queue.map((item) => this.getDeferredForRequest(item)\n            .then((defer) => {\n              defer.reject(reason);\n            })));\n        }));\n    })\n      .catch((reason) => {\n        this.logger.error(process.env.NODE_ENV === 'production' ? reason : reason.stack);\n\n        return Promise.reject(reason);\n      });\n  },\n\n  /**\n   * Performs any final transforms on the queue before submitting it to the API\n   * Intended to be overridden\n   * @param {Object|Array} queue\n   * @returns {Promise<Object>}\n   */\n  prepareRequest(queue) {\n    return Promise.resolve(queue);\n  },\n\n  /**\n   * Submits the prepared request body to the API.\n   * This method *must* be overridden\n   * @param {Object} payload\n   * @returns {Promise<HttpResponseObject>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  submitHttpRequest(payload) {\n    throw new Error('request() must be implemented');\n  },\n\n  /**\n   * Actions taken when the http request returns a success\n   * Intended to be overridden\n   * @param {Promise<HttpResponseObject>} res\n   * @returns {Promise<undefined>}\n   */\n  handleHttpSuccess(res) {\n    return Promise.all((res.body && res.body.items || res.body).map((item) => this.acceptItem(item)));\n  },\n\n  /**\n   * Actions taken when the http request returns a failure. Typically, this\n   * means failing the entire queue, but could be overridden in some\n   * implementations to e.g. reenqueue.\n   * Intended to be overridden\n   * @param {WebexHttpError} reason\n   * @returns {Promise<undefined>}\n   */\n  handleHttpError(reason) {\n    if (reason instanceof WebexHttpError) {\n      if (has(reason, 'options.body.map')) {\n        return Promise.all(reason.options.body.map((item) => this.getDeferredForRequest(item)\n          .then((defer) => {\n            defer.reject(reason);\n          })));\n      }\n    }\n    this.logger.error('http error handler called without a WebexHttpError object', reason);\n\n    return Promise.reject(reason);\n  },\n\n  /**\n   * Determines if the item succeeded or failed and delegates accordingly\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  acceptItem(item) {\n    return this.didItemFail(item)\n      .then((didFail) => {\n        if (didFail) {\n          return this.handleItemFailure(item);\n        }\n\n        return this.handleItemSuccess(item);\n      });\n  },\n\n  /**\n   * Indicates if the specified response item implies a success or a failure\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<Boolean>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  didItemFail(item) {\n    return Promise.resolve(false);\n  },\n\n  /**\n   * Finds the Defer for the specified item and rejects its promise\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  handleItemFailure(item) {\n    return this.getDeferredForResponse(item)\n      .then((defer) => {\n        defer.reject(item);\n      });\n  },\n\n  /**\n   * Finds the Defer for the specified item and resolves its promise\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  handleItemSuccess(item) {\n    return this.getDeferredForResponse(item)\n      .then((defer) => {\n        defer.resolve(item);\n      });\n  },\n\n  /**\n   * Returns the Deferred for the specified request item\n   * @param {Object} item\n   * @returns {Promise<Defer>}\n   */\n  getDeferredForRequest(item) {\n    return this.fingerprintRequest(item)\n      .then((idx) => {\n        const defer = this.deferreds.get(idx);\n\n        /* istanbul ignore if */\n        if (!defer) {\n          throw new Error('Could not find pending request for received response');\n        }\n\n        return defer;\n      });\n  },\n\n  /**\n   * Returns the Deferred for the specified response item\n   * @param {Object} item\n   * @returns {Promise<Defer>}\n   */\n  getDeferredForResponse(item) {\n    return this.fingerprintResponse(item)\n      .then((idx) => {\n        const defer = this.deferreds.get(idx);\n\n        /* istanbul ignore if */\n        if (!defer) {\n          throw new Error('Could not find pending request for received response');\n        }\n\n        return defer;\n      });\n  },\n\n  /**\n   * Generates a unique identifier for the item in a request payload\n   * Intended to be overridden\n   * Note that overrides must return a primitive.\n   * @param {Object} item\n   * @returns {Promise<primitive>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  fingerprintRequest(item) {\n    throw new Error('fingerprintRequest() must be implemented');\n  },\n\n  /**\n   * Generates a unique identifier for the item in a response payload\n   * Intended to be overridden\n   * Note that overrides must return a primitive.\n   * @param {Object} item\n   * @returns {Promise<primitive>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  fingerprintResponse(item) {\n    throw new Error('fingerprintResponse() must be implemented');\n  }\n});\n\nexport default Batcher;\n"]},"metadata":{},"sourceType":"script"}