{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _pick2 = require('lodash/pick');\n\nvar _pick3 = _interopRequireDefault(_pick2);\n\nvar _dec, _desc, _value, _obj;\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar _common = require('@webex/common');\n\nvar _commonTimers = require('@webex/common-timers');\n\nvar _webexHttpError = require('../webex-http-error');\n\nvar _webexHttpError2 = _interopRequireDefault(_webexHttpError);\n\nvar _webexPlugin = require('../webex-plugin');\n\nvar _webexPlugin2 = _interopRequireDefault(_webexPlugin);\n\nvar _scope = require('./scope');\n\nvar _grantErrors = require('./grant-errors');\n\nvar _grantErrors2 = _interopRequireDefault(_grantErrors);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n/* eslint-disable camelcase */\n\n/**\n * Parse response from CI and converts to structured error when appropriate\n * @param {WebexHttpError} res\n * @private\n * @returns {GrantError}\n */\n\n\nfunction processGrantError(res) {\n  if (res.statusCode !== 400) {\n    return _promise2.default.reject(res);\n  }\n\n  var ErrorConstructor = _grantErrors2.default.select(res.body.error);\n\n  if (ErrorConstructor === _grantErrors.OAuthError && res instanceof _webexHttpError2.default) {\n    return _promise2.default.reject(res);\n  }\n\n  if (!ErrorConstructor) {\n    return _promise2.default.reject(res);\n  }\n\n  return _promise2.default.reject(new ErrorConstructor(res._res || res));\n}\n/**\n * @class\n */\n\n\nvar Token = _webexPlugin2.default.extend((_dec = (0, _common.oneFlight)({\n  keyFactory: function keyFactory(scope) {\n    return scope;\n  }\n}), (_obj = {\n  derived: {\n    /**\n     * Indicates if this token can be used in an auth header. `true` iff\n     * {@link Token#access_token} is defined and {@link Token#isExpired} is\n     * false.\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canAuthorize: {\n      deps: ['access_token', 'isExpired'],\n      fn: function fn() {\n        return !!this.access_token && !this.isExpired;\n      }\n    },\n\n    /**\n     * Indicates that this token can be downscoped. `true` iff\n     * {@link config.credentials.client_id} is defined and if\n     * {@link Token#canAuthorize} is true\n     *\n     * Note: since {@link config} is not evented, we can't listen for changes to\n     * {@link config.credentials.client_id}. As such,\n     * {@link config.credentials.client_id} must always be set before\n     * instantiating a {@link Token}\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canDownscope: {\n      deps: ['canAuthorize'],\n      fn: function fn() {\n        return this.canAuthorize && !!this.config.client_id;\n      }\n    },\n\n    /**\n     * Indicates if this token can be refreshed. `true` iff\n     * {@link Token@refresh_token} is defined and\n     * {@link config.credentials.refreshCallback()} is defined\n     *\n     * Note: since {@link config} is not evented, we can't listen for changes to\n     * {@link config.credentials.refreshCallback()}. As such,\n     * {@link config.credentials.refreshCallback()} must always be set before\n     * instantiating a {@link Token}\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canRefresh: {\n      deps: ['refresh_token'],\n      fn: function fn() {\n        if (_common.inBrowser) {\n          return !!this.refresh_token && !!this.config.refreshCallback;\n        }\n\n        return !!this.refresh_token && !!this.config.client_secret;\n      }\n    },\n\n    /**\n     * Indicates if this `Token` is expired. `true` iff {@link Token#expires} is\n     * defined and is less than {@link Date.now()}.\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    isExpired: {\n      deps: ['expires', '_isExpired'],\n      fn: function fn() {\n        // in order to avoid setting `cache:false`, we'll use a private property\n        // and a timer rather than comparing to `Date.now()`;\n        return !!this.expires && this._isExpired;\n      }\n    },\n\n    /**\n     * Cache for toString()\n     * @instance\n     * @memberof Token\n     * @private\n     * @readonly\n     * @type {string}\n     */\n    _string: {\n      deps: ['access_token', 'token_type'],\n      fn: function fn() {\n        if (!this.access_token || !this.token_type) {\n          return '';\n        }\n\n        return this.token_type + ' ' + this.access_token;\n      }\n    }\n  },\n  namespace: 'Credentials',\n  props: {\n    /**\n     * Used for indexing in the credentials userTokens collection\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {string}\n     */\n    scope: 'string',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    access_token: 'string',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    expires: 'number',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    expires_in: 'number',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    refresh_token: 'string',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    refresh_token_expires: 'number',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    refresh_token_expires_in: 'number',\n\n    /**\n     * @default \"Bearer\"\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    token_type: {\n      default: 'Bearer',\n      type: 'string'\n    }\n  },\n  session: {\n    /**\n     * Used by {@link Token#isExpired} to avoid doing a Date comparison.\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {boolean}\n     */\n    _isExpired: {\n      default: false,\n      type: 'boolean'\n    },\n\n    /**\n     * Handle to the previous token that we'll revoke when we refresh this\n     * token. The idea is to keep allow two valid tokens when a refresh occurs;\n     * we don't want revoke a token that's in the middle of being used, so when\n     * we do a token refresh, we won't revoke the token being refreshed, but\n     * we'll revoke the previous one.\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {Object}\n     */\n    previousToken: {\n      type: 'state'\n    }\n  },\n\n  /**\n   * Uses this token to request a new Token with a subset of this Token's scopes\n   * @instance\n   * @memberof Token\n   * @param {string} scope\n   * @returns {Promise<Token>}\n   */\n  downscope: function downscope(scope) {\n    var _this = this;\n\n    this.logger.info('token: downscoping token to ' + scope);\n\n    if (this.isExpired) {\n      this.logger.info('token: request received to downscope expired access_token');\n      return _promise2.default.reject(new Error('cannot downscope expired access token'));\n    }\n\n    if (!this.canDownscope) {\n      if (this.config.client_id) {\n        this.logger.info('token: request received to downscope invalid access_token');\n      } else {\n        this.logger.trace('token: cannot downscope without client_id');\n      }\n\n      return _promise2.default.reject(new Error('cannot downscope access token'));\n    } // Since we're going to use scope as the index in our token collection, it's\n    // important scopes are always deterministically specified.\n\n\n    if (scope) {\n      scope = (0, _scope.sortScope)(scope);\n    } // Ideally, we could depend on the service to communicate this error, but\n    // all we get is \"invalid scope\", which, to the lay person, implies\n    // something wrong with *one* of the scopes, not the whole thing.\n\n\n    if (scope === (0, _scope.sortScope)(this.config.scope)) {\n      return _promise2.default.reject(new Error('token: scope reduction requires a reduced scope'));\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      uri: this.config.tokenUrl,\n      addAuthHeader: false,\n      form: {\n        grant_type: 'urn:cisco:oauth:grant-type:scope-reduction',\n        token: this.access_token,\n        scope: scope,\n        client_id: this.config.client_id\n      }\n    }).then(function (res) {\n      _this.logger.info('token: downscoped token to ' + scope);\n\n      return new Token((0, _assign2.default)(res.body, {\n        scope: scope\n      }), {\n        parent: _this.parent\n      });\n    });\n  },\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof Token\n   * @param {Object} [attrs={}]\n   * @param {Object} [options={}]\n   * @see {@link WebexPlugin#initialize()}\n   * @returns {Token}\n   */\n  initialize: function initialize() {\n    var _this2 = this;\n\n    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _apply2.default)(_webexPlugin2.default.prototype.initialize, this, [attrs, options]);\n\n    if (typeof attrs === 'string') {\n      this.access_token = attrs;\n    }\n\n    if (!this.access_token) {\n      throw new Error('`access_token` is required');\n    } // We don't want the derived property `isExpired` to need {cache:false}, so\n    // we'll set up a timer the runs when this token should expire.\n\n\n    if (this.expires) {\n      if (this.expires < Date.now()) {\n        this._isExpired = true;\n      } else {\n        (0, _commonTimers.safeSetTimeout)(function () {\n          _this2._isExpired = true;\n        }, this.expires - Date.now());\n      }\n    }\n  },\n\n  /**\n   * Refreshes this Token. Relies on\n   * {@link config.credentials.refreshCallback()}\n   * @instance\n   * @memberof Token\n   * @returns {Promise<Token>}\n   */\n  refresh: function refresh() {\n    var _this3 = this;\n\n    if (!this.canRefresh) {\n      throw new Error('Not enough information available to refresh this access token');\n    }\n\n    var promise = void 0;\n\n    if (_common.inBrowser) {\n      if (!this.config.refreshCallback) {\n        throw new Error('Cannot refresh access token without refreshCallback');\n      }\n\n      promise = _promise2.default.resolve(this.config.refreshCallback(this.webex, this));\n    }\n\n    return (promise || this.webex.request({\n      method: 'POST',\n      uri: this.config.tokenUrl,\n      form: {\n        grant_type: 'refresh_token',\n        redirect_uri: this.config.redirect_uri,\n        refresh_token: this.refresh_token\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n    }).then(function (res) {\n      return res.body;\n    })).then(function (obj) {\n      if (!obj) {\n        throw new Error('token: refreshCallback() did not produce an object');\n      } // If the authentication server did not send back a refresh token, copy\n      // the current refresh token and related values to the response (note:\n      // at time of implementation, CI never sends a new refresh token)\n\n\n      if (!obj.refresh_token) {\n        (0, _assign2.default)(obj, (0, _pick3.default)(_this3, 'refresh_token', 'refresh_token_expires', 'refresh_token_expires_in'));\n      } // If the new token is the same as the previous token, then we may have\n      // found a bug in CI; log the details and reject the Promise\n\n\n      if (_this3.access_token === obj.access_token) {\n        _this3.logger.error('token: new token matches current token'); // log the tokens if it is not production\n\n\n        if (process.env.NODE_ENV !== 'production') {\n          _this3.logger.error('token: current token:', _this3.access_token);\n\n          _this3.logger.error('token: new token:', obj.access_token);\n        }\n\n        return _promise2.default.reject(new Error('new token matches current token'));\n      }\n\n      if (_this3.previousToken) {\n        _this3.previousToken.revoke();\n\n        _this3.unset('previousToken');\n      }\n\n      obj.previousToken = _this3;\n      obj.scope = _this3.scope;\n      return new Token(obj, {\n        parent: _this3.parent\n      });\n    }).catch(processGrantError);\n  },\n\n  /**\n   * Revokes this token and unsets its local properties\n   * @instance\n   * @memberof Token\n   * @returns {Promise}\n   */\n  revoke: function revoke() {\n    var _this4 = this;\n\n    if (this.isExpired) {\n      this.logger.info('token: already expired, not making making revocation request');\n      return _promise2.default.resolve();\n    }\n\n    if (!this.canAuthorize) {\n      this.logger.info('token: no longer valid, not making revocation request');\n      return _promise2.default.resolve();\n    } // FIXME we need to use the user token revocation endpoint to revoke a token\n    // without a client_secret, but it doesn't current support using a token to\n    // revoke itself\n    // Note: I'm not making a canRevoke property because there should be changes\n    // coming to the user token revocation endpoint that allow us to do this\n    // correctly.\n\n\n    if (!this.config.client_secret) {\n      this.logger.info('token: no client secret available, not making revocation request');\n      return _promise2.default.resolve();\n    }\n\n    this.logger.info('token: revoking access token');\n    return this.webex.request({\n      method: 'POST',\n      uri: this.config.revokeUrl,\n      form: {\n        token: this.access_token,\n        token_type_hint: 'access_token'\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n    }).then(function () {\n      _this4.unset(['access_token', 'expires', 'expires_in', 'token_type']);\n\n      _this4.logger.info('token: access token revoked');\n    }).catch(processGrantError);\n  },\n  set: function set() {\n    // eslint-disable-next-line prefer-const\n    var _filterSetParameters = this._filterSetParameters.apply(this, arguments),\n        _filterSetParameters2 = (0, _slicedToArray3.default)(_filterSetParameters, 2),\n        attrs = _filterSetParameters2[0],\n        options = _filterSetParameters2[1];\n\n    if (!attrs.token_type && attrs.access_token && attrs.access_token.includes(' ')) {\n      var _attrs$access_token$s = attrs.access_token.split(' '),\n          _attrs$access_token$s2 = (0, _slicedToArray3.default)(_attrs$access_token$s, 2),\n          token_type = _attrs$access_token$s2[0],\n          access_token = _attrs$access_token$s2[1];\n\n      attrs = (0, _assign2.default)({}, attrs, {\n        access_token: access_token,\n        token_type: token_type\n      });\n    }\n\n    var now = Date.now();\n\n    if (!attrs.expires && attrs.expires_in) {\n      attrs.expires = now + attrs.expires_in * 1000;\n    }\n\n    if (!attrs.refresh_token_expires && attrs.refresh_token_expires_in) {\n      attrs.refresh_token_expires = now + attrs.refresh_token_expires_in * 1000;\n    }\n\n    if (attrs.scope) {\n      attrs.scope = (0, _scope.sortScope)(attrs.scope);\n    }\n\n    return (0, _apply2.default)(_webexPlugin2.default.prototype.set, this, [attrs, options]);\n  },\n\n  /**\n   * Renders the token object as an HTTP Header Value\n   * @instance\n   * @memberof Token\n   * @returns {string}\n   * @see {@link Object#toString()}\n   */\n  toString: function toString() {\n    if (!this._string) {\n      throw new Error('cannot stringify Token');\n    }\n\n    return this._string;\n  },\n\n  /**\n   * Uses a non-producation api to return information about this token. This\n   * method is primarily for tests and will throw if NODE_ENV === production\n   * @instance\n   * @memberof Token\n   * @private\n   * @returns {Promise}\n   */\n  validate: function validate() {\n    var _this5 = this;\n\n    if (process.env.NODE_ENV === 'production') {\n      throw new Error('Token#validate() must not be used in production');\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      service: 'conversation',\n      resource: 'users/validateAuthToken',\n      body: {\n        token: this.access_token\n      }\n    }).catch(function (reason) {\n      if ('statusCode' in reason) {\n        return _promise2.default.reject(reason);\n      }\n\n      _this5.logger.info('REMINDER: If you\\'re investigating a network error here, it\\'s normal'); // If we got an error that isn't a WebexHttpError, assume the problem is\n      // that we don't have the wdm plugin loaded and service/resource isn't\n      // a valid means of identifying a request.\n\n\n      var convApi = process.env.CONVERSATION_SERVICE || process.env.CONVERSATION_SERVICE_URL || 'https://conv-a.wbx2.com/conversation/api/v1';\n      return _this5.webex.request({\n        method: 'POST',\n        uri: convApi + '/users/validateAuthToken',\n        body: {\n          token: _this5.access_token\n        },\n        headers: {\n          authorization: 'Bearer ' + _this5.access_token\n        }\n      });\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n  version: '1.80.172'\n}, (_applyDecoratedDescriptor(_obj, 'downscope', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'downscope'), _obj), _applyDecoratedDescriptor(_obj, 'refresh', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'refresh'), _obj), _applyDecoratedDescriptor(_obj, 'revoke', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'revoke'), _obj)), _obj)));\n\nexports.default = Token;","map":{"version":3,"sources":["token.js"],"names":["res","ErrorConstructor","grantErrors","OAuthError","WebexHttpError","Token","derived","canAuthorize","deps","fn","canDownscope","canRefresh","inBrowser","isExpired","_string","namespace","props","scope","access_token","expires","expires_in","refresh_token","refresh_token_expires","refresh_token_expires_in","token_type","default","type","session","_isExpired","previousToken","keyFactory","downscope","method","uri","addAuthHeader","form","grant_type","token","client_id","parent","initialize","attrs","options","WebexPlugin","Date","oneFlight","refresh","promise","redirect_uri","auth","user","pass","sendImmediately","shouldRefreshAccessToken","obj","process","revoke","token_type_hint","set","now","toString","validate","service","resource","body","convApi","headers","authorization"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {pick} from 'lodash';\nimport {inBrowser, oneFlight} from '@webex/common';\nimport {safeSetTimeout} from '@webex/common-timers';\nimport WebexHttpError from '../webex-http-error';\nimport WebexPlugin from '../webex-plugin';\nimport {sortScope} from './scope';\nimport grantErrors, {OAuthError} from './grant-errors';\n\n/* eslint-disable camelcase */\n\n/**\n * Parse response from CI and converts to structured error when appropriate\n * @param {WebexHttpError} res\n * @private\n * @returns {GrantError}\n */\nfunction processGrantError(res) {\n  if (res.statusCode !== 400) {\n    return Promise.reject(res);\n  }\n\n  const ErrorConstructor = grantErrors.select(res.body.error);\n\n  if (ErrorConstructor === OAuthError && res instanceof WebexHttpError) {\n    return Promise.reject(res);\n  }\n  if (!ErrorConstructor) {\n    return Promise.reject(res);\n  }\n\n  return Promise.reject(new ErrorConstructor(res._res || res));\n}\n\n/**\n * @class\n */\nconst Token = WebexPlugin.extend({\n  derived: {\n    /**\n     * Indicates if this token can be used in an auth header. `true` iff\n     * {@link Token#access_token} is defined and {@link Token#isExpired} is\n     * false.\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canAuthorize: {\n      deps: ['access_token', 'isExpired'],\n      fn() {\n        return !!this.access_token && !this.isExpired;\n      }\n    },\n\n    /**\n     * Indicates that this token can be downscoped. `true` iff\n     * {@link config.credentials.client_id} is defined and if\n     * {@link Token#canAuthorize} is true\n     *\n     * Note: since {@link config} is not evented, we can't listen for changes to\n     * {@link config.credentials.client_id}. As such,\n     * {@link config.credentials.client_id} must always be set before\n     * instantiating a {@link Token}\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canDownscope: {\n      deps: ['canAuthorize'],\n      fn() {\n        return this.canAuthorize && !!this.config.client_id;\n      }\n    },\n\n    /**\n     * Indicates if this token can be refreshed. `true` iff\n     * {@link Token@refresh_token} is defined and\n     * {@link config.credentials.refreshCallback()} is defined\n     *\n     * Note: since {@link config} is not evented, we can't listen for changes to\n     * {@link config.credentials.refreshCallback()}. As such,\n     * {@link config.credentials.refreshCallback()} must always be set before\n     * instantiating a {@link Token}\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canRefresh: {\n      deps: ['refresh_token'],\n      fn() {\n        if (inBrowser) {\n          return !!this.refresh_token && !!this.config.refreshCallback;\n        }\n\n        return !!this.refresh_token && !!this.config.client_secret;\n      }\n    },\n\n    /**\n     * Indicates if this `Token` is expired. `true` iff {@link Token#expires} is\n     * defined and is less than {@link Date.now()}.\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    isExpired: {\n      deps: ['expires', '_isExpired'],\n      fn() {\n        // in order to avoid setting `cache:false`, we'll use a private property\n        // and a timer rather than comparing to `Date.now()`;\n        return !!this.expires && this._isExpired;\n      }\n    },\n\n    /**\n     * Cache for toString()\n     * @instance\n     * @memberof Token\n     * @private\n     * @readonly\n     * @type {string}\n     */\n    _string: {\n      deps: ['access_token', 'token_type'],\n      fn() {\n        if (!this.access_token || !this.token_type) {\n          return '';\n        }\n\n        return `${this.token_type} ${this.access_token}`;\n      }\n    }\n  },\n\n  namespace: 'Credentials',\n\n  props: {\n    /**\n     * Used for indexing in the credentials userTokens collection\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {string}\n     */\n    scope: 'string',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    access_token: 'string',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    expires: 'number',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    expires_in: 'number',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    refresh_token: 'string',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    refresh_token_expires: 'number',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    refresh_token_expires_in: 'number',\n    /**\n     * @default \"Bearer\"\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    token_type: {\n      default: 'Bearer',\n      type: 'string'\n    }\n  },\n\n  session: {\n    /**\n     * Used by {@link Token#isExpired} to avoid doing a Date comparison.\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {boolean}\n     */\n    _isExpired: {\n      default: false,\n      type: 'boolean'\n    },\n    /**\n     * Handle to the previous token that we'll revoke when we refresh this\n     * token. The idea is to keep allow two valid tokens when a refresh occurs;\n     * we don't want revoke a token that's in the middle of being used, so when\n     * we do a token refresh, we won't revoke the token being refreshed, but\n     * we'll revoke the previous one.\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {Object}\n     */\n    previousToken: {\n      type: 'state'\n    }\n  },\n\n  @oneFlight({\n    keyFactory(scope) {\n      return scope;\n    }\n  })\n  /**\n   * Uses this token to request a new Token with a subset of this Token's scopes\n   * @instance\n   * @memberof Token\n   * @param {string} scope\n   * @returns {Promise<Token>}\n   */\n  downscope(scope) {\n    this.logger.info(`token: downscoping token to ${scope}`);\n\n    if (this.isExpired) {\n      this.logger.info('token: request received to downscope expired access_token');\n\n      return Promise.reject(new Error('cannot downscope expired access token'));\n    }\n\n    if (!this.canDownscope) {\n      if (this.config.client_id) {\n        this.logger.info('token: request received to downscope invalid access_token');\n      }\n      else {\n        this.logger.trace('token: cannot downscope without client_id');\n      }\n\n      return Promise.reject(new Error('cannot downscope access token'));\n    }\n\n    // Since we're going to use scope as the index in our token collection, it's\n    // important scopes are always deterministically specified.\n    if (scope) {\n      scope = sortScope(scope);\n    }\n\n    // Ideally, we could depend on the service to communicate this error, but\n    // all we get is \"invalid scope\", which, to the lay person, implies\n    // something wrong with *one* of the scopes, not the whole thing.\n    if (scope === sortScope(this.config.scope)) {\n      return Promise.reject(new Error('token: scope reduction requires a reduced scope'));\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      uri: this.config.tokenUrl,\n      addAuthHeader: false,\n      form: {\n        grant_type: 'urn:cisco:oauth:grant-type:scope-reduction',\n        token: this.access_token,\n        scope,\n        client_id: this.config.client_id\n      }\n    })\n      .then((res) => {\n        this.logger.info(`token: downscoped token to ${scope}`);\n\n        return new Token(Object.assign(res.body, {scope}), {parent: this.parent});\n      });\n  },\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof Token\n   * @param {Object} [attrs={}]\n   * @param {Object} [options={}]\n   * @see {@link WebexPlugin#initialize()}\n   * @returns {Token}\n   */\n  initialize(attrs = {}, options = {}) {\n    Reflect.apply(WebexPlugin.prototype.initialize, this, [attrs, options]);\n\n    if (typeof attrs === 'string') {\n      this.access_token = attrs;\n    }\n\n    if (!this.access_token) {\n      throw new Error('`access_token` is required');\n    }\n\n    // We don't want the derived property `isExpired` to need {cache:false}, so\n    // we'll set up a timer the runs when this token should expire.\n    if (this.expires) {\n      if (this.expires < Date.now()) {\n        this._isExpired = true;\n      }\n      else {\n        safeSetTimeout(() => {\n          this._isExpired = true;\n        }, this.expires - Date.now());\n      }\n    }\n  },\n\n  @oneFlight\n  /**\n   * Refreshes this Token. Relies on\n   * {@link config.credentials.refreshCallback()}\n   * @instance\n   * @memberof Token\n   * @returns {Promise<Token>}\n   */\n  refresh() {\n    if (!this.canRefresh) {\n      throw new Error('Not enough information available to refresh this access token');\n    }\n\n    let promise;\n\n    if (inBrowser) {\n      if (!this.config.refreshCallback) {\n        throw new Error('Cannot refresh access token without refreshCallback');\n      }\n\n      promise = Promise.resolve(this.config.refreshCallback(this.webex, this));\n    }\n\n    return (promise || this.webex.request({\n      method: 'POST',\n      uri: this.config.tokenUrl,\n      form: {\n        grant_type: 'refresh_token',\n        redirect_uri: this.config.redirect_uri,\n        refresh_token: this.refresh_token\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n    })\n      .then((res) => res.body))\n      .then((obj) => {\n        if (!obj) {\n          throw new Error('token: refreshCallback() did not produce an object');\n        }\n        // If the authentication server did not send back a refresh token, copy\n        // the current refresh token and related values to the response (note:\n        // at time of implementation, CI never sends a new refresh token)\n        if (!obj.refresh_token) {\n          Object.assign(obj, pick(this, 'refresh_token', 'refresh_token_expires', 'refresh_token_expires_in'));\n        }\n\n        // If the new token is the same as the previous token, then we may have\n        // found a bug in CI; log the details and reject the Promise\n        if (this.access_token === obj.access_token) {\n          this.logger.error('token: new token matches current token');\n          // log the tokens if it is not production\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error('token: current token:', this.access_token);\n            this.logger.error('token: new token:', obj.access_token);\n          }\n\n          return Promise.reject(new Error('new token matches current token'));\n        }\n\n        if (this.previousToken) {\n          this.previousToken.revoke();\n          this.unset('previousToken');\n        }\n\n        obj.previousToken = this;\n        obj.scope = this.scope;\n\n        return new Token(obj, {parent: this.parent});\n      })\n      .catch(processGrantError);\n  },\n\n  @oneFlight\n  /**\n   * Revokes this token and unsets its local properties\n   * @instance\n   * @memberof Token\n   * @returns {Promise}\n   */\n  revoke() {\n    if (this.isExpired) {\n      this.logger.info('token: already expired, not making making revocation request');\n\n      return Promise.resolve();\n    }\n\n    if (!this.canAuthorize) {\n      this.logger.info('token: no longer valid, not making revocation request');\n\n      return Promise.resolve();\n    }\n\n    // FIXME we need to use the user token revocation endpoint to revoke a token\n    // without a client_secret, but it doesn't current support using a token to\n    // revoke itself\n    // Note: I'm not making a canRevoke property because there should be changes\n    // coming to the user token revocation endpoint that allow us to do this\n    // correctly.\n    if (!this.config.client_secret) {\n      this.logger.info('token: no client secret available, not making revocation request');\n\n      return Promise.resolve();\n    }\n\n    this.logger.info('token: revoking access token');\n\n    return this.webex.request({\n      method: 'POST',\n      uri: this.config.revokeUrl,\n      form: {\n        token: this.access_token,\n        token_type_hint: 'access_token'\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n    })\n      .then(() => {\n        this.unset([\n          'access_token',\n          'expires',\n          'expires_in',\n          'token_type'\n        ]);\n        this.logger.info('token: access token revoked');\n      })\n      .catch(processGrantError);\n  },\n\n  set(...args) {\n    // eslint-disable-next-line prefer-const\n    let [attrs, options] = this._filterSetParameters(...args);\n\n    if (!attrs.token_type && attrs.access_token && attrs.access_token.includes(' ')) {\n      const [token_type, access_token] = attrs.access_token.split(' ');\n\n      attrs = Object.assign({}, attrs, {access_token, token_type});\n    }\n    const now = Date.now();\n\n    if (!attrs.expires && attrs.expires_in) {\n      attrs.expires = now + attrs.expires_in * 1000;\n    }\n\n    if (!attrs.refresh_token_expires && attrs.refresh_token_expires_in) {\n      attrs.refresh_token_expires = now + attrs.refresh_token_expires_in * 1000;\n    }\n\n    if (attrs.scope) {\n      attrs.scope = sortScope(attrs.scope);\n    }\n\n    return Reflect.apply(WebexPlugin.prototype.set, this, [attrs, options]);\n  },\n\n  /**\n   * Renders the token object as an HTTP Header Value\n   * @instance\n   * @memberof Token\n   * @returns {string}\n   * @see {@link Object#toString()}\n   */\n  toString() {\n    if (!this._string) {\n      throw new Error('cannot stringify Token');\n    }\n\n    return this._string;\n  },\n\n  /**\n   * Uses a non-producation api to return information about this token. This\n   * method is primarily for tests and will throw if NODE_ENV === production\n   * @instance\n   * @memberof Token\n   * @private\n   * @returns {Promise}\n   */\n  validate() {\n    if (process.env.NODE_ENV === 'production') {\n      throw new Error('Token#validate() must not be used in production');\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      service: 'conversation',\n      resource: 'users/validateAuthToken',\n      body: {\n        token: this.access_token\n      }\n    })\n      .catch((reason) => {\n        if ('statusCode' in reason) {\n          return Promise.reject(reason);\n        }\n        this.logger.info('REMINDER: If you\\'re investigating a network error here, it\\'s normal');\n\n        // If we got an error that isn't a WebexHttpError, assume the problem is\n        // that we don't have the wdm plugin loaded and service/resource isn't\n        // a valid means of identifying a request.\n        const convApi = process.env.CONVERSATION_SERVICE || process.env.CONVERSATION_SERVICE_URL || 'https://conv-a.wbx2.com/conversation/api/v1';\n\n        return this.webex.request({\n          method: 'POST',\n          uri: `${convApi}/users/validateAuthToken`,\n          body: {\n            token: this.access_token\n          },\n          headers: {\n            authorization: `Bearer ${this.access_token}`\n          }\n        });\n      })\n      .then((res) => res.body);\n  }\n});\n\nexport default Token;\n"]},"metadata":{},"sourceType":"script"}