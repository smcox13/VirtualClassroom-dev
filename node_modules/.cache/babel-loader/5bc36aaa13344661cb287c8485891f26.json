{"ast":null,"code":"import * as asn1js from \"asn1js\";\nimport { getParametersValue, isEqualBuffer, clearProps } from \"pvutils\";\nimport { getAlgorithmByOID, getCrypto, getEngine } from \"./common.js\";\nimport ResponseData from \"./ResponseData.js\";\nimport AlgorithmIdentifier from \"./AlgorithmIdentifier.js\";\nimport Certificate from \"./Certificate.js\";\nimport CertID from \"./CertID.js\";\nimport RelativeDistinguishedNames from \"./RelativeDistinguishedNames.js\";\nimport CertificateChainValidationEngine from \"./CertificateChainValidationEngine.js\"; //**************************************************************************************\n\n/**\r\n * Class from RFC6960\r\n */\n\nexport default class BasicOCSPResponse {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for BasicOCSPResponse class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {ResponseData}\r\n     * @desc tbsResponseData\r\n     */\n    this.tbsResponseData = getParametersValue(parameters, \"tbsResponseData\", BasicOCSPResponse.defaultValues(\"tbsResponseData\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc signatureAlgorithm\r\n     */\n\n    this.signatureAlgorithm = getParametersValue(parameters, \"signatureAlgorithm\", BasicOCSPResponse.defaultValues(\"signatureAlgorithm\"));\n    /**\r\n     * @type {BitString}\r\n     * @desc signature\r\n     */\n\n    this.signature = getParametersValue(parameters, \"signature\", BasicOCSPResponse.defaultValues(\"signature\"));\n    if (\"certs\" in parameters)\n      /**\r\n       * @type {Array.<Certificate>}\r\n       * @desc certs\r\n       */\n      this.certs = getParametersValue(parameters, \"certs\", BasicOCSPResponse.defaultValues(\"certs\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"tbsResponseData\":\n        return new ResponseData();\n\n      case \"signatureAlgorithm\":\n        return new AlgorithmIdentifier();\n\n      case \"signature\":\n        return new asn1js.BitString();\n\n      case \"certs\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for BasicOCSPResponse class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"type\":\n        {\n          // noinspection OverlyComplexBooleanExpressionJS\n          let comparisonResult = ResponseData.compareWithDefault(\"tbs\", memberValue.tbs) && ResponseData.compareWithDefault(\"responderID\", memberValue.responderID) && ResponseData.compareWithDefault(\"producedAt\", memberValue.producedAt) && ResponseData.compareWithDefault(\"responses\", memberValue.responses);\n          if (\"responseExtensions\" in memberValue) comparisonResult = comparisonResult && ResponseData.compareWithDefault(\"responseExtensions\", memberValue.responseExtensions);\n          return comparisonResult;\n        }\n\n      case \"signatureAlgorithm\":\n        return memberValue.algorithmId === \"\" && \"algorithmParams\" in memberValue === false;\n\n      case \"signature\":\n        return memberValue.isEqual(BasicOCSPResponse.defaultValues(memberName));\n\n      case \"certs\":\n        return memberValue.length === 0;\n\n      default:\n        throw new Error(`Invalid member name for BasicOCSPResponse class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * BasicOCSPResponse       ::= SEQUENCE {\r\n   *    tbsResponseData      ResponseData,\r\n   *    signatureAlgorithm   AlgorithmIdentifier,\r\n   *    signature            BIT STRING,\r\n   *    certs            [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [tbsResponseData]\r\n     * @property {string} [signatureAlgorithm]\r\n     * @property {string} [signature]\r\n     * @property {string} [certs]\r\n     */\n    const names = getParametersValue(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"BasicOCSPResponse\",\n      value: [ResponseData.schema(names.tbsResponseData || {\n        names: {\n          blockName: \"BasicOCSPResponse.tbsResponseData\"\n        }\n      }), AlgorithmIdentifier.schema(names.signatureAlgorithm || {\n        names: {\n          blockName: \"BasicOCSPResponse.signatureAlgorithm\"\n        }\n      }), new asn1js.BitString({\n        name: names.signature || \"BasicOCSPResponse.signature\"\n      }), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.Sequence({\n          value: [new asn1js.Repeated({\n            name: \"BasicOCSPResponse.certs\",\n            value: Certificate.schema(names.certs || {})\n          })]\n        })]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\"BasicOCSPResponse.tbsResponseData\", \"BasicOCSPResponse.signatureAlgorithm\", \"BasicOCSPResponse.signature\", \"BasicOCSPResponse.certs\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, BasicOCSPResponse.schema());\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for BasicOCSPResponse\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.tbsResponseData = new ResponseData({\n      schema: asn1.result[\"BasicOCSPResponse.tbsResponseData\"]\n    });\n    this.signatureAlgorithm = new AlgorithmIdentifier({\n      schema: asn1.result[\"BasicOCSPResponse.signatureAlgorithm\"]\n    });\n    this.signature = asn1.result[\"BasicOCSPResponse.signature\"];\n    if (\"BasicOCSPResponse.certs\" in asn1.result) this.certs = Array.from(asn1.result[\"BasicOCSPResponse.certs\"], element => new Certificate({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n    outputArray.push(this.tbsResponseData.toSchema());\n    outputArray.push(this.signatureAlgorithm.toSchema());\n    outputArray.push(this.signature); //region Create array of certificates\n\n    if (\"certs\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.Sequence({\n          value: Array.from(this.certs, element => element.toSchema())\n        })]\n      }));\n    } //endregion\n    //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      tbsResponseData: this.tbsResponseData.toJSON(),\n      signatureAlgorithm: this.signatureAlgorithm.toJSON(),\n      signature: this.signature.toJSON()\n    };\n    if (\"certs\" in this) _object.certs = Array.from(this.certs, element => element.toJSON());\n    return _object;\n  } //**********************************************************************************\n\n  /**\r\n   * Get OCSP response status for specific certificate\r\n   * @param {Certificate} certificate Certificate to be checked\r\n   * @param {Certificate} issuerCertificate Certificate of issuer for certificate to be checked\r\n   * @returns {Promise}\r\n   */\n\n\n  getCertificateStatus(certificate, issuerCertificate) {\n    //region Initial variables\n    let sequence = Promise.resolve();\n    const result = {\n      isForCertificate: false,\n      status: 2 // 0 = good, 1 = revoked, 2 = unknown\n\n    };\n    const hashesObject = {};\n    const certIDs = [];\n    const certIDPromises = []; //endregion\n    //region Create all \"certIDs\" for input certificates\n\n    for (const response of this.tbsResponseData.responses) {\n      const hashAlgorithm = getAlgorithmByOID(response.certID.hashAlgorithm.algorithmId);\n      if (\"name\" in hashAlgorithm === false) return Promise.reject(`Wrong CertID hashing algorithm: ${response.certID.hashAlgorithm.algorithmId}`);\n\n      if (hashAlgorithm.name in hashesObject === false) {\n        hashesObject[hashAlgorithm.name] = 1;\n        const certID = new CertID();\n        certIDs.push(certID);\n        certIDPromises.push(certID.createForCertificate(certificate, {\n          hashAlgorithm: hashAlgorithm.name,\n          issuerCertificate\n        }));\n      }\n    }\n\n    sequence = sequence.then(() => Promise.all(certIDPromises)); //endregion\n    //region Compare all response's \"certIDs\" with identifiers for input certificate\n\n    sequence = sequence.then(() => {\n      for (const response of this.tbsResponseData.responses) {\n        for (const id of certIDs) {\n          if (response.certID.isEqual(id)) {\n            result.isForCertificate = true;\n\n            try {\n              switch (response.certStatus.idBlock.isConstructed) {\n                case true:\n                  if (response.certStatus.idBlock.tagNumber === 1) result.status = 1; // revoked\n\n                  break;\n\n                case false:\n                  switch (response.certStatus.idBlock.tagNumber) {\n                    case 0:\n                      // good\n                      result.status = 0;\n                      break;\n\n                    case 2:\n                      // unknown\n                      result.status = 2;\n                      break;\n\n                    default:\n                  }\n\n                  break;\n\n                default:\n              }\n            } catch (ex) {}\n\n            return result;\n          }\n        }\n      }\n\n      return result;\n    }); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n  /**\r\n   * Make signature for current OCSP Basic Response\r\n   * @param {Object} privateKey Private key for \"subjectPublicKeyInfo\" structure\r\n   * @param {string} [hashAlgorithm=\"SHA-1\"] Hashing algorithm. Default SHA-1\r\n   * @returns {Promise}\r\n   */\n\n\n  sign(privateKey, hashAlgorithm = \"SHA-1\") {\n    //region Initial checking\n    //region Get a private key from function parameter\n    if (typeof privateKey === \"undefined\") return Promise.reject(\"Need to provide a private key for signing\"); //endregion\n    //endregion\n    //region Initial variables\n\n    let sequence = Promise.resolve();\n    let parameters;\n    const engine = getEngine(); //endregion\n    //region Get a \"default parameters\" for current algorithm and set correct signature algorithm\n\n    sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));\n    sequence = sequence.then(result => {\n      parameters = result.parameters;\n      this.signatureAlgorithm = result.signatureAlgorithm;\n    }); //endregion\n    //region Create TBS data for signing\n\n    sequence = sequence.then(() => {\n      this.tbsResponseData.tbs = this.tbsResponseData.toSchema(true).toBER(false);\n    }); //endregion\n    //region Signing TBS data on provided private key\n\n    sequence = sequence.then(() => engine.subtle.signWithPrivateKey(this.tbsResponseData.tbs, privateKey, parameters));\n    sequence = sequence.then(result => {\n      this.signature = new asn1js.BitString({\n        valueHex: result\n      });\n    }); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n  /**\r\n   * Verify existing OCSP Basic Response\r\n   * @param {Object} parameters Additional parameters\r\n   * @returns {Promise}\r\n   */\n\n\n  verify(parameters = {}) {\n    //region Initial variables\n    let signerCert = null;\n    let certIndex = -1;\n    let sequence = Promise.resolve();\n    let trustedCerts = [];\n\n    const _this = this;\n\n    const engine = getEngine(); //endregion\n    //region Check amount of certificates\n\n    if (\"certs\" in this === false) return Promise.reject(\"No certificates attached to the BasicOCSPResponce\"); //endregion\n    //region Get input values\n\n    if (\"trustedCerts\" in parameters) trustedCerts = parameters.trustedCerts; //endregion\n    //region Aux functions\n\n    /**\r\n     * Check CA flag for the certificate\r\n     * @param {Certificate} cert Certificate to find CA flag for\r\n     * @returns {*}\r\n     */\n\n    function checkCA(cert) {\n      //region Do not include signer's certificate\n      if (cert.issuer.isEqual(signerCert.issuer) === true && cert.serialNumber.isEqual(signerCert.serialNumber) === true) return null; //endregion\n\n      let isCA = false;\n\n      for (const extension of cert.extensions) {\n        if (extension.extnID === \"2.5.29.19\") // BasicConstraints\n          {\n            if (\"cA\" in extension.parsedValue) {\n              if (extension.parsedValue.cA === true) isCA = true;\n            }\n          }\n      }\n\n      if (isCA) return cert;\n      return null;\n    } //endregion\n    //region Get a \"crypto\" extension\n\n\n    const crypto = getCrypto();\n    if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion\n    //region Find correct value for \"responderID\"\n\n    switch (true) {\n      case this.tbsResponseData.responderID instanceof RelativeDistinguishedNames:\n        // [1] Name\n        sequence = sequence.then(() => {\n          for (const [index, certificate] of _this.certs.entries()) {\n            if (certificate.subject.isEqual(_this.tbsResponseData.responderID)) {\n              certIndex = index;\n              break;\n            }\n          }\n        });\n        break;\n\n      case this.tbsResponseData.responderID instanceof asn1js.OctetString:\n        // [2] KeyHash\n        sequence = sequence.then(() => Promise.all(Array.from(_this.certs, element => crypto.digest({\n          name: \"sha-1\"\n        }, new Uint8Array(element.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex)))).then(results => {\n          for (const [index] of _this.certs.entries()) {\n            if (isEqualBuffer(results[index], _this.tbsResponseData.responderID.valueBlock.valueHex)) {\n              certIndex = index;\n              break;\n            }\n          }\n        }));\n        break;\n\n      default:\n        return Promise.reject(\"Wrong value for responderID\");\n    } //endregion\n    //region Make additional verification for signer's certificate\n\n\n    sequence = sequence.then(() => {\n      if (certIndex === -1) return Promise.reject(\"Correct certificate was not found in OCSP response\");\n      signerCert = this.certs[certIndex];\n      return Promise.all(Array.from(_this.certs, element => checkCA(element))).then(promiseResults => {\n        const additionalCerts = [];\n        additionalCerts.push(signerCert);\n\n        for (const promiseResult of promiseResults) {\n          if (promiseResult !== null) additionalCerts.push(promiseResult);\n        }\n\n        const certChain = new CertificateChainValidationEngine({\n          certs: additionalCerts,\n          trustedCerts\n        });\n        return certChain.verify().then(verificationResult => {\n          if (verificationResult.result === true) return Promise.resolve();\n          return Promise.reject(\"Validation of signer's certificate failed\");\n        }, error => Promise.reject(`Validation of signer's certificate failed with error: ${error instanceof Object ? error.resultMessage : error}`));\n      }, promiseError => Promise.reject(`Error during checking certificates for CA flag: ${promiseError}`));\n    }); //endregion\n\n    sequence = sequence.then(() => engine.subtle.verifyWithPublicKey(this.tbsResponseData.tbs, this.signature, this.certs[certIndex].subjectPublicKeyInfo, this.signatureAlgorithm));\n    return sequence;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************","map":{"version":3,"sources":["/Users/pratison/Work/Cisco/Education/React/education-webex/node_modules/pkijs/src/BasicOCSPResponse.js"],"names":["asn1js","getParametersValue","isEqualBuffer","clearProps","getAlgorithmByOID","getCrypto","getEngine","ResponseData","AlgorithmIdentifier","Certificate","CertID","RelativeDistinguishedNames","CertificateChainValidationEngine","BasicOCSPResponse","constructor","parameters","tbsResponseData","defaultValues","signatureAlgorithm","signature","certs","fromSchema","schema","memberName","BitString","Error","compareWithDefault","memberValue","comparisonResult","tbs","responderID","producedAt","responses","responseExtensions","algorithmId","isEqual","length","names","Sequence","name","blockName","value","Constructed","optional","idBlock","tagClass","tagNumber","Repeated","asn1","compareSchema","verified","result","Array","from","element","toSchema","outputArray","push","toJSON","_object","getCertificateStatus","certificate","issuerCertificate","sequence","Promise","resolve","isForCertificate","status","hashesObject","certIDs","certIDPromises","response","hashAlgorithm","certID","reject","createForCertificate","then","all","id","certStatus","isConstructed","ex","sign","privateKey","engine","subtle","getSignatureParameters","toBER","signWithPrivateKey","valueHex","verify","signerCert","certIndex","trustedCerts","_this","checkCA","cert","issuer","serialNumber","isCA","extension","extensions","extnID","parsedValue","cA","crypto","index","entries","subject","OctetString","digest","Uint8Array","subjectPublicKeyInfo","subjectPublicKey","valueBlock","results","promiseResults","additionalCerts","promiseResult","certChain","verificationResult","error","Object","resultMessage","promiseError","verifyWithPublicKey"],"mappings":"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","sourcesContent":["import * as asn1js from \"asn1js\";\r\nimport { getParametersValue, isEqualBuffer, clearProps } from \"pvutils\";\r\nimport { getAlgorithmByOID, getCrypto, getEngine } from \"./common.js\";\r\nimport ResponseData from \"./ResponseData.js\";\r\nimport AlgorithmIdentifier from \"./AlgorithmIdentifier.js\";\r\nimport Certificate from \"./Certificate.js\";\r\nimport CertID from \"./CertID.js\";\r\nimport RelativeDistinguishedNames from \"./RelativeDistinguishedNames.js\";\r\nimport CertificateChainValidationEngine from \"./CertificateChainValidationEngine.js\";\r\n//**************************************************************************************\r\n/**\r\n * Class from RFC6960\r\n */\r\nexport default class BasicOCSPResponse\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for BasicOCSPResponse class\r\n\t * @param {Object} [parameters={}]\r\n\t * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\t//region Internal properties of the object\r\n\t\t/**\r\n\t\t * @type {ResponseData}\r\n\t\t * @desc tbsResponseData\r\n\t\t */\r\n\t\tthis.tbsResponseData = getParametersValue(parameters, \"tbsResponseData\", BasicOCSPResponse.defaultValues(\"tbsResponseData\"));\r\n\t\t/**\r\n\t\t * @type {AlgorithmIdentifier}\r\n\t\t * @desc signatureAlgorithm\r\n\t\t */\r\n\t\tthis.signatureAlgorithm = getParametersValue(parameters, \"signatureAlgorithm\", BasicOCSPResponse.defaultValues(\"signatureAlgorithm\"));\r\n\t\t/**\r\n\t\t * @type {BitString}\r\n\t\t * @desc signature\r\n\t\t */\r\n\t\tthis.signature = getParametersValue(parameters, \"signature\", BasicOCSPResponse.defaultValues(\"signature\"));\r\n\t\t\r\n\t\tif(\"certs\" in parameters)\r\n\t\t\t/**\r\n\t\t\t * @type {Array.<Certificate>}\r\n\t\t\t * @desc certs\r\n\t\t\t */\r\n\t\t\tthis.certs = getParametersValue(parameters, \"certs\", BasicOCSPResponse.defaultValues(\"certs\"));\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region If input argument array contains \"schema\" for this object\r\n\t\tif(\"schema\" in parameters)\r\n\t\t\tthis.fromSchema(parameters.schema);\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Return default values for all class members\r\n\t * @param {string} memberName String name for a class member\r\n\t */\r\n\tstatic defaultValues(memberName)\r\n\t{\r\n\t\tswitch(memberName)\r\n\t\t{\r\n\t\t\tcase \"tbsResponseData\":\r\n\t\t\t\treturn new ResponseData();\r\n\t\t\tcase \"signatureAlgorithm\":\r\n\t\t\t\treturn new AlgorithmIdentifier();\r\n\t\t\tcase \"signature\":\r\n\t\t\t\treturn new asn1js.BitString();\r\n\t\t\tcase \"certs\":\r\n\t\t\t\treturn [];\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Invalid member name for BasicOCSPResponse class: ${memberName}`);\r\n\t\t}\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Compare values with default values for all class members\r\n\t * @param {string} memberName String name for a class member\r\n\t * @param {*} memberValue Value to compare with default value\r\n\t */\r\n\tstatic compareWithDefault(memberName, memberValue)\r\n\t{\r\n\t\tswitch(memberName)\r\n\t\t{\r\n\t\t\tcase \"type\":\r\n\t\t\t\t{\r\n\t\t\t\t\t// noinspection OverlyComplexBooleanExpressionJS\r\n\t\t\t\t\tlet comparisonResult = ((ResponseData.compareWithDefault(\"tbs\", memberValue.tbs)) &&\r\n\t\t\t\t\t(ResponseData.compareWithDefault(\"responderID\", memberValue.responderID)) &&\r\n\t\t\t\t\t(ResponseData.compareWithDefault(\"producedAt\", memberValue.producedAt)) &&\r\n\t\t\t\t\t(ResponseData.compareWithDefault(\"responses\", memberValue.responses)));\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(\"responseExtensions\" in memberValue)\r\n\t\t\t\t\t\tcomparisonResult = comparisonResult && (ResponseData.compareWithDefault(\"responseExtensions\", memberValue.responseExtensions));\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn comparisonResult;\r\n\t\t\t\t}\r\n\t\t\tcase \"signatureAlgorithm\":\r\n\t\t\t\treturn ((memberValue.algorithmId === \"\") && ((\"algorithmParams\" in memberValue) === false));\r\n\t\t\tcase \"signature\":\r\n\t\t\t\treturn (memberValue.isEqual(BasicOCSPResponse.defaultValues(memberName)));\r\n\t\t\tcase \"certs\":\r\n\t\t\t\treturn (memberValue.length === 0);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Invalid member name for BasicOCSPResponse class: ${memberName}`);\r\n\t\t}\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Return value of pre-defined ASN.1 schema for current class\r\n\t *\r\n\t * ASN.1 schema:\r\n\t * ```asn1\r\n\t * BasicOCSPResponse       ::= SEQUENCE {\r\n\t *    tbsResponseData      ResponseData,\r\n\t *    signatureAlgorithm   AlgorithmIdentifier,\r\n\t *    signature            BIT STRING,\r\n\t *    certs            [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL }\r\n\t * ```\r\n\t *\r\n\t * @param {Object} parameters Input parameters for the schema\r\n\t * @returns {Object} asn1js schema object\r\n\t */\r\n\tstatic schema(parameters = {})\r\n\t{\r\n\t\t/**\r\n\t\t * @type {Object}\r\n\t\t * @property {string} [blockName]\r\n\t\t * @property {string} [tbsResponseData]\r\n\t\t * @property {string} [signatureAlgorithm]\r\n\t\t * @property {string} [signature]\r\n\t\t * @property {string} [certs]\r\n\t\t */\r\n\t\tconst names = getParametersValue(parameters, \"names\", {});\r\n\t\t\r\n\t\treturn (new asn1js.Sequence({\r\n\t\t\tname: (names.blockName || \"BasicOCSPResponse\"),\r\n\t\t\tvalue: [\r\n\t\t\t\tResponseData.schema(names.tbsResponseData || {\r\n\t\t\t\t\tnames: {\r\n\t\t\t\t\t\tblockName: \"BasicOCSPResponse.tbsResponseData\"\r\n\t\t\t\t\t}\r\n\t\t\t\t}),\r\n\t\t\t\tAlgorithmIdentifier.schema(names.signatureAlgorithm || {\r\n\t\t\t\t\tnames: {\r\n\t\t\t\t\t\tblockName: \"BasicOCSPResponse.signatureAlgorithm\"\r\n\t\t\t\t\t}\r\n\t\t\t\t}),\r\n\t\t\t\tnew asn1js.BitString({ name: (names.signature || \"BasicOCSPResponse.signature\") }),\r\n\t\t\t\tnew asn1js.Constructed({\r\n\t\t\t\t\toptional: true,\r\n\t\t\t\t\tidBlock: {\r\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\r\n\t\t\t\t\t\ttagNumber: 0 // [0]\r\n\t\t\t\t\t},\r\n\t\t\t\t\tvalue: [\r\n\t\t\t\t\t\tnew asn1js.Sequence({\r\n\t\t\t\t\t\t\tvalue: [new asn1js.Repeated({\r\n\t\t\t\t\t\t\t\tname: \"BasicOCSPResponse.certs\",\r\n\t\t\t\t\t\t\t\tvalue: Certificate.schema(names.certs || {})\r\n\t\t\t\t\t\t\t})]\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t]\r\n\t\t\t\t})\r\n\t\t\t]\r\n\t\t}));\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convert parsed asn1js object into current class\r\n\t * @param {!Object} schema\r\n\t */\r\n\tfromSchema(schema)\r\n\t{\r\n\t\t//region Clear input data first\r\n\t\tclearProps(schema, [\r\n\t\t\t\"BasicOCSPResponse.tbsResponseData\",\r\n\t\t\t\"BasicOCSPResponse.signatureAlgorithm\",\r\n\t\t\t\"BasicOCSPResponse.signature\",\r\n\t\t\t\"BasicOCSPResponse.certs\"\r\n\t\t]);\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Check the schema is valid\r\n\t\tconst asn1 = asn1js.compareSchema(schema,\r\n\t\t\tschema,\r\n\t\t\tBasicOCSPResponse.schema()\r\n\t\t);\r\n\t\t\r\n\t\tif(asn1.verified === false)\r\n\t\t\tthrow new Error(\"Object's schema was not verified against input data for BasicOCSPResponse\");\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Get internal properties from parsed schema\r\n\t\tthis.tbsResponseData = new ResponseData({ schema: asn1.result[\"BasicOCSPResponse.tbsResponseData\"] });\r\n\t\tthis.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result[\"BasicOCSPResponse.signatureAlgorithm\"] });\r\n\t\tthis.signature = asn1.result[\"BasicOCSPResponse.signature\"];\r\n\t\t\r\n\t\tif(\"BasicOCSPResponse.certs\" in asn1.result)\r\n\t\t\tthis.certs = Array.from(asn1.result[\"BasicOCSPResponse.certs\"], element => new Certificate({ schema: element }));\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convert current object to asn1js object and set correct values\r\n\t * @returns {Object} asn1js object\r\n\t */\r\n\ttoSchema()\r\n\t{\r\n\t\t//region Create array for output sequence\r\n\t\tconst outputArray = [];\r\n\t\t\r\n\t\toutputArray.push(this.tbsResponseData.toSchema());\r\n\t\toutputArray.push(this.signatureAlgorithm.toSchema());\r\n\t\toutputArray.push(this.signature);\r\n\t\t\r\n\t\t//region Create array of certificates\r\n\t\tif(\"certs\" in this)\r\n\t\t{\r\n\t\t\toutputArray.push(new asn1js.Constructed({\r\n\t\t\t\tidBlock: {\r\n\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\r\n\t\t\t\t\ttagNumber: 0 // [0]\r\n\t\t\t\t},\r\n\t\t\t\tvalue: [\r\n\t\t\t\t\tnew asn1js.Sequence({\r\n\t\t\t\t\t\tvalue: Array.from(this.certs, element => element.toSchema())\r\n\t\t\t\t\t})\r\n\t\t\t\t]\r\n\t\t\t}));\r\n\t\t}\r\n\t\t//endregion\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Construct and return new ASN.1 schema for this object\r\n\t\treturn (new asn1js.Sequence({\r\n\t\t\tvalue: outputArray\r\n\t\t}));\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convertion for the class to JSON object\r\n\t * @returns {Object}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tconst _object = {\r\n\t\t\ttbsResponseData: this.tbsResponseData.toJSON(),\r\n\t\t\tsignatureAlgorithm: this.signatureAlgorithm.toJSON(),\r\n\t\t\tsignature: this.signature.toJSON()\r\n\t\t};\r\n\t\t\r\n\t\tif(\"certs\" in this)\r\n\t\t\t_object.certs = Array.from(this.certs, element => element.toJSON());\r\n\t\t\r\n\t\treturn _object;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Get OCSP response status for specific certificate\r\n\t * @param {Certificate} certificate Certificate to be checked\r\n\t * @param {Certificate} issuerCertificate Certificate of issuer for certificate to be checked\r\n\t * @returns {Promise}\r\n\t */\r\n\tgetCertificateStatus(certificate, issuerCertificate)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tlet sequence = Promise.resolve();\r\n\t\t\r\n\t\tconst result = {\r\n\t\t\tisForCertificate: false,\r\n\t\t\tstatus: 2 // 0 = good, 1 = revoked, 2 = unknown\r\n\t\t};\r\n\t\t\r\n\t\tconst hashesObject = {};\r\n\t\t\r\n\t\tconst certIDs = [];\r\n\t\tconst certIDPromises = [];\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Create all \"certIDs\" for input certificates\r\n\t\tfor(const response of this.tbsResponseData.responses)\r\n\t\t{\r\n\t\t\tconst hashAlgorithm = getAlgorithmByOID(response.certID.hashAlgorithm.algorithmId);\r\n\t\t\tif((\"name\" in hashAlgorithm) === false)\r\n\t\t\t\treturn Promise.reject(`Wrong CertID hashing algorithm: ${response.certID.hashAlgorithm.algorithmId}`);\r\n\t\t\t\r\n\t\t\tif((hashAlgorithm.name in hashesObject) === false)\r\n\t\t\t{\r\n\t\t\t\thashesObject[hashAlgorithm.name] = 1;\r\n\t\t\t\t\r\n\t\t\t\tconst certID = new CertID();\r\n\t\t\t\t\r\n\t\t\t\tcertIDs.push(certID);\r\n\t\t\t\tcertIDPromises.push(certID.createForCertificate(certificate, {\r\n\t\t\t\t\thashAlgorithm: hashAlgorithm.name,\r\n\t\t\t\t\tissuerCertificate\r\n\t\t\t\t}));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tsequence = sequence.then(() =>\r\n\t\t\tPromise.all(certIDPromises)\r\n\t\t);\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Compare all response's \"certIDs\" with identifiers for input certificate\r\n\t\tsequence = sequence.then(() =>\r\n\t\t{\r\n\t\t\tfor(const response of this.tbsResponseData.responses)\r\n\t\t\t{\r\n\t\t\t\tfor(const id of certIDs)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(response.certID.isEqual(id))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresult.isForCertificate = true;\r\n\r\n\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tswitch(response.certStatus.idBlock.isConstructed)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tcase true:\r\n\t\t\t\t\t\t\t\t\tif(response.certStatus.idBlock.tagNumber === 1)\r\n\t\t\t\t\t\t\t\t\t\tresult.status = 1; // revoked\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase false:\r\n\t\t\t\t\t\t\t\t\tswitch(response.certStatus.idBlock.tagNumber)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tcase 0: // good\r\n\t\t\t\t\t\t\t\t\t\t\tresult.status = 0;\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\tcase 2: // unknown\r\n\t\t\t\t\t\t\t\t\t\t\tresult.status = 2;\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch(ex)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn result;\r\n\t\t});\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn sequence;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Make signature for current OCSP Basic Response\r\n\t * @param {Object} privateKey Private key for \"subjectPublicKeyInfo\" structure\r\n\t * @param {string} [hashAlgorithm=\"SHA-1\"] Hashing algorithm. Default SHA-1\r\n\t * @returns {Promise}\r\n\t */\r\n\tsign(privateKey, hashAlgorithm = \"SHA-1\")\r\n\t{\r\n\t\t//region Initial checking\r\n\t\t//region Get a private key from function parameter\r\n\t\tif(typeof privateKey === \"undefined\")\r\n\t\t\treturn Promise.reject(\"Need to provide a private key for signing\");\r\n\t\t//endregion\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Initial variables\r\n\t\tlet sequence = Promise.resolve();\r\n\t\tlet parameters;\r\n\t\t\r\n\t\tconst engine = getEngine();\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Get a \"default parameters\" for current algorithm and set correct signature algorithm\r\n\t\tsequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));\r\n\t\t\r\n\t\tsequence = sequence.then(result =>\r\n\t\t{\r\n\t\t\tparameters = result.parameters;\r\n\t\t\tthis.signatureAlgorithm = result.signatureAlgorithm;\r\n\t\t});\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Create TBS data for signing\r\n\t\tsequence = sequence.then(() =>\r\n\t\t{\r\n\t\t\tthis.tbsResponseData.tbs = this.tbsResponseData.toSchema(true).toBER(false);\r\n\t\t});\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Signing TBS data on provided private key\r\n\t\tsequence = sequence.then(() => engine.subtle.signWithPrivateKey(this.tbsResponseData.tbs, privateKey, parameters));\r\n\t\t\r\n\t\tsequence = sequence.then(result =>\r\n\t\t{\r\n\t\t\tthis.signature = new asn1js.BitString({ valueHex: result });\r\n\t\t});\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn sequence;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Verify existing OCSP Basic Response\r\n\t * @param {Object} parameters Additional parameters\r\n\t * @returns {Promise}\r\n\t */\r\n\tverify(parameters = {})\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tlet signerCert = null;\r\n\t\t\r\n\t\tlet certIndex = -1;\r\n\t\t\r\n\t\tlet sequence = Promise.resolve();\r\n\t\t\r\n\t\tlet trustedCerts = [];\r\n\t\t\r\n\t\tconst _this = this;\r\n\t\t\r\n\t\tconst engine = getEngine();\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Check amount of certificates\r\n\t\tif((\"certs\" in this) === false)\r\n\t\t\treturn Promise.reject(\"No certificates attached to the BasicOCSPResponce\");\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Get input values\r\n\t\tif(\"trustedCerts\" in parameters)\r\n\t\t\ttrustedCerts = parameters.trustedCerts;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Aux functions\r\n\t\t/**\r\n\t\t * Check CA flag for the certificate\r\n\t\t * @param {Certificate} cert Certificate to find CA flag for\r\n\t\t * @returns {*}\r\n\t\t */\r\n\t\tfunction checkCA(cert)\r\n\t\t{\r\n\t\t\t//region Do not include signer's certificate\r\n\t\t\tif((cert.issuer.isEqual(signerCert.issuer) === true) && (cert.serialNumber.isEqual(signerCert.serialNumber) === true))\r\n\t\t\t\treturn null;\r\n\t\t\t//endregion\r\n\t\t\t\r\n\t\t\tlet isCA = false;\r\n\t\t\t\r\n\t\t\tfor(const extension of cert.extensions)\r\n\t\t\t{\r\n\t\t\t\tif(extension.extnID === \"2.5.29.19\") // BasicConstraints\r\n\t\t\t\t{\r\n\t\t\t\t\tif(\"cA\" in extension.parsedValue)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(extension.parsedValue.cA === true)\r\n\t\t\t\t\t\t\tisCA = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(isCA)\r\n\t\t\t\treturn cert;\r\n\t\t\t\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Get a \"crypto\" extension\r\n\t\tconst crypto = getCrypto();\r\n\t\tif(typeof crypto === \"undefined\")\r\n\t\t\treturn Promise.reject(\"Unable to create WebCrypto object\");\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Find correct value for \"responderID\"\r\n\t\tswitch(true)\r\n\t\t{\r\n\t\t\tcase (this.tbsResponseData.responderID instanceof RelativeDistinguishedNames): // [1] Name\r\n\t\t\t\tsequence = sequence.then(() =>\r\n\t\t\t\t{\r\n\t\t\t\t\tfor(const [index, certificate] of _this.certs.entries())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(certificate.subject.isEqual(_this.tbsResponseData.responderID))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcertIndex = index;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tbreak;\r\n\t\t\tcase (this.tbsResponseData.responderID instanceof asn1js.OctetString): // [2] KeyHash\r\n\t\t\t\tsequence = sequence.then(() => Promise.all(Array.from(_this.certs, element =>\r\n\t\t\t\t\tcrypto.digest({ name: \"sha-1\" }, new Uint8Array(element.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex)))).then(results =>\r\n\t\t\t\t{\r\n\t\t\t\t\tfor(const [index, ] of _this.certs.entries())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(isEqualBuffer(results[index], _this.tbsResponseData.responderID.valueBlock.valueHex))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcertIndex = index;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}));\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\treturn Promise.reject(\"Wrong value for responderID\");\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Make additional verification for signer's certificate\r\n\t\tsequence = sequence.then(() =>\r\n\t\t{\r\n\t\t\tif(certIndex === (-1))\r\n\t\t\t\treturn Promise.reject(\"Correct certificate was not found in OCSP response\");\r\n\t\t\t\r\n\t\t\tsignerCert = this.certs[certIndex];\r\n\t\t\t\r\n\t\t\treturn Promise.all(Array.from(_this.certs, element => checkCA(element))).then(promiseResults =>\r\n\t\t\t{\r\n\t\t\t\tconst additionalCerts = [];\r\n\t\t\t\tadditionalCerts.push(signerCert);\r\n\t\t\t\t\r\n\t\t\t\tfor(const promiseResult of promiseResults)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(promiseResult !== null)\r\n\t\t\t\t\t\tadditionalCerts.push(promiseResult);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tconst certChain = new CertificateChainValidationEngine({\r\n\t\t\t\t\tcerts: additionalCerts,\r\n\t\t\t\t\ttrustedCerts\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\treturn certChain.verify().then(verificationResult =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif(verificationResult.result === true)\r\n\t\t\t\t\t\treturn Promise.resolve();\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn Promise.reject(\"Validation of signer's certificate failed\");\r\n\t\t\t\t}, error =>\r\n\t\t\t\t\tPromise.reject(`Validation of signer's certificate failed with error: ${((error instanceof Object) ? error.resultMessage : error)}`)\r\n\t\t\t\t);\r\n\t\t\t}, promiseError =>\r\n\t\t\t\tPromise.reject(`Error during checking certificates for CA flag: ${promiseError}`)\r\n\t\t\t);\r\n\t\t});\r\n\t\t//endregion\r\n\t\t\r\n\t\tsequence = sequence.then(() => engine.subtle.verifyWithPublicKey(this.tbsResponseData.tbs, this.signature, this.certs[certIndex].subjectPublicKeyInfo, this.signatureAlgorithm));\r\n\t\t\r\n\t\treturn sequence;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n"]},"metadata":{},"sourceType":"module"}