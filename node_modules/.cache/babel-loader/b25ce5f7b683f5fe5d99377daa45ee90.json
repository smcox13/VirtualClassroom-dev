{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _events = require('events');\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _common = require('@webex/common');\n\nvar _nodeJose = require('node-jose');\n\nvar _nodeJose2 = _interopRequireDefault(_nodeJose);\n\nvar _nodeScr = require('node-scr');\n\nvar _nodeScr2 = _interopRequireDefault(_nodeScr);\n\nvar _ensureBuffer = require('./ensure-buffer');\n\nvar _ensureBuffer2 = _interopRequireDefault(_ensureBuffer);\n\nvar _kms = require('./kms');\n\nvar _kms2 = _interopRequireDefault(_kms);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar Encryption = _webexCore.WebexPlugin.extend({\n  children: {\n    kms: _kms2.default\n  },\n  namespace: 'Encryption',\n  processKmsMessageEvent: function processKmsMessageEvent(event) {\n    return this.kms.processKmsMessageEvent(event);\n  },\n  decryptBinary: function decryptBinary(scr, buffer) {\n    return (0, _ensureBuffer2.default)(buffer).then(function (b) {\n      /* istanbul ignore if */\n      if (buffer.length === 0 || buffer.byteLength === 0) {\n        return _promise2.default.reject(new Error('Attempted to decrypt zero-length buffer'));\n      }\n\n      return scr.decrypt(b);\n    });\n  },\n\n  /**\n   * Decrypt a SCR (Secure Content Resource) using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {Object} cipherScr - An encrypted SCR\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {Object} Decrypted SCR\n   */\n  decryptScr: function decryptScr(key, cipherScr, options) {\n    return this.getKey(key, options).then(function (k) {\n      return _nodeScr2.default.fromJWE(k.jwk, cipherScr);\n    });\n  },\n\n  /**\n   * Decrypt text using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {string} ciphertext - Encrypted text\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Decrypted plaintext\n   */\n  decryptText: function decryptText(key, ciphertext, options) {\n    return this.getKey(key, options).then(function (k) {\n      return _nodeJose2.default.JWE.createDecrypt(k.jwk).decrypt(ciphertext).then(function (result) {\n        return result.plaintext.toString();\n      });\n    });\n  },\n\n  /**\n   * Validate and initiate a Download request for requested file\n   *\n   * @param {Object} scr - Plaintext\n   * @param {Object} options - optional paramaters to download a file\n   * @returns {promise}\n   */\n  download: function download(scr, options) {\n    var _this = this;\n    /* istanbul ignore if */\n\n\n    if (!scr.loc) {\n      return _promise2.default.reject(new Error('`scr.loc` is required'));\n    }\n\n    var shunt = new _events.EventEmitter();\n\n    var promise = this._fetchDownloadUrl(scr, options).then(function (uri) {\n      var options = {\n        method: 'GET',\n        uri: uri,\n        responseType: 'buffer'\n      };\n\n      var ret = _this.request(options);\n\n      (0, _common.transferEvents)('progress', options.download, shunt);\n      return ret;\n    }).then(function (res) {\n      return _this.decryptBinary(scr, res.body);\n    });\n\n    (0, _common.proxyEvents)(shunt, promise);\n    return promise;\n  },\n\n  /**\n   * Fetch Download URL for the requested file\n   *\n   * @param {Object} scr - Plaintext\n   * @param {Object} options - optional paramaters to download a file\n   * @returns {promise} url of the downloadable file\n   */\n  _fetchDownloadUrl: function _fetchDownloadUrl(scr, options) {\n    var _this2 = this;\n\n    this.logger.info('encryption: retrieving download url for encrypted file');\n\n    if (process.env.NODE_ENV !== 'production' && scr.loc.includes('localhost')) {\n      this.logger.info('encryption: bypassing webex files because this looks to be a test file on localhost');\n      return _promise2.default.resolve(scr.loc);\n    }\n\n    var inputBody = {\n      endpoints: [scr.loc]\n    };\n\n    var endpointUrl = _url2.default.parse(scr.loc); // hardcode the url to use 'https' and the file service '/v1/download/endpoints' api\n\n\n    endpointUrl.protocol = 'https';\n    endpointUrl.pathname = '/v1/download/endpoints';\n    return this.request({\n      method: 'POST',\n      uri: _url2.default.format(endpointUrl),\n      body: options ? (0, _extends3.default)({}, inputBody, {\n        allow: options.params.allow\n      }) : inputBody\n    }).then(function (res) {\n      var url = res.body.endpoints[scr.loc];\n\n      if (!url) {\n        _this2.logger.warn('encryption: could not determine download url for `scr.loc`; attempting to download `scr.loc` directly');\n\n        return scr.loc;\n      }\n\n      _this2.logger.info('encryption: retrieved download url for encrypted file');\n\n      return url;\n    });\n  },\n  encryptBinary: function encryptBinary(file) {\n    return (0, _ensureBuffer2.default)(file).then(function (buffer) {\n      return _nodeScr2.default.create().then(function (scr) {\n        return scr.encrypt(buffer).then(_ensureBuffer2.default) // eslint-disable-next-line max-nested-callbacks\n        .then(function (cdata) {\n          return {\n            scr: scr,\n            cdata: cdata\n          };\n        });\n      });\n    });\n  },\n\n  /**\n   * Encrypt a SCR (Secure Content Resource) using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {Object} scr - Plaintext\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Encrypted SCR\n   */\n  encryptScr: function encryptScr(key, scr, options) {\n    /* istanbul ignore if */\n    if (!scr.loc) {\n      return _promise2.default.reject(new Error('Cannot encrypt `scr` without first setting `loc`'));\n    }\n\n    return this.getKey(key, options).then(function (k) {\n      return scr.toJWE(k.jwk);\n    });\n  },\n\n  /**\n   * Encrypt plaintext using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {string} plaintext\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Encrypted text\n   */\n  encryptText: function encryptText(key, plaintext, options) {\n    var _this3 = this;\n\n    return this.getKey(key, options).then(function (k) {\n      return _nodeJose2.default.JWE.createEncrypt(_this3.config.joseOptions, {\n        key: k.jwk,\n        header: {\n          alg: 'dir'\n        },\n        reference: null\n      }).final(plaintext, 'utf8');\n    });\n  },\n\n  /**\n   * Fetch the key associated with the supplied KMS uri.\n   *\n   * @param {string} uri - The uri of a key stored in KMS\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Key\n   */\n  getKey: function getKey(uri) {\n    var _this4 = this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        onBehalfOf = _ref.onBehalfOf;\n\n    if (uri.jwk) {\n      return this.kms.asKey(uri);\n    }\n\n    var storageKey = uri;\n\n    if (onBehalfOf) {\n      storageKey += '/onBehalfOf/' + onBehalfOf;\n    }\n\n    return this.unboundedStorage.get(storageKey).then(function (keyString) {\n      return JSON.parse(keyString);\n    }).then(function (keyObject) {\n      return _this4.kms.asKey(keyObject);\n    }).catch(function () {\n      return _this4.kms.fetchKey({\n        uri: uri,\n        onBehalfOf: onBehalfOf\n      }).then((0, _common.tap)(function (key) {\n        return _this4.unboundedStorage.put(storageKey, (0, _stringify2.default)(key, replacer));\n      }));\n    });\n  },\n  version: '1.80.172'\n});\n/**\n * JSON.stringify replacer that ensures private key data is serialized.\n * @param {string} k\n * @param {mixed} v\n * @returns {mixed}\n */\n\n\nfunction replacer(k, v) {\n  if (k === 'jwk') {\n    // note: this[k] and v may be different representations of the same value\n    // eslint-disable-next-line no-invalid-this\n    var json = this[k].toJSON(true);\n    return json;\n  }\n\n  return v;\n}\n\nexports.default = Encryption;","map":{"version":3,"sources":["encryption.js"],"names":["Encryption","children","kms","KMS","namespace","processKmsMessageEvent","decryptBinary","buffer","scr","decryptScr","SCR","k","decryptText","result","download","shunt","EventEmitter","promise","options","method","uri","responseType","ret","res","_fetchDownloadUrl","process","inputBody","endpoints","endpointUrl","url","body","allow","encryptBinary","ensureBuffer","cdata","encryptScr","encryptText","key","header","alg","reference","getKey","onBehalfOf","storageKey","JSON","json"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {EventEmitter} from 'events';\nimport url from 'url';\n\nimport {WebexPlugin} from '@webex/webex-core';\nimport {proxyEvents, tap, transferEvents} from '@webex/common';\nimport jose from 'node-jose';\nimport SCR from 'node-scr';\n\nimport ensureBuffer from './ensure-buffer';\nimport KMS from './kms';\n\nconst Encryption = WebexPlugin.extend({\n  children: {\n    kms: KMS\n  },\n\n  namespace: 'Encryption',\n\n  processKmsMessageEvent(event) {\n    return this.kms.processKmsMessageEvent(event);\n  },\n\n  decryptBinary(scr, buffer) {\n    return ensureBuffer(buffer)\n      .then((b) => {\n        /* istanbul ignore if */\n        if (buffer.length === 0 || buffer.byteLength === 0) {\n          return Promise.reject(new Error('Attempted to decrypt zero-length buffer'));\n        }\n\n        return scr.decrypt(b);\n      });\n  },\n\n  /**\n   * Decrypt a SCR (Secure Content Resource) using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {Object} cipherScr - An encrypted SCR\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {Object} Decrypted SCR\n   */\n  decryptScr(key, cipherScr, options) {\n    return this.getKey(key, options)\n      .then((k) => SCR.fromJWE(k.jwk, cipherScr));\n  },\n\n  /**\n   * Decrypt text using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {string} ciphertext - Encrypted text\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Decrypted plaintext\n   */\n  decryptText(key, ciphertext, options) {\n    return this.getKey(key, options)\n      .then((k) => jose.JWE\n        .createDecrypt(k.jwk)\n        .decrypt(ciphertext)\n        .then((result) => result.plaintext.toString()));\n  },\n\n  /**\n   * Validate and initiate a Download request for requested file\n   *\n   * @param {Object} scr - Plaintext\n   * @param {Object} options - optional paramaters to download a file\n   * @returns {promise}\n   */\n  download(scr, options) {\n    /* istanbul ignore if */\n    if (!scr.loc) {\n      return Promise.reject(new Error('`scr.loc` is required'));\n    }\n\n    const shunt = new EventEmitter();\n    const promise = this._fetchDownloadUrl(scr, options)\n      .then((uri) => {\n        const options = {\n          method: 'GET',\n          uri,\n          responseType: 'buffer'\n        };\n\n        const ret = this.request(options);\n\n        transferEvents('progress', options.download, shunt);\n\n        return ret;\n      })\n      .then((res) => this.decryptBinary(scr, res.body));\n\n    proxyEvents(shunt, promise);\n\n    return promise;\n  },\n\n  /**\n   * Fetch Download URL for the requested file\n   *\n   * @param {Object} scr - Plaintext\n   * @param {Object} options - optional paramaters to download a file\n   * @returns {promise} url of the downloadable file\n   */\n  _fetchDownloadUrl(scr, options) {\n    this.logger.info('encryption: retrieving download url for encrypted file');\n\n    if (process.env.NODE_ENV !== 'production' && scr.loc.includes('localhost')) {\n      this.logger.info('encryption: bypassing webex files because this looks to be a test file on localhost');\n\n      return Promise.resolve(scr.loc);\n    }\n\n    const inputBody = {\n      endpoints: [scr.loc]\n    };\n    const endpointUrl = url.parse(scr.loc);\n\n    // hardcode the url to use 'https' and the file service '/v1/download/endpoints' api\n    endpointUrl.protocol = 'https';\n    endpointUrl.pathname = '/v1/download/endpoints';\n\n    return this.request({\n      method: 'POST',\n      uri: url.format(endpointUrl),\n      body: options ? {\n        ...inputBody,\n        allow: options.params.allow\n      } : inputBody\n    })\n      .then((res) => {\n        const url = res.body.endpoints[scr.loc];\n\n        if (!url) {\n          this.logger.warn('encryption: could not determine download url for `scr.loc`; attempting to download `scr.loc` directly');\n\n          return scr.loc;\n        }\n        this.logger.info('encryption: retrieved download url for encrypted file');\n\n        return url;\n      });\n  },\n\n  encryptBinary(file) {\n    return ensureBuffer(file)\n      .then((buffer) => SCR.create()\n        .then((scr) => scr.encrypt(buffer)\n          .then(ensureBuffer)\n          // eslint-disable-next-line max-nested-callbacks\n          .then((cdata) => ({scr, cdata}))));\n  },\n\n  /**\n   * Encrypt a SCR (Secure Content Resource) using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {Object} scr - Plaintext\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Encrypted SCR\n   */\n  encryptScr(key, scr, options) {\n    /* istanbul ignore if */\n    if (!scr.loc) {\n      return Promise.reject(new Error('Cannot encrypt `scr` without first setting `loc`'));\n    }\n\n    return this.getKey(key, options)\n      .then((k) => scr.toJWE(k.jwk));\n  },\n\n  /**\n   * Encrypt plaintext using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {string} plaintext\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Encrypted text\n   */\n  encryptText(key, plaintext, options) {\n    return this.getKey(key, options)\n      .then((k) => jose.JWE\n        .createEncrypt(this.config.joseOptions, {\n          key: k.jwk,\n          header: {\n            alg: 'dir'\n          },\n          reference: null\n        })\n        .final(plaintext, 'utf8'));\n  },\n\n  /**\n   * Fetch the key associated with the supplied KMS uri.\n   *\n   * @param {string} uri - The uri of a key stored in KMS\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Key\n   */\n  getKey(uri, {onBehalfOf} = {}) {\n    if (uri.jwk) {\n      return this.kms.asKey(uri);\n    }\n\n    let storageKey = uri;\n\n    if (onBehalfOf) {\n      storageKey += `/onBehalfOf/${onBehalfOf}`;\n    }\n\n    return this.unboundedStorage.get(storageKey)\n      .then((keyString) => JSON.parse(keyString))\n      .then((keyObject) => this.kms.asKey(keyObject))\n      .catch(() => this.kms.fetchKey({uri, onBehalfOf})\n        .then(tap((key) => this.unboundedStorage.put(storageKey, JSON.stringify(key, replacer)))));\n  }\n});\n\n/**\n * JSON.stringify replacer that ensures private key data is serialized.\n * @param {string} k\n * @param {mixed} v\n * @returns {mixed}\n */\nfunction replacer(k, v) {\n  if (k === 'jwk') {\n    // note: this[k] and v may be different representations of the same value\n    // eslint-disable-next-line no-invalid-this\n    const json = this[k].toJSON(true);\n\n    return json;\n  }\n\n  return v;\n}\n\nexport default Encryption;\n"]},"metadata":{},"sourceType":"script"}