{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _max2 = require('lodash/max');\n\nvar _max3 = _interopRequireDefault(_max2);\n\nvar _min2 = require('lodash/min');\n\nvar _min3 = _interopRequireDefault(_min2);\n\nvar _constants = require('../constants');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar ParseUtils = {}; // https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Delta-Events\n\nParseUtils.compareLocus = function (newSequence, currentSequence) {\n  var newMin = Math.min(newSequence.rangeStart, (0, _min3.default)(newSequence.entries));\n  var newMax = Math.max(newSequence.rangeEnd, (0, _max3.default)(newSequence.entries));\n  var curMin = Math.min(currentSequence.rangeStart, (0, _min3.default)(currentSequence.entries));\n  var curMax = Math.max(currentSequence.rangeEnd, (0, _max3.default)(currentSequence.entries));\n  var newUniqueCurrent = ParseUtils.calculateUnique(newSequence, currentSequence);\n  var currentUniqueNew = ParseUtils.calculateUnique(currentSequence, newSequence);\n  var newHasRange = !(newSequence.rangeStart === 0 && newSequence.rangeEnd === 0);\n  var curHasRange = !(currentSequence.rangeStart === 0 && currentSequence.rangeEnd === 0);\n\n  if (newMin > curMax) {\n    return _constants.DELTAEVENT.GT;\n  }\n\n  if (newMax < curMin) {\n    return _constants.DELTAEVENT.LT;\n  }\n\n  if (!newUniqueCurrent.length && !currentUniqueNew.length) {\n    if (newSequence.rangeEnd - newMin > currentSequence.rangeEnd - curMin) {\n      return _constants.DELTAEVENT.GT;\n    }\n\n    if (newSequence.rangeEnd - newMin < currentSequence.rangeEnd - curMin) {\n      return _constants.DELTAEVENT.LT;\n    }\n\n    return _constants.DELTAEVENT.EQ;\n  }\n\n  if (newUniqueCurrent.length && !currentUniqueNew.length) {\n    return _constants.DELTAEVENT.GT;\n  }\n\n  if (currentUniqueNew.length && !newUniqueCurrent.length) {\n    return _constants.DELTAEVENT.LT;\n  }\n\n  if (!newHasRange && !curHasRange || ParseUtils.hasUniqueButInRange(newUniqueCurrent, curMin, curMax) || ParseUtils.hasUniqueButInRange(currentUniqueNew, newMin, newMax)) {\n    return _constants.DELTAEVENT.CF;\n  }\n\n  if ((0, _min3.default)(newUniqueCurrent) > (0, _min3.default)(currentUniqueNew)) {\n    return _constants.DELTAEVENT.GT;\n  }\n\n  return _constants.DELTAEVENT.LT;\n};\n\nParseUtils.generateSyncDebugFlag = function (meeting, deltaLocus) {\n  var baseSequence = deltaLocus.baseSequence;\n  var workingSequence = meeting.locusInfo.sequence;\n  var targetSequence = deltaLocus.sequence;\n  var flags = ['', '', '', '', '', ''];\n\n  var setFlag = function setFlag(sequence) {\n    if (!sequence) {\n      return _constants.LOCUS.SEQUENCE.UN_DEF;\n    }\n\n    return ParseUtils.isEmptySequence(sequence) ? _constants.LOCUS.SEQUENCE.EMPTY : _constants.LOCUS.SEQUENCE.DEF;\n  };\n\n  flags[0] = setFlag(baseSequence);\n  flags[1] = setFlag(workingSequence);\n  flags[2] = setFlag(targetSequence);\n  flags[3] = baseSequence && workingSequence ? ParseUtils.compareLocus(baseSequence, workingSequence).toLowerCase() : _constants.LOCUS.SEQUENCE.NA;\n  flags[4] = workingSequence && targetSequence ? ParseUtils.compareLocus(workingSequence, targetSequence).toLowerCase() : _constants.LOCUS.SEQUENCE.NA;\n  flags[5] = baseSequence && targetSequence ? ParseUtils.compareLocus(baseSequence, targetSequence).toLowerCase() : _constants.LOCUS.SEQUENCE.NA; // TODO: check where it is used\n\n  meeting.desync = flags.toString();\n};\n\nParseUtils.calculateUnique = function (s1, s2) {\n  var res = [];\n  s1.entries.forEach(function (entry) {\n    /* istanbul ignore else */\n    if ((entry < s2.rangeStart || entry > s2.rangeEnd) && s2.entries.indexOf(entry) === -1) {\n      res.push(entry);\n    }\n  });\n  return res;\n};\n\nParseUtils.isEmptySequence = function (sequence) {\n  if (Object.prototype.hasOwnProperty.call(sequence, _constants.LOCUS.SEQUENCE.RANGE_START) && sequence.rangeStart === 0 && Object.prototype.hasOwnProperty.call(sequence, _constants.LOCUS.SEQUENCE.RANGE_END) && sequence.rangeEnd === 0 && sequence.entries && sequence.entries.length === 0) {\n    return true;\n  }\n\n  return false;\n};\n\nParseUtils.hasUniqueButInRange = function (uniqueEntries, minimum, maximum) {\n  return uniqueEntries.some(function (entry) {\n    return entry > minimum && entry < maximum;\n  });\n};\n\nexports.default = ParseUtils;","map":{"version":3,"sources":["utils.js"],"names":["ParseUtils","newMin","Math","newSequence","newMax","curMin","currentSequence","curMax","newUniqueCurrent","currentUniqueNew","newHasRange","curHasRange","DELTAEVENT","baseSequence","deltaLocus","workingSequence","meeting","targetSequence","flags","setFlag","LOCUS","res","s1","entry","s2","Object","sequence"],"mappings":"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","sourcesContent":["import {min, max} from 'lodash';\n\nimport {DELTAEVENT, LOCUS} from '../constants';\n\nconst ParseUtils = {};\n\n// https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Delta-Events\nParseUtils.compareLocus = (newSequence, currentSequence) => {\n  const newMin = Math.min(newSequence.rangeStart, min(newSequence.entries));\n  const newMax = Math.max(newSequence.rangeEnd, max(newSequence.entries));\n  const curMin = Math.min(currentSequence.rangeStart, min(currentSequence.entries));\n  const curMax = Math.max(currentSequence.rangeEnd, max(currentSequence.entries));\n\n  const newUniqueCurrent = ParseUtils.calculateUnique(newSequence, currentSequence);\n  const currentUniqueNew = ParseUtils.calculateUnique(currentSequence, newSequence);\n\n  const newHasRange = !(newSequence.rangeStart === 0 && newSequence.rangeEnd === 0);\n  const curHasRange = !(currentSequence.rangeStart === 0 && currentSequence.rangeEnd === 0);\n\n  if (newMin > curMax) {\n    return DELTAEVENT.GT;\n  }\n  if (newMax < curMin) {\n    return DELTAEVENT.LT;\n  }\n  if (!newUniqueCurrent.length && !currentUniqueNew.length) {\n    if ((newSequence.rangeEnd - newMin) > (currentSequence.rangeEnd - curMin)) {\n      return DELTAEVENT.GT;\n    }\n    if ((newSequence.rangeEnd - newMin) < (currentSequence.rangeEnd - curMin)) {\n      return DELTAEVENT.LT;\n    }\n\n    return DELTAEVENT.EQ;\n  }\n  if (newUniqueCurrent.length && !currentUniqueNew.length) {\n    return DELTAEVENT.GT;\n  }\n  if (currentUniqueNew.length && !newUniqueCurrent.length) {\n    return DELTAEVENT.LT;\n  }\n\n  if ((!newHasRange && !curHasRange) || ParseUtils.hasUniqueButInRange(newUniqueCurrent, curMin, curMax) ||\n    ParseUtils.hasUniqueButInRange(currentUniqueNew, newMin, newMax)) {\n    return DELTAEVENT.CF;\n  }\n  if (min(newUniqueCurrent) > min(currentUniqueNew)) {\n    return DELTAEVENT.GT;\n  }\n\n  return DELTAEVENT.LT;\n};\n\n\nParseUtils.generateSyncDebugFlag = (meeting, deltaLocus) => {\n  const {baseSequence} = deltaLocus;\n  const workingSequence = meeting.locusInfo.sequence;\n  const targetSequence = deltaLocus.sequence;\n  const flags = ['', '', '', '', '', ''];\n\n  const setFlag = (sequence) => {\n    if (!sequence) {\n      return LOCUS.SEQUENCE.UN_DEF;\n    }\n\n    return (ParseUtils.isEmptySequence(sequence)) ? LOCUS.SEQUENCE.EMPTY : LOCUS.SEQUENCE.DEF;\n  };\n\n  flags[0] = setFlag(baseSequence);\n  flags[1] = setFlag(workingSequence);\n  flags[2] = setFlag(targetSequence);\n\n  flags[3] = (baseSequence && workingSequence) ? ParseUtils.compareLocus(baseSequence, workingSequence).toLowerCase() : LOCUS.SEQUENCE.NA;\n  flags[4] = (workingSequence && targetSequence) ? ParseUtils.compareLocus(workingSequence, targetSequence).toLowerCase() : LOCUS.SEQUENCE.NA;\n  flags[5] = (baseSequence && targetSequence) ? ParseUtils.compareLocus(baseSequence, targetSequence).toLowerCase() : LOCUS.SEQUENCE.NA;\n\n\n  // TODO: check where it is used\n  meeting.desync = flags.toString();\n};\n\nParseUtils.calculateUnique = (s1, s2) => {\n  const res = [];\n\n  s1.entries.forEach((entry) => {\n    /* istanbul ignore else */\n    if ((entry < s2.rangeStart || entry > s2.rangeEnd) && (s2.entries.indexOf(entry) === -1)) {\n      res.push(entry);\n    }\n  });\n\n  return res;\n};\n\n\nParseUtils.isEmptySequence = (sequence) => {\n  if (Object.prototype.hasOwnProperty.call(sequence, LOCUS.SEQUENCE.RANGE_START) && sequence.rangeStart === 0 &&\n    Object.prototype.hasOwnProperty.call(sequence, LOCUS.SEQUENCE.RANGE_END) && sequence.rangeEnd === 0 &&\n    sequence.entries && sequence.entries.length === 0) {\n    return true;\n  }\n\n  return false;\n};\n\nParseUtils.hasUniqueButInRange = (uniqueEntries, minimum, maximum) =>\n  uniqueEntries.some((entry) => ((entry > minimum) && (entry < maximum)));\n\nexport default ParseUtils;\n"]},"metadata":{},"sourceType":"script"}