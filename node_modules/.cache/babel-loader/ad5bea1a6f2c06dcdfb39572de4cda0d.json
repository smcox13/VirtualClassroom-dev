{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _analyzer = require('../analyzer/analyzer');\n\nvar _analyzer2 = _interopRequireDefault(_analyzer);\n\nvar _constants = require('../constants');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * @param {Object} operate the filtered, parsed, converted, transformed, simplified data point to check against\n * @param {String} type - local or remote\n * @param {String} keys - the stat keys for types of stats defined by DEFAULT_TRANSFORM_REGEX\n * @param {String} stat - the accessor to get the actual stat\n * @param {String} kind - audio or video\n * @returns {Object} always whatever the first sentFirstVideoBytes were, in the past or if it happened now, or undefined if never\n * @private\n * @memberof StatsEvents\n */\n\n\nvar operateEvent = function operateEvent(operate, type, keys, stat, kind) {\n  var foundMatch = {};\n  foundMatch.found = keys.some(function (key) {\n    if (operate[key] && operate[key][stat] && operate[key][stat] > 0) {\n      foundMatch.match = {\n        type: type,\n        key: key,\n        data: operate[key],\n        stat: stat,\n        kind: kind\n      };\n      return true;\n    }\n\n    return false;\n  });\n  return foundMatch;\n};\n/**\n * @export\n * @class StatsEvents\n */\n\n\nvar StatsEvents = function () {\n  /**\n   * constructs an instance\n   * @constructor\n   * @param {StatsHistory} series\n   * @param {Function} callback\n   * @memberof StatsEvents\n   */\n  function StatsEvents() {\n    var series = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n    (0, _classCallCheck3.default)(this, StatsEvents);\n    this.namespace = _constants.MEETINGS;\n    /**\n     * @instance\n     * @type {StatsHistory}\n     * @private\n     * @memberof StatsEvents\n     */\n\n    this.series = series;\n    /**\n     * @instance\n     * @type {Function}\n     * @private\n     * @memberof StatsEvents\n     */\n\n    this.callback = callback;\n    /**\n     * @instance\n     * @type {WebRTCData}\n     * @private\n     * @memberof StatsEvents\n     */\n\n    this.first = null;\n    /**\n     * @instance\n     * @type {Boolean}\n     * @private\n     * @memberof StatsEvents\n     */\n\n    this.sendRemainStopped = false;\n    /**\n     * @instance\n     * @type {Boolean}\n     * @private\n     * @memberof StatsEvents\n     */\n\n    this.recvRemainStopped = false;\n  }\n  /**\n   * looks for data starting to flow through\n   * @param {WebRTCData} data\n   * @returns {Object}\n   */\n\n\n  (0, _createClass3.default)(StatsEvents, [{\n    key: 'start',\n    value: function start(data) {\n      if (data && data.data && data.data.getData()) {\n        var operate = data.data.getData();\n\n        if (operate && !this.first) {\n          var operator = [operateEvent(operate, _constants.EVENT_TYPES.LOCAL, _constants.DEFAULT_EVENT_AUDIO_SEND_KEYS, _constants.EVENT_STATS_MAP.BYTES_SENT, _constants.AUDIO), operateEvent(operate, _constants.EVENT_TYPES.LOCAL, _constants.DEFAULT_EVENT_VIDEO_SEND_KEYS, _constants.EVENT_STATS_MAP.BYTES_SENT, _constants.VIDEO), operateEvent(operate, _constants.EVENT_TYPES.REMOTE, _constants.DEFAULT_EVENT_VIDEO_RECEIVE_KEYS, _constants.EVENT_STATS_MAP.BYTES_RECEIVED, _constants.VIDEO), operateEvent(operate, _constants.EVENT_TYPES.REMOTE, _constants.DEFAULT_EVENT_AUDIO_RECEIVE_KEYS, _constants.EVENT_STATS_MAP.BYTES_RECEIVED, _constants.AUDIO)];\n          var somethingMatched = operator.find(function (element) {\n            return element && element.found && element.match;\n          });\n\n          if (somethingMatched) {\n            this.first = somethingMatched.match;\n            this.callback(this.first);\n            return somethingMatched;\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Looks for data to stop coming through\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop() {\n      if (!this.series || this.series.get().length < 5) {\n        return null;\n      }\n\n      var fiveSecondsData = this.series.getSlice(5);\n      var prop = fiveSecondsData[0] && fiveSecondsData[0].rtpOutAudio || fiveSecondsData[0].rtpInAudio || fiveSecondsData[0].rtpInVideo || fiveSecondsData[0].rtpOutVideo;\n\n      var sendAnalysis = _analyzer2.default.analyze(fiveSecondsData, {\n        analysisKeys: [{\n          key: _constants.EVENT_STATS_MAP.BYTES_SENT,\n          check: _constants.ANALYSIS_CHECKS.INCREASING,\n          prop: prop\n        }]\n      });\n\n      var receiveAnalysis = _analyzer2.default.analyze(fiveSecondsData, {\n        analysisKeys: [{\n          key: _constants.EVENT_STATS_MAP.BYTES_RECEIVED,\n          check: _constants.ANALYSIS_CHECKS.INCREASING,\n          prop: prop\n        }]\n      });\n\n      if (!sendAnalysis.valid && sendAnalysis.data.bytesSent.reports.length > 0) {\n        if (!this.sendRemainStopped) {\n          var ret = {\n            stop: true,\n            stat: _constants.EVENT_STATS_MAP.BYTES_SENT\n          };\n          this.callback(ret);\n          this.sendRemainStopped = true;\n          this.first = null;\n          return ret;\n        }\n      } else if (sendAnalysis.valid && sendAnalysis.data.bytesSent.reports.length > 0) {\n        this.sendRemainStopped = false;\n      }\n\n      if (!receiveAnalysis.valid && receiveAnalysis.data.bytesReceived.reports.length > 0) {\n        if (!this.recvRemainStopped) {\n          var _ret = {\n            stop: true,\n            stat: _constants.EVENT_STATS_MAP.BYTES_RECEIVED\n          };\n          this.callback(_ret);\n          this.recvRemainStopped = true;\n          this.first = null;\n          return _ret;\n        }\n      } else if (receiveAnalysis.valid && receiveAnalysis.data.bytesReceived.reports.length > 0) {\n        this.recvRemainStopped = false;\n      }\n\n      return null;\n    }\n    /**\n     * handles all the types of events that need to be sent when they happen from getStats API\n     * @param {WebRTCData} data\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'event',\n    value: function event(data) {\n      return {\n        start: this.start(data),\n        stop: this.stop()\n      };\n    }\n  }]);\n  return StatsEvents;\n}();\n\nexports.default = StatsEvents;","map":{"version":3,"sources":["events.js"],"names":["operateEvent","foundMatch","operate","type","key","data","stat","kind","StatsEvents","namespace","MEETINGS","series","callback","operator","EVENT_TYPES","DEFAULT_EVENT_AUDIO_SEND_KEYS","EVENT_STATS_MAP","AUDIO","DEFAULT_EVENT_VIDEO_SEND_KEYS","VIDEO","DEFAULT_EVENT_VIDEO_RECEIVE_KEYS","DEFAULT_EVENT_AUDIO_RECEIVE_KEYS","somethingMatched","element","fiveSecondsData","prop","sendAnalysis","StatsAnalyzer","analysisKeys","check","ANALYSIS_CHECKS","receiveAnalysis","ret","stop","start"],"mappings":"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","sourcesContent":["import StatsAnalyzer from '../analyzer/analyzer';\nimport {\n  DEFAULT_EVENT_VIDEO_SEND_KEYS,\n  DEFAULT_EVENT_AUDIO_SEND_KEYS,\n  DEFAULT_EVENT_AUDIO_RECEIVE_KEYS,\n  DEFAULT_EVENT_VIDEO_RECEIVE_KEYS,\n  EVENT_TYPES,\n  EVENT_STATS_MAP,\n  MEETINGS,\n  AUDIO,\n  VIDEO,\n  ANALYSIS_CHECKS\n} from '../constants';\n\n/**\n * @param {Object} operate the filtered, parsed, converted, transformed, simplified data point to check against\n * @param {String} type - local or remote\n * @param {String} keys - the stat keys for types of stats defined by DEFAULT_TRANSFORM_REGEX\n * @param {String} stat - the accessor to get the actual stat\n * @param {String} kind - audio or video\n * @returns {Object} always whatever the first sentFirstVideoBytes were, in the past or if it happened now, or undefined if never\n * @private\n * @memberof StatsEvents\n */\nconst operateEvent = (operate, type, keys, stat, kind) => {\n  const foundMatch = {};\n\n  foundMatch.found = keys.some((key) => {\n    if (operate[key] && operate[key][stat] && operate[key][stat] > 0) {\n      foundMatch.match = {\n        type,\n        key,\n        data: operate[key],\n        stat,\n        kind\n      };\n\n      return true;\n    }\n\n    return false;\n  });\n\n  return foundMatch;\n};\n\n/**\n * @export\n * @class StatsEvents\n */\nexport default class StatsEvents {\n  namespace = MEETINGS;\n\n  /**\n   * constructs an instance\n   * @constructor\n   * @param {StatsHistory} series\n   * @param {Function} callback\n   * @memberof StatsEvents\n   */\n  constructor(series = null, callback = () => {}) {\n    /**\n     * @instance\n     * @type {StatsHistory}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.series = series;\n    /**\n     * @instance\n     * @type {Function}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.callback = callback;\n    /**\n     * @instance\n     * @type {WebRTCData}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.first = null;\n    /**\n     * @instance\n     * @type {Boolean}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.sendRemainStopped = false;\n    /**\n     * @instance\n     * @type {Boolean}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.recvRemainStopped = false;\n  }\n\n  /**\n   * looks for data starting to flow through\n   * @param {WebRTCData} data\n   * @returns {Object}\n   */\n  start(data) {\n    if (data && data.data && data.data.getData()) {\n      const operate = data.data.getData();\n\n      if (operate && !this.first) {\n        const operator = [\n          operateEvent(operate, EVENT_TYPES.LOCAL, DEFAULT_EVENT_AUDIO_SEND_KEYS, EVENT_STATS_MAP.BYTES_SENT, AUDIO),\n          operateEvent(operate, EVENT_TYPES.LOCAL, DEFAULT_EVENT_VIDEO_SEND_KEYS, EVENT_STATS_MAP.BYTES_SENT, VIDEO),\n          operateEvent(operate, EVENT_TYPES.REMOTE, DEFAULT_EVENT_VIDEO_RECEIVE_KEYS, EVENT_STATS_MAP.BYTES_RECEIVED, VIDEO),\n          operateEvent(operate, EVENT_TYPES.REMOTE, DEFAULT_EVENT_AUDIO_RECEIVE_KEYS, EVENT_STATS_MAP.BYTES_RECEIVED, AUDIO)\n        ];\n        const somethingMatched = operator.find((element) => element && element.found && element.match);\n\n        if (somethingMatched) {\n          this.first = somethingMatched.match;\n          this.callback(this.first);\n\n          return somethingMatched;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Looks for data to stop coming through\n   * @returns {Object}\n   */\n  stop() {\n    if (!this.series || this.series.get().length < 5) {\n      return null;\n    }\n    const fiveSecondsData = this.series.getSlice(5);\n    const prop = fiveSecondsData[0] && fiveSecondsData[0].rtpOutAudio || fiveSecondsData[0].rtpInAudio || fiveSecondsData[0].rtpInVideo || fiveSecondsData[0].rtpOutVideo;\n    const sendAnalysis = StatsAnalyzer.analyze(fiveSecondsData, {analysisKeys: [{key: EVENT_STATS_MAP.BYTES_SENT, check: ANALYSIS_CHECKS.INCREASING, prop}]});\n    const receiveAnalysis = StatsAnalyzer.analyze(fiveSecondsData, {analysisKeys: [{key: EVENT_STATS_MAP.BYTES_RECEIVED, check: ANALYSIS_CHECKS.INCREASING, prop}]});\n\n    if (!sendAnalysis.valid && sendAnalysis.data.bytesSent.reports.length > 0) {\n      if (!this.sendRemainStopped) {\n        const ret = {stop: true, stat: EVENT_STATS_MAP.BYTES_SENT};\n\n        this.callback(ret);\n        this.sendRemainStopped = true;\n        this.first = null;\n\n        return ret;\n      }\n    }\n    else if (sendAnalysis.valid && sendAnalysis.data.bytesSent.reports.length > 0) {\n      this.sendRemainStopped = false;\n    }\n    if (!receiveAnalysis.valid && receiveAnalysis.data.bytesReceived.reports.length > 0) {\n      if (!this.recvRemainStopped) {\n        const ret = {stop: true, stat: EVENT_STATS_MAP.BYTES_RECEIVED};\n\n        this.callback(ret);\n        this.recvRemainStopped = true;\n        this.first = null;\n\n        return ret;\n      }\n    }\n    else if (receiveAnalysis.valid && receiveAnalysis.data.bytesReceived.reports.length > 0) {\n      this.recvRemainStopped = false;\n    }\n\n    return null;\n  }\n\n  /**\n   * handles all the types of events that need to be sent when they happen from getStats API\n   * @param {WebRTCData} data\n   * @returns {Object}\n   */\n  event(data) {\n    return {\n      start: this.start(data),\n      stop: this.stop()\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"script"}