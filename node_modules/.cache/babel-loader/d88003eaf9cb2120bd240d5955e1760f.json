{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');\n\nvar _deleteProperty2 = _interopRequireDefault(_deleteProperty);\n\nvar _get2 = require('lodash/get');\n\nvar _get3 = _interopRequireDefault(_get2);\n\nvar _desc, _value, _obj;\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar _common = require('@webex/common');\n\nvar _webexCore = require('@webex/webex-core');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n\nvar Search = _webexCore.WebexPlugin.extend((_obj = {\n  namespace: 'Search',\n  people: function people(options) {\n    options = options || {};\n\n    if (!options.queryString && options.query) {\n      options.queryString = options.query;\n      (0, _deleteProperty2.default)(options, 'query');\n    }\n\n    if (!options.queryString) {\n      return _promise2.default.reject(new Error('`options.query` is required'));\n    }\n\n    return this.request({\n      api: 'argonaut',\n      resource: 'directory',\n      method: 'POST',\n      body: options\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n  bindSearchKey: function bindSearchKey() {\n    var _this = this;\n\n    return this.webex.internal.encryption.kms.createUnboundKeys({\n      count: 1\n    }).then(function (_ref) {\n      var _ref2 = (0, _slicedToArray3.default)(_ref, 1),\n          key = _ref2[0];\n\n      return _this.webex.internal.encryption.kms.createResource({\n        key: key,\n        userIds: [_this.webex.internal.device.userId]\n      }).then(function () {\n        return _this.webex.internal.device.set('searchEncryptionKeyUrl', key.uri);\n      });\n    });\n  },\n\n  /**\n  * Fetches search result activities\n  * @param {Object} options\n  * @param {boolean} options.includeRemoteClusterReferences when true,\n  * includes search results from remote clusters\n  * @returns {Promise<Array>} Resolves with the activities\n  */\n  search: function search(options) {\n    var _this2 = this;\n    /* eslint max-nested-callbacks: [0] */\n\n\n    options = options || {};\n\n    var promise = _promise2.default.resolve();\n\n    if (!this.webex.internal.device.searchEncryptionKeyUrl) {\n      promise = this.bindSearchKey();\n    }\n\n    return promise.then(function () {\n      return _this2.webex.request({\n        service: 'argonaut',\n        resource: 'search',\n        method: 'POST',\n        body: (0, _assign2.default)(options, {\n          searchEncryptionKeyUrl: _this2.webex.internal.device.searchEncryptionKeyUrl\n        })\n      });\n    }).then(function (res) {\n      var resActivities = (0, _get3.default)(res, 'body.activities.items', []);\n\n      if (options.includeRemoteClusterReferences && res.body.breadcrumbs) {\n        var breadcrumbs = res.body.breadcrumbs;\n        var promises = [];\n        (0, _keys2.default)(breadcrumbs).forEach(function (cluster) {\n          // Map activity URLs to their cluster\n          var editedCluster = cluster + ':identityLookup';\n          var clusterActivityUrls = breadcrumbs[cluster].items.map(function (activity) {\n            return activity.activityUrl;\n          }); // Find activities per cluster\n\n          var bulkActivitiesPromise = _this2.webex.internal.conversation.bulkActivitiesFetch(clusterActivityUrls, editedCluster).catch(function (err) {\n            _this2.logger.warn('search: error fetching from remote clusters', err);\n\n            return _promise2.default.resolve([]);\n          });\n\n          promises.push(bulkActivitiesPromise);\n        });\n        return _promise2.default.all(promises).then(function (clusterResults) {\n          return clusterResults.reduce(function (accumulator, clusterResult) {\n            return accumulator.concat(clusterResult);\n          }, resActivities);\n        });\n      }\n\n      return resActivities;\n    });\n  },\n  version: '1.80.172'\n}, _applyDecoratedDescriptor(_obj, 'bindSearchKey', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'bindSearchKey'), _obj), _obj));\n\nexports.default = Search;","map":{"version":3,"sources":["search.js"],"names":["Search","namespace","people","options","api","resource","method","body","res","oneFlight","bindSearchKey","count","key","userIds","search","promise","service","searchEncryptionKeyUrl","resActivities","breadcrumbs","promises","editedCluster","cluster","clusterActivityUrls","activity","bulkActivitiesPromise","accumulator"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {get} from 'lodash';\nimport {oneFlight} from '@webex/common';\nimport {WebexPlugin} from '@webex/webex-core';\n\nconst Search = WebexPlugin.extend({\n  namespace: 'Search',\n\n  people(options) {\n    options = options || {};\n\n    if (!options.queryString && options.query) {\n      options.queryString = options.query;\n      Reflect.deleteProperty(options, 'query');\n    }\n\n    if (!options.queryString) {\n      return Promise.reject(new Error('`options.query` is required'));\n    }\n\n    return this.request({\n      api: 'argonaut',\n      resource: 'directory',\n      method: 'POST',\n      body: options\n    })\n      .then((res) => res.body);\n  },\n\n  @oneFlight\n  bindSearchKey() {\n    return this.webex.internal.encryption.kms.createUnboundKeys({count: 1})\n      .then(([key]) => this.webex.internal.encryption.kms.createResource({\n        key,\n        userIds: [this.webex.internal.device.userId]\n      })\n        .then(() => this.webex.internal.device.set('searchEncryptionKeyUrl', key.uri)));\n  },\n\n  /**\n  * Fetches search result activities\n  * @param {Object} options\n  * @param {boolean} options.includeRemoteClusterReferences when true,\n  * includes search results from remote clusters\n  * @returns {Promise<Array>} Resolves with the activities\n  */\n  search(options) {\n    /* eslint max-nested-callbacks: [0] */\n    options = options || {};\n\n    let promise = Promise.resolve();\n\n    if (!this.webex.internal.device.searchEncryptionKeyUrl) {\n      promise = this.bindSearchKey();\n    }\n\n    return promise\n      .then(() => this.webex.request({\n        service: 'argonaut',\n        resource: 'search',\n        method: 'POST',\n        body: Object.assign(options, {\n          searchEncryptionKeyUrl: this.webex.internal.device.searchEncryptionKeyUrl\n        })\n      }))\n      .then((res) => {\n        const resActivities = get(res, 'body.activities.items', []);\n\n        if (options.includeRemoteClusterReferences && res.body.breadcrumbs) {\n          const {breadcrumbs} = res.body;\n          const promises = [];\n\n          Object.keys(breadcrumbs).forEach((cluster) => {\n            // Map activity URLs to their cluster\n            const editedCluster = `${cluster}:identityLookup`;\n            const clusterActivityUrls = breadcrumbs[cluster].items.map(\n              (activity) => activity.activityUrl\n            );\n\n            // Find activities per cluster\n            const bulkActivitiesPromise = this.webex.internal.conversation.bulkActivitiesFetch(\n              clusterActivityUrls,\n              editedCluster\n            )\n              .catch((err) => {\n                this.logger.warn(\n                  'search: error fetching from remote clusters',\n                  err\n                );\n\n                return Promise.resolve([]);\n              });\n\n            promises.push(bulkActivitiesPromise);\n          });\n\n          return Promise.all(promises).then(\n            (clusterResults) => clusterResults.reduce(\n              (accumulator, clusterResult) => accumulator.concat(clusterResult),\n              resActivities\n            )\n          );\n        }\n\n        return resActivities;\n      });\n  }\n\n});\n\nexport default Search;\n"]},"metadata":{},"sourceType":"script"}