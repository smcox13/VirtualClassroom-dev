{"ast":null,"code":"/**\n * Copyright (c) 2019, Peculiar Ventures, All rights reserved.\n */\nfunction PrepareBuffer(buffer) {\n  if (typeof Buffer !== \"undefined\" && Buffer.isBuffer(buffer)) {\n    return new Uint8Array(buffer);\n  } else if (ArrayBuffer.isView(buffer)) {\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  } else {\n    return new Uint8Array(buffer);\n  }\n}\n\nclass Convert {\n  static ToString(buffer, enc = \"utf8\") {\n    const buf = PrepareBuffer(buffer);\n\n    switch (enc.toLowerCase()) {\n      case \"utf8\":\n        return this.ToUtf8String(buf);\n\n      case \"binary\":\n        return this.ToBinary(buf);\n\n      case \"hex\":\n        return this.ToHex(buf);\n\n      case \"base64\":\n        return this.ToBase64(buf);\n\n      case \"base64url\":\n        return this.ToBase64Url(buf);\n\n      default:\n        throw new Error(`Unknown type of encoding '${enc}'`);\n    }\n  }\n\n  static FromString(str, enc = \"utf8\") {\n    switch (enc.toLowerCase()) {\n      case \"utf8\":\n        return this.FromUtf8String(str);\n\n      case \"binary\":\n        return this.FromBinary(str);\n\n      case \"hex\":\n        return this.FromHex(str);\n\n      case \"base64\":\n        return this.FromBase64(str);\n\n      case \"base64url\":\n        return this.FromBase64Url(str);\n\n      default:\n        throw new Error(`Unknown type of encoding '${enc}'`);\n    }\n  }\n\n  static ToBase64(buffer) {\n    const buf = PrepareBuffer(buffer);\n\n    if (typeof btoa !== \"undefined\") {\n      const binary = this.ToString(buf, \"binary\");\n      return btoa(binary);\n    } else {\n      return Buffer.from(buf).toString(\"base64\");\n    }\n  }\n\n  static FromBase64(base64Text) {\n    base64Text = base64Text.replace(/\\n/g, \"\").replace(/\\r/g, \"\").replace(/\\t/g, \"\").replace(/\\s/g, \"\");\n\n    if (typeof atob !== \"undefined\") {\n      return this.FromBinary(atob(base64Text));\n    } else {\n      return new Uint8Array(Buffer.from(base64Text, \"base64\")).buffer;\n    }\n  }\n\n  static FromBase64Url(base64url) {\n    return this.FromBase64(this.Base64Padding(base64url.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\")));\n  }\n\n  static ToBase64Url(data) {\n    return this.ToBase64(data).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\");\n  }\n\n  static FromUtf8String(text) {\n    const s = unescape(encodeURIComponent(text));\n    const uintArray = new Uint8Array(s.length);\n\n    for (let i = 0; i < s.length; i++) {\n      uintArray[i] = s.charCodeAt(i);\n    }\n\n    return uintArray.buffer;\n  }\n\n  static ToUtf8String(buffer) {\n    const buf = PrepareBuffer(buffer);\n    const encodedString = String.fromCharCode.apply(null, buf);\n    const decodedString = decodeURIComponent(escape(encodedString));\n    return decodedString;\n  }\n\n  static FromBinary(text) {\n    const stringLength = text.length;\n    const resultView = new Uint8Array(stringLength);\n\n    for (let i = 0; i < stringLength; i++) {\n      resultView[i] = text.charCodeAt(i);\n    }\n\n    return resultView.buffer;\n  }\n\n  static ToBinary(buffer) {\n    const buf = PrepareBuffer(buffer);\n    let resultString = \"\";\n    const len = buf.length;\n\n    for (let i = 0; i < len; i++) {\n      resultString = resultString + String.fromCharCode(buf[i]);\n    }\n\n    return resultString;\n  }\n\n  static ToHex(buffer) {\n    const buf = PrepareBuffer(buffer);\n    const splitter = \"\";\n    const res = [];\n    const len = buf.length;\n\n    for (let i = 0; i < len; i++) {\n      const char = buf[i].toString(16);\n      res.push(char.length === 1 ? \"0\" + char : char);\n    }\n\n    return res.join(splitter);\n  }\n\n  static FromHex(hexString) {\n    const res = new Uint8Array(hexString.length / 2);\n\n    for (let i = 0; i < hexString.length; i = i + 2) {\n      const c = hexString.slice(i, i + 2);\n      res[i / 2] = parseInt(c, 16);\n    }\n\n    return res.buffer;\n  }\n\n  static Base64Padding(base64) {\n    const padCount = 4 - base64.length % 4;\n\n    if (padCount < 4) {\n      for (let i = 0; i < padCount; i++) {\n        base64 += \"=\";\n      }\n    }\n\n    return base64;\n  }\n\n}\n\nclass BufferSourceConverter {\n  static toArrayBuffer(data) {\n    const buf = this.toUint8Array(data);\n\n    if (buf.byteOffset || buf.length) {\n      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n    }\n\n    return buf.buffer;\n  }\n\n  static toUint8Array(data) {\n    if (typeof Buffer !== \"undefined\" && Buffer.isBuffer(data)) {\n      return new Uint8Array(data);\n    }\n\n    if (ArrayBuffer.isView(data)) {\n      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    }\n\n    if (data instanceof ArrayBuffer) {\n      return new Uint8Array(data);\n    }\n\n    throw new TypeError(\"The provided value is not of type '(ArrayBuffer or ArrayBufferView)'\");\n  }\n\n  static isBufferSource(data) {\n    return ArrayBuffer.isView(data) || data instanceof ArrayBuffer;\n  }\n\n}\n\nfunction assign(target, ...sources) {\n  const res = arguments[0];\n\n  for (let i = 1; i < arguments.length; i++) {\n    const obj = arguments[i];\n\n    for (const prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n\n  return res;\n}\n\nfunction combine(...buf) {\n  const totalByteLength = buf.map(item => item.byteLength).reduce((prev, cur) => prev + cur);\n  const res = new Uint8Array(totalByteLength);\n  let currentPos = 0;\n  buf.map(item => new Uint8Array(item)).forEach(arr => {\n    for (const item2 of arr) {\n      res[currentPos++] = item2;\n    }\n  });\n  return res.buffer;\n}\n\nfunction isEqual(bytes1, bytes2) {\n  if (!(bytes1 && bytes2)) {\n    return false;\n  }\n\n  if (bytes1.byteLength !== bytes2.byteLength) {\n    return false;\n  }\n\n  const b1 = new Uint8Array(bytes1);\n  const b2 = new Uint8Array(bytes2);\n\n  for (let i = 0; i < bytes1.byteLength; i++) {\n    if (b1[i] !== b2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport { BufferSourceConverter, Convert, assign, combine, isEqual };","map":{"version":3,"sources":["/Users/pratison/Work/Cisco/Education/React/education-webex/node_modules/pvtsutils/build/index.es.js"],"names":["PrepareBuffer","buffer","Buffer","isBuffer","Uint8Array","ArrayBuffer","isView","byteOffset","byteLength","Convert","ToString","enc","buf","toLowerCase","ToUtf8String","ToBinary","ToHex","ToBase64","ToBase64Url","Error","FromString","str","FromUtf8String","FromBinary","FromHex","FromBase64","FromBase64Url","btoa","binary","from","toString","base64Text","replace","atob","base64url","Base64Padding","data","text","s","unescape","encodeURIComponent","uintArray","length","i","charCodeAt","encodedString","String","fromCharCode","apply","decodedString","decodeURIComponent","escape","stringLength","resultView","resultString","len","splitter","res","char","push","join","hexString","c","slice","parseInt","base64","padCount","BufferSourceConverter","toArrayBuffer","toUint8Array","TypeError","isBufferSource","assign","target","sources","arguments","obj","prop","combine","totalByteLength","map","item","reduce","prev","cur","currentPos","forEach","arr","item2","isEqual","bytes1","bytes2","b1","b2"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2019, Peculiar Ventures, All rights reserved.\n */\n\nfunction PrepareBuffer(buffer) {\r\n    if (typeof Buffer !== \"undefined\" && Buffer.isBuffer(buffer)) {\r\n        return new Uint8Array(buffer);\r\n    }\r\n    else if (ArrayBuffer.isView(buffer)) {\r\n        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\r\n    }\r\n    else {\r\n        return new Uint8Array(buffer);\r\n    }\r\n}\r\nclass Convert {\r\n    static ToString(buffer, enc = \"utf8\") {\r\n        const buf = PrepareBuffer(buffer);\r\n        switch (enc.toLowerCase()) {\r\n            case \"utf8\":\r\n                return this.ToUtf8String(buf);\r\n            case \"binary\":\r\n                return this.ToBinary(buf);\r\n            case \"hex\":\r\n                return this.ToHex(buf);\r\n            case \"base64\":\r\n                return this.ToBase64(buf);\r\n            case \"base64url\":\r\n                return this.ToBase64Url(buf);\r\n            default:\r\n                throw new Error(`Unknown type of encoding '${enc}'`);\r\n        }\r\n    }\r\n    static FromString(str, enc = \"utf8\") {\r\n        switch (enc.toLowerCase()) {\r\n            case \"utf8\":\r\n                return this.FromUtf8String(str);\r\n            case \"binary\":\r\n                return this.FromBinary(str);\r\n            case \"hex\":\r\n                return this.FromHex(str);\r\n            case \"base64\":\r\n                return this.FromBase64(str);\r\n            case \"base64url\":\r\n                return this.FromBase64Url(str);\r\n            default:\r\n                throw new Error(`Unknown type of encoding '${enc}'`);\r\n        }\r\n    }\r\n    static ToBase64(buffer) {\r\n        const buf = PrepareBuffer(buffer);\r\n        if (typeof btoa !== \"undefined\") {\r\n            const binary = this.ToString(buf, \"binary\");\r\n            return btoa(binary);\r\n        }\r\n        else {\r\n            return Buffer.from(buf).toString(\"base64\");\r\n        }\r\n    }\r\n    static FromBase64(base64Text) {\r\n        base64Text = base64Text.replace(/\\n/g, \"\").replace(/\\r/g, \"\").replace(/\\t/g, \"\").replace(/\\s/g, \"\");\r\n        if (typeof atob !== \"undefined\") {\r\n            return this.FromBinary(atob(base64Text));\r\n        }\r\n        else {\r\n            return new Uint8Array(Buffer.from(base64Text, \"base64\")).buffer;\r\n        }\r\n    }\r\n    static FromBase64Url(base64url) {\r\n        return this.FromBase64(this.Base64Padding(base64url.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\")));\r\n    }\r\n    static ToBase64Url(data) {\r\n        return this.ToBase64(data).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\");\r\n    }\r\n    static FromUtf8String(text) {\r\n        const s = unescape(encodeURIComponent(text));\r\n        const uintArray = new Uint8Array(s.length);\r\n        for (let i = 0; i < s.length; i++) {\r\n            uintArray[i] = s.charCodeAt(i);\r\n        }\r\n        return uintArray.buffer;\r\n    }\r\n    static ToUtf8String(buffer) {\r\n        const buf = PrepareBuffer(buffer);\r\n        const encodedString = String.fromCharCode.apply(null, buf);\r\n        const decodedString = decodeURIComponent(escape(encodedString));\r\n        return decodedString;\r\n    }\r\n    static FromBinary(text) {\r\n        const stringLength = text.length;\r\n        const resultView = new Uint8Array(stringLength);\r\n        for (let i = 0; i < stringLength; i++) {\r\n            resultView[i] = text.charCodeAt(i);\r\n        }\r\n        return resultView.buffer;\r\n    }\r\n    static ToBinary(buffer) {\r\n        const buf = PrepareBuffer(buffer);\r\n        let resultString = \"\";\r\n        const len = buf.length;\r\n        for (let i = 0; i < len; i++) {\r\n            resultString = resultString + String.fromCharCode(buf[i]);\r\n        }\r\n        return resultString;\r\n    }\r\n    static ToHex(buffer) {\r\n        const buf = PrepareBuffer(buffer);\r\n        const splitter = \"\";\r\n        const res = [];\r\n        const len = buf.length;\r\n        for (let i = 0; i < len; i++) {\r\n            const char = buf[i].toString(16);\r\n            res.push(char.length === 1 ? \"0\" + char : char);\r\n        }\r\n        return res.join(splitter);\r\n    }\r\n    static FromHex(hexString) {\r\n        const res = new Uint8Array(hexString.length / 2);\r\n        for (let i = 0; i < hexString.length; i = i + 2) {\r\n            const c = hexString.slice(i, i + 2);\r\n            res[i / 2] = parseInt(c, 16);\r\n        }\r\n        return res.buffer;\r\n    }\r\n    static Base64Padding(base64) {\r\n        const padCount = 4 - (base64.length % 4);\r\n        if (padCount < 4) {\r\n            for (let i = 0; i < padCount; i++) {\r\n                base64 += \"=\";\r\n            }\r\n        }\r\n        return base64;\r\n    }\r\n}\n\nclass BufferSourceConverter {\r\n    static toArrayBuffer(data) {\r\n        const buf = this.toUint8Array(data);\r\n        if (buf.byteOffset || buf.length) {\r\n            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\r\n        }\r\n        return buf.buffer;\r\n    }\r\n    static toUint8Array(data) {\r\n        if (typeof Buffer !== \"undefined\" && Buffer.isBuffer(data)) {\r\n            return new Uint8Array(data);\r\n        }\r\n        if (ArrayBuffer.isView(data)) {\r\n            return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\r\n        }\r\n        if (data instanceof ArrayBuffer) {\r\n            return new Uint8Array(data);\r\n        }\r\n        throw new TypeError(\"The provided value is not of type '(ArrayBuffer or ArrayBufferView)'\");\r\n    }\r\n    static isBufferSource(data) {\r\n        return ArrayBuffer.isView(data) || data instanceof ArrayBuffer;\r\n    }\r\n}\n\nfunction assign(target, ...sources) {\r\n    const res = arguments[0];\r\n    for (let i = 1; i < arguments.length; i++) {\r\n        const obj = arguments[i];\r\n        for (const prop in obj) {\r\n            res[prop] = obj[prop];\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction combine(...buf) {\r\n    const totalByteLength = buf.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);\r\n    const res = new Uint8Array(totalByteLength);\r\n    let currentPos = 0;\r\n    buf.map((item) => new Uint8Array(item)).forEach((arr) => {\r\n        for (const item2 of arr) {\r\n            res[currentPos++] = item2;\r\n        }\r\n    });\r\n    return res.buffer;\r\n}\r\nfunction isEqual(bytes1, bytes2) {\r\n    if (!(bytes1 && bytes2)) {\r\n        return false;\r\n    }\r\n    if (bytes1.byteLength !== bytes2.byteLength) {\r\n        return false;\r\n    }\r\n    const b1 = new Uint8Array(bytes1);\r\n    const b2 = new Uint8Array(bytes2);\r\n    for (let i = 0; i < bytes1.byteLength; i++) {\r\n        if (b1[i] !== b2[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n\nexport { BufferSourceConverter, Convert, assign, combine, isEqual };\n"]},"metadata":{},"sourceType":"module"}