{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _weakMap = require('babel-runtime/core-js/weak-map');\n\nvar _weakMap2 = _interopRequireDefault(_weakMap);\n\nvar _stream = require('stream');\n\nvar _events = require('events');\n\nvar _commonTimers = require('@webex/common-timers');\n\nvar _constants = require('../constants');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar pcsByRTCRtpDirection = new _weakMap2.default();\nvar emittersByRTCRtpDirection = new _weakMap2.default();\nvar RTCRtpDirectionByEmitter = new _weakMap2.default();\nvar emittersByStream = new _weakMap2.default();\nvar timersByEmitter = new _weakMap2.default();\n/**\n * Helper function that ensures no matter how many stats streams we create, we\n * don't poll the PeerConnection more than once per interval.\n * @param {EventEmitter} emitter\n * @param {Number} interval\n * @private\n * @returns {undefined}\n */\n\nvar schedule = function schedule(emitter, interval) {\n  var timer = (0, _commonTimers.safeSetTimeout)(function () {\n    var direction = RTCRtpDirectionByEmitter.get(emitter);\n    var pc = pcsByRTCRtpDirection.get(direction);\n\n    if (direction) {\n      direction.getStats().then(function (stats) {\n        emitter.emit(_constants.STATS.DATA, stats); // TODO: Remove on 1.0 spec adoption\n        // \"closed\" is supposed to be part of the {@link RTCPeerConnectionState}\n        // enum according to spec, but at time of writing, was still implemented\n        // in the {@link RTCSignalingState} enum.\n\n        if (!(pc.signalingState === _constants.STATS.CLOSED || pc.connectionState === _constants.STATS.CLOSED)) {\n          schedule(emitter, interval);\n        }\n      }).catch(function (err) {\n        emitter.emit(_constants.ERROR, err);\n      });\n    }\n  }, interval);\n  timersByEmitter.set(emitter, timer);\n};\n/**\n * Polls an {@link RTCPeerConnection} once per second and emits its {@link RTCStatsReport}\n * {@link RTCStatsReport}\n */\n\n\nvar StatsStream = function (_Readable) {\n  (0, _inherits3.default)(StatsStream, _Readable);\n  /**\n   * @private\n   * @param {Object} config\n   * @param {RTCRtpSender|RTCRtpReceiver} config.rTCRtpDirection\n   * @param {RTCPeerConnection} config.peerConnection\n   * @param {Number} config.interval\n   */\n\n  function StatsStream() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    (0, _classCallCheck3.default)(this, StatsStream);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (StatsStream.__proto__ || (0, _getPrototypeOf2.default)(StatsStream)).call(this, {\n      objectMode: true\n    }));\n\n    _this.interval = config.interval;\n\n    if (!emittersByRTCRtpDirection.has(config.rTCRtpDirection)) {\n      emittersByRTCRtpDirection.set(config.rTCRtpDirection, new _events.EventEmitter());\n    }\n\n    var emitter = emittersByRTCRtpDirection.get(config.rTCRtpDirection);\n\n    if (!emittersByStream.has(_this)) {\n      emittersByStream.set(_this, emitter);\n    }\n\n    if (!RTCRtpDirectionByEmitter.has(emitter)) {\n      RTCRtpDirectionByEmitter.set(emitter, config.rTCRtpDirection);\n    }\n\n    if (!pcsByRTCRtpDirection.has(config.rTCRtpDirection)) {\n      pcsByRTCRtpDirection.set(config.rTCRtpDirection, config.peerConnection);\n    }\n\n    emitter.once(_constants.ERROR, function (err) {\n      _this.emit(_constants.ERROR, err);\n    });\n    return _this;\n  }\n  /**\n   * See NodeJS Docs\n   * @private\n   * @returns {undefined}\n   */\n\n\n  (0, _createClass3.default)(StatsStream, [{\n    key: '_read',\n    value: function _read() {\n      var _this2 = this;\n\n      var emitter = emittersByStream.get(this);\n      emitter.once(_constants.STATS.DATA, function (data) {\n        if (!_this2.isPaused()) {\n          _this2.push(data);\n        }\n      });\n\n      if (!timersByEmitter.has(emitter)) {\n        schedule(emitter, this.interval);\n      }\n    }\n  }]);\n  return StatsStream;\n}(_stream.Readable);\n\nexports.default = StatsStream;","map":{"version":3,"sources":["stream.js"],"names":["pcsByRTCRtpDirection","emittersByRTCRtpDirection","RTCRtpDirectionByEmitter","emittersByStream","timersByEmitter","schedule","timer","direction","pc","emitter","STATS","ERROR","StatsStream","Readable","config","objectMode","EventEmitter"],"mappings":"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","sourcesContent":["import {Readable} from 'stream';\nimport {EventEmitter} from 'events';\n\nimport {safeSetTimeout} from '@webex/common-timers';\n\nimport {\n  ERROR,\n  STATS\n} from '../constants';\n\nconst pcsByRTCRtpDirection = new WeakMap();\nconst emittersByRTCRtpDirection = new WeakMap();\nconst RTCRtpDirectionByEmitter = new WeakMap();\nconst emittersByStream = new WeakMap();\nconst timersByEmitter = new WeakMap();\n\n/**\n * Helper function that ensures no matter how many stats streams we create, we\n * don't poll the PeerConnection more than once per interval.\n * @param {EventEmitter} emitter\n * @param {Number} interval\n * @private\n * @returns {undefined}\n */\nconst schedule = (emitter, interval) => {\n  const timer = safeSetTimeout(() => {\n    const direction = RTCRtpDirectionByEmitter.get(emitter);\n    const pc = pcsByRTCRtpDirection.get(direction);\n\n    if (direction) {\n      direction.getStats()\n        .then((stats) => {\n          emitter.emit(STATS.DATA, stats);\n          // TODO: Remove on 1.0 spec adoption\n          // \"closed\" is supposed to be part of the {@link RTCPeerConnectionState}\n          // enum according to spec, but at time of writing, was still implemented\n          // in the {@link RTCSignalingState} enum.\n          if (!(pc.signalingState === STATS.CLOSED || pc.connectionState === STATS.CLOSED)) {\n            schedule(emitter, interval);\n          }\n        })\n        .catch((err) => {\n          emitter.emit(ERROR, err);\n        });\n    }\n  }, interval);\n\n  timersByEmitter.set(emitter, timer);\n};\n\n/**\n * Polls an {@link RTCPeerConnection} once per second and emits its {@link RTCStatsReport}\n * {@link RTCStatsReport}\n */\nexport default class StatsStream extends Readable {\n  /**\n   * @private\n   * @param {Object} config\n   * @param {RTCRtpSender|RTCRtpReceiver} config.rTCRtpDirection\n   * @param {RTCPeerConnection} config.peerConnection\n   * @param {Number} config.interval\n   */\n  constructor(config = {}) {\n    super({objectMode: true});\n\n    this.interval = config.interval;\n\n    if (!emittersByRTCRtpDirection.has(config.rTCRtpDirection)) {\n      emittersByRTCRtpDirection.set(config.rTCRtpDirection, new EventEmitter());\n    }\n    const emitter = emittersByRTCRtpDirection.get(config.rTCRtpDirection);\n\n    if (!emittersByStream.has(this)) {\n      emittersByStream.set(this, emitter);\n    }\n    if (!RTCRtpDirectionByEmitter.has(emitter)) {\n      RTCRtpDirectionByEmitter.set(emitter, config.rTCRtpDirection);\n    }\n\n    if (!pcsByRTCRtpDirection.has(config.rTCRtpDirection)) {\n      pcsByRTCRtpDirection.set(config.rTCRtpDirection, config.peerConnection);\n    }\n\n    emitter.once(ERROR, (err) => {\n      this.emit(ERROR, err);\n    });\n  }\n\n  /**\n   * See NodeJS Docs\n   * @private\n   * @returns {undefined}\n   */\n  _read() {\n    const emitter = emittersByStream.get(this);\n\n    emitter.once(STATS.DATA, (data) => {\n      if (!this.isPaused()) {\n        this.push(data);\n      }\n    });\n\n    if (!timersByEmitter.has(emitter)) {\n      schedule(emitter, this.interval);\n    }\n  }\n}\n\n"]},"metadata":{},"sourceType":"script"}